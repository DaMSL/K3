include "Annotation/Maps/MapE.k3"
include "Core/Barrier.k3"
include "Core/Messaging.k3"

// Create base relation indexes for Mosaic warmup map accesses.
control MosaicIndex[ lbl          : label
                   , relation     : label
                   , key_type     : type
                   , lookup_probe : expr
                   , index_probe  : expr
                   , missing_fn   : expr
                   , present_fn   : expr
                   , index_key    : [labeltype]
                   , index_value  : [labeltype]]
{
  // Slice materialization
  ((?e.filter ?filterF)
      .fold   ?foldF (?acc1 : ?t1)
  )
  => (($[lbl]_index @:{RelationName "$[|literalLabel 'relation|]"}).lookup $[lookup_probe] (\_ -> $.[acc1]) (\r -> r.value)
      ) @:{PartitionConstraint "$[|partitionConstraint 'lookup_probe 'index_probe|]"}
  +> {
    declare $[lbl]_index : mut collection {key: $[key_type], value: $::[t1]} @MapE(key:=index_key, value:=index_value)

    declare $[lbl]_init_index : () -> () = \_ -> (
      $.[e].iterate (\t -> $[lbl]_index.upsert_with $[index_probe] $[missing_fn] $[present_fn])
    )
  }
}

// For use with Mosaic's fold encoding.
control MosaicFusion {

  // Filter-filter
  ((?e).filter ?filterF1).filter ?filterF2 => ($.[e].filter (\x -> ($.[filterF1] x) and ($.[filterF2] x))) @MosaicFusion

  // Fusion pushdown through flatten
  (?e).fold (\_accext -> (\?bvi1 -> bind ?bv1 as ?bind1 in ((_accext.extend ?e2); _accext))) ?z
  => (($.[e] @MosaicFusion).fold (\_accext -> (\$#[bvi1] ->
        (bind $.[bv1] as $~![bind1] in ((_accext.extend ($.[e2] @MosaicFusion)); _accext)))) $.[z])

  // Map-maps encoded as folds.
  ((?e).fold (\_accmap -> (\?bvi1 -> (bind ?bv1 as ?bind1 in ((_accmap.insert ?v1); _accmap))))
             (?acc1 : collection ?t1))
       .fold (\_accmap -> (\?bvi2 -> (bind ?bv2 as ?bind2 in ((_accmap.insert ?v2); _accmap))))
             (?acc2 : collection ?t2)
  =>
  (($.[e] @MosaicFusion)
        .fold (\_accmap ->
                  \$#[bvi1] -> bind $.[bv1] as $~![bind1] in
                  (_accmap.insert ((\$#[bvi2] -> bind $.[bv2] as $~![bind2] in ($.[v2] @MosaicFusion))
                                  ($.[v1] @MosaicFusion));
                   _accmap))
              $.[acc2]
  ) @MosaicFusion

  // Map-filter, with map encoded as fold.
  ((?e).fold   (\_accmap -> (\?bvi1 -> (bind ?bv1 as ?bind1 in ((_accmap.insert ?v1); _accmap))))
               (?acc1 : collection ?t1))
       .filter ?filterF
  =>
  (($.[e] @MosaicFusion)
        .fold (\_accmap -> \$#[bvi1] -> bind $.[bv1] as $~![bind1] in
                let r = $.[v1] @MosaicFusion in
                if $.[filterF] r then (_accmap.insert r; _accmap) else _accmap)
              $.[acc1]
  ) @MosaicFusion

  // Filter-map, with map encoded as fold.
  ((?e).filter ?filterF)
       .fold   (\_accmap -> (\?bvi1 -> (bind ?bv1 as ?bind1 in ((_accmap.insert ?v1); _accmap))))
               (?acc1 : collection ?t1)
  =>
  (($.[e] @MosaicFusion)
       .fold (\_accmap -> \$#[bvi1] ->
                if $.[filterF] $#[bvi1]
                  then bind $.[bv1] as $~![bind1] in ((_accmap.insert ($.[v1] @MosaicFusion)); _accmap)
                  else _accmap)
             $.[acc1]
  ) @MosaicFusion

  // Map-sum encoded as folds.
  ((?e).fold (\_accmap -> (\?bvi1 -> (bind ?bv1 as ?bind1 in ((_accmap.insert ?v1); _accmap))))
             (?acc1 : collection ?t1))
       .fold (\?acc2i -> (\?bvi2 -> (bind ?bv2 as ?bind2 in (?acc2v + ?v2))))
             ?acc2
  =>
  (($.[e] @MosaicFusion)
        .fold (\$#[acc2i] -> \$#[bvi1] ->
                bind $.[bv1] as $~![bind1] in
                $.[acc2v] + ((\$#[bvi2] -> bind $.[bv2] as $~![bind2] in ($.[v2] @MosaicFusion)) ($.[v1] @MosaicFusion)))
              $.[acc2]
  ) @MosaicFusion

  // TODO: chained fusion rules for filter-map/map-filter and map.

  // Fold search descent
  (?e).fold ?accF ?z => (($.[e] @MosaicFusion).fold $.[accF] $.[z])

  // Group-by search descent
  (?e).group_by ?groupF ?accF ?z => ($.[e] @MosaicFusion).group_by $.[groupF] $.[accF] $.[z]

  // Children descent.
  ?E => $[| rewriteChildren 'E.expr ["MosaicFusion"] |]
}

control MosaicInferPartition {
  ?E => ($[|propagatePartition 'E.expr|]) @MosaicPartition
}

// TODO: replace with MosaicExecutePartitions
control MosaicPartition {
  ?E => $.[E]
}

// Create stages and materialized intermediates for Mosaic warmup expressions.
control MosaicMaterialization[lbl : label, cnt : expr, finaltrg : expr]
{
  // Enforce fusion before materialization.
  ?v = ((?e.fold ?accF ?z) @MosaicFusion)
  => ($#[v] = (($.[e].fold $.[accF] $.[z]) @MosaicFusion)) @MosaicMaterialization(lbl=lbl, cnt=cnt, finaltrg=finaltrg)

  ?v = ((?e.group_by ?groupF ?accF ?z) @MosaicFusion)
  => ($#[v] = (($.[e].group_by $.[groupF] $.[accF] $.[z]) @MosaicFusion)) @MosaicMaterialization(lbl=lbl, cnt=cnt, finaltrg=finaltrg)

  // Materialization base cases with base relations
  (?v = ((?e @:BaseRelation).fold ?accF ?z)); (?dest, me) <- ()
  => ((($#[v] = $.[e].fold $.[accF] $.[z]); ($.[dest], me) <- ()) @MosaicInferPartition)

  (?v = ((?e @:BaseRelation).group_by ?groupF ?accF ?z)); (?dest, me) <- ()
  => ((($#[v] = $.[e].group_by $.[groupF] $.[accF] $.[z]); ($.[dest], me) <- ()) @MosaicInferPartition)

  // Materialization base cases with constant relations
  (?v = ((let ?c = ?e in ?rc).fold ?accF ?z)); (?dest, me) <- ()
  => ((($#[v] = ((let $#[c] = $.[e] in $.[rc]) @:ConstantRelation).fold $.[accF] $.[z]); ($.[dest], me) <- ()) @MosaicInferPartition)

  (?v = ((let ?c = ?e in ?rc).group_by ?groupF ?accF ?z)); (?dest, me) <- ()
  => ((($#[v] = ((let $#[c] = $.[e] in $.[rc]) @:ConstantRelation).group_by $.[groupF] $.[accF] $.[z]); ($.[dest], me) <- ()) @MosaicInferPartition)

  // Materialization staging
  ?v = ((?e : ?t).fold ?accF ?z)
  => ((($[lbl]_$[| labelExpr 'cnt |] = $.[e]);
        ($[lbl]_stage$[| labelExpr 'cnt |], me) <- ())
          @MosaicMaterialization(lbl=lbl, cnt=[$ $[|incrExpr 'cnt|] ], finaltrg=finaltrg))
  +> {
    declare $[lbl]_$[| labelExpr 'cnt |] : mut $::[t]

    trigger $[lbl]_stage$[| labelExpr 'cnt|] : () = \_ -> (
      ((($#[v] = ($[lbl]_$[| labelExpr 'cnt |] @:MaterializedRelation).fold $.[accF] $.[z]);
        ($[finaltrg], me) <- ()
       ) @MosaicInferPartition)
    )
  }

  (?v = ((?e : ?t).fold ?accF ?z)); (?dest, me) <- ()
  => ((($[lbl]_$[| labelExpr 'cnt |] = $.[e]);
        ($[lbl]_stage$[| labelExpr 'cnt |], me) <- ())
          @MosaicMaterialization(lbl=lbl, cnt=[$ $[|incrExpr 'cnt|] ], finaltrg=finaltrg))
  +> {
    declare $[lbl]_$[| labelExpr 'cnt |] : mut $::[t]

    trigger $[lbl]_stage$[| labelExpr 'cnt|] : () = \_ -> (
      ((($#[v] = ($[lbl]_$[| labelExpr 'cnt |] @:MaterializedRelation).fold $.[accF] $.[z]);
        ($.[dest], me) <- ()
      ) @MosaicInferPartition)
    )
  }

  ?v = ((?e : ?t).group_by ?groupF ?accF ?z)
  => ((($[lbl]_$[| labelExpr 'cnt |] = $.[e]);
        ($[lbl]_stage$[| labelExpr 'cnt |], me) <- ())
          @MosaicMaterialization(lbl=lbl, cnt=[$ $[|incrExpr 'cnt|] ], finaltrg=finaltrg))
  +> {
    declare $[lbl]_$[| labelExpr 'cnt |] : mut $::[t]

    trigger $[lbl]_stage$[| labelExpr 'cnt|] : () = \_ -> (
      ((($#[v] = ($[lbl]_$[| labelExpr 'cnt |] @:MaterializedRelation).group_by $.[groupF] $.[accF] $.[z]);
        ($[finaltrg], me) <- ()
      ) @MosaicInferPartition)
    )
  }

  (?v = ((?e : ?t).group_by ?groupF ?accF ?z)); (?dest, me) <- ()
  => ((($[lbl]_$[| labelExpr 'cnt |] = $.[e]);
        ($[lbl]_stage$[| labelExpr 'cnt |], me) <- ())
          @MosaicMaterialization(lbl=lbl, cnt=[$ $[|incrExpr 'cnt|] ], finaltrg=finaltrg))
  +> {
    declare $[lbl]_$[| labelExpr 'cnt |] : mut $::[t]

    trigger $[lbl]_stage$[| labelExpr 'cnt|] : () = \_ -> (
      ((($#[v] = ($[lbl]_$[| labelExpr 'cnt |] @:MaterializedRelation).group_by $.[groupF] $.[accF] $.[z]);
       ($.[dest], me) <- ()
      ) @MosaicInferPartition)
    )
  }
}

control MosaicMultiExchange [ lbl : label
                            , relations : [{ i : label
                                           , key_type  : type
                                           , val_type  : type
                                           , elem_type : type
                                           , query     : expr
                                           , clear     : expr }]
                            , joinOrder   : [{ lbl              : label
                                             , lhs_ht_id        : label
                                             , lhs_query        : expr
                                             , lhs_query_clear  : expr
                                             , rhs_query        : expr
                                             , rhs_query_clear  : expr
                                             , lhs_ht_ty        : type
                                             , rhs_ht_ty        : type
                                             , lhs_insert_with  : expr
                                             , lhs_probe        : expr
                                             , lhs_ht_clear     : expr }]
                            , next        : expr
                            , coordinator : expr
                            , nodes       : expr ]
{
	() => nodes.iterate (\p ->
          $[| mosaicStartMultiExchange 'relations "p.addr" |]
            // Generate a send to each relation's exchange trigger
        )

  +>
  {
    trigger $[lbl]_global_barrier : () = \_ -> (
      ( () @MosaicMultiwayJoin( lbl         = lbl
                              , joinOrder   = joinOrder
                              , next        = next
                              , coordinator = coordinator
                              , nodes       = nodes)
      ) @OnCounter( id=[# $[lbl]_exchange_done], eq=[$ $[| mosaicExchangeBarrierCount 'relations 'nodes |] ]
                  , reset=[$ false], profile=[$ false] )
    )

    for r in relations:
      declare $[r.i]_offset : mut int = 0
      declare $[r.i]_stride : mut int = 0
      declare $[r.i]_cnt    : mut int = 0

      declare $[r.i]_next_bucket : () -> int = \_ -> (
        $[r.i]_cnt = $[r.i]_cnt + 1;
        $[r.i]_offset + ($[r.i]_stride * $[r.i]_cnt)
      )

      declare $[r.i]_pidx  : collection {key : $[r.key_type], value: int} @Map
      declare $[r.i]_parts : collection {key : int, value: collection $[r.val_type] @Collection} @Map

      trigger $[r.i]_exchange : () = \_ -> (
        ((ignore $[r.query])
          @PartitionShuffleWithMissing(
            lbl           = [# $[r.i]_exchange]
          , dest_trg      = [$ $[r.i]_process_exchange]
          , nodes         = nodes
          , send_extra_fn = [$ \x -> x]
          , send_ty       = [: $[|specializeMapTypeByKV 'elem_type|] ]
          ));
          $[r.clear]
      )

      trigger $[r.i]_process_exchange : $[|specializeMapTypeByKV 'elem_type|] = \vals -> (
        (vals.iterate (\v ->
          $[r.i]_pidx.lookup {key: v.key, value: 0}
            (\_ -> let bucket_id = $[r.i]_next_bucket ()
                   in (($[r.i]_pidx.insert  {key: v.key,     value: bucket_id});
                       ($[r.i]_parts.insert {key: bucket_id, value: v.value})))
            (\bucket_id -> $[r.i]_parts.insert_with {key: bucket_id, value: v.value} (\old -> \new -> old.combine new)));
        ( ( $[lbl]_global_barrier, $[coordinator] ) <- ()
        ) @OnCounter(id=[# $[r.i]_exchange_done], eq=[$ $[nodes].size()], reset=[$ false], profile=[$ false])
        )
      )
  }
}


control MosaicMultiwayJoin [ lbl : label
                           , relations : [{ i : label
                                           , key_type  : type
                                           , val_type  : type
                                           , elem_type : type
                                           , query     : expr
                                           , clear     : expr }]
                           , joinOrder : [{ lbl              : label
                                          , lhs_ht_id        : label
                                          , lhs_query        : expr
                                          , lhs_query_clear  : expr
                                          , rhs_query        : expr
                                          , rhs_query_clear  : expr
                                          , lhs_ht_ty        : type
                                          , rhs_ht_ty        : type
                                          , lhs_insert_with  : expr
                                          , lhs_probe        : expr
                                          , result_id        : label
                                          , result_ty        : type
                                          , lhs_ht_clear     : expr }]
                           , next        : expr
                           , coordinator : expr
                           , nodes       : expr
                           ]
{
  () => nodes.iterate (\p -> $[| mosaicStartMultiwayJoin 'joinOrder "p.addr" |])
          // Generate a message to the first join's lhs_redistribute trigger
  +>
  {
    trigger $[lbl]_mjoin_barrier : () = \_ -> (
      ( () @MosaicFetchPartitions( lbl         = lbl
                                 , relations   = relations
                                 , partitions  = [$ $[| mosaicMultiwayJoinResult 'joinOrder |] ]
                                 , next        = next
                                 , coordinator = coordinator
                                 , nodes       = nodes )
      ) @OnCounter( id=[# $[lbl]_mjoin_done], eq=[$ $[| mosaicMjoinBarrierCount 'relations 'nodes |] ]
                  , reset=[$ false], profile=[$ false] )
    )

    for J in joinOrder:
      declare $[J.lhs_ht_id] : mut $[|specializeMapTypeByKV 'J.lhs_ht_ty|]
      declare $[J.result_id] : mut $[J.result_ty]

      trigger $[J.i]_lhs_redistribute : () = \_ -> (
        ((ignore $[J.lhs_query])
          @PartitionShuffleWithMissing(
            lbl           = [# $[J.i]_lhs]
          , dest_trg      = [$ $[J.i]_lhs_process_redistribute]
          , nodes         = nodes
          , send_extra_fn = [$ \x -> x]
          , send_ty       = [: $[|specializeMapTypeByKV 'J.lhs_ht_ty|] ]
          ));
          $[J.lhs_query_clear]
      )

      trigger $[J.i]_lhs_process_redistribute : $[|specializeMapTypeByKV 'J.lhs_ht_ty|] = (\vals ->
      ((vals.iterate (\v -> $[J.lhs_ht_id].insert_with v $[J.lhs_insert_with]));
        ( $[nodes].iterate (\p -> ($[J.i]_rhs_redistribute, p.addr) <- ())
        ) @OnCounter(id=[# $[J.i]_peer_build_done], eq=[$ $[nodes].size()], reset=[$ false], profile=[$ false]))
      )

      trigger $[J.i]_rhs_redistribute : () = \_ -> (
        (((ignore $[J.rhs_query])
              @PartitionShuffleWithMissing(
                lbl           = [# $[J.i]_rhs]
              , dest_trg      = [$ $[J.i]_rhs_process_redistribute]
              , nodes         = nodes
              , send_extra_fn = [$ \x -> x]
              , send_ty       = [: $[|specializeMapTypeByKV 'J.rhs_ht_ty|] ]
              );
          $[J.rhs_query_clear])
        ) @OnCounter(id=[# $[J.i]_lhs_done], eq=[$ $[nodes].size()], reset=[$ false], profile=[$ false])
      )

      trigger $[J.i]_rhs_process_redistribute : $[|specializeMapTypeByKV 'J.rhs_ht_ty|] = (\vals -> (
        // Probe LHS hash table.
        vals.iterate $[J.lhs_probe];
        ( ( $[J.lhs_ht_clear] );
          ( $[J.i]_global_barrier, $[coordinator] ) <- ()
        ) @OnCounter(id=[# $[J.i]_rhs_done], eq=[$ $[nodes].size()], reset=[$ false], profile=[$ false])
        ))

      trigger $[J.i]_global_barrier : () = \_ -> (
        ( $[| mosaicGlobalNextMultiwayJoin 'joinOrder 'J |]
            // Generate a message to the next join's lhs_redistribute trigger
        ) @OnCounter(id=[# $[J.i]_join_done], eq=[$ $[nodes].size()], reset=[$ false], profile=[$ false])
      )
  }
}


control MosaicFetchPartitions [ relations : [{ i : label
                                             , key_type  : type
                                             , val_type  : type
                                             , elem_type : type
                                             , query     : expr
                                             , clear     : expr }]
                              , partitions  : expr
                              , next        : expr
                              , coordinator : expr
                              , nodes       : expr
                              ]
{
  () => nodes.iterate (\p -> ($[lbl]_fetch_partitions, p.addr) <- ())
  +> {
    trigger $[lbl]_fetch_partitions : () = \_ -> (
      $[partitions].iterate (\part_ids ->
        $[| mosaicPartitionFetch 'relations "part_ids" |]
      )
    )

    trigger $[lbl]_fetch_barrier : () = \_ -> (
      ( $[next]
      ) @OnCounter(lbl=[# $[lbl]_fetch_done], eq=[$ nodes.size() ], reset=[$ false], profile=[$ false])
    )

    for r in relations:
      declare $[r.i]_exec_parts : collection {key : int, value: collection $[r.val_type] @Collection} @Map

      trigger $[r.i]_fetch_part : {part_id: int, dest : address} = \x -> (
        $[r.i]_parts.lookup {key: x.part_id, value: empty $[r.val_type] @Collection}
          (\_ -> ())
          (\partition -> ($[r.i]_recv_part, x.dest) <- {key: x.part_id, value: partition})
      )

      trigger $[r.i]_recv_part : {key: int, value: collection $[r.val_type] @Collection} = \part -> (
        ($[r.i]_exec_parts.insert part);
        ( ($[lbl]_fetch_barrier, coordinator) <- ()
        ) @OnCounter( id=[# $[J.i]_recv_part_done], eq=[$ $[| mosaicRecvPartitionBarrier 'relations 'r |] ]
                    , reset=[$ false], profile=[$ false] )
      )
  }
}

control MosaicExecutePartitions[coordinator : expr, nodes : expr]
{
  (?v = ?E; (?dest, me) <- ())
  => () @MosaicMultiExchange(
            lbl         = [# $#[v] ]
          , relations   = $[| mosaicExtractRelations 'E |]
          , joinOrder   = $[| mosaicExtractJoinOrder 'E |]
          , next        = [$ $[nodes].iterate (\p -> ($#[v]_execute, p.addr) <- ()) ]
          , coordinator = coordinator
          , nodes       = nodes
         )
  +> {
     trigger $#[v]_execute : () = \_ -> (
       $[| mosaicMultiwayJoinResultE 'E |].iterate (\j ->
         // We can skip assigning to partitions when the partition id is -1 (used to encode outer joins).
         $[| mosaicAssignInputPartitions 'E "j"|]

         // Execute query over partitions.
         // TODO: accumulate result over all partitions.
         $[| mosaicAccumulatePartition 'v 'E |]
       )
       ($.[dest], me) <- ()
     )
  }
}
