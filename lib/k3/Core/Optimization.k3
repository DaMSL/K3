include "Annotation/Maps/MapE.k3"

control ManualFusion {

  ((((((( ?e ).filter   ?filterF)
              .group_by ?gbF1 ?accF1 (?z1 : ?accT1))
              .fold     ((?foldF1) @:Accumulate) ?fz1)
              .group_by ((?gbF2) @:Projection) ((?accF2) @:Accumulate) ?z2)
  ) @:Fuse
  ) : collection ?t @IntMap
  => ( ($.[e].fold @:AccumulatingTransformer)
                   (\acc2 -> \v ->
                     if $.[filterF] v then
                     ( let k  = $.[gbF1] v in
                       let k2 = $.[gbF2] {key: k, value: $.[z1]} in
                       let cz1 = $.[fz1] in
                       ((acc2.upsert_with {key: k2, value: cz1}
                           (\_ -> let ncz1 = cz1 in
                                  ((ncz1.insert {key: k, value: (($.[accF1] $.[z1]) v)});
                                   {key: k2, value: ncz1})
                           )
                           (\acc -> ((acc.value.upsert_with {key:k, value: $.[z1]}
                                        (\_   -> {key: k, value: (($.[accF1] $.[z1]) v)})
                                        (\old -> {key: k, value: (($.[accF1] old.value) v)}));
                                     acc)
                           ));
                         acc2)
                     )
                     else acc2
                   )
                   (empty $::[t] @IntMap)
      )


  ((((((( ?e ).filter   ?filterF)
              .group_by ?gbF1 ?accF1 (?z1 : ?accT1))
              .fold     ((?foldF1) @:Accumulate) ?fz1)
              .group_by ((?gbF2) @:Projection) ((?accF2) @:Accumulate) ?z2)
  ) @:Fuse
  ) : collection ?t @StrMap
  => ( ($.[e].fold @:AccumulatingTransformer)
                   (\acc2 -> \v ->
                     if $.[filterF] v then
                     ( let k  = $.[gbF1] v in
                       let k2 = $.[gbF2] {key: k, value: $.[z1]} in
                       let cz1 = $.[fz1] in
                       ((acc2.upsert_with {key: k2, value: cz1}
                           (\_ -> let ncz1 = cz1 in
                                  ((ncz1.insert {key: k, value: (($.[accF1] $.[z1]) v)});
                                   {key: k2, value: ncz1})
                           )
                           (\acc -> ((acc.value.upsert_with {key:k, value: $.[z1]}
                                        (\_   -> {key: k, value: (($.[accF1] $.[z1]) v)})
                                        (\old -> {key: k, value: (($.[accF1] old.value) v)}));
                                     acc)
                           ));
                         acc2)
                     )
                     else acc2
                   )
                   (empty $::[t] @StrMap)
      )


  ((((((( ?e ).filter   ?filterF)
              .group_by ?gbF1 ?accF1 (?z1 : ?accT1))
              .fold     ((?foldF1) @:Accumulate) ?fz1)
              .group_by ((?gbF2) @:Projection) ((?accF2) @:Accumulate) ?z2)
  ) @:Fuse
  ) : collection ?t @Map
  => ( ($.[e].fold @:AccumulatingTransformer)
                   (\acc2 -> \v ->
                     if $.[filterF] v then
                     ( let k  = $.[gbF1] v in
                       let k2 = $.[gbF2] {key: k, value: $.[z1]} in
                       let cz1 = $.[fz1] in
                       ((acc2.upsert_with {key: k2, value: cz1}
                           (\_ -> let ncz1 = cz1 in
                                  ((ncz1.insert {key: k, value: (($.[accF1] $.[z1]) v)});
                                   {key: k2, value: ncz1})
                           )
                           (\acc -> ((acc.value.upsert_with {key:k, value: $.[z1]}
                                        (\_   -> {key: k, value: (($.[accF1] $.[z1]) v)})
                                        (\old -> {key: k, value: (($.[accF1] old.value) v)}));
                                     acc)
                           ));
                         acc2)
                     )
                     else acc2
                   )
                  (empty $::[t] @Map)
      )
}

// For use with Mosaic's fold encoding.
control MosaicFusion {

  // Filter-filter
  ((?e).filter ?filterF1).filter ?filterF2 => ($.[e].filter (\x -> ($.[filterF1] x) and ($.[filterF2] x))) @MosaicFusion

  // Map-maps encoded as folds.
  ((?e).fold (\_accmap -> (\?bvi1 -> (bind ?bv1 as ?bind1 in ((_accmap.insert ?v1); _accmap))))
             (?acc1 : collection ?t1))
       .fold (\_accmap -> (\?bvi2 -> (bind ?bv2 as ?bind2 in ((_accmap.insert ?v2); _accmap))))
             (?acc2 : collection ?t2)
  =>
  (($.[e] @MosaicFusion)
        .fold (\_accmap ->
                  \$#[bvi1] -> bind $.[bv1] as $~![bind1] in
                  (_accmap.insert ((\$#[bvi2] -> bind $.[bv2] as $~![bind2] in ($.[v2] @MosaicFusion))
                                  ($.[v1] @MosaicFusion));
                   _accmap))
              $.[acc2]
  ) @MosaicFusion

  // Map-filter, with map encoded as fold.
  ((?e).fold   (\_accmap -> (\?bvi1 -> (bind ?bv1 as ?bind1 in ((_accmap.insert ?v1); _accmap))))
               (?acc1 : collection ?t1))
       .filter ?filterF
  =>
  (($.[e] @MosaicFusion)
        .fold (\_accmap -> \$#[bvi1] -> bind $.[bv1] as $~![bind1] in
                let r = $.[v1] @MosaicFusion in
                if $.[filterF] r then (_accmap.insert r; _accmap) else _accmap)
              $.[acc1]
  ) @MosaicFusion

  // Filter-map, with map encoded as fold.
  ((?e).filter ?filterF)
       .fold   (\_accmap -> (\?bvi1 -> (bind ?bv1 as ?bind1 in ((_accmap.insert ?v1); _accmap))))
               (?acc1 : collection ?t1)
  =>
  (($.[e] @MosaicFusion)
       .fold (\_accmap -> \$#[bvi1] ->
                if $.[filterF] $#[bvi1]
                  then bind $.[bv1] as $~![bind1] in ((_accmap.insert ($.[v1] @MosaicFusion)); _accmap)
                  else _accmap)
             $.[acc1]
  ) @MosaicFusion

  // Map-sum encoded as folds.
  ((?e).fold (\_accmap -> (\?bvi1 -> (bind ?bv1 as ?bind1 in ((_accmap.insert ?v1); _accmap))))
             (?acc1 : collection ?t1))
       .fold (\?acc2i -> (\?bvi2 -> (bind ?bv2 as ?bind2 in (?acc2v + ?v2))))
             ?acc2
  =>
  (($.[e] @MosaicFusion)
        .fold (\$#[acc2i] -> \$#[bvi1] ->
                bind $.[bv1] as $~![bind1] in
                $.[acc2v] + ((\$#[bvi2] -> bind $.[bv2] as $~![bind2] in ($.[v2] @MosaicFusion)) ($.[v1] @MosaicFusion)))
              $.[acc2]
  ) @MosaicFusion

  // TODO: chained fusion rules for filter-map/map-filter and map.

  // Fold search descent
  (?e).fold ?accF ?z => (($.[e] @MosaicFusion).fold $.[accF] $.[z])

  // Group-by search descent
  (?e).group_by ?groupF ?accF ?z => ($.[e] @MosaicFusion).group_by $.[groupF] $.[accF] $.[z]

  // Children descent.
  ?E => $[| rewriteChildren 'E.expr ["MosaicFusion"] |]
}

control MosaicPartition {
  ?E => $[|propagatePartition 'E.expr|]
}

// Create base relation indexes for Mosaic warmup map accesses.
control MosaicIndex[ lbl          : label
                   , key_type     : type
                   , lookup_probe : expr
                   , index_probe  : expr
                   , missing_fn   : expr
                   , present_fn   : expr
                   , index_key    : [labeltype]
                   , index_value  : [labeltype]]
{
  // Slice materialization
  ((?e.filter ?filterF)
      .fold   ?foldF (?acc1 : ?t1)
  )
  => ($[lbl]_index.lookup $[lookup_probe] (\_ -> $.[acc1]) (\r -> r.value)) @:{PartitionAlias "$[|initPartition 'lookup_probe index_probe|]"}
  +> {
    declare $[lbl]_index : mut collection {key: $[key_type], value: $::[t1]} @MapE(key:=index_key, value:=index_value)

    declare $[lbl]_init_index : () -> () = \_ -> (
      $.[e].iterate (\t -> $[lbl]_index.upsert_with $[index_probe] $[missing_fn] $[present_fn])
    )
  }
}

// Create stages and materialized intermediates for Mosaic warmup expressions.
control MosaicMaterialization[lbl : label, cnt : expr, finaltrg : expr]
{
  ?v = ((?e.fold ?accF ?z) @MosaicFusion)
  => ($#[v] = (($.[e].fold $.[accF] $.[z]) @MosaicFusion)) @MosaicMaterialization(lbl=lbl, cnt=cnt, finaltrg=finaltrg)

  ?v = ((?e.group_by ?groupF ?accF ?z) @MosaicFusion)
  => ($#[v] = (($.[e].group_by $.[groupF] $.[accF] $.[z]) @MosaicFusion)) @MosaicMaterialization(lbl=lbl, cnt=cnt, finaltrg=finaltrg)

  (?v = ((?e @:BaseRelation).fold ?accF ?z)); (?dest, me) <- ()
  => (($#[v] = $.[e].fold $.[accF] $.[z]) @MosaicPartition); ($.[dest], me) <- ()

  (?v = ((?e @:BaseRelation).group_by ?groupF ?accF ?z)); (?dest, me) <- ()
  => (($#[v] = $.[e].group_by $.[groupF] $.[accF] $.[z]) @MosaicPartition); ($.[dest], me) <- ()

  ?v = ((?e : ?t).fold ?accF ?z)
  => ((($[lbl]_$[| labelExpr 'cnt |] = $.[e]);
        ($[lbl]_stage$[| labelExpr 'cnt |], me) <- ())
          @MosaicMaterialization(lbl=lbl, cnt=[$ $[|incrExpr 'cnt|] ], finaltrg=finaltrg))
  +> {
    declare $[lbl]_$[| labelExpr 'cnt |] : mut $::[t]

    trigger $[lbl]_stage$[| labelExpr 'cnt|] : () = \_ -> (
      (($#[v] = $[lbl]_$[| labelExpr 'cnt |].fold $.[accF] $.[z]) @MosaicPartition);
      ($[finaltrg], me) <- ()
    )
  }

  (?v = ((?e : ?t).fold ?accF ?z)); (?dest, me) <- ()
  => ((($[lbl]_$[| labelExpr 'cnt |] = $.[e]);
        ($[lbl]_stage$[| labelExpr 'cnt |], me) <- ())
          @MosaicMaterialization(lbl=lbl, cnt=[$ $[|incrExpr 'cnt|] ], finaltrg=finaltrg))
  +> {
    declare $[lbl]_$[| labelExpr 'cnt |] : mut $::[t]

    trigger $[lbl]_stage$[| labelExpr 'cnt|] : () = \_ -> (
      (($#[v] = $[lbl]_$[| labelExpr 'cnt |].fold $.[accF] $.[z]) @MosaicPartition);
      ($.[dest], me) <- ()
    )
  }

  ?v = ((?e : ?t).group_by ?groupF ?accF ?z)
  => ((($[lbl]_$[| labelExpr 'cnt |] = $.[e]);
        ($[lbl]_stage$[| labelExpr 'cnt |], me) <- ())
          @MosaicMaterialization(lbl=lbl, cnt=[$ $[|incrExpr 'cnt|] ], finaltrg=finaltrg))
  +> {
    declare $[lbl]_$[| labelExpr 'cnt |] : mut $::[t]

    trigger $[lbl]_stage$[| labelExpr 'cnt|] : () = \_ -> (
      (($#[v] = $[lbl]_$[| labelExpr 'cnt |].group_by $.[groupF] $.[accF] $.[z]) @MosaicPartition);
      ($[finaltrg], me) <- ()
    )
  }

  (?v = ((?e : ?t).group_by ?groupF ?accF ?z)); (?dest, me) <- ()
  => ((($[lbl]_$[| labelExpr 'cnt |] = $.[e]);
        ($[lbl]_stage$[| labelExpr 'cnt |], me) <- ())
          @MosaicMaterialization(lbl=lbl, cnt=[$ $[|incrExpr 'cnt|] ], finaltrg=finaltrg))
  +> {
    declare $[lbl]_$[| labelExpr 'cnt |] : mut $::[t]

    trigger $[lbl]_stage$[| labelExpr 'cnt|] : () = \_ -> (
      (($#[v] = $[lbl]_$[| labelExpr 'cnt |].group_by $.[groupF] $.[accF] $.[z]) @MosaicPartition);
      ($.[dest], me) <- ()
    )
  }
}
