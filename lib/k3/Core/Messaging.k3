control SendByKey[dest_trg : expr, barrier_trg : expr, nodes : expr, send_extra_fn : expr] {
  ?e => ( $.[e].iterate (\v -> case $[nodes].at v.key of
                               { Some p -> ($[dest_trg], p.addr) <- ($[send_extra_fn] v.value) }
                               { None -> error () }
                        );

          // Send punctuation: we're done
          $[nodes].iterate(\p -> ($[barrier_trg], p.addr) <- ()) )
}

control PartitionByKey {
  ?e : collection ?t @Map
      => ( ($.[e].groupBy @:HGroupBy) (\v -> index_by_hash v.key)
                                      (\acc -> \v -> ((acc.insert v); acc))
                                      empty $::[t] @Map )

  ?e : collection ?t
      => ( $.[e].groupBy (\v -> index_by_hash v.key)
                         (\acc -> \v -> ((acc.insert v); acc))
                         empty $::[t] @Collection )
}

control PartitionRoundRobin {
  ?e : collection ?t @Map
    => ( let i = mut 0 in
         ($.[e].groupBy @:HGroupBy) (\v -> ((i = i + 1); (i % ($[nodes].size()))))
                                    (\acc -> \v -> ((acc.insert v); acc))
                                    empty $::[t] @Map )

  ?e : collection ?t
    => ( let i = mut 0 in
         $.[e].groupBy (\v -> ((i = i + 1); (i % ($[nodes].size()))))
                       (\acc -> \v -> ((acc.insert v); acc))
                       empty $::[t] @Collection )
}

control SendPartitionByKey[dest_trg : expr, barrier_trg : expr, nodes : expr, send_extra_fn : expr] {
  ?e : collection ?t
    => ( $.[e] @PartitionByKey
       ) @SendByKey(dest_trg = dest_trg, barrier_trg = barrier_trg, nodes = nodes, send_extra_fn = send_extra_fn)
}

control SendRoundRobin[dest_trg : expr, barrier_trg : expr, nodes : expr, send_extra_fn : expr] {
  ?e : collection ?t
    => ( $.[e] @PartitionRoundRobin
       ) @SendByKey(dest_trg = dest_trg, barrier_trg = barrier_trg, nodes = nodes, send_extra_fn = send_extra_fn)
}

control SendBroadcast[dest_trg : expr, barrier_trg : expr, nodes : expr, send_extra_fn : expr] {
  ?e : collection ?t
    => ( $[nodes].iterate (\n -> ((($[dest_trg],    n.addr) <- ($[send_extra_fn] $.[e]));
                                   ($[barrier_trg], n.addr) <- ()))
       )
}