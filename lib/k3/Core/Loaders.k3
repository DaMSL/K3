include "Annotation/Collection.k3"

control ScanCSV[lbl : label, filepath : expr, blocksize : expr, next_peer : expr, parser : expr, fn : expr, done : expr] {
  ( empty ?t @Collection ) => empty $::[t] @Collection
    +> {
         declare $[lbl]_init_scan : () -> () = \_ -> (
           (openFile $[|exprLabel 'lbl|] $[filepath] "k3" "r");
           ($[lbl]_scan_block, me) <- ()
         )

         trigger $[lbl]_scan_block : () = \_ -> (
           if hasRead $[|exprLabel 'lbl|]
           then (let b = doReadBlock $[|exprLabel 'lbl|] $[blocksize] in
                 let p = $[next_peer]
                 in (($[lbl]_process_block, p) <- b);
                    (($[lbl]_scan_block, me) <- ()))
           else ((close $[|exprLabel 'lbl|]); $[done])
         )

         trigger $[lbl]_process_block : collection {elem: string} @Collection = \block -> (
          let b = block.fold (\acc -> \v -> ((acc.insert ($[parser] v)); acc))
                             (empty $::[t] @Collection)
          in $[fn] b
         )
       }

  (() @:Run) => $[lbl]_init_scan ()
}

control ScanCSVForPeers[lbl : label, filepath : expr, blocksize : expr, parser : expr, fn : expr, done : expr] {
  ( empty ?t @Collection ) => ( empty $::[t] @Collection )
      @ScanCSV(  lbl       = lbl
               , filepath  = filepath
               , blocksize = blocksize
               , next_peer = [$ (($[lbl]_next_peer = ($[lbl]_next_peer + 1 % local_peers.size()));
                                  local_peers.at ($[lbl]_next_peer)) ]
               , parser    = parser
               , fn        = fn
               , done      = done)

  +> { declare $[lbl]_next_peer : mut int = 0 }
}


control GatherCollection [ lbl      : label
                         , nodes    : expr
                         , next     : expr ]
{
  ignore ( ?e : ?t ) => $[nodes].iterate (\p -> ($[lbl]_fetch, p.addr) <- me)
   +> {
        declare $[lbl]_stash : mut collection {key: address, value: $::[t]} @Map

        trigger $[lbl]_fetch : address = \dest -> (
          ($[lbl]_push, dest) <- {key: me, value: $.[e]}
        )

        trigger $[lbl]_push : {key: address, value: $::[t]} = \v -> (
          $[lbl]_stash.insert v;
          ( ($[next] $[lbl]_stash);
            $[lbl]_stash = empty {key: address, value: $::[t]} @Map
          ) @OnCounter(lbl=[# $[lbl]_gathered], eq=[$ $[nodes].size()], reset=[$ false], profile=[$ false])
        )
      }
}

control GatherCollectionAsCSV [ lbl      : label
                              , filepath : expr
                              , nodes    : expr
                              , next     : expr ]
{
  ignore ( ?e : ?t ) => ignore ( $.[e] @GatherCollection(lbl=lbl, nodes=nodes, next=[$ (\v -> (($[lbl]_save_csv v); $[next])) ]) )
   +> {
        // TODO: generate builtin
        declare $[lbl]_save_csv : string -> collection {key: address, value: $::[t]} @Map -> ()
      }
}

control GatherResultsAsCSV [query_cl : [label], nodes : expr, outdir : expr]
{
  () => $[| let gatherE clbl = idOfSLabel clbl >>= \ci ->
                                  (EC.applyMany (EC.variable "ignore") [EC.variable ci]
                                  ) @+ (EApplyGen True "GatherCollectionAsCSV" $
                                          mkSpliceEnv [ ("lbl", clbl)
                                                      , ("filepath", EC.binop OConcat (expOfSExpr 'outdir)
                                                                      $ EC.constant $ CString $ "/" ++ ci)
                                                      , ("nodes", 'nodes)
                                                      , ("next", SExpr EC.unit)])
            in EC.block $ catMaybes (elemsOfSList 'query_cl >>= mapM gatherE)
         |]
}

@:CArgs 2
declare loadQ1: string -> collection {pageURL: string,pageRank: int} @ { Collection } -> ()

@:CArgs 2
declare loadQ2: string -> collection {adRevenue: real, sourceIP: string} @ { Collection } -> ()


@:CArgs 2
declare loadUVQ3: string -> collection {sourceIP: string, destURL: string, visitDate: string, adRevenue: real } @{ Collection } -> ()

@:CArgs 2
declare loadRKQ3 : string -> collection {key: string, value: int} @Map  -> ()

@:CArgs 2
declare graphLoader: string -> collection { key: int, value: int } @ { Collection } -> ()

@:CArgs 2
declare loadGraph: string -> collection { key: int, value: collection { elem: int } @ Collection  } @ Map  -> ()
