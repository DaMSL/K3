include "Core/Messaging.k3"

declare masters      : collection {addr : address} @Collection
declare local_peers  : collection {addr : address} @Collection
declare peer_masters : collection {key: address, value: address} @Map

// Split a single partitioned broadcast into a dual-tier messaging pattern.
control DispatchByMachine[ lbl : label, dest_trg : expr
                         , masters : expr, masters_map : expr
                         , send_ty : type, send_extra_fn : expr]
{
  // Rewrite the receiving trigger to to synchronously call the existing trigger on the global
  // stashed by the machine-local master. As long as the trigger doesn't modify its argument, the
  // global will be passed in by constant reference, and no copies will take place.
  ((\?x -> ?b) @:Broadcast)
     => (\$#[x] -> $.[b])
     +> { trigger $[lbl]_peerproxy : int = \msg_id -> (
            ( $[lbl]_machvar.lookup_with {key: msg_id, value: $[lbl]_machvar_default}
                                         (\r -> (\$#[x] -> $.[b]) r.value) );
            ( $[masters_map].lookup_with {key:me, value:me}
                                         (\ms -> ($[lbl]_machvar_gc, ms.value) <- msg_id ) )
          )
        }

  ( ignore ?e ) @: SendBroadcast
     => ( $[masters].iterate (\n -> ($[lbl]_machproxy, n.addr) <- ($[send_extra_fn] $.[e])) )
     +> {
          @:Pinned
          declare $[lbl]_machvar : collection {key: int, value: $[send_ty]} @Map

          @:Pinned
          declare $[lbl]_machvar_gc_ids : collection {key: int, value: int} @Map

          // @:Pinned
          // TODO: pinning this causes a code generator bug.
          declare $[lbl]_machvar_cnt : mut int = 0

          @:Pinned
          declare $[lbl]_machvar_default : $[send_ty]

          // These two triggers must only run at the machine master since they modify
          // the above pinned variables.

          trigger $[lbl]_machproxy : $[send_ty] = \m -> (
            ( $[lbl]_machvar.insert        {key: $[lbl]_machvar_cnt, value: m} );
            ( $[lbl]_machvar_gc_ids.insert {key: $[lbl]_machvar_cnt, value: local_peers.size()} );
            ( local_peers.iterate (\a -> ($[lbl]_peerproxy, a.addr) <- $[lbl]_machvar_cnt) );
            $[lbl]_machvar_cnt = $[lbl]_machvar_cnt + 1
          )

          trigger $[lbl]_machvar_gc : int = \msg_id -> (
            $[lbl]_machvar_gc_ids.lookup_with {key: msg_id, value: 0}
              (\r -> if r.value == 1
                     then ( ($[lbl]_machvar_gc_ids.erase r);
                            ($[lbl]_machvar.erase {key:msg_id, value: $[lbl]_machvar_default}) )
                     else ( $[lbl]_machvar_gc_ids.upsert_with r
                              (\_ -> {key: r.key, value: r.value - 1})
                              (\_ -> {key: r.key, value: r.value - 1}) )
              )
          )
        }

  ((\?x -> ?b) @:Shuffle)
     => (\$#[x] -> $.[b])
     +> { trigger $[lbl]_peerproxy : int = \msg_id -> (
            $[lbl]_machvar.lookup_with
                {key: msg_id, value: $[lbl]_machvar_peer_default}
                (\r -> (
                  ( r.value.lookup_with {key: me, value: $[lbl]_machvar_default}
                                        (\v -> (\$#[x] -> $.[b]) v.value) );

                  ( $[masters_map].lookup_with {key:me, value:me}
                                               (\ms -> ($[lbl]_machvar_gc, ms.value) <- msg_id) ))
                )
          )
        }

  ( ignore ?e ) @: SendShuffle
     => $.[e].iterate (\v -> ($[lbl]_machproxy, v.key) <- v.value)
     +> {
          @:Pinned
          declare $[lbl]_machvar : collection {key: int, value: collection {key: address, value: $[send_ty]} @Map} @Map

          @:Pinned
          declare $[lbl]_machvar_gc_ids : collection {key: int, value: int} @Map

          // @:Pinned
          // TODO: pinning this causes a code generator bug.
          declare $[lbl]_machvar_cnt : mut int = 0

          @:Pinned
          declare $[lbl]_machvar_peer_default : collection {key: address, value: $[send_ty]} @Map

          @:Pinned
          declare $[lbl]_machvar_default : $[send_ty]

          trigger $[lbl]_machproxy : collection {key: address, value: $[send_ty]} @Map = \m -> (
            ( $[lbl]_machvar.insert {key: $[lbl]_machvar_cnt, value: m} );
            ( $[lbl]_machvar_gc_ids.insert {key: $[lbl]_machvar_cnt, value: local_peers.size()} );
            ( local_peers.iterate (\a -> ($[lbl]_peerproxy, a.addr) <- $[lbl]_machvar_cnt) );
            $[lbl]_machvar_cnt = $[lbl]_machvar_cnt + 1
          )

          // For simplicity, garbage collection in bulk across all peers, rather than per-peer.
          trigger $[lbl]_machvar_gc : int = \msg_id -> (
            $[lbl]_machvar_gc_ids.lookup_with {key: msg_id, value: 0}
              (\r -> if r.value == 1
                     then ( ($[lbl]_machvar_gc_ids.erase r);
                            ($[lbl]_machvar.erase {key:msg_id, value: $[lbl]_machvar_peer_default}) )
                     else ( $[lbl]_machvar_gc_ids.upsert_with r
                              (\_ -> {key: r.key, value: r.value - 1})
                              (\_ -> {key: r.key, value: r.value - 1}) )
              )
          )
        }
}

control BroadcastByMachine[lbl : label, dest_trg : expr, masters : expr, masters_map : expr
                         , send_ty : type, send_extra_fn : expr]
{
  ( ignore (?e : collection ?t) ) @:Send
    => (( ignore $.[e] ) @: SendBroadcast
       ) @DispatchByMachine( lbl = lbl, dest_trg = barrier_trg
                           , masters = masters, masters_map = masters_map
                           , send_ty = send_ty, send_extra_fn = send_extra_fn )

    +> {}

  () @:Send
    => ( ( ignore () ) @: SendBroadcast
       ) @DispatchByMachine( lbl = lbl, dest_trg = barrier_trg
                           , masters = masters, masters_map = masters_map
                           , send_ty = send_ty, send_extra_fn = send_extra_fn )

    +> {}

  ( (\?x -> ?b) @:Receive )
     => ( (\$#[x] -> $.[b]) @:Broadcast
        ) @DispatchByMachine( lbl = lbl, dest_trg = barrier_trg
                            , masters = masters, masters_map = masters_map
                            , send_ty = send_ty, send_extra_fn = send_extra_fn )
}

// Partition a collection into a triply-nested map (machine address => peer address => data)
// for sending as a batched shuffle.
control PartitionByKeyMachine[masters_map : expr, nodes : expr, send_ty : type, send_extra_fn : expr] {
  ?e : collection ?t @Map
      => ((( ($.[e].groupBy @:HGroupBy) (\v -> case $[nodes].at (index_by_hash v.key)
                                               of { Some n -> n.addr }
                                                  { None -> ((error (print ("Invalid node"))); me) }
                                        )
                                        (\acc -> \v -> ((acc.insert v); acc))
                                        (empty $::[t] @Map) )
                   .groupBy @:HGroupBy) (\v -> case $[masters_map].lookup {key: v.key, value: me}
                                               of { Some mstr -> mstr.value }
                                                  { None -> ((error (print ("No machine master found for " ++ (atos v.key)))); me) }
                                        )
                                        (\acc -> \v -> ((acc.insert {key: v.key, value: ($[send_extra_fn] v.value)}); acc))
                                        (empty {key: address, value: $[send_ty]} @Map))

  ?e : collection ?t
      => (($.[e].groupBy (\v -> case $[nodes].at (index_by_hash v.key)
                                of { Some n -> n.addr }
                                   { None -> ((error (print ("Invalid node"))); me) }
                         )
                         (\acc -> \v -> ((acc.insert v); acc))
                         (empty $::[t] @Collection))
                .groupBy (\v -> case $[masters_map].lookup {key: v.key, value: me}
                                of { Some mstr -> mstr.value }
                                   { None -> ((error (print ("No machine master found for " ++ (atos v.key)))); me) }
                         )
                         (\acc -> \v -> ((acc.insert {key: v.key, value: ($[send_extra_fn] v)}); acc))
                         (empty {key: address, value: $[send_ty]} @Collection))
}

control ShuffleByMachine[ lbl : label, punclbl : label
                        , dest_trg : expr, barrier_trg : expr
                        , nodes : expr, masters : expr, masters_map : expr
                        , send_ty : type, send_extra_fn : expr ]
{
  ( ignore (?e : collection ?t) ) @:Send
    => (( ((ignore ( $.[e] @PartitionByKeyMachine( masters_map = masters_map, nodes = nodes
                                                 , send_ty = send_ty, send_extra_fn = send_extra_fn)
                   )
          ) @:SendShuffle
          ) @DispatchByMachine(
                lbl = lbl, dest_trg = dest_trg, masters = masters, masters_map = masters_map
              , send_ty = send_ty, send_extra_fn = send_extra_fn)
          );
          (( ignore () ) @:SendBroadcast
          ) @DispatchByMachine(
                lbl = punclbl, dest_trg = barrier_trg, masters = masters, masters_map = masters_map
              , send_ty = [: ()], send_extra_fn = [$ \x -> x ])
       )
    +> {}

  ( (\?x -> ?b) @:Receive )
    => ( (\$#[x] -> $.[b]) @:Shuffle
       )  @DispatchByMachine( lbl = lbl, dest_trg = dest_trg, masters = masters, masters_map = masters_map
                            , send_ty = send_ty, send_extra_fn = send_extra_fn )
    +> {}

  ( (\?x -> ?b) @:BarrierReceive )
    => ( (\$#[x] -> $.[b]) @:Broadcast
       )  @DispatchByMachine( lbl = punclbl, dest_trg = barrier_trg, masters = masters, masters_map = masters_map
                            , send_ty = [: ()], send_extra_fn = [$ \x -> x ] )
    +> {}

}