declare error : () -> unknown

declare __map_ids__ : collection { _r1_:int, _r2_:string, _r3_:int
  } @ { Collection } = {| _r1_:int, _r2_:string, _r3_:int |
  {_r1_:1, _r2_:"ATIMESD", _r3_:1}, {_r1_:2, _r2_:"ATIMESD_mT1", _r3_:2},
  {_r1_:3, _r2_:"ATIMESD_mT1_mR1", _r3_:3},
  {_r1_:4, _r2_:"ATIMESD_mS1", _r3_:2}, {_r1_:5, _r2_:"ATIMESD_mS2", _r3_:2},
  {_r1_:6, _r2_:"ATIMESD_mR1", _r3_:2}|} @ { Collection }

declare __vid_counter__ : collection {i:int} @ { Collection } = {|i:int|
  1|} @ { Collection }

declare __epoch__ : collection {i:int} @ { Collection } = {|i:int|
  0|} @ { Collection }

declare __init_vid__ : { _r1_:int, _r2_:int, _r3_:int } =
  {_r1_:0, _r2_:0, _r3_:hash me}

declare ATIMESD : ind collection {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:int } @ { Collection } = ind {|
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
  {key:__init_vid__, value:0}|} @ { Collection }

declare ATIMESD_mT1 : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare ATIMESD_mT1_mR1 : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Collection }

declare ATIMESD_mS1 : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare ATIMESD_mS2 : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare ATIMESD_mR1 : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mT1_s0_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mT1_mR1_s2_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Collection }

declare map_ATIMESD_mT1_s3_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mT1_mR1_s5_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Collection }

declare map_ATIMESD_mS1_s6_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mS2_s6_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mS1_s7_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mS2_s9_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mS1_s10_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mS2_s10_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mS1_s11_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mS2_s13_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mR1_s14_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mT1_mR1_s15_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Collection }

declare map_ATIMESD_mR1_s17_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mT1_mR1_s18_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Collection }

declare map_ATIMESD_mS2_s24_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mS2_s26_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mS1_s28_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mS1_s30_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mS2_s32_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mS2_s34_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mS1_s36_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map_ATIMESD_mS1_s38_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare __stmt_cntrs__ : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare log__master : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare log_insert_T : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare log_delete_T : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare log_insert_S : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare log_delete_S : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare log_insert_R : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare log_delete_R : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare vid_eq : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in l0 == r0 and (l1 == r1 and l2
  == r2))

declare vid_neq : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in not (l0 == r0 and (l1 == r1 and
  l2 == r2)))

declare vid_lt : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in l0 < r0 or (l0 == r0 and (l1 <
  r1 or (l1 == r1 and l2 < r2))))

declare vid_gt : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in l0 > r0 or (l0 == r0 and (l1 >
  r1 or (l1 == r1 and l2 > r2))))

declare vid_leq : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in not (l0 > r0 or (l0 == r0 and
  (l1 > r1 or (l1 == r1 and l2 > r2)))))

declare vid_geq : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in not (l0 < r0 or (l0 == r0 and
  (l1 < r1 or (l1 == r1 and l2 < r2)))))

declare frontier_int_int_int : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Collection } } -> collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {key:vid, value:input_map} in (input_map.groupBy
                                                  ((\_b1_ -> 
                                                    bind _b1_ as {_r1_:map_vid,
                                                                  _r2_:__map_0,
                                                                  _r3_:__map_1,
                                                                  _r4_:__map_val} in 
                                                    {key:__map_0, value:__map_1}))
                                                  ((\_b2_ -> (\_b5_ -> 
                                                    bind _b2_ as {key:acc,
                                                                  value:max_vid} in 
                                                    bind _b5_ as {_r1_:map_vid,
                                                                  _r2_:__map_0,
                                                                  _r3_:__map_1,
                                                                  _r4_:__map_val} in 
                                                    if vid_lt
                                                         {key:map_vid,
                                                          value:vid}
                                                    then
                                                      if vid_eq
                                                           {key:map_vid,
                                                            value:max_vid}
                                                      then
                                                        {key:({|
                                                         _r1_:{
                                                         _r1_:int, _r2_:int,
                                                         _r3_:int }, _r2_:int,
                                                         _r3_:int, _r4_:int |
                                                         {_r1_:map_vid,
                                                          _r2_:__map_0,
                                                          _r3_:__map_1,
                                                          _r4_:__map_val}|} @ { Collection }).combine
                                                         acc, value:max_vid}
                                                      else
                                                        if vid_gt
                                                             {key:map_vid,
                                                              value:max_vid}
                                                        then
                                                          {key:{|
                                                           _r1_:{
                                                           _r1_:int, _r2_:int,
                                                           _r3_:int },
                                                           _r2_:int, _r3_:int,
                                                           _r4_:int |
                                                           {_r1_:map_vid,
                                                            _r2_:__map_0,
                                                            _r3_:__map_1,
                                                            _r4_:__map_val}|} @ { Collection },
                                                           value:map_vid}
                                                        else
                                                          {key:acc,
                                                           value:max_vid}
                                                    else
                                                      {key:acc, value:max_vid})))
                                                  {key:empty {
                                                   _r1_:{
                                                   _r1_:int, _r2_:int, _r3_:int
                                                   }, _r2_:int, _r3_:int,
                                                   _r4_:int } @ { Collection },
                                                   value:{_r1_:0, _r2_:0,
                                                          _r3_:0}}).fold
                                                 ((\__acc_ext -> (\_b3_ -> 
                                                   bind _b3_ as {value:_b4_} in 
                                                   bind _b4_ as {key:project} in 
                                                   __acc_ext.combine 
                                                 project))) empty {
                                                 _r1_:{
                                                 _r1_:int, _r2_:int, _r3_:int
                                                 }, _r2_:int, _r3_:int,
                                                 _r4_:int } @ { Collection })

declare frontier_int : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:int } @ { Collection }
  } -> collection { key:{ _r1_:int, _r2_:int, _r3_:int }, value:int
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {key:vid, value:input_map} in bind input_map.fold
                                                      ((\_b2_ -> (\_b5_ -> 
                                                        bind _b2_ as {
                                                        key:acc, value:max_vid} in 
                                                        bind _b5_ as {
                                                        key:map_vid,
                                                        value:__map_val} in 
                                                      if vid_lt
                                                           {key:map_vid,
                                                            value:vid}
                                                      then
                                                        if vid_eq
                                                             {key:map_vid,
                                                              value:max_vid}
                                                        then
                                                          {key:({|
                                                           key:{
                                                           _r1_:int, _r2_:int,
                                                           _r3_:int },
                                                           value:int |
                                                           {key:map_vid,
                                                            value:__map_val}|} @ { Collection }).combine
                                                           acc, value:max_vid}
                                                        else
                                                          if vid_gt
                                                               {key:map_vid,
                                                                value:max_vid}
                                                          then
                                                            {key:{|
                                                             key:{
                                                             _r1_:int,
                                                             _r2_:int, _r3_:int
                                                             }, value:int |
                                                             {key:map_vid,
                                                              value:__map_val}|} @ { Collection },
                                                             value:map_vid}
                                                          else
                                                            {key:acc,
                                                             value:max_vid}
                                                      else
                                                        {key:acc, value:max_vid})))
                                                      {key:empty {
                                                       key:{
                                                       _r1_:int, _r2_:int,
                                                       _r3_:int }, value:int
                                                       } @ { Collection },
                                                       value:{_r1_:0, _r2_:0,
                                                              _r3_:0}} as {
  key:__1, value:__2} in __1)

declare frontier_int_int : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
  } -> collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {key:vid, value:input_map} in (input_map.groupBy
                                                  ((\_b1_ -> 
                                                    bind _b1_ as {_r1_:map_vid,
                                                                  _r2_:__map_0,
                                                                  _r3_:__map_val} in 
                                                    __map_0)) ((\_b2_ ->
                                                  (\_b5_ -> 
                                                    bind _b2_ as {key:acc,
                                                                  value:max_vid} in 
                                                    bind _b5_ as {_r1_:map_vid,
                                                                  _r2_:__map_0,
                                                                  _r3_:__map_val} in 
                                                    if vid_lt
                                                         {key:map_vid,
                                                          value:vid}
                                                    then
                                                      if vid_eq
                                                           {key:map_vid,
                                                            value:max_vid}
                                                      then
                                                        {key:({|
                                                         _r1_:{
                                                         _r1_:int, _r2_:int,
                                                         _r3_:int }, _r2_:int,
                                                         _r3_:int |
                                                         {_r1_:map_vid,
                                                          _r2_:__map_0,
                                                          _r3_:__map_val}|} @ { Collection }).combine
                                                         acc, value:max_vid}
                                                      else
                                                        if vid_gt
                                                             {key:map_vid,
                                                              value:max_vid}
                                                        then
                                                          {key:{|
                                                           _r1_:{
                                                           _r1_:int, _r2_:int,
                                                           _r3_:int },
                                                           _r2_:int, _r3_:int |
                                                           {_r1_:map_vid,
                                                            _r2_:__map_0,
                                                            _r3_:__map_val}|} @ { Collection },
                                                           value:map_vid}
                                                        else
                                                          {key:acc,
                                                           value:max_vid}
                                                    else
                                                      {key:acc, value:max_vid})))
                                                  {key:empty {
                                                   _r1_:{
                                                   _r1_:int, _r2_:int, _r3_:int
                                                   }, _r2_:int, _r3_:int
                                                   } @ { Collection },
                                                   value:{_r1_:0, _r2_:0,
                                                          _r3_:0}}).fold
                                                 ((\__acc_ext -> (\_b3_ -> 
                                                   bind _b3_ as {value:_b4_} in 
                                                   bind _b4_ as {key:project} in 
                                                   __acc_ext.combine 
                                                 project))) empty {
                                                 _r1_:{
                                                 _r1_:int, _r2_:int, _r3_:int
                                                 }, _r2_:int, _r3_:int
                                                 } @ { Collection })

declare log_read_geq : { _r1_:int, _r2_:int, _r3_:int } -> collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
  } @ { Collection } = (\vid2 -> 
    log__master.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:vid, _r2_:trig_id, _r3_:stmt_id} in vid_geq
                                                                 {key:vid,
                                                                  value:vid2})))

declare check_and_update_stmt_cntr_index : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:int } -> bool = (\_b1_ -> 
    bind _b1_ as {key:vid, value:stmt_id} in if __stmt_cntrs__.filter
                                               ((\_b1_ -> 
                                                 bind _b1_ as {_r1_:_r1_,
                                                               _r2_:_r2_,
                                                               _r3_:_r3_} in _r1_
                                               == vid and _r2_ == stmt_id)) !=
                                               empty {
                                               _r1_:{
                                               _r1_:int, _r2_:int, _r3_:int },
                                               _r2_:int, _r3_:int
                                               } @ { Collection }
                                             then (
                                                 case
                                                 ((__stmt_cntrs__.filter
                                                 ((\_b1_ -> 
                                                   bind _b1_ as {_r1_:_r1_,
                                                                 _r2_:_r2_,
                                                                 _r3_:_r3_} in _r1_
                                                 == vid and _r2_ == stmt_id))).peek
                                                 ())
                                                 of
                                                 {Some ctr_slice ->
                                                   __stmt_cntrs__.update
                                                     ctr_slice
                                                     (bind ctr_slice as {
                                                     _r1_:vid, _r2_:stmt_id,
                                                     _r3_:counter} in 
                                                     {_r1_:vid, _r2_:stmt_id,
                                                      _r3_:counter - 1})}
                                                 {None -> ()};
                                                 if ((__stmt_cntrs__.filter
                                                   ((\_b1_ -> 
                                                     bind _b1_ as {_r1_:_r1_,
                                                                   _r2_:_r2_,
                                                                   _r3_:_r3_} in 
                                                     _r1_ == vid and _r2_ ==
                                                   stmt_id))).peek ()) ==
                                                   Some {_r1_:vid,
                                                         _r2_:stmt_id, _r3_:0}
                                                 then true
                                                 else false
                                                 )
                                             else (
                                                 __stmt_cntrs__.insert
                                                   {_r1_:vid, _r2_:stmt_id,
                                                    _r3_:-1};
                                                 false
                                                 ))

declare add_delta_to_int_int_int : {
  _r1_:ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Collection }, _r2_:bool, _r3_:{ _r1_:int, _r2_:int, _r3_:int },
  _r4_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Collection } } -> () = (\_b1_ -> 
    bind _b1_ as {_r1_:target_map, _r2_:corrective, _r3_:min_vid,
                  _r4_:delta_tuples} in (
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_val} in 
      let lookup_value =
        if corrective
        then (bind target_map as ind __x in __x).filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in (_r1_
          == vid and _r3_ == __map_1) and _r2_ == __map_0))
        else empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
          } @ { Collection } in case (lookup_value.peek ()) of
      {Some val ->
        let update_value = __map_val +
          bind val as {_r1_:__1, _r2_:__2, _r3_:__3, _r4_:__4} in __4 in
        (bind
          target_map
          as ind __x
          in __x).insert
          {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:update_value}}{None ->
                                                                    let lookup_value =
                                                                    frontier_int_int_int
                                                                    {
                                                                    key:vid,
                                                                    value:(bind
                                                                    target_map
                                                                    as ind __x
                                                                    in __x).filter
                                                                    ((\_b1_ -> 
                                                                    bind _b1_ as {
                                                                    _r1_:_r1_,
                                                                    _r2_:_r2_,
                                                                    _r3_:_r3_,
                                                                    _r4_:_r4_} in 
                                                                    _r2_ ==
                                                                    __map_0 and
                                                                    _r3_ ==
                                                                    __map_1))} in
                                                                    let update_value =
                                                                    __map_val +
                                                                    case
                                                                    (lookup_value.peek
                                                                    ()) of
                                                                    {Some val ->
                                                                    bind val as {
                                                                    _r1_:__1,
                                                                    _r2_:__2,
                                                                    _r3_:__3,
                                                                    _r4_:__4} in 
                                                                    __4}
                                                                    {None -> 0} in
                                                                    (bind
                                                                    target_map
                                                                    as ind __x
                                                                    in __x).insert
                                                                    {
                                                                    _r1_:vid,
                                                                    _r2_:__map_0,
                                                                    _r3_:__map_1,
                                                                    _r4_:update_value}}));
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_val} in 
        let filtered =
          ((bind
            target_map
            as ind __x
            in __x).filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in _r2_
            == __arg_0 and _r3_ == __arg_1))).filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                            _r4_:__map_val} in vid > min_vid)) in
      filtered.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_val} in 
          (bind
            target_map
            as ind __x
            in __x).update
            {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_val}
            {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_val + __arg_val}))))
    ))

declare add_delta_to_int : {
  _r1_:ind collection { key:{ _r1_:int, _r2_:int, _r3_:int }, value:int
  } @ { Collection }, _r2_:bool, _r3_:{ _r1_:int, _r2_:int, _r3_:int },
  _r4_:collection { key:{ _r1_:int, _r2_:int, _r3_:int }, value:int
  } @ { Collection } } -> () = (\_b1_ -> 
    bind _b1_ as {_r1_:target_map, _r2_:corrective, _r3_:min_vid,
                  _r4_:delta_tuples} in (
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:vid, value:__map_val} in let lookup_value =
                                                     if corrective
                                                     then (bind target_map
                                                       as ind __x
                                                       in __x).filter
                                                       ((\_b1_ -> 
                                                         bind _b1_ as {
                                                         key:key, value:value} in 
                                                         key == vid))
                                                     else empty {
                                                       key:{
                                                       _r1_:int, _r2_:int,
                                                       _r3_:int }, value:int
                                                       } @ { Collection } in
      case (lookup_value.peek ()) of
      {Some val ->
        let update_value = __map_val + bind val as {key:__1, value:__2} in __2 in
        (bind
          target_map
          as ind __x
          in __x).insert
          {key:vid, value:update_value}}{None ->
                                          let lookup_value =
                                            frontier_int
                                              {key:vid, value:bind target_map
                                               as ind __x in __x} in
                                          let update_value = __map_val + case
                                            (lookup_value.peek ()) of
                                            {Some val ->
                                              bind val as {key:__1, value:__2} in 
                                              __2}{None -> 0} in
                                          (bind
                                            target_map
                                            as ind __x
                                            in __x).insert
                                            {key:vid, value:update_value}}));
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:vid_arg, value:__arg_val} in let filtered =
                                                         (bind
                                                           target_map
                                                           as ind __x
                                                           in __x).filter
                                                           ((\_b1_ -> 
                                                             bind _b1_ as {
                                                             key:vid,
                                                             value:__map_val} in 
                                                             vid > min_vid)) in
      filtered.iterate
        ((\_b1_ -> 
          bind _b1_ as {key:vid, value:__map_val} in (bind
                                                       target_map
                                                       as ind __x
                                                       in __x).update
                                                       {key:vid,
                                                        value:__map_val}
                                                       {key:vid,
                                                        value:__map_val +
                                                        __arg_val}))))
    ))

declare add_delta_to_int_int : {
  _r1_:ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection },
  _r2_:bool, _r3_:{ _r1_:int, _r2_:int, _r3_:int }, _r4_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
  } -> () = (\_b1_ -> 
    bind _b1_ as {_r1_:target_map, _r2_:corrective, _r3_:min_vid,
                  _r4_:delta_tuples} in (
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in let lookup_value =
                                                                   if corrective
                                                                   then (bind
                                                                    target_map
                                                                    as ind __x
                                                                    in __x).filter
                                                                    ((\_b1_ -> 
                                                                    bind _b1_ as {
                                                                    _r1_:_r1_,
                                                                    _r2_:_r2_,
                                                                    _r3_:_r3_} in 
                                                                    _r1_ == vid
                                                                    and _r2_ ==
                                                                    __map_0))
                                                                   else empty {
                                                                    _r1_:{
                                                                    _r1_:int,
                                                                    _r2_:int,
                                                                    _r3_:int },
                                                                    _r2_:int,
                                                                    _r3_:int
                                                                    } @ { Collection }
                                                                   in case
      (lookup_value.peek ()) of
      {Some val ->
        let update_value = __map_val +
          bind val as {_r1_:__1, _r2_:__2, _r3_:__3} in __3 in
        (bind
          target_map
          as ind __x
          in __x).insert
          {_r1_:vid, _r2_:__map_0, _r3_:update_value}}{None ->
                                                        let lookup_value =
                                                          frontier_int_int
                                                            {key:vid,
                                                             value:(bind
                                                             target_map
                                                             as ind __x
                                                             in __x).filter
                                                             ((\_b1_ -> 
                                                               bind _b1_ as {
                                                               _r1_:_r1_,
                                                               _r2_:_r2_,
                                                               _r3_:_r3_} in _r2_
                                                             == __map_0))} in
                                                        let update_value =
                                                          __map_val + case
                                                          (lookup_value.peek
                                                          ()) of
                                                          {Some val ->
                                                            bind val as {
                                                            _r1_:__1, _r2_:__2,
                                                            _r3_:__3} in __3}
                                                          {None -> 0} in
                                                        (bind
                                                          target_map
                                                          as ind __x
                                                          in __x).insert
                                                          {_r1_:vid,
                                                           _r2_:__map_0,
                                                           _r3_:update_value}}));
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
      let filtered =
        ((bind
          target_map
          as ind __x
          in __x).filter
          ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
          __arg_0))).filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
          min_vid)) in
      filtered.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in (bind
                                                                    target_map
                                                                    as ind __x
                                                                    in __x).update
                                                                    {
                                                                    _r1_:vid,
                                                                    _r2_:__map_0,
                                                                    _r3_:__map_val}
                                                                    {
                                                                    _r1_:vid,
                                                                    _r2_:__map_0,
                                                                    _r3_:__map_val
                                                                    + __arg_val}))))
    ))

declare log_master_write : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = (\_b1_ ->
  
    bind _b1_ as {_r1_:vid, _r2_:trig_id, _r3_:stmt_id} in log__master.insert
                                                             {_r1_:vid,
                                                              _r2_:trig_id,
                                                              _r3_:stmt_id})

declare log_write_insert_T : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = (\_b1_ ->
  
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in log_insert_T.insert
                                                     {_r1_:vid, _r2_:T_C,
                                                      _r3_:T_D})

declare log_write_delete_T : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = (\_b1_ ->
  
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in log_delete_T.insert
                                                     {_r1_:vid, _r2_:T_C,
                                                      _r3_:T_D})

declare log_write_insert_S : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = (\_b1_ ->
  
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in log_insert_S.insert
                                                     {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C})

declare log_write_delete_S : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = (\_b1_ ->
  
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in log_delete_S.insert
                                                     {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C})

declare log_write_insert_R : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = (\_b1_ ->
  
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in log_insert_R.insert
                                                     {_r1_:vid, _r2_:R_A,
                                                      _r3_:R_B})

declare log_write_delete_R : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = (\_b1_ ->
  
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in log_delete_R.insert
                                                     {_r1_:vid, _r2_:R_A,
                                                      _r3_:R_B})

declare log_get_bound_insert_T : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } = (\vid ->  
  case ((log_insert_T.filter
  ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid))).peek
  ()) of {Some slice -> slice}{None -> error ()})

declare log_get_bound_delete_T : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } = (\vid ->  
  case ((log_delete_T.filter
  ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid))).peek
  ()) of {Some slice -> slice}{None -> error ()})

declare log_get_bound_insert_S : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } = (\vid ->  
  case ((log_insert_S.filter
  ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid))).peek
  ()) of {Some slice -> slice}{None -> error ()})

declare log_get_bound_delete_S : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } = (\vid ->  
  case ((log_delete_S.filter
  ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid))).peek
  ()) of {Some slice -> slice}{None -> error ()})

declare log_get_bound_insert_R : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } = (\vid ->  
  case ((log_insert_R.filter
  ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid))).peek
  ()) of {Some slice -> slice}{None -> error ()})

declare log_get_bound_delete_R : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } = (\vid ->  
  case ((log_delete_R.filter
  ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid))).peek
  ()) of {Some slice -> slice}{None -> error ()})

declare node_ring : collection {
  _r1_:address, _r2_:string, _r3_:string, _r4_:int } @ { Seq }

declare replicas : collection {i:int} @ { Set } = {|i:int| 8|} @ { Set }

declare set_replicas : int -> () = (\n -> 
    replicas.update
      ({i:case (replicas.peek ()) of {Some _i -> _i.i}{None -> error ()}})
      {i:n})

declare add_node : { _r1_:address, _r2_:string, _r3_:string } -> () = (\_b1_ ->
  
    bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name} in let rng =
                                                          range
                                                            (case
                                                            (replicas.peek 
                                                            ()) of
                                                            {Some _i -> _i.i}
                                                            {None -> 
                                                              error ()}) in
  let new_elems =
    rng.fold
      ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:i} in __acc_map.combine
      ({| _r1_:address, _r2_:string, _r3_:string, _r4_:int |
      {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash (i + hash addr)}|} @ { Seq }))))
      empty { _r1_:address, _r2_:string, _r3_:string, _r4_:int } @ { Seq } in (
    new_elems.iterate ((\x ->  node_ring.insert x));
    let temp_ring = node_ring.sort
      ((\_b2_ -> (\_b7_ -> 
        bind _b2_ as {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash1} in 
        bind _b7_ as {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash2} in 
      if hash1 > hash2
      then -1
      else 1))) in
    (
      node_ring.iterate ((\node ->  node_ring.erase node));
      temp_ring.iterate ((\node ->  node_ring.insert node))
      )
    ))

declare remove_node : { _r1_:address, _r2_:string, _r3_:string } -> () =
  (\_b1_ -> 
    bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name} in let nodes_to_delete =
                                                          node_ring.filter
                                                          ((\_b1_ -> 
                                                            bind _b1_ as {
                                                            _r1_:_r1_,
                                                            _r2_:_r2_,
                                                            _r3_:_r3_,
                                                            _r4_:_r4_} in (_r1_
                                                          == addr and _r3_ ==
                                                          name) and _r2_ ==
                                                          _role_)) in
  nodes_to_delete.iterate ((\x ->  node_ring.erase x)))

declare get_ring_node : { key:int, value:int } -> address = (\_b1_ -> 
    bind _b1_ as {key:data, value:max_val} in let scaled =
                                                truncate
                                                  (real_of_int (get_max_int ())
                                                  * (real_of_int data /
                                                  real_of_int max_val)) in
  let results =
    node_ring.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash} in hash >=
      scaled)) in bind case (results.peek ()) of
  {Some res_val -> res_val}{None -> case (node_ring.peek ()) of
                             {Some _i -> _i}{None -> error ()}} as {_r1_:addr} in 
  addr)

declare get_all_uniq_nodes : () -> collection {i:address} @ { Collection } =
  (\_ -> 
    ((node_ring.fold
        ((\acc_conv -> (\x ->  ({|
        _r1_:address, _r2_:string, _r3_:string, _r4_:int |
        x|} @ { Collection }).combine acc_conv))) empty {
        _r1_:address, _r2_:string, _r3_:string, _r4_:int } @ { Collection }).groupBy
       ((\_b1_ -> 
         bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash} in addr))
       ((\_ -> (\_ ->  ()))) ()).fold
      ((\__acc_map -> (\_b3_ -> 
        bind _b3_ as {key:__1, value:__2} in __acc_map.combine
      ({|i:address| __1|} @ { Collection }))))
      empty {i:address} @ { Collection })

declare pmap_data : collection {
  key:int, value:collection { key:int, value:int } @ { Seq } } @ { Seq } =
  pmap_input.fold
    ((\__acc_map -> (\_b3_ -> 
      bind _b3_ as {key:map_name, value:map_types} in __acc_map.combine
    ({| key:int, value:collection { key:int, value:int } @ { Seq } |
    {key:bind case ((__map_ids__.filter
     ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
     map_name))).peek ()) of
     {Some _i -> _i}{None -> error ()} as {_r1_:__1, _r2_:__2, _r3_:__3} in 
     __1, value:map_types}|} @ { Seq })))) empty {
    key:int, value:collection { key:int, value:int } @ { Seq } } @ { Seq }

declare calc_dim_bounds : collection { key:int, value:int } @ { Seq } -> {
  key:collection { key:int, value:int } @ { Seq }, value:int } = (\pmap -> 
    pmap.fold
      ((\_b2_ -> (\_b5_ -> 
        bind _b2_ as {key:xs, value:acc_size} in 
        bind _b5_ as {key:pos, value:bin_size} in {key:xs.combine
                                                   ({| key:int, value:int |
                                                   {key:pos, value:acc_size}|} @ { Seq }),
                                                   value:bin_size * acc_size})))
      {key:empty { key:int, value:int } @ { Seq }, value:1})

declare route_to_int : { key:int, value:option int
  } -> collection {i:address} @ { Collection } = (\_b1_ -> 
    bind _b1_ as {key:map_id, value:key_0} in let pmap = bind case
                                                ((pmap_data.filter
                                                ((\_b1_ -> 
                                                  bind _b1_ as {key:key,
                                                                value:value} in key
                                                == map_id))).peek ()) of
                                                {Some _i -> _i}{None ->
                                                                 error ()} as {
                                                key:__1, value:__2} in __2 in
  if pmap == empty { key:int, value:int } @ { Seq }
  then get_all_uniq_nodes ()
  else bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in 
    let bound_bucket = case key_0 of
      {Some key_0_unwrap ->
        let pmap_slice = pmap.filter
          ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0)) in case
        (pmap_slice.peek ()) of
        {Some peek_slice ->
          let value = hash key_0_unwrap %
            bind peek_slice as {key:__1, value:__2} in __2 in value * bind case
          ((dim_bounds.filter
          ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).peek
          ()) of {Some _i -> _i}{None -> error ()} as {key:__1, value:__2} in 
          __2}{None -> 0}}{None -> 0} + 0 in
    let free_dims =
      (if key_0 != None immut
       then empty { key:int, value:int } @ { Seq }
       else pmap.filter
         ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).combine
      empty { key:int, value:int } @ { Seq } in
    let free_domains =
      free_dims.fold
        ((\__acc_map -> (\_b3_ -> 
          bind _b3_ as {key:i, value:b_i} in __acc_map.combine
        ({| key:int, value:collection {i:int} @ { Seq } |
        {key:i, value:range b_i}|} @ { Seq })))) empty {
        key:int, value:collection {i:int} @ { Seq } } @ { Seq } in
    let free_cart_prod =
      free_domains.fold
        ((\prev_cart_prod -> (\_b3_ -> 
          bind _b3_ as {key:i, value:domain} in domain.fold
                                                  ((\__acc_ext -> (\_b3_ -> 
                                                    bind _b3_ as {i:domain_element} in 
                                                    __acc_ext.combine
                                                  (if prev_cart_prod ==
                                                     empty {i:collection {
                                                     key:int, value:int
                                                     } @ { Seq }} @ { Seq }
                                                   then {|i:collection {
                                                     key:int, value:int
                                                     } @ { Seq }| {|
                                                     key:int, value:int |
                                                     {key:i,
                                                      value:domain_element}|} @ { Seq }|} @ { Seq }
                                                   else
                                                     prev_cart_prod.fold
                                                       ((\__acc_map ->
                                                       (\_b3_ -> 
                                                         bind _b3_ as {i:rest_tup} in 
                                                         __acc_map.combine
                                                       ({|i:collection {
                                                       key:int, value:int
                                                       } @ { Seq }|
                                                       rest_tup.combine
                                                       ({| key:int, value:int |
                                                       {key:i,
                                                        value:domain_element}|} @ { Seq })|} @ { Seq }))))
                                                       empty {i:collection {
                                                       key:int, value:int
                                                       } @ { Seq }} @ { Seq }))))
                                                  empty {i:collection {
                                                  key:int, value:int
                                                  } @ { Seq }} @ { Seq })))
        empty {i:collection { key:int, value:int } @ { Seq }} @ { Seq } in
    let sorted_ip_list =
      (free_cart_prod.fold
         ((\acc_ips -> (\_b3_ -> 
           bind _b3_ as {i:free_bucket} in acc_ips.combine
         ({|i:address|
         get_ring_node
           {key:free_bucket.fold
                  ((\acc -> (\_b3_ ->  bind _b3_ as {key:i, value:val} in acc +
                  (val * bind case ((dim_bounds.filter
                  ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == i))).peek
                  ()) of
                  {Some _i -> _i}{None -> error ()} as {key:__1, value:__2} in 
                  __2)))) bound_bucket, value:max_val}|} @ { Collection }))))
         empty {i:address} @ { Collection }).groupBy
        ((\_b1_ ->  bind _b1_ as {i:ip} in ip)) ((\_ -> (\_ ->  ()))) () in
    if sorted_ip_list == empty { key:address, value:() } @ { Collection }
    then {|i:address|
      get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
    else
      sorted_ip_list.fold
        ((\__acc_map -> (\_b3_ -> 
          bind _b3_ as {key:__1, value:__2} in __acc_map.combine
        ({|i:address| __1|} @ { Collection }))))
        empty {i:address} @ { Collection })

declare route_to_int_int : { _r1_:int, _r2_:option int, _r3_:option int
  } -> collection {i:address} @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:map_id, _r2_:key_0, _r3_:key_1} in let pmap = bind case
                                                            ((pmap_data.filter
                                                            ((\_b1_ -> 
                                                              bind _b1_ as {
                                                              key:key,
                                                              value:value} in key
                                                            == map_id))).peek
                                                            ()) of
                                                            {Some _i -> _i}
                                                            {None -> 
                                                              error ()} as {
                                                            key:__1, value:__2} in 
                                                            __2 in
  if pmap == empty { key:int, value:int } @ { Seq }
  then get_all_uniq_nodes ()
  else bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in 
    let bound_bucket = case key_1 of
      {Some key_1_unwrap ->
        let pmap_slice = pmap.filter
          ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1)) in case
        (pmap_slice.peek ()) of
        {Some peek_slice ->
          let value = hash key_1_unwrap %
            bind peek_slice as {key:__1, value:__2} in __2 in value * bind case
          ((dim_bounds.filter
          ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1))).peek
          ()) of {Some _i -> _i}{None -> error ()} as {key:__1, value:__2} in 
          __2}{None -> 0}}{None -> 0} + (case key_0 of
      {Some key_0_unwrap ->
        let pmap_slice = pmap.filter
          ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0)) in case
        (pmap_slice.peek ()) of
        {Some peek_slice ->
          let value = hash key_0_unwrap %
            bind peek_slice as {key:__1, value:__2} in __2 in value * bind case
          ((dim_bounds.filter
          ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).peek
          ()) of {Some _i -> _i}{None -> error ()} as {key:__1, value:__2} in 
          __2}{None -> 0}}{None -> 0} + 0) in
    let free_dims =
      (if key_1 != None immut
       then empty { key:int, value:int } @ { Seq }
       else pmap.filter
         ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1))).combine
      ((if key_0 != None immut
        then empty { key:int, value:int } @ { Seq }
        else pmap.filter
          ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).combine
      empty { key:int, value:int } @ { Seq }) in
    let free_domains =
      free_dims.fold
        ((\__acc_map -> (\_b3_ -> 
          bind _b3_ as {key:i, value:b_i} in __acc_map.combine
        ({| key:int, value:collection {i:int} @ { Seq } |
        {key:i, value:range b_i}|} @ { Seq })))) empty {
        key:int, value:collection {i:int} @ { Seq } } @ { Seq } in
    let free_cart_prod =
      free_domains.fold
        ((\prev_cart_prod -> (\_b3_ -> 
          bind _b3_ as {key:i, value:domain} in domain.fold
                                                  ((\__acc_ext -> (\_b3_ -> 
                                                    bind _b3_ as {i:domain_element} in 
                                                    __acc_ext.combine
                                                  (if prev_cart_prod ==
                                                     empty {i:collection {
                                                     key:int, value:int
                                                     } @ { Seq }} @ { Seq }
                                                   then {|i:collection {
                                                     key:int, value:int
                                                     } @ { Seq }| {|
                                                     key:int, value:int |
                                                     {key:i,
                                                      value:domain_element}|} @ { Seq }|} @ { Seq }
                                                   else
                                                     prev_cart_prod.fold
                                                       ((\__acc_map ->
                                                       (\_b3_ -> 
                                                         bind _b3_ as {i:rest_tup} in 
                                                         __acc_map.combine
                                                       ({|i:collection {
                                                       key:int, value:int
                                                       } @ { Seq }|
                                                       rest_tup.combine
                                                       ({| key:int, value:int |
                                                       {key:i,
                                                        value:domain_element}|} @ { Seq })|} @ { Seq }))))
                                                       empty {i:collection {
                                                       key:int, value:int
                                                       } @ { Seq }} @ { Seq }))))
                                                  empty {i:collection {
                                                  key:int, value:int
                                                  } @ { Seq }} @ { Seq })))
        empty {i:collection { key:int, value:int } @ { Seq }} @ { Seq } in
    let sorted_ip_list =
      (free_cart_prod.fold
         ((\acc_ips -> (\_b3_ -> 
           bind _b3_ as {i:free_bucket} in acc_ips.combine
         ({|i:address|
         get_ring_node
           {key:free_bucket.fold
                  ((\acc -> (\_b3_ ->  bind _b3_ as {key:i, value:val} in acc +
                  (val * bind case ((dim_bounds.filter
                  ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == i))).peek
                  ()) of
                  {Some _i -> _i}{None -> error ()} as {key:__1, value:__2} in 
                  __2)))) bound_bucket, value:max_val}|} @ { Collection }))))
         empty {i:address} @ { Collection }).groupBy
        ((\_b1_ ->  bind _b1_ as {i:ip} in ip)) ((\_ -> (\_ ->  ()))) () in
    if sorted_ip_list == empty { key:address, value:() } @ { Collection }
    then {|i:address|
      get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
    else
      sorted_ip_list.fold
        ((\__acc_map -> (\_b3_ -> 
          bind _b3_ as {key:__1, value:__2} in __acc_map.combine
        ({|i:address| __1|} @ { Collection }))))
        empty {i:address} @ { Collection })

declare route_to_ : { key:int, value:()
  } -> collection {i:address} @ { Collection } = (\_b1_ ->  {|i:address|
  get_ring_node {key:1, value:1}|} @ { Collection })

declare shuffle_ATIMESD_mT1_to_ATIMESD : {
  _r1_:(), _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection },
  _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r2_:tuples, _r3_:shuffle_on_empty} in let all_targets =
                                                           if shuffle_on_empty
                                                             == true
                                                           then
                                                             (route_to_
                                                                {key:1,
                                                                 value:()}).fold
                                                               ((\__acc_map ->
                                                               (\_b3_ -> 
                                                                 bind _b3_ as {i:ip} in 
                                                                 __acc_map.combine
                                                               ({|
                                                               key:address,
                                                               value:collection {
                                                               _r1_:{
                                                               _r1_:int,
                                                               _r2_:int,
                                                               _r3_:int },
                                                               _r2_:int,
                                                               _r3_:int
                                                               } @ { Collection }
                                                               |
                                                               {key:ip,
                                                                value:empty {
                                                                _r1_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r2_:int,
                                                                _r3_:int
                                                                } @ { Collection }}|} @ { Collection }))))
                                                               empty {
                                                               key:address,
                                                               value:collection {
                                                               _r1_:{
                                                               _r1_:int,
                                                               _r2_:int,
                                                               _r3_:int },
                                                               _r2_:int,
                                                               _r3_:int
                                                               } @ { Collection }
                                                               } @ { Collection }
                                                           else empty {
                                                             key:address,
                                                             value:collection {
                                                             _r1_:{
                                                             _r1_:int,
                                                             _r2_:int, _r3_:int
                                                             }, _r2_:int,
                                                             _r3_:int
                                                             } @ { Collection }
                                                             } @ { Collection } in
  (all_targets.combine
    (tuples.fold
       ((\__acc_ext -> (\r_tuple ->  __acc_ext.combine
       (bind r_tuple as {_r1_:rkey_0, _r2_:rkey_1, _r3_:rkey_2} in 
       (route_to_ {key:1, value:()}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({|
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } |
         {key:ip, value:{|
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
          r_tuple|} @ { Collection }}|} @ { Collection })))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } } @ { Collection })))) empty {
       key:address, value:collection {
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
       } @ { Collection } } @ { Collection })).groupBy
    ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc -> (\_b3_ -> 
      bind _b3_ as {key:ip, value:tuple} in tuple.combine acc))) empty {
    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
    } @ { Collection })

declare shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mR1_bind_0t0 : {
  _r1_:option int, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Collection }, _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Collection } } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:lkey_0, _r2_:tuples, _r3_:shuffle_on_empty} in 
  let all_targets =
    if shuffle_on_empty == true
    then
      (route_to_int {key:6, value:lkey_0}).fold
        ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
        ({|
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
        } @ { Collection } |
        {key:ip, value:empty {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
         } @ { Collection }}|} @ { Collection })))) empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
        } @ { Collection } } @ { Collection }
    else empty {
      key:address, value:collection {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
      } @ { Collection } } @ { Collection } in
  (all_targets.combine
    (tuples.fold
       ((\__acc_ext -> (\r_tuple ->  __acc_ext.combine
       (bind r_tuple as {_r1_:rkey_0, _r2_:rkey_1, _r3_:rkey_2, _r4_:rkey_3} in 
       (route_to_int {key:6, value:Some rkey_1}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({|
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
         } @ { Collection } |
         {key:ip, value:{|
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int |
          r_tuple|} @ { Collection }}|} @ { Collection })))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
         } @ { Collection } } @ { Collection })))) empty {
       key:address, value:collection {
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
       } @ { Collection } } @ { Collection })).groupBy
    ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc -> (\_b3_ -> 
      bind _b3_ as {key:ip, value:tuple} in tuple.combine acc))) empty {
    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
    } @ { Collection })

declare shuffle_ATIMESD_mS1_to_ATIMESD : {
  _r1_:(), _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection },
  _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r2_:tuples, _r3_:shuffle_on_empty} in let all_targets =
                                                           if shuffle_on_empty
                                                             == true
                                                           then
                                                             (route_to_
                                                                {key:1,
                                                                 value:()}).fold
                                                               ((\__acc_map ->
                                                               (\_b3_ -> 
                                                                 bind _b3_ as {i:ip} in 
                                                                 __acc_map.combine
                                                               ({|
                                                               key:address,
                                                               value:collection {
                                                               _r1_:{
                                                               _r1_:int,
                                                               _r2_:int,
                                                               _r3_:int },
                                                               _r2_:int,
                                                               _r3_:int
                                                               } @ { Collection }
                                                               |
                                                               {key:ip,
                                                                value:empty {
                                                                _r1_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r2_:int,
                                                                _r3_:int
                                                                } @ { Collection }}|} @ { Collection }))))
                                                               empty {
                                                               key:address,
                                                               value:collection {
                                                               _r1_:{
                                                               _r1_:int,
                                                               _r2_:int,
                                                               _r3_:int },
                                                               _r2_:int,
                                                               _r3_:int
                                                               } @ { Collection }
                                                               } @ { Collection }
                                                           else empty {
                                                             key:address,
                                                             value:collection {
                                                             _r1_:{
                                                             _r1_:int,
                                                             _r2_:int, _r3_:int
                                                             }, _r2_:int,
                                                             _r3_:int
                                                             } @ { Collection }
                                                             } @ { Collection } in
  (all_targets.combine
    (tuples.fold
       ((\__acc_ext -> (\r_tuple ->  __acc_ext.combine
       (bind r_tuple as {_r1_:rkey_0, _r2_:rkey_1, _r3_:rkey_2} in 
       (route_to_ {key:1, value:()}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({|
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } |
         {key:ip, value:{|
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
          r_tuple|} @ { Collection }}|} @ { Collection })))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } } @ { Collection })))) empty {
       key:address, value:collection {
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
       } @ { Collection } } @ { Collection })).groupBy
    ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc -> (\_b3_ -> 
      bind _b3_ as {key:ip, value:tuple} in tuple.combine acc))) empty {
    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
    } @ { Collection })

declare shuffle_ATIMESD_mS2_to_ATIMESD : {
  _r1_:(), _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection },
  _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r2_:tuples, _r3_:shuffle_on_empty} in let all_targets =
                                                           if shuffle_on_empty
                                                             == true
                                                           then
                                                             (route_to_
                                                                {key:1,
                                                                 value:()}).fold
                                                               ((\__acc_map ->
                                                               (\_b3_ -> 
                                                                 bind _b3_ as {i:ip} in 
                                                                 __acc_map.combine
                                                               ({|
                                                               key:address,
                                                               value:collection {
                                                               _r1_:{
                                                               _r1_:int,
                                                               _r2_:int,
                                                               _r3_:int },
                                                               _r2_:int,
                                                               _r3_:int
                                                               } @ { Collection }
                                                               |
                                                               {key:ip,
                                                                value:empty {
                                                                _r1_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r2_:int,
                                                                _r3_:int
                                                                } @ { Collection }}|} @ { Collection }))))
                                                               empty {
                                                               key:address,
                                                               value:collection {
                                                               _r1_:{
                                                               _r1_:int,
                                                               _r2_:int,
                                                               _r3_:int },
                                                               _r2_:int,
                                                               _r3_:int
                                                               } @ { Collection }
                                                               } @ { Collection }
                                                           else empty {
                                                             key:address,
                                                             value:collection {
                                                             _r1_:{
                                                             _r1_:int,
                                                             _r2_:int, _r3_:int
                                                             }, _r2_:int,
                                                             _r3_:int
                                                             } @ { Collection }
                                                             } @ { Collection } in
  (all_targets.combine
    (tuples.fold
       ((\__acc_ext -> (\r_tuple ->  __acc_ext.combine
       (bind r_tuple as {_r1_:rkey_0, _r2_:rkey_1, _r3_:rkey_2} in 
       (route_to_ {key:1, value:()}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({|
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } |
         {key:ip, value:{|
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
          r_tuple|} @ { Collection }}|} @ { Collection })))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } } @ { Collection })))) empty {
       key:address, value:collection {
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
       } @ { Collection } } @ { Collection })).groupBy
    ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc -> (\_b3_ -> 
      bind _b3_ as {key:ip, value:tuple} in tuple.combine acc))) empty {
    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
    } @ { Collection })

declare shuffle_ATIMESD_mS1_to_ATIMESD_mT1 : {
  _r1_:option int, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection },
  _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:lkey_0, _r2_:tuples, _r3_:shuffle_on_empty} in 
  let all_targets =
    if shuffle_on_empty == true
    then
      (route_to_int {key:2, value:lkey_0}).fold
        ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
        ({|
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
        } @ { Collection } |
        {key:ip, value:empty {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection }}|} @ { Collection })))) empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
        } @ { Collection } } @ { Collection }
    else empty {
      key:address, value:collection {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Collection } } @ { Collection } in
  (all_targets.combine
    (tuples.fold
       ((\__acc_ext -> (\r_tuple ->  __acc_ext.combine
       (bind r_tuple as {_r1_:rkey_0, _r2_:rkey_1, _r3_:rkey_2} in 
       (route_to_int {key:2, value:lkey_0}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({|
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } |
         {key:ip, value:{|
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
          r_tuple|} @ { Collection }}|} @ { Collection })))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } } @ { Collection })))) empty {
       key:address, value:collection {
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
       } @ { Collection } } @ { Collection })).groupBy
    ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc -> (\_b3_ -> 
      bind _b3_ as {key:ip, value:tuple} in tuple.combine acc))) empty {
    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
    } @ { Collection })

declare shuffle_ATIMESD_mS2_to_ATIMESD_mR1 : {
  _r1_:option int, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection },
  _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:lkey_0, _r2_:tuples, _r3_:shuffle_on_empty} in 
  let all_targets =
    if shuffle_on_empty == true
    then
      (route_to_int {key:6, value:lkey_0}).fold
        ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
        ({|
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
        } @ { Collection } |
        {key:ip, value:empty {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection }}|} @ { Collection })))) empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
        } @ { Collection } } @ { Collection }
    else empty {
      key:address, value:collection {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Collection } } @ { Collection } in
  (all_targets.combine
    (tuples.fold
       ((\__acc_ext -> (\r_tuple ->  __acc_ext.combine
       (bind r_tuple as {_r1_:rkey_0, _r2_:rkey_1, _r3_:rkey_2} in 
       (route_to_int {key:6, value:lkey_0}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({|
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } |
         {key:ip, value:{|
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
          r_tuple|} @ { Collection }}|} @ { Collection })))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } } @ { Collection })))) empty {
       key:address, value:collection {
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
       } @ { Collection } } @ { Collection })).groupBy
    ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc -> (\_b3_ -> 
      bind _b3_ as {key:ip, value:tuple} in tuple.combine acc))) empty {
    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
    } @ { Collection })

declare shuffle_ATIMESD_mR1_to_ATIMESD : {
  _r1_:(), _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection },
  _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r2_:tuples, _r3_:shuffle_on_empty} in let all_targets =
                                                           if shuffle_on_empty
                                                             == true
                                                           then
                                                             (route_to_
                                                                {key:1,
                                                                 value:()}).fold
                                                               ((\__acc_map ->
                                                               (\_b3_ -> 
                                                                 bind _b3_ as {i:ip} in 
                                                                 __acc_map.combine
                                                               ({|
                                                               key:address,
                                                               value:collection {
                                                               _r1_:{
                                                               _r1_:int,
                                                               _r2_:int,
                                                               _r3_:int },
                                                               _r2_:int,
                                                               _r3_:int
                                                               } @ { Collection }
                                                               |
                                                               {key:ip,
                                                                value:empty {
                                                                _r1_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r2_:int,
                                                                _r3_:int
                                                                } @ { Collection }}|} @ { Collection }))))
                                                               empty {
                                                               key:address,
                                                               value:collection {
                                                               _r1_:{
                                                               _r1_:int,
                                                               _r2_:int,
                                                               _r3_:int },
                                                               _r2_:int,
                                                               _r3_:int
                                                               } @ { Collection }
                                                               } @ { Collection }
                                                           else empty {
                                                             key:address,
                                                             value:collection {
                                                             _r1_:{
                                                             _r1_:int,
                                                             _r2_:int, _r3_:int
                                                             }, _r2_:int,
                                                             _r3_:int
                                                             } @ { Collection }
                                                             } @ { Collection } in
  (all_targets.combine
    (tuples.fold
       ((\__acc_ext -> (\r_tuple ->  __acc_ext.combine
       (bind r_tuple as {_r1_:rkey_0, _r2_:rkey_1, _r3_:rkey_2} in 
       (route_to_ {key:1, value:()}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({|
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } |
         {key:ip, value:{|
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
          r_tuple|} @ { Collection }}|} @ { Collection })))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } } @ { Collection })))) empty {
       key:address, value:collection {
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
       } @ { Collection } } @ { Collection })).groupBy
    ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc -> (\_b3_ -> 
      bind _b3_ as {key:ip, value:tuple} in tuple.combine acc))) empty {
    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
    } @ { Collection })

declare shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mT1_bind_0t1 : {
  _r1_:option int, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Collection }, _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Collection } } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:lkey_0, _r2_:tuples, _r3_:shuffle_on_empty} in 
  let all_targets =
    if shuffle_on_empty == true
    then
      (route_to_int {key:2, value:lkey_0}).fold
        ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
        ({|
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
        } @ { Collection } |
        {key:ip, value:empty {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
         } @ { Collection }}|} @ { Collection })))) empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
        } @ { Collection } } @ { Collection }
    else empty {
      key:address, value:collection {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
      } @ { Collection } } @ { Collection } in
  (all_targets.combine
    (tuples.fold
       ((\__acc_ext -> (\r_tuple ->  __acc_ext.combine
       (bind r_tuple as {_r1_:rkey_0, _r2_:rkey_1, _r3_:rkey_2, _r4_:rkey_3} in 
       (route_to_int {key:2, value:Some rkey_2}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({|
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
         } @ { Collection } |
         {key:ip, value:{|
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int |
          r_tuple|} @ { Collection }}|} @ { Collection })))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
         } @ { Collection } } @ { Collection })))) empty {
       key:address, value:collection {
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
       } @ { Collection } } @ { Collection })).groupBy
    ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc -> (\_b3_ -> 
      bind _b3_ as {key:ip, value:tuple} in tuple.combine acc))) empty {
    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
    } @ { Collection })

declare init : () = (
    my_peers.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name} in if _role_ !=
                                                              "switch"
                                                            then
                                                              add_node
                                                                {_r1_:addr,
                                                                 _r2_:_role_,
                                                                 _r3_:name}
                                                            else ()))
    )

declare filter_corrective_list : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection { key:int, value:int
  } @ { Collection } } -> collection {
  key:int, value:collection { _r1_:int, _r2_:int, _r3_:int } @ { Seq }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {key:request_vid, value:trig_stmt_list} in let log_entries =
                                                              log_read_geq
                                                                request_vid in
  (((log_entries.fold
       ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:vid, _r2_:trig_id, _r3_:stmt_id} in acc.combine
       ({| key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
       {key:vid, value:stmt_id}|} @ { Seq })))) empty {
       key:{ _r1_:int, _r2_:int, _r3_:int }, value:int } @ { Seq }).sort
     ((\_b2_ -> (\_b5_ -> 
       bind _b2_ as {key:vid1, value:stmt1} in 
       bind _b5_ as {key:vid2, value:stmt2} in if vid_lt {key:vid1, value:vid2}
                                               then -1
                                               else 1)))).groupBy
     ((\_b1_ ->  bind _b1_ as {value:stmt_id} in stmt_id)) ((\vid_list ->
     (\_b3_ ->  bind _b3_ as {key:vid} in vid_list.combine
     ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq })))) empty {
     _r1_:int, _r2_:int, _r3_:int } @ { Seq }).fold
    ((\acc_conv -> (\x ->  ({|
    key:int, value:collection { _r1_:int, _r2_:int, _r3_:int } @ { Seq } |
    x|} @ { Collection }).combine acc_conv))) empty {
    key:int, value:collection { _r1_:int, _r2_:int, _r3_:int } @ { Seq }
    } @ { Collection })

trigger insert_T : {
key:int, value:int
}
= (\_b1_ ->

  bind _b1_ as {key:T_C, value:T_D} in (
  let vid =
    {_r1_:case (__epoch__.peek ()) of {Some _i -> _i.i}{None -> 0}, _r2_:case
     (__vid_counter__.peek ()) of {Some _i -> _i.i}{None -> 0}, _r3_:
     hash me} in
  (
    (insert_T_send_fetch, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D};
    let vid_counter_old = case (__vid_counter__.peek ()) of
      {Some _i -> _i.i}{None -> 0} in
    __vid_counter__.update {i:vid_counter_old} ({i:1 + vid_counter_old})
    )
  ))

trigger insert_T_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in (
  (route_to_int {key:5, value:Some T_C}).iterate
    ((\_b1_ -> 
      bind _b1_ as {i:ip} in (insert_T_do_complete_s1, ip)<- {_r1_:vid,
                                                              _r2_:T_C,
                                                              _r3_:T_D}));
  ((((empty {
      _r1_:address, _r2_:int, _r3_:int
      } @ { Collection }).combine
      (let sender_count =
         (route_to_int {key:2, value:Some T_C}).fold
           ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
      ((shuffle_ATIMESD_mT1_to_ATIMESD
          {_r1_:(), _r2_:empty {
           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
           } @ { Collection }, _r3_:true}).fold
         ((\__acc_map -> (\_b3_ -> 
           bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
         ({| _r1_:address, _r2_:int, _r3_:int |
         {_r1_:ip, _r2_:0, _r3_:sender_count}|} @ { Collection })))) empty {
         _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
      (let sender_count =
         (route_to_int_int {_r1_:3, _r2_:None immut, _r3_:Some T_C}).fold
           ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
      (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mR1_bind_0t0
         {_r1_:None immut, _r2_:empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
          } @ { Collection }, _r3_:true}).fold
        ((\__acc_map -> (\_b3_ -> 
          bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
        ({| _r1_:address, _r2_:int, _r3_:int |
        {_r1_:ip, _r2_:2, _r3_:sender_count}|} @ { Collection })))) empty {
        _r1_:address, _r2_:int, _r3_:int } @ { Collection }))).groupBy
      ((\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in {key:ip,
                                                             value:stmt_id}))
      ((\acc -> (\_b3_ -> 
        bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupBy
     ((\_b1_ -> 
       bind _b1_ as {key:_b2_, value:count} in 
       bind _b2_ as {key:ip, value:stmt_id} in ip)) ((\acc -> (\_b3_ -> 
       bind _b3_ as {key:ip_and_stmt_id, value:count} in bind ip_and_stmt_id as {
     key:ip, value:stmt_id} in acc.combine
     ({| key:int, value:int | {key:stmt_id, value:count}|} @ { Collection }))))
     empty { key:int, value:int } @ { Collection }).iterate
    ((\_b1_ ->  bind _b1_ as {key:ip, value:stmt_id_cnt_list} in (
      (insert_T_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list, _r3_:vid,
                                _r4_:T_C, _r5_:T_D}
      )));
  ((((route_to_int_int {_r1_:3, _r2_:None immut, _r3_:Some T_C}).fold
       ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
       ({| _r1_:int, _r2_:int, _r3_:address |
       {_r1_:2, _r2_:3, _r3_:ip}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
     (((route_to_int {key:2, value:Some T_C}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({| _r1_:int, _r2_:int, _r3_:address |
         {_r1_:0, _r2_:2, _r3_:ip}|} @ { Collection })))) empty {
         _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
     empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection })).groupBy
     ((\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip))
     ((\acc -> (\_b3_ -> 
       bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
     ({| key:int, value:int | {key:stmt_id, value:map_id}|} @ { Collection }))))
     empty { key:int, value:int } @ { Collection }).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:stmt_map_ids} in (insert_T_rcv_fetch, ip)<- {
                                                     _r1_:stmt_map_ids,
                                                     _r2_:vid, _r3_:T_C,
                                                     _r4_:T_D}))
  ))

trigger insert_T_rcv_put : {
_r1_:address, _r2_:collection { key:int, value:int } @ { Collection }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid, _r4_:T_C,
                _r5_:T_D} in (
  stmt_id_cnt_list.iterate
    ((\_b1_ ->  bind _b1_ as {key:stmt_id, value:count} in case
    ((__stmt_cntrs__.filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid
    and _r2_ == stmt_id))).peek ()) of
    {Some old_val -> bind old_val as {_r3_:old_count} in 
      let new_count = old_count + count in (
        __stmt_cntrs__.update
          {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
          {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
        if new_count == 0
        then
          if stmt_id == 2
          then (insert_T_do_complete_s2, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
          else
            if stmt_id == 1
            then (insert_T_do_complete_s1, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
            else
              if stmt_id == 0
              then
                (insert_T_do_complete_s0, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
              else ()
        else ()
        )}{None -> __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count}}))
  ))

trigger insert_T_rcv_fetch : {
_r1_:collection { key:int, value:int } @ { Collection }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:T_C, _r4_:T_D} in (
  log_write_insert_T {_r1_:vid, _r2_:T_C, _r3_:T_D};
  stmts_and_map_ids.iterate
    ((\_b1_ -> 
      bind _b1_ as {key:stmt_id, value:map_id} in if stmt_id == 0
                                                  then
                                                    if map_id == 2
                                                    then
                                                      (insert_T_send_push_s0_m_ATIMESD_mT1,
                                                        me)<- {_r1_:vid,
                                                               _r2_:T_C,
                                                               _r3_:T_D}
                                                    else ()
                                                  else
                                                    if stmt_id == 2
                                                    then
                                                      if map_id == 3
                                                      then
                                                        (insert_T_send_push_s2_m_ATIMESD_mT1_mR1,
                                                          me)<- {_r1_:vid,
                                                                 _r2_:T_C,
                                                                 _r3_:T_D}
                                                      else ()
                                                    else ()))
  ))

trigger insert_T_send_push_s0_m_ATIMESD_mT1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in (
  log_master_write {_r1_:vid, _r2_:0, _r3_:0};
  (shuffle_ATIMESD_mT1_to_ATIMESD
     {_r1_:(),
      _r2_:frontier_int_int
             {key:vid, value:(bind ATIMESD_mT1 as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == T_C))},
      _r3_:true}).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:tuples} in (insert_T_rcv_push_s0_m_ATIMESD_mT1,
                                               ip)<- {_r1_:tuples, _r2_:vid,
                                                      _r3_:T_C, _r4_:T_D}))
  ))

trigger insert_T_send_push_s2_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in (
  log_master_write {_r1_:vid, _r2_:0, _r3_:2};
  (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mR1_bind_0t0
     {_r1_:None immut,
      _r2_:frontier_int_int_int
             {key:vid, value:(bind ATIMESD_mT1_mR1 as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in _r3_
              == T_C))}, _r3_:true}).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:tuples} in (insert_T_rcv_push_s2_m_ATIMESD_mT1_mR1,
                                               ip)<- {_r1_:tuples, _r2_:vid,
                                                      _r3_:T_C, _r4_:T_D}))
  ))

trigger insert_T_rcv_push_s0_m_ATIMESD_mT1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:T_C, _r4_:T_D} in (
  log_write_insert_T {_r1_:vid, _r2_:T_C, _r3_:T_D};
  tuples.iterate
    ((\tuple ->  bind tuple as {_r1_:_tup0, _r2_:_tup1, _r3_:_tup2} in case
    (((bind map_ATIMESD_mT1_s0_buf as ind __x in __x).filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == _tup0
    and _r2_ == _tup1))).peek ()) of
    {Some vals ->
      (bind map_ATIMESD_mT1_s0_buf as ind __x in __x).update vals tuple}
    {None -> (bind map_ATIMESD_mT1_s0_buf as ind __x in __x).insert tuple}));
  if check_and_update_stmt_cntr_index {key:vid, value:0}
  then (insert_T_do_complete_s0, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
  else ()
  ))

trigger insert_T_rcv_push_s2_m_ATIMESD_mT1_mR1 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:T_C, _r4_:T_D} in (
  log_write_insert_T {_r1_:vid, _r2_:T_C, _r3_:T_D};
  tuples.iterate
    ((\tuple -> 
      bind tuple as {_r1_:_tup0, _r2_:_tup1, _r3_:_tup2, _r4_:_tup3} in case
    (((bind map_ATIMESD_mT1_mR1_s2_buf as ind __x in __x).filter
    ((\_b1_ -> 
      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in (_r1_ ==
    _tup0 and _r3_ == _tup2) and _r2_ == _tup1))).peek ()) of
    {Some vals ->
      (bind map_ATIMESD_mT1_mR1_s2_buf as ind __x in __x).update vals tuple}
    {None -> (bind map_ATIMESD_mT1_mR1_s2_buf as ind __x in __x).insert tuple}));
  if check_and_update_stmt_cntr_index {key:vid, value:2}
  then (insert_T_do_complete_s2, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
  else ()
  ))

trigger insert_T_do_complete_s0 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in let __prod_ret__1 =
                                                     (let wrapped_lookup_value =
                                                        (frontier_int_int
                                                           {key:vid,
                                                            value:(bind
                                                            map_ATIMESD_mT1_s0_buf
                                                            as ind __x
                                                            in __x).filter
                                                            ((\_b1_ -> 
                                                              bind _b1_ as {
                                                              _r1_:_r1_,
                                                              _r2_:_r2_,
                                                              _r3_:_r3_} in _r2_
                                                            == T_C))}).fold
                                                          ((\__acc_map ->
                                                          (\_b3_ -> 
                                                            bind _b3_ as {
                                                            _r1_:map_vid,
                                                            _r2_:__map_0,
                                                            _r3_:__map_val} in __acc_map.combine
                                                          ({|
                                                          key:int, value:int |
                                                          {key:__map_0,
                                                           value:__map_val}|} @ { Collection }))))
                                                          empty {
                                                          key:int, value:int
                                                          } @ { Collection } in
                                                     case
                                                     (wrapped_lookup_value.peek
                                                     ()) of
                                                     {Some unwrapped_value ->
                                                       bind unwrapped_value as {
                                                       value:projected_field} in 
                                                       projected_field}
                                                     {None -> 0}) * T_D in (
    add_delta_to_int
      {_r1_:ATIMESD, _r2_:false, _r3_:vid, _r4_:{|
       key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
       {key:vid, value:__prod_ret__1}|} @ { Collection }}
    ))

trigger insert_T_do_complete_s1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in let __val_ret__2 = T_D in (
    add_delta_to_int_int
      {_r1_:ATIMESD_mS2, _r2_:false, _r3_:vid, _r4_:{|
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
       {_r1_:vid, _r2_:T_C, _r3_:__val_ret__2}|} @ { Collection }};
    (ATIMESD_mS2_send_correctives, me)<- {key:vid, value:{|
                                          _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                          }, _r2_:int, _r3_:int |
                                          {_r1_:vid, _r2_:T_C,
                                           _r3_:__val_ret__2}|} @ { Collection }}
    ))

trigger insert_T_do_complete_s2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in let __delta_values__ =
                                                     (((frontier_int_int_int
                                                          {key:vid, value:(bind
                                                           map_ATIMESD_mT1_mR1_s2_buf
                                                           as ind __x
                                                           in __x).filter
                                                           ((\_b1_ -> 
                                                             bind _b1_ as {
                                                             _r1_:_r1_,
                                                             _r2_:_r2_,
                                                             _r3_:_r3_,
                                                             _r4_:_r4_} in _r3_
                                                           == T_C))}).fold
                                                         ((\__acc_map ->
                                                         (\_b3_ -> 
                                                           bind _b3_ as {
                                                           _r1_:map_vid,
                                                           _r2_:__map_0,
                                                           _r3_:__map_1,
                                                           _r4_:__map_val} in __acc_map.combine
                                                         ({|
                                                         _r1_:int, _r2_:int,
                                                         _r3_:int |
                                                         {_r1_:__map_0,
                                                          _r2_:__map_1,
                                                          _r3_:__map_val}|} @ { Collection }))))
                                                         empty {
                                                         _r1_:int, _r2_:int,
                                                         _r3_:int
                                                         } @ { Collection }).fold
                                                        ((\__acc_map ->
                                                        (\_b3_ -> 
                                                          bind _b3_ as {
                                                          _r1_:ATIMESD_mRR_B,
                                                          _r2_:T_C,
                                                          _r3_:__map_ret__2} in __acc_map.combine
                                                        ({| key:int, value:int
                                                        |
                                                        {key:ATIMESD_mRR_B,
                                                         value:__map_ret__2}|} @ { Collection }))))
                                                        empty {
                                                        key:int, value:int
                                                        } @ { Collection }).fold
                                                       ((\__acc_map ->
                                                       (\_b3_ -> 
                                                         bind _b3_ as {
                                                         key:ATIMESD_mRR_B,
                                                         value:__map_ret__2} in __acc_map.combine
                                                       ({| key:int, value:int |
                                                       {key:ATIMESD_mRR_B,
                                                        value:__map_ret__2 *
                                                        T_D}|} @ { Collection }))))
                                                       empty {
                                                       key:int, value:int
                                                       } @ { Collection } in
  let __delta_with_vid__ =
    __delta_values__.fold
      ((\__acc_map -> (\_b3_ -> 
        bind _b3_ as {key:ATIMESD_mRR_B, value:__prod_ret__2} in __acc_map.combine
      ({| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
      {_r1_:vid, _r2_:ATIMESD_mRR_B, _r3_:__prod_ret__2}|} @ { Collection }))))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Collection } in (
    add_delta_to_int_int
      {_r1_:ATIMESD_mR1, _r2_:false, _r3_:vid, _r4_:__delta_with_vid__};
    (ATIMESD_mR1_send_correctives, me)<- {key:vid, value:__delta_with_vid__}
    ))

trigger insert_T_rcv_corrective_s0_m_ATIMESD_mT1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
  add_delta_to_int_int
    {_r1_:map_ATIMESD_mT1_s0_buf, _r2_:false, _r3_:vid, _r4_:delta_tuples};
  compute_vids.iterate
    ((\compute_vid -> 
      if ((__stmt_cntrs__.filter
        ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
        compute_vid and _r2_ == 0))).peek ()) ==
        Some {_r1_:compute_vid, _r2_:0, _r3_:0}
      then
        bind log_get_bound_insert_T compute_vid as {_r1_:vid, _r2_:T_C,
                                                    _r3_:T_D} in 
        (insert_T_do_corrective_s0_m_ATIMESD_mT1, me)<- {_r1_:compute_vid,
                                                         _r2_:T_C, _r3_:T_D,
                                                         _r4_:delta_tuples}
      else ()))
  ))

trigger insert_T_rcv_corrective_s2_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
} @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
  add_delta_to_int_int_int
    {_r1_:map_ATIMESD_mT1_mR1_s2_buf, _r2_:false, _r3_:vid, _r4_:delta_tuples};
  compute_vids.iterate
    ((\compute_vid -> 
      if ((__stmt_cntrs__.filter
        ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
        compute_vid and _r2_ == 2))).peek ()) ==
        Some {_r1_:compute_vid, _r2_:2, _r3_:0}
      then
        bind log_get_bound_insert_T compute_vid as {_r1_:vid, _r2_:T_C,
                                                    _r3_:T_D} in 
        (insert_T_do_corrective_s2_m_ATIMESD_mT1_mR1, me)<- {_r1_:compute_vid,
                                                             _r2_:T_C,
                                                             _r3_:T_D,
                                                             _r4_:delta_tuples}
      else ()))
  ))

trigger insert_T_do_corrective_s0_m_ATIMESD_mT1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D, _r4_:delta_tuples} in 
  delta_tuples.iterate
    ((\_b1_ -> 
      bind _b1_ as {_r2_:delta_ATIMESD_mTT_C, _r3_:delta_ATIMESD_mT1} in 
    let __prod_ret__63 = ((if T_C == delta_ATIMESD_mTT_C then 1 else 0) *
      delta_ATIMESD_mT1) * T_D in (
      add_delta_to_int
        {_r1_:ATIMESD, _r2_:true, _r3_:vid, _r4_:{|
         key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
         {key:vid, value:__prod_ret__63}|} @ { Collection }}
      ))))

trigger insert_T_do_corrective_s2_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
} @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D, _r4_:delta_tuples} in 
  delta_tuples.iterate
    ((\_b1_ -> 
      bind _b1_ as {_r2_:delta_ATIMESD_mT1_mRR_B, _r3_:delta_ATIMESD_mTT_C,
                    _r4_:delta_ATIMESD_mT1_mR1} in let __prod_ret__65 =
                                                     ((if T_C ==
                                                         delta_ATIMESD_mTT_C
                                                       then 1
                                                       else 0) *
                                                     delta_ATIMESD_mT1_mR1) *
                                                     T_D in (
      add_delta_to_int_int
        {_r1_:ATIMESD_mR1, _r2_:true, _r3_:vid, _r4_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:delta_ATIMESD_mT1_mRR_B, _r3_:__prod_ret__65}|} @ { Collection }};
      (ATIMESD_mR1_send_correctives, me)<- {key:vid, value:{|
                                            _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                            }, _r2_:int, _r3_:int |
                                            {_r1_:vid,
                                             _r2_:delta_ATIMESD_mT1_mRR_B,
                                             _r3_:__prod_ret__65}|} @ { Collection }}
      ))))

trigger delete_T : {
key:int, value:int
}
= (\_b1_ ->

  bind _b1_ as {key:T_C, value:T_D} in (
  let vid =
    {_r1_:case (__epoch__.peek ()) of {Some _i -> _i.i}{None -> 0}, _r2_:case
     (__vid_counter__.peek ()) of {Some _i -> _i.i}{None -> 0}, _r3_:
     hash me} in
  (
    (delete_T_send_fetch, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D};
    let vid_counter_old = case (__vid_counter__.peek ()) of
      {Some _i -> _i.i}{None -> 0} in
    __vid_counter__.update {i:vid_counter_old} ({i:1 + vid_counter_old})
    )
  ))

trigger delete_T_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in (
  (route_to_int {key:5, value:Some T_C}).iterate
    ((\_b1_ -> 
      bind _b1_ as {i:ip} in (delete_T_do_complete_s4, ip)<- {_r1_:vid,
                                                              _r2_:T_C,
                                                              _r3_:T_D}));
  ((((empty {
      _r1_:address, _r2_:int, _r3_:int
      } @ { Collection }).combine
      (let sender_count =
         (route_to_int {key:2, value:Some T_C}).fold
           ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
      ((shuffle_ATIMESD_mT1_to_ATIMESD
          {_r1_:(), _r2_:empty {
           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
           } @ { Collection }, _r3_:true}).fold
         ((\__acc_map -> (\_b3_ -> 
           bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
         ({| _r1_:address, _r2_:int, _r3_:int |
         {_r1_:ip, _r2_:3, _r3_:sender_count}|} @ { Collection })))) empty {
         _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
      (let sender_count =
         (route_to_int_int {_r1_:3, _r2_:None immut, _r3_:Some T_C}).fold
           ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
      (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mR1_bind_0t0
         {_r1_:None immut, _r2_:empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
          } @ { Collection }, _r3_:true}).fold
        ((\__acc_map -> (\_b3_ -> 
          bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
        ({| _r1_:address, _r2_:int, _r3_:int |
        {_r1_:ip, _r2_:5, _r3_:sender_count}|} @ { Collection })))) empty {
        _r1_:address, _r2_:int, _r3_:int } @ { Collection }))).groupBy
      ((\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in {key:ip,
                                                             value:stmt_id}))
      ((\acc -> (\_b3_ -> 
        bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupBy
     ((\_b1_ -> 
       bind _b1_ as {key:_b2_, value:count} in 
       bind _b2_ as {key:ip, value:stmt_id} in ip)) ((\acc -> (\_b3_ -> 
       bind _b3_ as {key:ip_and_stmt_id, value:count} in bind ip_and_stmt_id as {
     key:ip, value:stmt_id} in acc.combine
     ({| key:int, value:int | {key:stmt_id, value:count}|} @ { Collection }))))
     empty { key:int, value:int } @ { Collection }).iterate
    ((\_b1_ ->  bind _b1_ as {key:ip, value:stmt_id_cnt_list} in (
      (delete_T_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list, _r3_:vid,
                                _r4_:T_C, _r5_:T_D}
      )));
  ((((route_to_int_int {_r1_:3, _r2_:None immut, _r3_:Some T_C}).fold
       ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
       ({| _r1_:int, _r2_:int, _r3_:address |
       {_r1_:5, _r2_:3, _r3_:ip}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
     (((route_to_int {key:2, value:Some T_C}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({| _r1_:int, _r2_:int, _r3_:address |
         {_r1_:3, _r2_:2, _r3_:ip}|} @ { Collection })))) empty {
         _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
     empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection })).groupBy
     ((\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip))
     ((\acc -> (\_b3_ -> 
       bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
     ({| key:int, value:int | {key:stmt_id, value:map_id}|} @ { Collection }))))
     empty { key:int, value:int } @ { Collection }).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:stmt_map_ids} in (delete_T_rcv_fetch, ip)<- {
                                                     _r1_:stmt_map_ids,
                                                     _r2_:vid, _r3_:T_C,
                                                     _r4_:T_D}))
  ))

trigger delete_T_rcv_put : {
_r1_:address, _r2_:collection { key:int, value:int } @ { Collection }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid, _r4_:T_C,
                _r5_:T_D} in (
  stmt_id_cnt_list.iterate
    ((\_b1_ ->  bind _b1_ as {key:stmt_id, value:count} in case
    ((__stmt_cntrs__.filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid
    and _r2_ == stmt_id))).peek ()) of
    {Some old_val -> bind old_val as {_r3_:old_count} in 
      let new_count = old_count + count in (
        __stmt_cntrs__.update
          {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
          {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
        if new_count == 0
        then
          if stmt_id == 5
          then (delete_T_do_complete_s5, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
          else
            if stmt_id == 4
            then (delete_T_do_complete_s4, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
            else
              if stmt_id == 3
              then
                (delete_T_do_complete_s3, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
              else ()
        else ()
        )}{None -> __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count}}))
  ))

trigger delete_T_rcv_fetch : {
_r1_:collection { key:int, value:int } @ { Collection }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:T_C, _r4_:T_D} in (
  log_write_delete_T {_r1_:vid, _r2_:T_C, _r3_:T_D};
  stmts_and_map_ids.iterate
    ((\_b1_ -> 
      bind _b1_ as {key:stmt_id, value:map_id} in if stmt_id == 3
                                                  then
                                                    if map_id == 2
                                                    then
                                                      (delete_T_send_push_s3_m_ATIMESD_mT1,
                                                        me)<- {_r1_:vid,
                                                               _r2_:T_C,
                                                               _r3_:T_D}
                                                    else ()
                                                  else
                                                    if stmt_id == 5
                                                    then
                                                      if map_id == 3
                                                      then
                                                        (delete_T_send_push_s5_m_ATIMESD_mT1_mR1,
                                                          me)<- {_r1_:vid,
                                                                 _r2_:T_C,
                                                                 _r3_:T_D}
                                                      else ()
                                                    else ()))
  ))

trigger delete_T_send_push_s3_m_ATIMESD_mT1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in (
  log_master_write {_r1_:vid, _r2_:1, _r3_:3};
  (shuffle_ATIMESD_mT1_to_ATIMESD
     {_r1_:(),
      _r2_:frontier_int_int
             {key:vid, value:(bind ATIMESD_mT1 as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == T_C))},
      _r3_:true}).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:tuples} in (delete_T_rcv_push_s3_m_ATIMESD_mT1,
                                               ip)<- {_r1_:tuples, _r2_:vid,
                                                      _r3_:T_C, _r4_:T_D}))
  ))

trigger delete_T_send_push_s5_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in (
  log_master_write {_r1_:vid, _r2_:1, _r3_:5};
  (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mR1_bind_0t0
     {_r1_:None immut,
      _r2_:frontier_int_int_int
             {key:vid, value:(bind ATIMESD_mT1_mR1 as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in _r3_
              == T_C))}, _r3_:true}).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:tuples} in (delete_T_rcv_push_s5_m_ATIMESD_mT1_mR1,
                                               ip)<- {_r1_:tuples, _r2_:vid,
                                                      _r3_:T_C, _r4_:T_D}))
  ))

trigger delete_T_rcv_push_s3_m_ATIMESD_mT1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:T_C, _r4_:T_D} in (
  log_write_delete_T {_r1_:vid, _r2_:T_C, _r3_:T_D};
  tuples.iterate
    ((\tuple ->  bind tuple as {_r1_:_tup0, _r2_:_tup1, _r3_:_tup2} in case
    (((bind map_ATIMESD_mT1_s3_buf as ind __x in __x).filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == _tup0
    and _r2_ == _tup1))).peek ()) of
    {Some vals ->
      (bind map_ATIMESD_mT1_s3_buf as ind __x in __x).update vals tuple}
    {None -> (bind map_ATIMESD_mT1_s3_buf as ind __x in __x).insert tuple}));
  if check_and_update_stmt_cntr_index {key:vid, value:3}
  then (delete_T_do_complete_s3, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
  else ()
  ))

trigger delete_T_rcv_push_s5_m_ATIMESD_mT1_mR1 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:T_C, _r4_:T_D} in (
  log_write_delete_T {_r1_:vid, _r2_:T_C, _r3_:T_D};
  tuples.iterate
    ((\tuple -> 
      bind tuple as {_r1_:_tup0, _r2_:_tup1, _r3_:_tup2, _r4_:_tup3} in case
    (((bind map_ATIMESD_mT1_mR1_s5_buf as ind __x in __x).filter
    ((\_b1_ -> 
      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in (_r1_ ==
    _tup0 and _r3_ == _tup2) and _r2_ == _tup1))).peek ()) of
    {Some vals ->
      (bind map_ATIMESD_mT1_mR1_s5_buf as ind __x in __x).update vals tuple}
    {None -> (bind map_ATIMESD_mT1_mR1_s5_buf as ind __x in __x).insert tuple}));
  if check_and_update_stmt_cntr_index {key:vid, value:5}
  then (delete_T_do_complete_s5, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
  else ()
  ))

trigger delete_T_do_complete_s3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in let __prod_ret__4 =
                                                     (let wrapped_lookup_value =
                                                        (frontier_int_int
                                                           {key:vid,
                                                            value:(bind
                                                            map_ATIMESD_mT1_s3_buf
                                                            as ind __x
                                                            in __x).filter
                                                            ((\_b1_ -> 
                                                              bind _b1_ as {
                                                              _r1_:_r1_,
                                                              _r2_:_r2_,
                                                              _r3_:_r3_} in _r2_
                                                            == T_C))}).fold
                                                          ((\__acc_map ->
                                                          (\_b3_ -> 
                                                            bind _b3_ as {
                                                            _r1_:map_vid,
                                                            _r2_:__map_0,
                                                            _r3_:__map_val} in __acc_map.combine
                                                          ({|
                                                          key:int, value:int |
                                                          {key:__map_0,
                                                           value:__map_val}|} @ { Collection }))))
                                                          empty {
                                                          key:int, value:int
                                                          } @ { Collection } in
                                                     case
                                                     (wrapped_lookup_value.peek
                                                     ()) of
                                                     {Some unwrapped_value ->
                                                       bind unwrapped_value as {
                                                       value:projected_field} in 
                                                       projected_field}
                                                     {None -> 0}) * -T_D in (
    add_delta_to_int
      {_r1_:ATIMESD, _r2_:false, _r3_:vid, _r4_:{|
       key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
       {key:vid, value:__prod_ret__4}|} @ { Collection }}
    ))

trigger delete_T_do_complete_s4 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in let __prod_ret__5 = -T_D in
  (
    add_delta_to_int_int
      {_r1_:ATIMESD_mS2, _r2_:false, _r3_:vid, _r4_:{|
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
       {_r1_:vid, _r2_:T_C, _r3_:__prod_ret__5}|} @ { Collection }};
    (ATIMESD_mS2_send_correctives, me)<- {key:vid, value:{|
                                          _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                          }, _r2_:int, _r3_:int |
                                          {_r1_:vid, _r2_:T_C,
                                           _r3_:__prod_ret__5}|} @ { Collection }}
    ))

trigger delete_T_do_complete_s5 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in let __delta_values__ =
                                                     (((frontier_int_int_int
                                                          {key:vid, value:(bind
                                                           map_ATIMESD_mT1_mR1_s5_buf
                                                           as ind __x
                                                           in __x).filter
                                                           ((\_b1_ -> 
                                                             bind _b1_ as {
                                                             _r1_:_r1_,
                                                             _r2_:_r2_,
                                                             _r3_:_r3_,
                                                             _r4_:_r4_} in _r3_
                                                           == T_C))}).fold
                                                         ((\__acc_map ->
                                                         (\_b3_ -> 
                                                           bind _b3_ as {
                                                           _r1_:map_vid,
                                                           _r2_:__map_0,
                                                           _r3_:__map_1,
                                                           _r4_:__map_val} in __acc_map.combine
                                                         ({|
                                                         _r1_:int, _r2_:int,
                                                         _r3_:int |
                                                         {_r1_:__map_0,
                                                          _r2_:__map_1,
                                                          _r3_:__map_val}|} @ { Collection }))))
                                                         empty {
                                                         _r1_:int, _r2_:int,
                                                         _r3_:int
                                                         } @ { Collection }).fold
                                                        ((\__acc_map ->
                                                        (\_b3_ -> 
                                                          bind _b3_ as {
                                                          _r1_:ATIMESD_mRR_B,
                                                          _r2_:T_C,
                                                          _r3_:__map_ret__4} in __acc_map.combine
                                                        ({| key:int, value:int
                                                        |
                                                        {key:ATIMESD_mRR_B,
                                                         value:__map_ret__4}|} @ { Collection }))))
                                                        empty {
                                                        key:int, value:int
                                                        } @ { Collection }).fold
                                                       ((\__acc_map ->
                                                       (\_b3_ -> 
                                                         bind _b3_ as {
                                                         key:ATIMESD_mRR_B,
                                                         value:__map_ret__4} in __acc_map.combine
                                                       ({| key:int, value:int |
                                                       {key:ATIMESD_mRR_B,
                                                        value:__map_ret__4 *
                                                        -T_D}|} @ { Collection }))))
                                                       empty {
                                                       key:int, value:int
                                                       } @ { Collection } in
  let __delta_with_vid__ =
    __delta_values__.fold
      ((\__acc_map -> (\_b3_ -> 
        bind _b3_ as {key:ATIMESD_mRR_B, value:__prod_ret__7} in __acc_map.combine
      ({| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
      {_r1_:vid, _r2_:ATIMESD_mRR_B, _r3_:__prod_ret__7}|} @ { Collection }))))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Collection } in (
    add_delta_to_int_int
      {_r1_:ATIMESD_mR1, _r2_:false, _r3_:vid, _r4_:__delta_with_vid__};
    (ATIMESD_mR1_send_correctives, me)<- {key:vid, value:__delta_with_vid__}
    ))

trigger delete_T_rcv_corrective_s3_m_ATIMESD_mT1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
  add_delta_to_int_int
    {_r1_:map_ATIMESD_mT1_s3_buf, _r2_:false, _r3_:vid, _r4_:delta_tuples};
  compute_vids.iterate
    ((\compute_vid -> 
      if ((__stmt_cntrs__.filter
        ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
        compute_vid and _r2_ == 3))).peek ()) ==
        Some {_r1_:compute_vid, _r2_:3, _r3_:0}
      then
        bind log_get_bound_delete_T compute_vid as {_r1_:vid, _r2_:T_C,
                                                    _r3_:T_D} in 
        (delete_T_do_corrective_s3_m_ATIMESD_mT1, me)<- {_r1_:compute_vid,
                                                         _r2_:T_C, _r3_:T_D,
                                                         _r4_:delta_tuples}
      else ()))
  ))

trigger delete_T_rcv_corrective_s5_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
} @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
  add_delta_to_int_int_int
    {_r1_:map_ATIMESD_mT1_mR1_s5_buf, _r2_:false, _r3_:vid, _r4_:delta_tuples};
  compute_vids.iterate
    ((\compute_vid -> 
      if ((__stmt_cntrs__.filter
        ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
        compute_vid and _r2_ == 5))).peek ()) ==
        Some {_r1_:compute_vid, _r2_:5, _r3_:0}
      then
        bind log_get_bound_delete_T compute_vid as {_r1_:vid, _r2_:T_C,
                                                    _r3_:T_D} in 
        (delete_T_do_corrective_s5_m_ATIMESD_mT1_mR1, me)<- {_r1_:compute_vid,
                                                             _r2_:T_C,
                                                             _r3_:T_D,
                                                             _r4_:delta_tuples}
      else ()))
  ))

trigger delete_T_do_corrective_s3_m_ATIMESD_mT1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D, _r4_:delta_tuples} in 
  delta_tuples.iterate
    ((\_b1_ -> 
      bind _b1_ as {_r2_:delta_ATIMESD_mTT_C, _r3_:delta_ATIMESD_mT1} in 
    let __prod_ret__68 = (if T_C == delta_ATIMESD_mTT_C then 1 else 0) *
      (-delta_ATIMESD_mT1 * T_D) in (
      add_delta_to_int
        {_r1_:ATIMESD, _r2_:true, _r3_:vid, _r4_:{|
         key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
         {key:vid, value:__prod_ret__68}|} @ { Collection }}
      ))))

trigger delete_T_do_corrective_s5_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
} @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D, _r4_:delta_tuples} in 
  delta_tuples.iterate
    ((\_b1_ -> 
      bind _b1_ as {_r2_:delta_ATIMESD_mT1_mRR_B, _r3_:delta_ATIMESD_mTT_C,
                    _r4_:delta_ATIMESD_mT1_mR1} in let __prod_ret__71 =
                                                     (if T_C ==
                                                        delta_ATIMESD_mTT_C
                                                      then 1
                                                      else 0) *
                                                     (-delta_ATIMESD_mT1_mR1 *
                                                     T_D) in (
      add_delta_to_int_int
        {_r1_:ATIMESD_mR1, _r2_:true, _r3_:vid, _r4_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:delta_ATIMESD_mT1_mRR_B, _r3_:__prod_ret__71}|} @ { Collection }};
      (ATIMESD_mR1_send_correctives, me)<- {key:vid, value:{|
                                            _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                            }, _r2_:int, _r3_:int |
                                            {_r1_:vid,
                                             _r2_:delta_ATIMESD_mT1_mRR_B,
                                             _r3_:__prod_ret__71}|} @ { Collection }}
      ))))

trigger insert_S : {
key:int, value:int
}
= (\_b1_ ->

  bind _b1_ as {key:S_B, value:S_C} in (
  let vid =
    {_r1_:case (__epoch__.peek ()) of {Some _i -> _i.i}{None -> 0}, _r2_:case
     (__vid_counter__.peek ()) of {Some _i -> _i.i}{None -> 0}, _r3_:
     hash me} in
  (
    (insert_S_send_fetch, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C};
    let vid_counter_old = case (__vid_counter__.peek ()) of
      {Some _i -> _i.i}{None -> 0} in
    __vid_counter__.update {i:vid_counter_old} ({i:1 + vid_counter_old})
    )
  ))

trigger insert_S_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
  (route_to_int_int {_r1_:3, _r2_:Some S_B, _r3_:Some S_C}).iterate
    ((\_b1_ -> 
      bind _b1_ as {i:ip} in (insert_S_do_complete_s8, ip)<- {_r1_:vid,
                                                              _r2_:S_B,
                                                              _r3_:S_C}));
  ((((empty {
      _r1_:address, _r2_:int, _r3_:int
      } @ { Collection }).combine
      (let sender_count =
         (route_to_int {key:4, value:Some S_B}).fold
           ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
      ((shuffle_ATIMESD_mS1_to_ATIMESD
          {_r1_:(), _r2_:empty {
           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
           } @ { Collection }, _r3_:true}).fold
         ((\__acc_map -> (\_b3_ -> 
           bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
         ({| _r1_:address, _r2_:int, _r3_:int |
         {_r1_:ip, _r2_:6, _r3_:sender_count}|} @ { Collection })))) empty {
         _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
      (let sender_count =
         (route_to_int {key:5, value:Some S_C}).fold
           ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
      ((shuffle_ATIMESD_mS2_to_ATIMESD
          {_r1_:(), _r2_:empty {
           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
           } @ { Collection }, _r3_:true}).fold
         ((\__acc_map -> (\_b3_ -> 
           bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
         ({| _r1_:address, _r2_:int, _r3_:int |
         {_r1_:ip, _r2_:6, _r3_:sender_count}|} @ { Collection })))) empty {
         _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
      (let sender_count =
         (route_to_int {key:4, value:Some S_B}).fold
           ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
      ((shuffle_ATIMESD_mS1_to_ATIMESD_mT1
          {_r1_:Some S_C, _r2_:empty {
           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
           } @ { Collection }, _r3_:true}).fold
         ((\__acc_map -> (\_b3_ -> 
           bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
         ({| _r1_:address, _r2_:int, _r3_:int |
         {_r1_:ip, _r2_:7, _r3_:sender_count}|} @ { Collection })))) empty {
         _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
      (let sender_count =
         (route_to_int {key:5, value:Some S_C}).fold
           ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
      (shuffle_ATIMESD_mS2_to_ATIMESD_mR1
         {_r1_:Some S_B, _r2_:empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }, _r3_:true}).fold
        ((\__acc_map -> (\_b3_ -> 
          bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
        ({| _r1_:address, _r2_:int, _r3_:int |
        {_r1_:ip, _r2_:9, _r3_:sender_count}|} @ { Collection })))) empty {
        _r1_:address, _r2_:int, _r3_:int } @ { Collection }))))).groupBy
      ((\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in {key:ip,
                                                             value:stmt_id}))
      ((\acc -> (\_b3_ -> 
        bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupBy
     ((\_b1_ -> 
       bind _b1_ as {key:_b2_, value:count} in 
       bind _b2_ as {key:ip, value:stmt_id} in ip)) ((\acc -> (\_b3_ -> 
       bind _b3_ as {key:ip_and_stmt_id, value:count} in bind ip_and_stmt_id as {
     key:ip, value:stmt_id} in acc.combine
     ({| key:int, value:int | {key:stmt_id, value:count}|} @ { Collection }))))
     empty { key:int, value:int } @ { Collection }).iterate
    ((\_b1_ ->  bind _b1_ as {key:ip, value:stmt_id_cnt_list} in (
      (insert_S_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list, _r3_:vid,
                                _r4_:S_B, _r5_:S_C}
      )));
  ((((route_to_int {key:5, value:Some S_C}).fold
       ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
       ({| _r1_:int, _r2_:int, _r3_:address |
       {_r1_:9, _r2_:5, _r3_:ip}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
     (((route_to_int {key:4, value:Some S_B}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({| _r1_:int, _r2_:int, _r3_:address |
         {_r1_:7, _r2_:4, _r3_:ip}|} @ { Collection })))) empty {
         _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
     (((route_to_int {key:5, value:Some S_C}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({| _r1_:int, _r2_:int, _r3_:address |
         {_r1_:6, _r2_:5, _r3_:ip}|} @ { Collection })))) empty {
         _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
     (((route_to_int {key:4, value:Some S_B}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({| _r1_:int, _r2_:int, _r3_:address |
         {_r1_:6, _r2_:4, _r3_:ip}|} @ { Collection })))) empty {
         _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
     empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection })))).groupBy
     ((\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip))
     ((\acc -> (\_b3_ -> 
       bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
     ({| key:int, value:int | {key:stmt_id, value:map_id}|} @ { Collection }))))
     empty { key:int, value:int } @ { Collection }).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:stmt_map_ids} in (insert_S_rcv_fetch, ip)<- {
                                                     _r1_:stmt_map_ids,
                                                     _r2_:vid, _r3_:S_B,
                                                     _r4_:S_C}))
  ))

trigger insert_S_rcv_put : {
_r1_:address, _r2_:collection { key:int, value:int } @ { Collection }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid, _r4_:S_B,
                _r5_:S_C} in (
  stmt_id_cnt_list.iterate
    ((\_b1_ ->  bind _b1_ as {key:stmt_id, value:count} in case
    ((__stmt_cntrs__.filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid
    and _r2_ == stmt_id))).peek ()) of
    {Some old_val -> bind old_val as {_r3_:old_count} in 
      let new_count = old_count + count in (
        __stmt_cntrs__.update
          {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
          {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
        if new_count == 0
        then
          if stmt_id == 9
          then (insert_S_do_complete_s9, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
          else
            if stmt_id == 8
            then (insert_S_do_complete_s8, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
            else
              if stmt_id == 7
              then
                (insert_S_do_complete_s7, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
              else
                if stmt_id == 6
                then
                  (insert_S_do_complete_s6, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
                else ()
        else ()
        )}{None -> __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count}}))
  ))

trigger insert_S_rcv_fetch : {
_r1_:collection { key:int, value:int } @ { Collection }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
  log_write_insert_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
  stmts_and_map_ids.iterate
    ((\_b1_ -> 
      bind _b1_ as {key:stmt_id, value:map_id} in if stmt_id == 6
                                                  then
                                                    if map_id == 4
                                                    then
                                                      (insert_S_send_push_s6_m_ATIMESD_mS1,
                                                        me)<- {_r1_:vid,
                                                               _r2_:S_B,
                                                               _r3_:S_C}
                                                    else
                                                      if map_id == 5
                                                      then
                                                        (insert_S_send_push_s6_m_ATIMESD_mS2,
                                                          me)<- {_r1_:vid,
                                                                 _r2_:S_B,
                                                                 _r3_:S_C}
                                                      else ()
                                                  else
                                                    if stmt_id == 7
                                                    then
                                                      if map_id == 4
                                                      then
                                                        (insert_S_send_push_s7_m_ATIMESD_mS1,
                                                          me)<- {_r1_:vid,
                                                                 _r2_:S_B,
                                                                 _r3_:S_C}
                                                      else ()
                                                    else
                                                      if stmt_id == 9
                                                      then
                                                        if map_id == 5
                                                        then
                                                          (insert_S_send_push_s9_m_ATIMESD_mS2,
                                                            me)<- {_r1_:vid,
                                                                   _r2_:S_B,
                                                                   _r3_:S_C}
                                                        else ()
                                                      else ()))
  ))

trigger insert_S_send_push_s6_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
  log_master_write {_r1_:vid, _r2_:2, _r3_:6};
  (shuffle_ATIMESD_mS1_to_ATIMESD
     {_r1_:(),
      _r2_:frontier_int_int
             {key:vid, value:(bind ATIMESD_mS1 as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B))},
      _r3_:true}).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:tuples} in (insert_S_rcv_push_s6_m_ATIMESD_mS1,
                                               ip)<- {_r1_:tuples, _r2_:vid,
                                                      _r3_:S_B, _r4_:S_C}))
  ))

trigger insert_S_send_push_s6_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
  log_master_write {_r1_:vid, _r2_:2, _r3_:6};
  (shuffle_ATIMESD_mS2_to_ATIMESD
     {_r1_:(),
      _r2_:frontier_int_int
             {key:vid, value:(bind ATIMESD_mS2 as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_C))},
      _r3_:true}).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:tuples} in (insert_S_rcv_push_s6_m_ATIMESD_mS2,
                                               ip)<- {_r1_:tuples, _r2_:vid,
                                                      _r3_:S_B, _r4_:S_C}))
  ))

trigger insert_S_send_push_s7_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
  log_master_write {_r1_:vid, _r2_:2, _r3_:7};
  (shuffle_ATIMESD_mS1_to_ATIMESD_mT1
     {_r1_:Some S_C,
      _r2_:frontier_int_int
             {key:vid, value:(bind ATIMESD_mS1 as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B))},
      _r3_:true}).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:tuples} in (insert_S_rcv_push_s7_m_ATIMESD_mS1,
                                               ip)<- {_r1_:tuples, _r2_:vid,
                                                      _r3_:S_B, _r4_:S_C}))
  ))

trigger insert_S_send_push_s9_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
  log_master_write {_r1_:vid, _r2_:2, _r3_:9};
  (shuffle_ATIMESD_mS2_to_ATIMESD_mR1
     {_r1_:Some S_B,
      _r2_:frontier_int_int
             {key:vid, value:(bind ATIMESD_mS2 as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_C))},
      _r3_:true}).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:tuples} in (insert_S_rcv_push_s9_m_ATIMESD_mS2,
                                               ip)<- {_r1_:tuples, _r2_:vid,
                                                      _r3_:S_B, _r4_:S_C}))
  ))

trigger insert_S_rcv_push_s6_m_ATIMESD_mS1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
  log_write_insert_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
  tuples.iterate
    ((\tuple ->  bind tuple as {_r1_:_tup0, _r2_:_tup1, _r3_:_tup2} in case
    (((bind map_ATIMESD_mS1_s6_buf as ind __x in __x).filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == _tup0
    and _r2_ == _tup1))).peek ()) of
    {Some vals ->
      (bind map_ATIMESD_mS1_s6_buf as ind __x in __x).update vals tuple}
    {None -> (bind map_ATIMESD_mS1_s6_buf as ind __x in __x).insert tuple}));
  if check_and_update_stmt_cntr_index {key:vid, value:6}
  then (insert_S_do_complete_s6, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
  else ()
  ))

trigger insert_S_rcv_push_s6_m_ATIMESD_mS2 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
  log_write_insert_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
  tuples.iterate
    ((\tuple ->  bind tuple as {_r1_:_tup0, _r2_:_tup1, _r3_:_tup2} in case
    (((bind map_ATIMESD_mS2_s6_buf as ind __x in __x).filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == _tup0
    and _r2_ == _tup1))).peek ()) of
    {Some vals ->
      (bind map_ATIMESD_mS2_s6_buf as ind __x in __x).update vals tuple}
    {None -> (bind map_ATIMESD_mS2_s6_buf as ind __x in __x).insert tuple}));
  if check_and_update_stmt_cntr_index {key:vid, value:6}
  then (insert_S_do_complete_s6, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
  else ()
  ))

trigger insert_S_rcv_push_s7_m_ATIMESD_mS1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
  log_write_insert_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
  tuples.iterate
    ((\tuple ->  bind tuple as {_r1_:_tup0, _r2_:_tup1, _r3_:_tup2} in case
    (((bind map_ATIMESD_mS1_s7_buf as ind __x in __x).filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == _tup0
    and _r2_ == _tup1))).peek ()) of
    {Some vals ->
      (bind map_ATIMESD_mS1_s7_buf as ind __x in __x).update vals tuple}
    {None -> (bind map_ATIMESD_mS1_s7_buf as ind __x in __x).insert tuple}));
  if check_and_update_stmt_cntr_index {key:vid, value:7}
  then (insert_S_do_complete_s7, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
  else ()
  ))

trigger insert_S_rcv_push_s9_m_ATIMESD_mS2 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
  log_write_insert_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
  tuples.iterate
    ((\tuple ->  bind tuple as {_r1_:_tup0, _r2_:_tup1, _r3_:_tup2} in case
    (((bind map_ATIMESD_mS2_s9_buf as ind __x in __x).filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == _tup0
    and _r2_ == _tup1))).peek ()) of
    {Some vals ->
      (bind map_ATIMESD_mS2_s9_buf as ind __x in __x).update vals tuple}
    {None -> (bind map_ATIMESD_mS2_s9_buf as ind __x in __x).insert tuple}));
  if check_and_update_stmt_cntr_index {key:vid, value:9}
  then (insert_S_do_complete_s9, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
  else ()
  ))

trigger insert_S_do_complete_s6 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in let __prod_ret__8 =
                                                     (let wrapped_lookup_value =
                                                        (frontier_int_int
                                                           {key:vid,
                                                            value:(bind
                                                            map_ATIMESD_mS1_s6_buf
                                                            as ind __x
                                                            in __x).filter
                                                            ((\_b1_ -> 
                                                              bind _b1_ as {
                                                              _r1_:_r1_,
                                                              _r2_:_r2_,
                                                              _r3_:_r3_} in _r2_
                                                            == S_B))}).fold
                                                          ((\__acc_map ->
                                                          (\_b3_ -> 
                                                            bind _b3_ as {
                                                            _r1_:map_vid,
                                                            _r2_:__map_0,
                                                            _r3_:__map_val} in __acc_map.combine
                                                          ({|
                                                          key:int, value:int |
                                                          {key:__map_0,
                                                           value:__map_val}|} @ { Collection }))))
                                                          empty {
                                                          key:int, value:int
                                                          } @ { Collection } in
                                                     case
                                                     (wrapped_lookup_value.peek
                                                     ()) of
                                                     {Some unwrapped_value ->
                                                       bind unwrapped_value as {
                                                       value:projected_field} in 
                                                       projected_field}
                                                     {None -> 0}) *
                                                     let wrapped_lookup_value =
                                                       (frontier_int_int
                                                          {key:vid, value:(bind
                                                           map_ATIMESD_mS2_s6_buf
                                                           as ind __x
                                                           in __x).filter
                                                           ((\_b1_ -> 
                                                             bind _b1_ as {
                                                             _r1_:_r1_,
                                                             _r2_:_r2_,
                                                             _r3_:_r3_} in _r2_
                                                           == S_C))}).fold
                                                         ((\__acc_map ->
                                                         (\_b3_ -> 
                                                           bind _b3_ as {
                                                           _r1_:map_vid,
                                                           _r2_:__map_0,
                                                           _r3_:__map_val} in __acc_map.combine
                                                         ({| key:int, value:int
                                                         |
                                                         {key:__map_0,
                                                          value:__map_val}|} @ { Collection }))))
                                                         empty {
                                                         key:int, value:int
                                                         } @ { Collection } in
                                                     case
                                                     (wrapped_lookup_value.peek
                                                     ()) of
                                                     {Some unwrapped_value ->
                                                       bind unwrapped_value as {
                                                       value:projected_field} in 
                                                       projected_field}
                                                     {None -> 0} in (
    add_delta_to_int
      {_r1_:ATIMESD, _r2_:false, _r3_:vid, _r4_:{|
       key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
       {key:vid, value:__prod_ret__8}|} @ { Collection }}
    ))

trigger insert_S_do_complete_s7 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in let __map_ret__7 =
                                                     let wrapped_lookup_value =
                                                       (frontier_int_int
                                                          {key:vid, value:(bind
                                                           map_ATIMESD_mS1_s7_buf
                                                           as ind __x
                                                           in __x).filter
                                                           ((\_b1_ -> 
                                                             bind _b1_ as {
                                                             _r1_:_r1_,
                                                             _r2_:_r2_,
                                                             _r3_:_r3_} in _r2_
                                                           == S_B))}).fold
                                                         ((\__acc_map ->
                                                         (\_b3_ -> 
                                                           bind _b3_ as {
                                                           _r1_:map_vid,
                                                           _r2_:__map_0,
                                                           _r3_:__map_val} in __acc_map.combine
                                                         ({| key:int, value:int
                                                         |
                                                         {key:__map_0,
                                                          value:__map_val}|} @ { Collection }))))
                                                         empty {
                                                         key:int, value:int
                                                         } @ { Collection } in
                                                     case
                                                     (wrapped_lookup_value.peek
                                                     ()) of
                                                     {Some unwrapped_value ->
                                                       bind unwrapped_value as {
                                                       value:projected_field} in 
                                                       projected_field}
                                                     {None -> 0} in (
    add_delta_to_int_int
      {_r1_:ATIMESD_mT1, _r2_:false, _r3_:vid, _r4_:{|
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
       {_r1_:vid, _r2_:S_C, _r3_:__map_ret__7}|} @ { Collection }};
    (ATIMESD_mT1_send_correctives, me)<- {key:vid, value:{|
                                          _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                          }, _r2_:int, _r3_:int |
                                          {_r1_:vid, _r2_:S_C,
                                           _r3_:__map_ret__7}|} @ { Collection }}
    ))

trigger insert_S_do_complete_s8 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in let __val_ret__10 = 1 in (
    add_delta_to_int_int_int
      {_r1_:ATIMESD_mT1_mR1, _r2_:false, _r3_:vid, _r4_:{|
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int |
       {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:__val_ret__10}|} @ { Collection }};
    (ATIMESD_mT1_mR1_send_correctives, me)<- {key:vid, value:{|
                                              _r1_:{
                                              _r1_:int, _r2_:int, _r3_:int },
                                              _r2_:int, _r3_:int, _r4_:int |
                                              {_r1_:vid, _r2_:S_B, _r3_:S_C,
                                               _r4_:__val_ret__10}|} @ { Collection }}
    ))

trigger insert_S_do_complete_s9 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in let __map_ret__8 =
                                                     let wrapped_lookup_value =
                                                       (frontier_int_int
                                                          {key:vid, value:(bind
                                                           map_ATIMESD_mS2_s9_buf
                                                           as ind __x
                                                           in __x).filter
                                                           ((\_b1_ -> 
                                                             bind _b1_ as {
                                                             _r1_:_r1_,
                                                             _r2_:_r2_,
                                                             _r3_:_r3_} in _r2_
                                                           == S_C))}).fold
                                                         ((\__acc_map ->
                                                         (\_b3_ -> 
                                                           bind _b3_ as {
                                                           _r1_:map_vid,
                                                           _r2_:__map_0,
                                                           _r3_:__map_val} in __acc_map.combine
                                                         ({| key:int, value:int
                                                         |
                                                         {key:__map_0,
                                                          value:__map_val}|} @ { Collection }))))
                                                         empty {
                                                         key:int, value:int
                                                         } @ { Collection } in
                                                     case
                                                     (wrapped_lookup_value.peek
                                                     ()) of
                                                     {Some unwrapped_value ->
                                                       bind unwrapped_value as {
                                                       value:projected_field} in 
                                                       projected_field}
                                                     {None -> 0} in (
    add_delta_to_int_int
      {_r1_:ATIMESD_mR1, _r2_:false, _r3_:vid, _r4_:{|
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
       {_r1_:vid, _r2_:S_B, _r3_:__map_ret__8}|} @ { Collection }};
    (ATIMESD_mR1_send_correctives, me)<- {key:vid, value:{|
                                          _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                          }, _r2_:int, _r3_:int |
                                          {_r1_:vid, _r2_:S_B,
                                           _r3_:__map_ret__8}|} @ { Collection }}
    ))

trigger insert_S_rcv_corrective_s6_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
  add_delta_to_int_int
    {_r1_:map_ATIMESD_mS1_s6_buf, _r2_:false, _r3_:vid, _r4_:delta_tuples};
  compute_vids.iterate
    ((\compute_vid -> 
      if ((__stmt_cntrs__.filter
        ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
        compute_vid and _r2_ == 6))).peek ()) ==
        Some {_r1_:compute_vid, _r2_:6, _r3_:0}
      then
        bind log_get_bound_insert_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                    _r3_:S_C} in 
        (insert_S_do_corrective_s6_m_ATIMESD_mS1, me)<- {_r1_:compute_vid,
                                                         _r2_:S_B, _r3_:S_C,
                                                         _r4_:delta_tuples}
      else ()))
  ))

trigger insert_S_rcv_corrective_s6_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
  add_delta_to_int_int
    {_r1_:map_ATIMESD_mS2_s6_buf, _r2_:false, _r3_:vid, _r4_:delta_tuples};
  compute_vids.iterate
    ((\compute_vid -> 
      if ((__stmt_cntrs__.filter
        ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
        compute_vid and _r2_ == 6))).peek ()) ==
        Some {_r1_:compute_vid, _r2_:6, _r3_:0}
      then
        bind log_get_bound_insert_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                    _r3_:S_C} in 
        (insert_S_do_corrective_s6_m_ATIMESD_mS2, me)<- {_r1_:compute_vid,
                                                         _r2_:S_B, _r3_:S_C,
                                                         _r4_:delta_tuples}
      else ()))
  ))

trigger insert_S_rcv_corrective_s7_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
  add_delta_to_int_int
    {_r1_:map_ATIMESD_mS1_s7_buf, _r2_:false, _r3_:vid, _r4_:delta_tuples};
  compute_vids.iterate
    ((\compute_vid -> 
      if ((__stmt_cntrs__.filter
        ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
        compute_vid and _r2_ == 7))).peek ()) ==
        Some {_r1_:compute_vid, _r2_:7, _r3_:0}
      then
        bind log_get_bound_insert_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                    _r3_:S_C} in 
        (insert_S_do_corrective_s7_m_ATIMESD_mS1, me)<- {_r1_:compute_vid,
                                                         _r2_:S_B, _r3_:S_C,
                                                         _r4_:delta_tuples}
      else ()))
  ))

trigger insert_S_rcv_corrective_s9_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
  add_delta_to_int_int
    {_r1_:map_ATIMESD_mS2_s9_buf, _r2_:false, _r3_:vid, _r4_:delta_tuples};
  compute_vids.iterate
    ((\compute_vid -> 
      if ((__stmt_cntrs__.filter
        ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
        compute_vid and _r2_ == 9))).peek ()) ==
        Some {_r1_:compute_vid, _r2_:9, _r3_:0}
      then
        bind log_get_bound_insert_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                    _r3_:S_C} in 
        (insert_S_do_corrective_s9_m_ATIMESD_mS2, me)<- {_r1_:compute_vid,
                                                         _r2_:S_B, _r3_:S_C,
                                                         _r4_:delta_tuples}
      else ()))
  ))

trigger insert_S_do_corrective_s6_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
  delta_tuples.iterate
    ((\_b1_ -> 
      bind _b1_ as {_r2_:delta_ATIMESD_mSS_B, _r3_:delta_ATIMESD_mS1} in 
    let __prod_ret__31 = ((if S_B == delta_ATIMESD_mSS_B then 1 else 0) *
      let wrapped_lookup_value =
        (frontier_int_int
           {key:vid, value:(bind map_ATIMESD_mS2_s6_buf as ind __x
            in __x).filter
            ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
            == S_C))}).fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in __acc_map.combine
          ({| key:int, value:int |
          {key:__map_0, value:__map_val}|} @ { Collection })))) empty {
          key:int, value:int } @ { Collection } in case
      (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value ->
        bind unwrapped_value as {value:projected_field} in projected_field}
      {None -> 0}) * delta_ATIMESD_mS1 in (
      add_delta_to_int
        {_r1_:ATIMESD, _r2_:true, _r3_:vid, _r4_:{|
         key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
         {key:vid, value:__prod_ret__31}|} @ { Collection }}
      ))))

trigger insert_S_do_corrective_s6_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
  delta_tuples.iterate
    ((\_b1_ -> 
      bind _b1_ as {_r2_:delta_ATIMESD_mSS_C, _r3_:delta_ATIMESD_mS2} in 
    let __prod_ret__37 = ((if S_C == delta_ATIMESD_mSS_C then 1 else 0) *
      let wrapped_lookup_value =
        (frontier_int_int
           {key:vid, value:(bind map_ATIMESD_mS1_s6_buf as ind __x
            in __x).filter
            ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
            == S_B))}).fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in __acc_map.combine
          ({| key:int, value:int |
          {key:__map_0, value:__map_val}|} @ { Collection })))) empty {
          key:int, value:int } @ { Collection } in case
      (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value ->
        bind unwrapped_value as {value:projected_field} in projected_field}
      {None -> 0}) * delta_ATIMESD_mS2 in (
      add_delta_to_int
        {_r1_:ATIMESD, _r2_:true, _r3_:vid, _r4_:{|
         key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
         {key:vid, value:__prod_ret__37}|} @ { Collection }}
      ))))

trigger insert_S_do_corrective_s7_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
  delta_tuples.iterate
    ((\_b1_ -> 
      bind _b1_ as {_r2_:delta_ATIMESD_mSS_B, _r3_:delta_ATIMESD_mS1} in 
    let __prod_ret__32 = (if S_B == delta_ATIMESD_mSS_B then 1 else 0) *
      delta_ATIMESD_mS1 in (
      add_delta_to_int_int
        {_r1_:ATIMESD_mT1, _r2_:true, _r3_:vid, _r4_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:S_C, _r3_:__prod_ret__32}|} @ { Collection }};
      (ATIMESD_mT1_send_correctives, me)<- {key:vid, value:{|
                                            _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                            }, _r2_:int, _r3_:int |
                                            {_r1_:vid, _r2_:S_C,
                                             _r3_:__prod_ret__32}|} @ { Collection }}
      ))))

trigger insert_S_do_corrective_s9_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
  delta_tuples.iterate
    ((\_b1_ -> 
      bind _b1_ as {_r2_:delta_ATIMESD_mSS_C, _r3_:delta_ATIMESD_mS2} in 
    let __prod_ret__38 = (if S_C == delta_ATIMESD_mSS_C then 1 else 0) *
      delta_ATIMESD_mS2 in (
      add_delta_to_int_int
        {_r1_:ATIMESD_mR1, _r2_:true, _r3_:vid, _r4_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:S_B, _r3_:__prod_ret__38}|} @ { Collection }};
      (ATIMESD_mR1_send_correctives, me)<- {key:vid, value:{|
                                            _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                            }, _r2_:int, _r3_:int |
                                            {_r1_:vid, _r2_:S_B,
                                             _r3_:__prod_ret__38}|} @ { Collection }}
      ))))

trigger delete_S : {
key:int, value:int
}
= (\_b1_ ->

  bind _b1_ as {key:S_B, value:S_C} in (
  let vid =
    {_r1_:case (__epoch__.peek ()) of {Some _i -> _i.i}{None -> 0}, _r2_:case
     (__vid_counter__.peek ()) of {Some _i -> _i.i}{None -> 0}, _r3_:
     hash me} in
  (
    (delete_S_send_fetch, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C};
    let vid_counter_old = case (__vid_counter__.peek ()) of
      {Some _i -> _i.i}{None -> 0} in
    __vid_counter__.update {i:vid_counter_old} ({i:1 + vid_counter_old})
    )
  ))

trigger delete_S_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
  (route_to_int_int {_r1_:3, _r2_:Some S_B, _r3_:Some S_C}).iterate
    ((\_b1_ -> 
      bind _b1_ as {i:ip} in (delete_S_do_complete_s12, ip)<- {_r1_:vid,
                                                               _r2_:S_B,
                                                               _r3_:S_C}));
  ((((empty {
      _r1_:address, _r2_:int, _r3_:int
      } @ { Collection }).combine
      (let sender_count =
         (route_to_int {key:4, value:Some S_B}).fold
           ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
      ((shuffle_ATIMESD_mS1_to_ATIMESD
          {_r1_:(), _r2_:empty {
           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
           } @ { Collection }, _r3_:true}).fold
         ((\__acc_map -> (\_b3_ -> 
           bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
         ({| _r1_:address, _r2_:int, _r3_:int |
         {_r1_:ip, _r2_:10, _r3_:sender_count}|} @ { Collection })))) empty {
         _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
      (let sender_count =
         (route_to_int {key:5, value:Some S_C}).fold
           ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
      ((shuffle_ATIMESD_mS2_to_ATIMESD
          {_r1_:(), _r2_:empty {
           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
           } @ { Collection }, _r3_:true}).fold
         ((\__acc_map -> (\_b3_ -> 
           bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
         ({| _r1_:address, _r2_:int, _r3_:int |
         {_r1_:ip, _r2_:10, _r3_:sender_count}|} @ { Collection })))) empty {
         _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
      (let sender_count =
         (route_to_int {key:4, value:Some S_B}).fold
           ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
      ((shuffle_ATIMESD_mS1_to_ATIMESD_mT1
          {_r1_:Some S_C, _r2_:empty {
           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
           } @ { Collection }, _r3_:true}).fold
         ((\__acc_map -> (\_b3_ -> 
           bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
         ({| _r1_:address, _r2_:int, _r3_:int |
         {_r1_:ip, _r2_:11, _r3_:sender_count}|} @ { Collection })))) empty {
         _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
      (let sender_count =
         (route_to_int {key:5, value:Some S_C}).fold
           ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
      (shuffle_ATIMESD_mS2_to_ATIMESD_mR1
         {_r1_:Some S_B, _r2_:empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }, _r3_:true}).fold
        ((\__acc_map -> (\_b3_ -> 
          bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
        ({| _r1_:address, _r2_:int, _r3_:int |
        {_r1_:ip, _r2_:13, _r3_:sender_count}|} @ { Collection })))) empty {
        _r1_:address, _r2_:int, _r3_:int } @ { Collection }))))).groupBy
      ((\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in {key:ip,
                                                             value:stmt_id}))
      ((\acc -> (\_b3_ -> 
        bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupBy
     ((\_b1_ -> 
       bind _b1_ as {key:_b2_, value:count} in 
       bind _b2_ as {key:ip, value:stmt_id} in ip)) ((\acc -> (\_b3_ -> 
       bind _b3_ as {key:ip_and_stmt_id, value:count} in bind ip_and_stmt_id as {
     key:ip, value:stmt_id} in acc.combine
     ({| key:int, value:int | {key:stmt_id, value:count}|} @ { Collection }))))
     empty { key:int, value:int } @ { Collection }).iterate
    ((\_b1_ ->  bind _b1_ as {key:ip, value:stmt_id_cnt_list} in (
      (delete_S_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list, _r3_:vid,
                                _r4_:S_B, _r5_:S_C}
      )));
  ((((route_to_int {key:5, value:Some S_C}).fold
       ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
       ({| _r1_:int, _r2_:int, _r3_:address |
       {_r1_:13, _r2_:5, _r3_:ip}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
     (((route_to_int {key:4, value:Some S_B}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({| _r1_:int, _r2_:int, _r3_:address |
         {_r1_:11, _r2_:4, _r3_:ip}|} @ { Collection })))) empty {
         _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
     (((route_to_int {key:5, value:Some S_C}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({| _r1_:int, _r2_:int, _r3_:address |
         {_r1_:10, _r2_:5, _r3_:ip}|} @ { Collection })))) empty {
         _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
     (((route_to_int {key:4, value:Some S_B}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({| _r1_:int, _r2_:int, _r3_:address |
         {_r1_:10, _r2_:4, _r3_:ip}|} @ { Collection })))) empty {
         _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
     empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection })))).groupBy
     ((\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip))
     ((\acc -> (\_b3_ -> 
       bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
     ({| key:int, value:int | {key:stmt_id, value:map_id}|} @ { Collection }))))
     empty { key:int, value:int } @ { Collection }).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:stmt_map_ids} in (delete_S_rcv_fetch, ip)<- {
                                                     _r1_:stmt_map_ids,
                                                     _r2_:vid, _r3_:S_B,
                                                     _r4_:S_C}))
  ))

trigger delete_S_rcv_put : {
_r1_:address, _r2_:collection { key:int, value:int } @ { Collection }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid, _r4_:S_B,
                _r5_:S_C} in (
  stmt_id_cnt_list.iterate
    ((\_b1_ ->  bind _b1_ as {key:stmt_id, value:count} in case
    ((__stmt_cntrs__.filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid
    and _r2_ == stmt_id))).peek ()) of
    {Some old_val -> bind old_val as {_r3_:old_count} in 
      let new_count = old_count + count in (
        __stmt_cntrs__.update
          {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
          {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
        if new_count == 0
        then
          if stmt_id == 13
          then (delete_S_do_complete_s13, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
          else
            if stmt_id == 12
            then
              (delete_S_do_complete_s12, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
            else
              if stmt_id == 11
              then
                (delete_S_do_complete_s11, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
              else
                if stmt_id == 10
                then
                  (delete_S_do_complete_s10, me)<- {_r1_:vid, _r2_:S_B,
                                                    _r3_:S_C}
                else ()
        else ()
        )}{None -> __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count}}))
  ))

trigger delete_S_rcv_fetch : {
_r1_:collection { key:int, value:int } @ { Collection }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
  log_write_delete_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
  stmts_and_map_ids.iterate
    ((\_b1_ -> 
      bind _b1_ as {key:stmt_id, value:map_id} in if stmt_id == 10
                                                  then
                                                    if map_id == 4
                                                    then
                                                      (delete_S_send_push_s10_m_ATIMESD_mS1,
                                                        me)<- {_r1_:vid,
                                                               _r2_:S_B,
                                                               _r3_:S_C}
                                                    else
                                                      if map_id == 5
                                                      then
                                                        (delete_S_send_push_s10_m_ATIMESD_mS2,
                                                          me)<- {_r1_:vid,
                                                                 _r2_:S_B,
                                                                 _r3_:S_C}
                                                      else ()
                                                  else
                                                    if stmt_id == 11
                                                    then
                                                      if map_id == 4
                                                      then
                                                        (delete_S_send_push_s11_m_ATIMESD_mS1,
                                                          me)<- {_r1_:vid,
                                                                 _r2_:S_B,
                                                                 _r3_:S_C}
                                                      else ()
                                                    else
                                                      if stmt_id == 13
                                                      then
                                                        if map_id == 5
                                                        then
                                                          (delete_S_send_push_s13_m_ATIMESD_mS2,
                                                            me)<- {_r1_:vid,
                                                                   _r2_:S_B,
                                                                   _r3_:S_C}
                                                        else ()
                                                      else ()))
  ))

trigger delete_S_send_push_s10_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
  log_master_write {_r1_:vid, _r2_:3, _r3_:10};
  (shuffle_ATIMESD_mS1_to_ATIMESD
     {_r1_:(),
      _r2_:frontier_int_int
             {key:vid, value:(bind ATIMESD_mS1 as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B))},
      _r3_:true}).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:tuples} in (delete_S_rcv_push_s10_m_ATIMESD_mS1,
                                               ip)<- {_r1_:tuples, _r2_:vid,
                                                      _r3_:S_B, _r4_:S_C}))
  ))

trigger delete_S_send_push_s10_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
  log_master_write {_r1_:vid, _r2_:3, _r3_:10};
  (shuffle_ATIMESD_mS2_to_ATIMESD
     {_r1_:(),
      _r2_:frontier_int_int
             {key:vid, value:(bind ATIMESD_mS2 as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_C))},
      _r3_:true}).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:tuples} in (delete_S_rcv_push_s10_m_ATIMESD_mS2,
                                               ip)<- {_r1_:tuples, _r2_:vid,
                                                      _r3_:S_B, _r4_:S_C}))
  ))

trigger delete_S_send_push_s11_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
  log_master_write {_r1_:vid, _r2_:3, _r3_:11};
  (shuffle_ATIMESD_mS1_to_ATIMESD_mT1
     {_r1_:Some S_C,
      _r2_:frontier_int_int
             {key:vid, value:(bind ATIMESD_mS1 as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B))},
      _r3_:true}).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:tuples} in (delete_S_rcv_push_s11_m_ATIMESD_mS1,
                                               ip)<- {_r1_:tuples, _r2_:vid,
                                                      _r3_:S_B, _r4_:S_C}))
  ))

trigger delete_S_send_push_s13_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
  log_master_write {_r1_:vid, _r2_:3, _r3_:13};
  (shuffle_ATIMESD_mS2_to_ATIMESD_mR1
     {_r1_:Some S_B,
      _r2_:frontier_int_int
             {key:vid, value:(bind ATIMESD_mS2 as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_C))},
      _r3_:true}).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:tuples} in (delete_S_rcv_push_s13_m_ATIMESD_mS2,
                                               ip)<- {_r1_:tuples, _r2_:vid,
                                                      _r3_:S_B, _r4_:S_C}))
  ))

trigger delete_S_rcv_push_s10_m_ATIMESD_mS1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
  log_write_delete_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
  tuples.iterate
    ((\tuple ->  bind tuple as {_r1_:_tup0, _r2_:_tup1, _r3_:_tup2} in case
    (((bind map_ATIMESD_mS1_s10_buf as ind __x in __x).filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == _tup0
    and _r2_ == _tup1))).peek ()) of
    {Some vals ->
      (bind map_ATIMESD_mS1_s10_buf as ind __x in __x).update vals tuple}
    {None -> (bind map_ATIMESD_mS1_s10_buf as ind __x in __x).insert tuple}));
  if check_and_update_stmt_cntr_index {key:vid, value:10}
  then (delete_S_do_complete_s10, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
  else ()
  ))

trigger delete_S_rcv_push_s10_m_ATIMESD_mS2 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
  log_write_delete_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
  tuples.iterate
    ((\tuple ->  bind tuple as {_r1_:_tup0, _r2_:_tup1, _r3_:_tup2} in case
    (((bind map_ATIMESD_mS2_s10_buf as ind __x in __x).filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == _tup0
    and _r2_ == _tup1))).peek ()) of
    {Some vals ->
      (bind map_ATIMESD_mS2_s10_buf as ind __x in __x).update vals tuple}
    {None -> (bind map_ATIMESD_mS2_s10_buf as ind __x in __x).insert tuple}));
  if check_and_update_stmt_cntr_index {key:vid, value:10}
  then (delete_S_do_complete_s10, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
  else ()
  ))

trigger delete_S_rcv_push_s11_m_ATIMESD_mS1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
  log_write_delete_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
  tuples.iterate
    ((\tuple ->  bind tuple as {_r1_:_tup0, _r2_:_tup1, _r3_:_tup2} in case
    (((bind map_ATIMESD_mS1_s11_buf as ind __x in __x).filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == _tup0
    and _r2_ == _tup1))).peek ()) of
    {Some vals ->
      (bind map_ATIMESD_mS1_s11_buf as ind __x in __x).update vals tuple}
    {None -> (bind map_ATIMESD_mS1_s11_buf as ind __x in __x).insert tuple}));
  if check_and_update_stmt_cntr_index {key:vid, value:11}
  then (delete_S_do_complete_s11, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
  else ()
  ))

trigger delete_S_rcv_push_s13_m_ATIMESD_mS2 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
  log_write_delete_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
  tuples.iterate
    ((\tuple ->  bind tuple as {_r1_:_tup0, _r2_:_tup1, _r3_:_tup2} in case
    (((bind map_ATIMESD_mS2_s13_buf as ind __x in __x).filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == _tup0
    and _r2_ == _tup1))).peek ()) of
    {Some vals ->
      (bind map_ATIMESD_mS2_s13_buf as ind __x in __x).update vals tuple}
    {None -> (bind map_ATIMESD_mS2_s13_buf as ind __x in __x).insert tuple}));
  if check_and_update_stmt_cntr_index {key:vid, value:13}
  then (delete_S_do_complete_s13, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
  else ()
  ))

trigger delete_S_do_complete_s10 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in let __prod_ret__10 =
                                                     ((let wrapped_lookup_value =
                                                         (frontier_int_int
                                                            {key:vid,
                                                             value:(bind
                                                             map_ATIMESD_mS1_s10_buf
                                                             as ind __x
                                                             in __x).filter
                                                             ((\_b1_ -> 
                                                               bind _b1_ as {
                                                               _r1_:_r1_,
                                                               _r2_:_r2_,
                                                               _r3_:_r3_} in _r2_
                                                             == S_B))}).fold
                                                           ((\__acc_map ->
                                                           (\_b3_ -> 
                                                             bind _b3_ as {
                                                             _r1_:map_vid,
                                                             _r2_:__map_0,
                                                             _r3_:__map_val} in __acc_map.combine
                                                           ({|
                                                           key:int, value:int |
                                                           {key:__map_0,
                                                            value:__map_val}|} @ { Collection }))))
                                                           empty {
                                                           key:int, value:int
                                                           } @ { Collection } in
                                                     case
                                                     (wrapped_lookup_value.peek
                                                     ()) of
                                                     {Some unwrapped_value ->
                                                       bind unwrapped_value as {
                                                       value:projected_field} in 
                                                       projected_field}
                                                     {None -> 0}) *
                                                     let wrapped_lookup_value =
                                                       (frontier_int_int
                                                          {key:vid, value:(bind
                                                           map_ATIMESD_mS2_s10_buf
                                                           as ind __x
                                                           in __x).filter
                                                           ((\_b1_ -> 
                                                             bind _b1_ as {
                                                             _r1_:_r1_,
                                                             _r2_:_r2_,
                                                             _r3_:_r3_} in _r2_
                                                           == S_C))}).fold
                                                         ((\__acc_map ->
                                                         (\_b3_ -> 
                                                           bind _b3_ as {
                                                           _r1_:map_vid,
                                                           _r2_:__map_0,
                                                           _r3_:__map_val} in __acc_map.combine
                                                         ({| key:int, value:int
                                                         |
                                                         {key:__map_0,
                                                          value:__map_val}|} @ { Collection }))))
                                                         empty {
                                                         key:int, value:int
                                                         } @ { Collection } in
                                                     case
                                                     (wrapped_lookup_value.peek
                                                     ()) of
                                                     {Some unwrapped_value ->
                                                       bind unwrapped_value as {
                                                       value:projected_field} in 
                                                       projected_field}
                                                     {None -> 0}) * -1 in (
    add_delta_to_int
      {_r1_:ATIMESD, _r2_:false, _r3_:vid, _r4_:{|
       key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
       {key:vid, value:__prod_ret__10}|} @ { Collection }}
    ))

trigger delete_S_do_complete_s11 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in let __prod_ret__11 =
                                                     (let wrapped_lookup_value =
                                                        (frontier_int_int
                                                           {key:vid,
                                                            value:(bind
                                                            map_ATIMESD_mS1_s11_buf
                                                            as ind __x
                                                            in __x).filter
                                                            ((\_b1_ -> 
                                                              bind _b1_ as {
                                                              _r1_:_r1_,
                                                              _r2_:_r2_,
                                                              _r3_:_r3_} in _r2_
                                                            == S_B))}).fold
                                                          ((\__acc_map ->
                                                          (\_b3_ -> 
                                                            bind _b3_ as {
                                                            _r1_:map_vid,
                                                            _r2_:__map_0,
                                                            _r3_:__map_val} in __acc_map.combine
                                                          ({|
                                                          key:int, value:int |
                                                          {key:__map_0,
                                                           value:__map_val}|} @ { Collection }))))
                                                          empty {
                                                          key:int, value:int
                                                          } @ { Collection } in
                                                     case
                                                     (wrapped_lookup_value.peek
                                                     ()) of
                                                     {Some unwrapped_value ->
                                                       bind unwrapped_value as {
                                                       value:projected_field} in 
                                                       projected_field}
                                                     {None -> 0}) * -1 in (
    add_delta_to_int_int
      {_r1_:ATIMESD_mT1, _r2_:false, _r3_:vid, _r4_:{|
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
       {_r1_:vid, _r2_:S_C, _r3_:__prod_ret__11}|} @ { Collection }};
    (ATIMESD_mT1_send_correctives, me)<- {key:vid, value:{|
                                          _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                          }, _r2_:int, _r3_:int |
                                          {_r1_:vid, _r2_:S_C,
                                           _r3_:__prod_ret__11}|} @ { Collection }}
    ))

trigger delete_S_do_complete_s12 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in let __val_ret__13 = -1 in (
    add_delta_to_int_int_int
      {_r1_:ATIMESD_mT1_mR1, _r2_:false, _r3_:vid, _r4_:{|
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int |
       {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:__val_ret__13}|} @ { Collection }};
    (ATIMESD_mT1_mR1_send_correctives, me)<- {key:vid, value:{|
                                              _r1_:{
                                              _r1_:int, _r2_:int, _r3_:int },
                                              _r2_:int, _r3_:int, _r4_:int |
                                              {_r1_:vid, _r2_:S_B, _r3_:S_C,
                                               _r4_:__val_ret__13}|} @ { Collection }}
    ))

trigger delete_S_do_complete_s13 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in let __prod_ret__12 =
                                                     (let wrapped_lookup_value =
                                                        (frontier_int_int
                                                           {key:vid,
                                                            value:(bind
                                                            map_ATIMESD_mS2_s13_buf
                                                            as ind __x
                                                            in __x).filter
                                                            ((\_b1_ -> 
                                                              bind _b1_ as {
                                                              _r1_:_r1_,
                                                              _r2_:_r2_,
                                                              _r3_:_r3_} in _r2_
                                                            == S_C))}).fold
                                                          ((\__acc_map ->
                                                          (\_b3_ -> 
                                                            bind _b3_ as {
                                                            _r1_:map_vid,
                                                            _r2_:__map_0,
                                                            _r3_:__map_val} in __acc_map.combine
                                                          ({|
                                                          key:int, value:int |
                                                          {key:__map_0,
                                                           value:__map_val}|} @ { Collection }))))
                                                          empty {
                                                          key:int, value:int
                                                          } @ { Collection } in
                                                     case
                                                     (wrapped_lookup_value.peek
                                                     ()) of
                                                     {Some unwrapped_value ->
                                                       bind unwrapped_value as {
                                                       value:projected_field} in 
                                                       projected_field}
                                                     {None -> 0}) * -1 in (
    add_delta_to_int_int
      {_r1_:ATIMESD_mR1, _r2_:false, _r3_:vid, _r4_:{|
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
       {_r1_:vid, _r2_:S_B, _r3_:__prod_ret__12}|} @ { Collection }};
    (ATIMESD_mR1_send_correctives, me)<- {key:vid, value:{|
                                          _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                          }, _r2_:int, _r3_:int |
                                          {_r1_:vid, _r2_:S_B,
                                           _r3_:__prod_ret__12}|} @ { Collection }}
    ))

trigger delete_S_rcv_corrective_s10_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
  add_delta_to_int_int
    {_r1_:map_ATIMESD_mS1_s10_buf, _r2_:false, _r3_:vid, _r4_:delta_tuples};
  compute_vids.iterate
    ((\compute_vid -> 
      if ((__stmt_cntrs__.filter
        ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
        compute_vid and _r2_ == 10))).peek ()) ==
        Some {_r1_:compute_vid, _r2_:10, _r3_:0}
      then
        bind log_get_bound_delete_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                    _r3_:S_C} in 
        (delete_S_do_corrective_s10_m_ATIMESD_mS1, me)<- {_r1_:compute_vid,
                                                          _r2_:S_B, _r3_:S_C,
                                                          _r4_:delta_tuples}
      else ()))
  ))

trigger delete_S_rcv_corrective_s10_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
  add_delta_to_int_int
    {_r1_:map_ATIMESD_mS2_s10_buf, _r2_:false, _r3_:vid, _r4_:delta_tuples};
  compute_vids.iterate
    ((\compute_vid -> 
      if ((__stmt_cntrs__.filter
        ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
        compute_vid and _r2_ == 10))).peek ()) ==
        Some {_r1_:compute_vid, _r2_:10, _r3_:0}
      then
        bind log_get_bound_delete_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                    _r3_:S_C} in 
        (delete_S_do_corrective_s10_m_ATIMESD_mS2, me)<- {_r1_:compute_vid,
                                                          _r2_:S_B, _r3_:S_C,
                                                          _r4_:delta_tuples}
      else ()))
  ))

trigger delete_S_rcv_corrective_s11_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
  add_delta_to_int_int
    {_r1_:map_ATIMESD_mS1_s11_buf, _r2_:false, _r3_:vid, _r4_:delta_tuples};
  compute_vids.iterate
    ((\compute_vid -> 
      if ((__stmt_cntrs__.filter
        ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
        compute_vid and _r2_ == 11))).peek ()) ==
        Some {_r1_:compute_vid, _r2_:11, _r3_:0}
      then
        bind log_get_bound_delete_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                    _r3_:S_C} in 
        (delete_S_do_corrective_s11_m_ATIMESD_mS1, me)<- {_r1_:compute_vid,
                                                          _r2_:S_B, _r3_:S_C,
                                                          _r4_:delta_tuples}
      else ()))
  ))

trigger delete_S_rcv_corrective_s13_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
  add_delta_to_int_int
    {_r1_:map_ATIMESD_mS2_s13_buf, _r2_:false, _r3_:vid, _r4_:delta_tuples};
  compute_vids.iterate
    ((\compute_vid -> 
      if ((__stmt_cntrs__.filter
        ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
        compute_vid and _r2_ == 13))).peek ()) ==
        Some {_r1_:compute_vid, _r2_:13, _r3_:0}
      then
        bind log_get_bound_delete_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                    _r3_:S_C} in 
        (delete_S_do_corrective_s13_m_ATIMESD_mS2, me)<- {_r1_:compute_vid,
                                                          _r2_:S_B, _r3_:S_C,
                                                          _r4_:delta_tuples}
      else ()))
  ))

trigger delete_S_do_corrective_s10_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
  delta_tuples.iterate
    ((\_b1_ -> 
      bind _b1_ as {_r2_:delta_ATIMESD_mSS_B, _r3_:delta_ATIMESD_mS1} in 
    let __prod_ret__44 = ((if S_B == delta_ATIMESD_mSS_B then 1 else 0) *
      let wrapped_lookup_value =
        (frontier_int_int
           {key:vid, value:(bind map_ATIMESD_mS2_s10_buf as ind __x
            in __x).filter
            ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
            == S_C))}).fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in __acc_map.combine
          ({| key:int, value:int |
          {key:__map_0, value:__map_val}|} @ { Collection })))) empty {
          key:int, value:int } @ { Collection } in case
      (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value ->
        bind unwrapped_value as {value:projected_field} in projected_field}
      {None -> 0}) * -delta_ATIMESD_mS1 in (
      add_delta_to_int
        {_r1_:ATIMESD, _r2_:true, _r3_:vid, _r4_:{|
         key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
         {key:vid, value:__prod_ret__44}|} @ { Collection }}
      ))))

trigger delete_S_do_corrective_s10_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
  delta_tuples.iterate
    ((\_b1_ -> 
      bind _b1_ as {_r2_:delta_ATIMESD_mSS_C, _r3_:delta_ATIMESD_mS2} in 
    let __prod_ret__54 = ((if S_C == delta_ATIMESD_mSS_C then 1 else 0) *
      let wrapped_lookup_value =
        (frontier_int_int
           {key:vid, value:(bind map_ATIMESD_mS1_s10_buf as ind __x
            in __x).filter
            ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
            == S_B))}).fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in __acc_map.combine
          ({| key:int, value:int |
          {key:__map_0, value:__map_val}|} @ { Collection })))) empty {
          key:int, value:int } @ { Collection } in case
      (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value ->
        bind unwrapped_value as {value:projected_field} in projected_field}
      {None -> 0}) * -delta_ATIMESD_mS2 in (
      add_delta_to_int
        {_r1_:ATIMESD, _r2_:true, _r3_:vid, _r4_:{|
         key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
         {key:vid, value:__prod_ret__54}|} @ { Collection }}
      ))))

trigger delete_S_do_corrective_s11_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
  delta_tuples.iterate
    ((\_b1_ -> 
      bind _b1_ as {_r2_:delta_ATIMESD_mSS_B, _r3_:delta_ATIMESD_mS1} in 
    let __prod_ret__46 = (if S_B == delta_ATIMESD_mSS_B then 1 else 0) *
      -delta_ATIMESD_mS1 in (
      add_delta_to_int_int
        {_r1_:ATIMESD_mT1, _r2_:true, _r3_:vid, _r4_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:S_C, _r3_:__prod_ret__46}|} @ { Collection }};
      (ATIMESD_mT1_send_correctives, me)<- {key:vid, value:{|
                                            _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                            }, _r2_:int, _r3_:int |
                                            {_r1_:vid, _r2_:S_C,
                                             _r3_:__prod_ret__46}|} @ { Collection }}
      ))))

trigger delete_S_do_corrective_s13_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
  delta_tuples.iterate
    ((\_b1_ -> 
      bind _b1_ as {_r2_:delta_ATIMESD_mSS_C, _r3_:delta_ATIMESD_mS2} in 
    let __prod_ret__56 = (if S_C == delta_ATIMESD_mSS_C then 1 else 0) *
      -delta_ATIMESD_mS2 in (
      add_delta_to_int_int
        {_r1_:ATIMESD_mR1, _r2_:true, _r3_:vid, _r4_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:S_B, _r3_:__prod_ret__56}|} @ { Collection }};
      (ATIMESD_mR1_send_correctives, me)<- {key:vid, value:{|
                                            _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                            }, _r2_:int, _r3_:int |
                                            {_r1_:vid, _r2_:S_B,
                                             _r3_:__prod_ret__56}|} @ { Collection }}
      ))))

trigger insert_R : {
key:int, value:int
}
= (\_b1_ ->

  bind _b1_ as {key:R_A, value:R_B} in (
  let vid =
    {_r1_:case (__epoch__.peek ()) of {Some _i -> _i.i}{None -> 0}, _r2_:case
     (__vid_counter__.peek ()) of {Some _i -> _i.i}{None -> 0}, _r3_:
     hash me} in
  (
    (insert_R_send_fetch, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B};
    let vid_counter_old = case (__vid_counter__.peek ()) of
      {Some _i -> _i.i}{None -> 0} in
    __vid_counter__.update {i:vid_counter_old} ({i:1 + vid_counter_old})
    )
  ))

trigger insert_R_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
  (route_to_int {key:4, value:Some R_B}).iterate
    ((\_b1_ -> 
      bind _b1_ as {i:ip} in (insert_R_do_complete_s16, ip)<- {_r1_:vid,
                                                               _r2_:R_A,
                                                               _r3_:R_B}));
  ((((empty {
      _r1_:address, _r2_:int, _r3_:int
      } @ { Collection }).combine
      (let sender_count =
         (route_to_int {key:6, value:Some R_B}).fold
           ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
      ((shuffle_ATIMESD_mR1_to_ATIMESD
          {_r1_:(), _r2_:empty {
           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
           } @ { Collection }, _r3_:true}).fold
         ((\__acc_map -> (\_b3_ -> 
           bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
         ({| _r1_:address, _r2_:int, _r3_:int |
         {_r1_:ip, _r2_:14, _r3_:sender_count}|} @ { Collection })))) empty {
         _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
      (let sender_count =
         (route_to_int_int {_r1_:3, _r2_:Some R_B, _r3_:None immut}).fold
           ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
      (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mT1_bind_0t1
         {_r1_:None immut, _r2_:empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
          } @ { Collection }, _r3_:true}).fold
        ((\__acc_map -> (\_b3_ -> 
          bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
        ({| _r1_:address, _r2_:int, _r3_:int |
        {_r1_:ip, _r2_:15, _r3_:sender_count}|} @ { Collection })))) empty {
        _r1_:address, _r2_:int, _r3_:int } @ { Collection }))).groupBy
      ((\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in {key:ip,
                                                             value:stmt_id}))
      ((\acc -> (\_b3_ -> 
        bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupBy
     ((\_b1_ -> 
       bind _b1_ as {key:_b2_, value:count} in 
       bind _b2_ as {key:ip, value:stmt_id} in ip)) ((\acc -> (\_b3_ -> 
       bind _b3_ as {key:ip_and_stmt_id, value:count} in bind ip_and_stmt_id as {
     key:ip, value:stmt_id} in acc.combine
     ({| key:int, value:int | {key:stmt_id, value:count}|} @ { Collection }))))
     empty { key:int, value:int } @ { Collection }).iterate
    ((\_b1_ ->  bind _b1_ as {key:ip, value:stmt_id_cnt_list} in (
      (insert_R_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list, _r3_:vid,
                                _r4_:R_A, _r5_:R_B}
      )));
  ((((route_to_int_int {_r1_:3, _r2_:Some R_B, _r3_:None immut}).fold
       ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
       ({| _r1_:int, _r2_:int, _r3_:address |
       {_r1_:15, _r2_:3, _r3_:ip}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
     (((route_to_int {key:6, value:Some R_B}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({| _r1_:int, _r2_:int, _r3_:address |
         {_r1_:14, _r2_:6, _r3_:ip}|} @ { Collection })))) empty {
         _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
     empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection })).groupBy
     ((\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip))
     ((\acc -> (\_b3_ -> 
       bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
     ({| key:int, value:int | {key:stmt_id, value:map_id}|} @ { Collection }))))
     empty { key:int, value:int } @ { Collection }).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:stmt_map_ids} in (insert_R_rcv_fetch, ip)<- {
                                                     _r1_:stmt_map_ids,
                                                     _r2_:vid, _r3_:R_A,
                                                     _r4_:R_B}))
  ))

trigger insert_R_rcv_put : {
_r1_:address, _r2_:collection { key:int, value:int } @ { Collection }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid, _r4_:R_A,
                _r5_:R_B} in (
  stmt_id_cnt_list.iterate
    ((\_b1_ ->  bind _b1_ as {key:stmt_id, value:count} in case
    ((__stmt_cntrs__.filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid
    and _r2_ == stmt_id))).peek ()) of
    {Some old_val -> bind old_val as {_r3_:old_count} in 
      let new_count = old_count + count in (
        __stmt_cntrs__.update
          {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
          {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
        if new_count == 0
        then
          if stmt_id == 16
          then (insert_R_do_complete_s16, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
          else
            if stmt_id == 15
            then
              (insert_R_do_complete_s15, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
            else
              if stmt_id == 14
              then
                (insert_R_do_complete_s14, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
              else ()
        else ()
        )}{None -> __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count}}))
  ))

trigger insert_R_rcv_fetch : {
_r1_:collection { key:int, value:int } @ { Collection }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
  log_write_insert_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
  stmts_and_map_ids.iterate
    ((\_b1_ -> 
      bind _b1_ as {key:stmt_id, value:map_id} in if stmt_id == 14
                                                  then
                                                    if map_id == 6
                                                    then
                                                      (insert_R_send_push_s14_m_ATIMESD_mR1,
                                                        me)<- {_r1_:vid,
                                                               _r2_:R_A,
                                                               _r3_:R_B}
                                                    else ()
                                                  else
                                                    if stmt_id == 15
                                                    then
                                                      if map_id == 3
                                                      then
                                                        (insert_R_send_push_s15_m_ATIMESD_mT1_mR1,
                                                          me)<- {_r1_:vid,
                                                                 _r2_:R_A,
                                                                 _r3_:R_B}
                                                      else ()
                                                    else ()))
  ))

trigger insert_R_send_push_s14_m_ATIMESD_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
  log_master_write {_r1_:vid, _r2_:4, _r3_:14};
  (shuffle_ATIMESD_mR1_to_ATIMESD
     {_r1_:(),
      _r2_:frontier_int_int
             {key:vid, value:(bind ATIMESD_mR1 as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == R_B))},
      _r3_:true}).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:tuples} in (insert_R_rcv_push_s14_m_ATIMESD_mR1,
                                               ip)<- {_r1_:tuples, _r2_:vid,
                                                      _r3_:R_A, _r4_:R_B}))
  ))

trigger insert_R_send_push_s15_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
  log_master_write {_r1_:vid, _r2_:4, _r3_:15};
  (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mT1_bind_0t1
     {_r1_:None immut,
      _r2_:frontier_int_int_int
             {key:vid, value:(bind ATIMESD_mT1_mR1 as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in _r2_
              == R_B))}, _r3_:true}).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:tuples} in (insert_R_rcv_push_s15_m_ATIMESD_mT1_mR1,
                                               ip)<- {_r1_:tuples, _r2_:vid,
                                                      _r3_:R_A, _r4_:R_B}))
  ))

trigger insert_R_rcv_push_s14_m_ATIMESD_mR1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
  log_write_insert_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
  tuples.iterate
    ((\tuple ->  bind tuple as {_r1_:_tup0, _r2_:_tup1, _r3_:_tup2} in case
    (((bind map_ATIMESD_mR1_s14_buf as ind __x in __x).filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == _tup0
    and _r2_ == _tup1))).peek ()) of
    {Some vals ->
      (bind map_ATIMESD_mR1_s14_buf as ind __x in __x).update vals tuple}
    {None -> (bind map_ATIMESD_mR1_s14_buf as ind __x in __x).insert tuple}));
  if check_and_update_stmt_cntr_index {key:vid, value:14}
  then (insert_R_do_complete_s14, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
  else ()
  ))

trigger insert_R_rcv_push_s15_m_ATIMESD_mT1_mR1 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
  log_write_insert_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
  tuples.iterate
    ((\tuple -> 
      bind tuple as {_r1_:_tup0, _r2_:_tup1, _r3_:_tup2, _r4_:_tup3} in case
    (((bind map_ATIMESD_mT1_mR1_s15_buf as ind __x in __x).filter
    ((\_b1_ -> 
      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in (_r1_ ==
    _tup0 and _r3_ == _tup2) and _r2_ == _tup1))).peek ()) of
    {Some vals ->
      (bind map_ATIMESD_mT1_mR1_s15_buf as ind __x in __x).update vals tuple}
    {None -> (bind map_ATIMESD_mT1_mR1_s15_buf as ind __x in __x).insert tuple}));
  if check_and_update_stmt_cntr_index {key:vid, value:15}
  then (insert_R_do_complete_s15, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
  else ()
  ))

trigger insert_R_do_complete_s14 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in let __prod_ret__13 =
                                                     (let wrapped_lookup_value =
                                                        (frontier_int_int
                                                           {key:vid,
                                                            value:(bind
                                                            map_ATIMESD_mR1_s14_buf
                                                            as ind __x
                                                            in __x).filter
                                                            ((\_b1_ -> 
                                                              bind _b1_ as {
                                                              _r1_:_r1_,
                                                              _r2_:_r2_,
                                                              _r3_:_r3_} in _r2_
                                                            == R_B))}).fold
                                                          ((\__acc_map ->
                                                          (\_b3_ -> 
                                                            bind _b3_ as {
                                                            _r1_:map_vid,
                                                            _r2_:__map_0,
                                                            _r3_:__map_val} in __acc_map.combine
                                                          ({|
                                                          key:int, value:int |
                                                          {key:__map_0,
                                                           value:__map_val}|} @ { Collection }))))
                                                          empty {
                                                          key:int, value:int
                                                          } @ { Collection } in
                                                     case
                                                     (wrapped_lookup_value.peek
                                                     ()) of
                                                     {Some unwrapped_value ->
                                                       bind unwrapped_value as {
                                                       value:projected_field} in 
                                                       projected_field}
                                                     {None -> 0}) * R_A in (
    add_delta_to_int
      {_r1_:ATIMESD, _r2_:false, _r3_:vid, _r4_:{|
       key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
       {key:vid, value:__prod_ret__13}|} @ { Collection }}
    ))

trigger insert_R_do_complete_s15 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in let __delta_values__ =
                                                     (((frontier_int_int_int
                                                          {key:vid, value:(bind
                                                           map_ATIMESD_mT1_mR1_s15_buf
                                                           as ind __x
                                                           in __x).filter
                                                           ((\_b1_ -> 
                                                             bind _b1_ as {
                                                             _r1_:_r1_,
                                                             _r2_:_r2_,
                                                             _r3_:_r3_,
                                                             _r4_:_r4_} in _r2_
                                                           == R_B))}).fold
                                                         ((\__acc_map ->
                                                         (\_b3_ -> 
                                                           bind _b3_ as {
                                                           _r1_:map_vid,
                                                           _r2_:__map_0,
                                                           _r3_:__map_1,
                                                           _r4_:__map_val} in __acc_map.combine
                                                         ({|
                                                         _r1_:int, _r2_:int,
                                                         _r3_:int |
                                                         {_r1_:__map_0,
                                                          _r2_:__map_1,
                                                          _r3_:__map_val}|} @ { Collection }))))
                                                         empty {
                                                         _r1_:int, _r2_:int,
                                                         _r3_:int
                                                         } @ { Collection }).fold
                                                        ((\__acc_map ->
                                                        (\_b3_ -> 
                                                          bind _b3_ as {
                                                          _r1_:R_B,
                                                          _r2_:ATIMESD_mTT_C,
                                                          _r3_:__map_ret__14} in 
                                                          __acc_map.combine
                                                        ({| key:int, value:int
                                                        |
                                                        {key:ATIMESD_mTT_C,
                                                         value:__map_ret__14}|} @ { Collection }))))
                                                        empty {
                                                        key:int, value:int
                                                        } @ { Collection }).fold
                                                       ((\__acc_map ->
                                                       (\_b3_ -> 
                                                         bind _b3_ as {
                                                         key:ATIMESD_mTT_C,
                                                         value:__map_ret__14} in 
                                                         __acc_map.combine
                                                       ({| key:int, value:int |
                                                       {key:ATIMESD_mTT_C,
                                                        value:__map_ret__14 *
                                                        R_A}|} @ { Collection }))))
                                                       empty {
                                                       key:int, value:int
                                                       } @ { Collection } in
  let __delta_with_vid__ =
    __delta_values__.fold
      ((\__acc_map -> (\_b3_ -> 
        bind _b3_ as {key:ATIMESD_mTT_C, value:__prod_ret__14} in __acc_map.combine
      ({| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
      {_r1_:vid, _r2_:ATIMESD_mTT_C, _r3_:__prod_ret__14}|} @ { Collection }))))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Collection } in (
    add_delta_to_int_int
      {_r1_:ATIMESD_mT1, _r2_:false, _r3_:vid, _r4_:__delta_with_vid__};
    (ATIMESD_mT1_send_correctives, me)<- {key:vid, value:__delta_with_vid__}
    ))

trigger insert_R_do_complete_s16 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in let __val_ret__17 = R_A in (
    add_delta_to_int_int
      {_r1_:ATIMESD_mS1, _r2_:false, _r3_:vid, _r4_:{|
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
       {_r1_:vid, _r2_:R_B, _r3_:__val_ret__17}|} @ { Collection }};
    (ATIMESD_mS1_send_correctives, me)<- {key:vid, value:{|
                                          _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                          }, _r2_:int, _r3_:int |
                                          {_r1_:vid, _r2_:R_B,
                                           _r3_:__val_ret__17}|} @ { Collection }}
    ))

trigger insert_R_rcv_corrective_s14_m_ATIMESD_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
  add_delta_to_int_int
    {_r1_:map_ATIMESD_mR1_s14_buf, _r2_:false, _r3_:vid, _r4_:delta_tuples};
  compute_vids.iterate
    ((\compute_vid -> 
      if ((__stmt_cntrs__.filter
        ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
        compute_vid and _r2_ == 14))).peek ()) ==
        Some {_r1_:compute_vid, _r2_:14, _r3_:0}
      then
        bind log_get_bound_insert_R compute_vid as {_r1_:vid, _r2_:R_A,
                                                    _r3_:R_B} in 
        (insert_R_do_corrective_s14_m_ATIMESD_mR1, me)<- {_r1_:compute_vid,
                                                          _r2_:R_A, _r3_:R_B,
                                                          _r4_:delta_tuples}
      else ()))
  ))

trigger insert_R_rcv_corrective_s15_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
} @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
  add_delta_to_int_int_int
    {_r1_:map_ATIMESD_mT1_mR1_s15_buf, _r2_:false, _r3_:vid, _r4_:delta_tuples};
  compute_vids.iterate
    ((\compute_vid -> 
      if ((__stmt_cntrs__.filter
        ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
        compute_vid and _r2_ == 15))).peek ()) ==
        Some {_r1_:compute_vid, _r2_:15, _r3_:0}
      then
        bind log_get_bound_insert_R compute_vid as {_r1_:vid, _r2_:R_A,
                                                    _r3_:R_B} in 
        (insert_R_do_corrective_s15_m_ATIMESD_mT1_mR1, me)<- {_r1_:compute_vid,
                                                              _r2_:R_A,
                                                              _r3_:R_B,
                                                              _r4_:delta_tuples}
      else ()))
  ))

trigger insert_R_do_corrective_s14_m_ATIMESD_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples} in 
  delta_tuples.iterate
    ((\_b1_ -> 
      bind _b1_ as {_r2_:delta_ATIMESD_mRR_B, _r3_:delta_ATIMESD_mR1} in 
    let __prod_ret__21 = ((if R_B == delta_ATIMESD_mRR_B then 1 else 0) *
      delta_ATIMESD_mR1) * R_A in (
      add_delta_to_int
        {_r1_:ATIMESD, _r2_:true, _r3_:vid, _r4_:{|
         key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
         {key:vid, value:__prod_ret__21}|} @ { Collection }}
      ))))

trigger insert_R_do_corrective_s15_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
} @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples} in 
  delta_tuples.iterate
    ((\_b1_ -> 
      bind _b1_ as {_r2_:delta_ATIMESD_mT1_mRR_B, _r3_:delta_ATIMESD_mTT_C,
                    _r4_:delta_ATIMESD_mT1_mR1} in let __prod_ret__23 =
                                                     ((if R_B ==
                                                         delta_ATIMESD_mT1_mRR_B
                                                       then 1
                                                       else 0) *
                                                     delta_ATIMESD_mT1_mR1) *
                                                     R_A in (
      add_delta_to_int_int
        {_r1_:ATIMESD_mT1, _r2_:true, _r3_:vid, _r4_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:delta_ATIMESD_mTT_C, _r3_:__prod_ret__23}|} @ { Collection }};
      (ATIMESD_mT1_send_correctives, me)<- {key:vid, value:{|
                                            _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                            }, _r2_:int, _r3_:int |
                                            {_r1_:vid,
                                             _r2_:delta_ATIMESD_mTT_C,
                                             _r3_:__prod_ret__23}|} @ { Collection }}
      ))))

trigger delete_R : {
key:int, value:int
}
= (\_b1_ ->

  bind _b1_ as {key:R_A, value:R_B} in (
  let vid =
    {_r1_:case (__epoch__.peek ()) of {Some _i -> _i.i}{None -> 0}, _r2_:case
     (__vid_counter__.peek ()) of {Some _i -> _i.i}{None -> 0}, _r3_:
     hash me} in
  (
    (delete_R_send_fetch, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B};
    let vid_counter_old = case (__vid_counter__.peek ()) of
      {Some _i -> _i.i}{None -> 0} in
    __vid_counter__.update {i:vid_counter_old} ({i:1 + vid_counter_old})
    )
  ))

trigger delete_R_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
  (route_to_int {key:4, value:Some R_B}).iterate
    ((\_b1_ -> 
      bind _b1_ as {i:ip} in (delete_R_do_complete_s19, ip)<- {_r1_:vid,
                                                               _r2_:R_A,
                                                               _r3_:R_B}));
  ((((empty {
      _r1_:address, _r2_:int, _r3_:int
      } @ { Collection }).combine
      (let sender_count =
         (route_to_int {key:6, value:Some R_B}).fold
           ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
      ((shuffle_ATIMESD_mR1_to_ATIMESD
          {_r1_:(), _r2_:empty {
           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
           } @ { Collection }, _r3_:true}).fold
         ((\__acc_map -> (\_b3_ -> 
           bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
         ({| _r1_:address, _r2_:int, _r3_:int |
         {_r1_:ip, _r2_:17, _r3_:sender_count}|} @ { Collection })))) empty {
         _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
      (let sender_count =
         (route_to_int_int {_r1_:3, _r2_:Some R_B, _r3_:None immut}).fold
           ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
      (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mT1_bind_0t1
         {_r1_:None immut, _r2_:empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
          } @ { Collection }, _r3_:true}).fold
        ((\__acc_map -> (\_b3_ -> 
          bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
        ({| _r1_:address, _r2_:int, _r3_:int |
        {_r1_:ip, _r2_:18, _r3_:sender_count}|} @ { Collection })))) empty {
        _r1_:address, _r2_:int, _r3_:int } @ { Collection }))).groupBy
      ((\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in {key:ip,
                                                             value:stmt_id}))
      ((\acc -> (\_b3_ -> 
        bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupBy
     ((\_b1_ -> 
       bind _b1_ as {key:_b2_, value:count} in 
       bind _b2_ as {key:ip, value:stmt_id} in ip)) ((\acc -> (\_b3_ -> 
       bind _b3_ as {key:ip_and_stmt_id, value:count} in bind ip_and_stmt_id as {
     key:ip, value:stmt_id} in acc.combine
     ({| key:int, value:int | {key:stmt_id, value:count}|} @ { Collection }))))
     empty { key:int, value:int } @ { Collection }).iterate
    ((\_b1_ ->  bind _b1_ as {key:ip, value:stmt_id_cnt_list} in (
      (delete_R_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list, _r3_:vid,
                                _r4_:R_A, _r5_:R_B}
      )));
  ((((route_to_int_int {_r1_:3, _r2_:Some R_B, _r3_:None immut}).fold
       ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
       ({| _r1_:int, _r2_:int, _r3_:address |
       {_r1_:18, _r2_:3, _r3_:ip}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
     (((route_to_int {key:6, value:Some R_B}).fold
         ((\__acc_map -> (\_b3_ ->  bind _b3_ as {i:ip} in __acc_map.combine
         ({| _r1_:int, _r2_:int, _r3_:address |
         {_r1_:17, _r2_:6, _r3_:ip}|} @ { Collection })))) empty {
         _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
     empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection })).groupBy
     ((\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip))
     ((\acc -> (\_b3_ -> 
       bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
     ({| key:int, value:int | {key:stmt_id, value:map_id}|} @ { Collection }))))
     empty { key:int, value:int } @ { Collection }).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:stmt_map_ids} in (delete_R_rcv_fetch, ip)<- {
                                                     _r1_:stmt_map_ids,
                                                     _r2_:vid, _r3_:R_A,
                                                     _r4_:R_B}))
  ))

trigger delete_R_rcv_put : {
_r1_:address, _r2_:collection { key:int, value:int } @ { Collection }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid, _r4_:R_A,
                _r5_:R_B} in (
  stmt_id_cnt_list.iterate
    ((\_b1_ ->  bind _b1_ as {key:stmt_id, value:count} in case
    ((__stmt_cntrs__.filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid
    and _r2_ == stmt_id))).peek ()) of
    {Some old_val -> bind old_val as {_r3_:old_count} in 
      let new_count = old_count + count in (
        __stmt_cntrs__.update
          {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
          {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
        if new_count == 0
        then
          if stmt_id == 19
          then (delete_R_do_complete_s19, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
          else
            if stmt_id == 18
            then
              (delete_R_do_complete_s18, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
            else
              if stmt_id == 17
              then
                (delete_R_do_complete_s17, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
              else ()
        else ()
        )}{None -> __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count}}))
  ))

trigger delete_R_rcv_fetch : {
_r1_:collection { key:int, value:int } @ { Collection }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
  log_write_delete_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
  stmts_and_map_ids.iterate
    ((\_b1_ -> 
      bind _b1_ as {key:stmt_id, value:map_id} in if stmt_id == 17
                                                  then
                                                    if map_id == 6
                                                    then
                                                      (delete_R_send_push_s17_m_ATIMESD_mR1,
                                                        me)<- {_r1_:vid,
                                                               _r2_:R_A,
                                                               _r3_:R_B}
                                                    else ()
                                                  else
                                                    if stmt_id == 18
                                                    then
                                                      if map_id == 3
                                                      then
                                                        (delete_R_send_push_s18_m_ATIMESD_mT1_mR1,
                                                          me)<- {_r1_:vid,
                                                                 _r2_:R_A,
                                                                 _r3_:R_B}
                                                      else ()
                                                    else ()))
  ))

trigger delete_R_send_push_s17_m_ATIMESD_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
  log_master_write {_r1_:vid, _r2_:5, _r3_:17};
  (shuffle_ATIMESD_mR1_to_ATIMESD
     {_r1_:(),
      _r2_:frontier_int_int
             {key:vid, value:(bind ATIMESD_mR1 as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == R_B))},
      _r3_:true}).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:tuples} in (delete_R_rcv_push_s17_m_ATIMESD_mR1,
                                               ip)<- {_r1_:tuples, _r2_:vid,
                                                      _r3_:R_A, _r4_:R_B}))
  ))

trigger delete_R_send_push_s18_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
  log_master_write {_r1_:vid, _r2_:5, _r3_:18};
  (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mT1_bind_0t1
     {_r1_:None immut,
      _r2_:frontier_int_int_int
             {key:vid, value:(bind ATIMESD_mT1_mR1 as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in _r2_
              == R_B))}, _r3_:true}).iterate
    ((\_b1_ -> 
      bind _b1_ as {key:ip, value:tuples} in (delete_R_rcv_push_s18_m_ATIMESD_mT1_mR1,
                                               ip)<- {_r1_:tuples, _r2_:vid,
                                                      _r3_:R_A, _r4_:R_B}))
  ))

trigger delete_R_rcv_push_s17_m_ATIMESD_mR1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
  log_write_delete_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
  tuples.iterate
    ((\tuple ->  bind tuple as {_r1_:_tup0, _r2_:_tup1, _r3_:_tup2} in case
    (((bind map_ATIMESD_mR1_s17_buf as ind __x in __x).filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == _tup0
    and _r2_ == _tup1))).peek ()) of
    {Some vals ->
      (bind map_ATIMESD_mR1_s17_buf as ind __x in __x).update vals tuple}
    {None -> (bind map_ATIMESD_mR1_s17_buf as ind __x in __x).insert tuple}));
  if check_and_update_stmt_cntr_index {key:vid, value:17}
  then (delete_R_do_complete_s17, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
  else ()
  ))

trigger delete_R_rcv_push_s18_m_ATIMESD_mT1_mR1 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
  log_write_delete_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
  tuples.iterate
    ((\tuple -> 
      bind tuple as {_r1_:_tup0, _r2_:_tup1, _r3_:_tup2, _r4_:_tup3} in case
    (((bind map_ATIMESD_mT1_mR1_s18_buf as ind __x in __x).filter
    ((\_b1_ -> 
      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in (_r1_ ==
    _tup0 and _r3_ == _tup2) and _r2_ == _tup1))).peek ()) of
    {Some vals ->
      (bind map_ATIMESD_mT1_mR1_s18_buf as ind __x in __x).update vals tuple}
    {None -> (bind map_ATIMESD_mT1_mR1_s18_buf as ind __x in __x).insert tuple}));
  if check_and_update_stmt_cntr_index {key:vid, value:18}
  then (delete_R_do_complete_s18, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
  else ()
  ))

trigger delete_R_do_complete_s17 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in let __prod_ret__16 =
                                                     (let wrapped_lookup_value =
                                                        (frontier_int_int
                                                           {key:vid,
                                                            value:(bind
                                                            map_ATIMESD_mR1_s17_buf
                                                            as ind __x
                                                            in __x).filter
                                                            ((\_b1_ -> 
                                                              bind _b1_ as {
                                                              _r1_:_r1_,
                                                              _r2_:_r2_,
                                                              _r3_:_r3_} in _r2_
                                                            == R_B))}).fold
                                                          ((\__acc_map ->
                                                          (\_b3_ -> 
                                                            bind _b3_ as {
                                                            _r1_:map_vid,
                                                            _r2_:__map_0,
                                                            _r3_:__map_val} in __acc_map.combine
                                                          ({|
                                                          key:int, value:int |
                                                          {key:__map_0,
                                                           value:__map_val}|} @ { Collection }))))
                                                          empty {
                                                          key:int, value:int
                                                          } @ { Collection } in
                                                     case
                                                     (wrapped_lookup_value.peek
                                                     ()) of
                                                     {Some unwrapped_value ->
                                                       bind unwrapped_value as {
                                                       value:projected_field} in 
                                                       projected_field}
                                                     {None -> 0}) * -R_A in (
    add_delta_to_int
      {_r1_:ATIMESD, _r2_:false, _r3_:vid, _r4_:{|
       key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
       {key:vid, value:__prod_ret__16}|} @ { Collection }}
    ))

trigger delete_R_do_complete_s18 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in let __delta_values__ =
                                                     (((frontier_int_int_int
                                                          {key:vid, value:(bind
                                                           map_ATIMESD_mT1_mR1_s18_buf
                                                           as ind __x
                                                           in __x).filter
                                                           ((\_b1_ -> 
                                                             bind _b1_ as {
                                                             _r1_:_r1_,
                                                             _r2_:_r2_,
                                                             _r3_:_r3_,
                                                             _r4_:_r4_} in _r2_
                                                           == R_B))}).fold
                                                         ((\__acc_map ->
                                                         (\_b3_ -> 
                                                           bind _b3_ as {
                                                           _r1_:map_vid,
                                                           _r2_:__map_0,
                                                           _r3_:__map_1,
                                                           _r4_:__map_val} in __acc_map.combine
                                                         ({|
                                                         _r1_:int, _r2_:int,
                                                         _r3_:int |
                                                         {_r1_:__map_0,
                                                          _r2_:__map_1,
                                                          _r3_:__map_val}|} @ { Collection }))))
                                                         empty {
                                                         _r1_:int, _r2_:int,
                                                         _r3_:int
                                                         } @ { Collection }).fold
                                                        ((\__acc_map ->
                                                        (\_b3_ -> 
                                                          bind _b3_ as {
                                                          _r1_:R_B,
                                                          _r2_:ATIMESD_mTT_C,
                                                          _r3_:__map_ret__16} in 
                                                          __acc_map.combine
                                                        ({| key:int, value:int
                                                        |
                                                        {key:ATIMESD_mTT_C,
                                                         value:__map_ret__16}|} @ { Collection }))))
                                                        empty {
                                                        key:int, value:int
                                                        } @ { Collection }).fold
                                                       ((\__acc_map ->
                                                       (\_b3_ -> 
                                                         bind _b3_ as {
                                                         key:ATIMESD_mTT_C,
                                                         value:__map_ret__16} in 
                                                         __acc_map.combine
                                                       ({| key:int, value:int |
                                                       {key:ATIMESD_mTT_C,
                                                        value:__map_ret__16 *
                                                        -R_A}|} @ { Collection }))))
                                                       empty {
                                                       key:int, value:int
                                                       } @ { Collection } in
  let __delta_with_vid__ =
    __delta_values__.fold
      ((\__acc_map -> (\_b3_ -> 
        bind _b3_ as {key:ATIMESD_mTT_C, value:__prod_ret__18} in __acc_map.combine
      ({| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
      {_r1_:vid, _r2_:ATIMESD_mTT_C, _r3_:__prod_ret__18}|} @ { Collection }))))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Collection } in (
    add_delta_to_int_int
      {_r1_:ATIMESD_mT1, _r2_:false, _r3_:vid, _r4_:__delta_with_vid__};
    (ATIMESD_mT1_send_correctives, me)<- {key:vid, value:__delta_with_vid__}
    ))

trigger delete_R_do_complete_s19 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in let __prod_ret__19 = -R_A in
  (
    add_delta_to_int_int
      {_r1_:ATIMESD_mS1, _r2_:false, _r3_:vid, _r4_:{|
       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
       {_r1_:vid, _r2_:R_B, _r3_:__prod_ret__19}|} @ { Collection }};
    (ATIMESD_mS1_send_correctives, me)<- {key:vid, value:{|
                                          _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                          }, _r2_:int, _r3_:int |
                                          {_r1_:vid, _r2_:R_B,
                                           _r3_:__prod_ret__19}|} @ { Collection }}
    ))

trigger delete_R_rcv_corrective_s17_m_ATIMESD_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
  add_delta_to_int_int
    {_r1_:map_ATIMESD_mR1_s17_buf, _r2_:false, _r3_:vid, _r4_:delta_tuples};
  compute_vids.iterate
    ((\compute_vid -> 
      if ((__stmt_cntrs__.filter
        ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
        compute_vid and _r2_ == 17))).peek ()) ==
        Some {_r1_:compute_vid, _r2_:17, _r3_:0}
      then
        bind log_get_bound_delete_R compute_vid as {_r1_:vid, _r2_:R_A,
                                                    _r3_:R_B} in 
        (delete_R_do_corrective_s17_m_ATIMESD_mR1, me)<- {_r1_:compute_vid,
                                                          _r2_:R_A, _r3_:R_B,
                                                          _r4_:delta_tuples}
      else ()))
  ))

trigger delete_R_rcv_corrective_s18_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
} @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
  add_delta_to_int_int_int
    {_r1_:map_ATIMESD_mT1_mR1_s18_buf, _r2_:false, _r3_:vid, _r4_:delta_tuples};
  compute_vids.iterate
    ((\compute_vid -> 
      if ((__stmt_cntrs__.filter
        ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
        compute_vid and _r2_ == 18))).peek ()) ==
        Some {_r1_:compute_vid, _r2_:18, _r3_:0}
      then
        bind log_get_bound_delete_R compute_vid as {_r1_:vid, _r2_:R_A,
                                                    _r3_:R_B} in 
        (delete_R_do_corrective_s18_m_ATIMESD_mT1_mR1, me)<- {_r1_:compute_vid,
                                                              _r2_:R_A,
                                                              _r3_:R_B,
                                                              _r4_:delta_tuples}
      else ()))
  ))

trigger delete_R_do_corrective_s17_m_ATIMESD_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples} in 
  delta_tuples.iterate
    ((\_b1_ -> 
      bind _b1_ as {_r2_:delta_ATIMESD_mRR_B, _r3_:delta_ATIMESD_mR1} in 
    let __prod_ret__26 = (if R_B == delta_ATIMESD_mRR_B then 1 else 0) *
      (-delta_ATIMESD_mR1 * R_A) in (
      add_delta_to_int
        {_r1_:ATIMESD, _r2_:true, _r3_:vid, _r4_:{|
         key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
         {key:vid, value:__prod_ret__26}|} @ { Collection }}
      ))))

trigger delete_R_do_corrective_s18_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
} @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples} in 
  delta_tuples.iterate
    ((\_b1_ -> 
      bind _b1_ as {_r2_:delta_ATIMESD_mT1_mRR_B, _r3_:delta_ATIMESD_mTT_C,
                    _r4_:delta_ATIMESD_mT1_mR1} in let __prod_ret__29 =
                                                     (if R_B ==
                                                        delta_ATIMESD_mT1_mRR_B
                                                      then 1
                                                      else 0) *
                                                     (-delta_ATIMESD_mT1_mR1 *
                                                     R_A) in (
      add_delta_to_int_int
        {_r1_:ATIMESD_mT1, _r2_:true, _r3_:vid, _r4_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:delta_ATIMESD_mTT_C, _r3_:__prod_ret__29}|} @ { Collection }};
      (ATIMESD_mT1_send_correctives, me)<- {key:vid, value:{|
                                            _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                            }, _r2_:int, _r3_:int |
                                            {_r1_:vid,
                                             _r2_:delta_ATIMESD_mTT_C,
                                             _r3_:__prod_ret__29}|} @ { Collection }}
      ))))

trigger ATIMESD_mS1_send_correctives : {
key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {key:corrective_vid, value:delta_tuples} in let corrective_list =
                                                               filter_corrective_list
                                                                 {key:corrective_vid,
                                                                  value:{|
                                                                  key:int,
                                                                  value:int |
                                                                  {key:3,
                                                                   value:11},
                                                                  {key:3,
                                                                   value:10},
                                                                  {key:2,
                                                                   value:7},
                                                                  {key:2,
                                                                   value:6}|} @ { Collection }}
                                                               in
  corrective_list.iterate
    ((\_b1_ -> 
      bind _b1_ as {key:stmt_id, value:vid_list} in if stmt_id == 11
                                                    then
                                                      ((vid_list.fold
                                                          ((\__acc_ext ->
                                                          (\vid -> 
                                                            __acc_ext.combine
                                                          (bind log_get_bound_delete_S
                                                                  vid as {
                                                          _r1_:vid, _r2_:S_B,
                                                          _r3_:S_C} in 
                                                          (shuffle_ATIMESD_mS1_to_ATIMESD_mT1
                                                             {_r1_:Some S_C,
                                                              _r2_:delta_tuples,
                                                              _r3_:false}).fold
                                                            ((\__acc_map ->
                                                            (\_b3_ -> 
                                                              bind _b3_ as {
                                                              key:ip,
                                                              value:tuples} in __acc_map.combine
                                                            ({|
                                                            _r1_:address,
                                                            _r2_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r3_:collection {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int
                                                            } @ { Collection }
                                                            |
                                                            {_r1_:ip, _r2_:vid,
                                                             _r3_:tuples}|} @ { Collection }))))
                                                            empty {
                                                            _r1_:address,
                                                            _r2_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r3_:collection {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int
                                                            } @ { Collection }
                                                            } @ { Collection }))))
                                                          empty {
                                                          _r1_:address, _r2_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int },
                                                          _r3_:collection {
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int
                                                          } @ { Collection }
                                                          } @ { Collection }).groupBy
                                                         ((\_b1_ -> 
                                                           bind _b1_ as {
                                                           _r1_:ip, _r2_:vid,
                                                           _r3_:tuples} in ip))
                                                         ((\_b2_ -> (\_b5_ -> 
                                                           bind _b2_ as {
                                                           key:acc_vid,
                                                           value:acc_tuples} in 
                                                           bind _b5_ as {
                                                           _r1_:ip, _r2_:vid,
                                                           _r3_:tuples} in {
                                                         key:acc_vid.combine
                                                         ({|
                                                         _r1_:int, _r2_:int,
                                                         _r3_:int |
                                                         vid|} @ { Seq }),
                                                         value:((acc_tuples.combine
                                                                  tuples).groupBy
                                                                  ((\tuple -> 
                                                                    tuple))
                                                                  ((\_ ->
                                                                  (\_ ->  
                                                                  ()))) ()).fold
                                                                 ((\__acc_map ->
                                                                 (\_b3_ -> 
                                                                   bind _b3_ as {
                                                                   key:__1,
                                                                   value:__2} in 
                                                                   __acc_map.combine
                                                                 ({|
                                                                 _r1_:{
                                                                 _r1_:int,
                                                                 _r2_:int,
                                                                 _r3_:int },
                                                                 _r2_:int,
                                                                 _r3_:int |
                                                                 __1|} @ { Collection }))))
                                                                 empty {
                                                                 _r1_:{
                                                                 _r1_:int,
                                                                 _r2_:int,
                                                                 _r3_:int },
                                                                 _r2_:int,
                                                                 _r3_:int
                                                                 } @ { Collection }})))
                                                         {key:empty {
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int } @ { Seq },
                                                          value:empty {
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int
                                                          } @ { Collection }}).iterate
                                                        ((\_b1_ -> 
                                                          bind _b1_ as {
                                                          key:ip, value:_b3_} in 
                                                          bind _b3_ as {
                                                          key:vid_send_list,
                                                          value:tuple} in 
                                                        (delete_S_rcv_corrective_s11_m_ATIMESD_mS1,
                                                          ip)<- {_r1_:corrective_vid,
                                                                 _r2_:vid_send_list,
                                                                 _r3_:tuple}))
                                                    else
                                                      if stmt_id == 10
                                                      then
                                                        ((vid_list.fold
                                                            ((\__acc_ext ->
                                                            (\vid -> 
                                                              __acc_ext.combine
                                                            (bind log_get_bound_delete_S
                                                                    vid as {
                                                            _r1_:vid, _r2_:S_B,
                                                            _r3_:S_C} in 
                                                            (shuffle_ATIMESD_mS1_to_ATIMESD
                                                               {_r1_:(),
                                                                _r2_:delta_tuples,
                                                                _r3_:false}).fold
                                                              ((\__acc_map ->
                                                              (\_b3_ -> 
                                                                bind _b3_ as {
                                                                key:ip,
                                                                value:tuples} in 
                                                                __acc_map.combine
                                                              ({|
                                                              _r1_:address,
                                                              _r2_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r3_:collection {
                                                              _r1_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r2_:int,
                                                              _r3_:int
                                                              } @ { Collection }
                                                              |
                                                              {_r1_:ip,
                                                               _r2_:vid,
                                                               _r3_:tuples}|} @ { Collection }))))
                                                              empty {
                                                              _r1_:address,
                                                              _r2_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r3_:collection {
                                                              _r1_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r2_:int,
                                                              _r3_:int
                                                              } @ { Collection }
                                                              } @ { Collection }))))
                                                            empty {
                                                            _r1_:address,
                                                            _r2_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r3_:collection {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int
                                                            } @ { Collection }
                                                            } @ { Collection }).groupBy
                                                           ((\_b1_ -> 
                                                             bind _b1_ as {
                                                             _r1_:ip, _r2_:vid,
                                                             _r3_:tuples} in ip))
                                                           ((\_b2_ -> (\_b5_ ->
                                                           
                                                             bind _b2_ as {
                                                             key:acc_vid,
                                                             value:acc_tuples} in 
                                                             bind _b5_ as {
                                                             _r1_:ip, _r2_:vid,
                                                             _r3_:tuples} in {
                                                           key:acc_vid.combine
                                                           ({|
                                                           _r1_:int, _r2_:int,
                                                           _r3_:int |
                                                           vid|} @ { Seq }),
                                                           value:((acc_tuples.combine
                                                                    tuples).groupBy
                                                                    ((\tuple ->
                                                                     
                                                                    tuple))
                                                                    ((\_ ->
                                                                    (\_ -> 
                                                                    ()))) ()).fold
                                                                   ((\__acc_map ->
                                                                   (\_b3_ -> 
                                                                    bind _b3_ as {
                                                                    key:__1,
                                                                    value:__2} in 
                                                                    __acc_map.combine
                                                                   ({|
                                                                   _r1_:{
                                                                   _r1_:int,
                                                                   _r2_:int,
                                                                   _r3_:int },
                                                                   _r2_:int,
                                                                   _r3_:int |
                                                                   __1|} @ { Collection }))))
                                                                   empty {
                                                                   _r1_:{
                                                                   _r1_:int,
                                                                   _r2_:int,
                                                                   _r3_:int },
                                                                   _r2_:int,
                                                                   _r3_:int
                                                                   } @ { Collection }})))
                                                           {key:empty {
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int
                                                            } @ { Seq },
                                                            value:empty {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int
                                                            } @ { Collection }}).iterate
                                                          ((\_b1_ -> 
                                                            bind _b1_ as {
                                                            key:ip, value:_b3_} in 
                                                            bind _b3_ as {
                                                            key:vid_send_list,
                                                            value:tuple} in 
                                                          (delete_S_rcv_corrective_s10_m_ATIMESD_mS1,
                                                            ip)<- {_r1_:corrective_vid,
                                                                   _r2_:vid_send_list,
                                                                   _r3_:tuple}))
                                                      else
                                                        if stmt_id == 7
                                                        then
                                                          ((vid_list.fold
                                                              ((\__acc_ext ->
                                                              (\vid -> 
                                                                __acc_ext.combine
                                                              (bind log_get_bound_insert_S
                                                                    vid as {
                                                              _r1_:vid,
                                                              _r2_:S_B,
                                                              _r3_:S_C} in 
                                                              (shuffle_ATIMESD_mS1_to_ATIMESD_mT1
                                                                 {_r1_:Some S_C,
                                                                  _r2_:delta_tuples,
                                                                  _r3_:false}).fold
                                                                ((\__acc_map ->
                                                                (\_b3_ -> 
                                                                  bind _b3_ as {
                                                                  key:ip,
                                                                  value:tuples} in 
                                                                  __acc_map.combine
                                                                ({|
                                                                _r1_:address,
                                                                _r2_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r3_:collection {
                                                                _r1_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r2_:int,
                                                                _r3_:int
                                                                } @ { Collection }
                                                                |
                                                                {_r1_:ip,
                                                                 _r2_:vid,
                                                                 _r3_:tuples}|} @ { Collection }))))
                                                                empty {
                                                                _r1_:address,
                                                                _r2_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r3_:collection {
                                                                _r1_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r2_:int,
                                                                _r3_:int
                                                                } @ { Collection }
                                                                } @ { Collection }))))
                                                              empty {
                                                              _r1_:address,
                                                              _r2_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r3_:collection {
                                                              _r1_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r2_:int,
                                                              _r3_:int
                                                              } @ { Collection }
                                                              } @ { Collection }).groupBy
                                                             ((\_b1_ -> 
                                                               bind _b1_ as {
                                                               _r1_:ip,
                                                               _r2_:vid,
                                                               _r3_:tuples} in ip))
                                                             ((\_b2_ ->
                                                             (\_b5_ -> 
                                                               bind _b2_ as {
                                                               key:acc_vid,
                                                               value:acc_tuples} in 
                                                               bind _b5_ as {
                                                               _r1_:ip,
                                                               _r2_:vid,
                                                               _r3_:tuples} in {
                                                             key:acc_vid.combine
                                                             ({|
                                                             _r1_:int,
                                                             _r2_:int, _r3_:int
                                                             | vid|} @ { Seq }),
                                                             value:((acc_tuples.combine
                                                                    tuples).groupBy
                                                                    ((\tuple ->
                                                                     
                                                                    tuple))
                                                                    ((\_ ->
                                                                    (\_ -> 
                                                                    ()))) ()).fold
                                                                    ((\__acc_map ->
                                                                    (\_b3_ -> 
                                                                    bind _b3_ as {
                                                                    key:__1,
                                                                    value:__2} in 
                                                                    __acc_map.combine
                                                                    ({|
                                                                    _r1_:{
                                                                    _r1_:int,
                                                                    _r2_:int,
                                                                    _r3_:int },
                                                                    _r2_:int,
                                                                    _r3_:int |
                                                                    __1|} @ { Collection }))))
                                                                    empty {
                                                                    _r1_:{
                                                                    _r1_:int,
                                                                    _r2_:int,
                                                                    _r3_:int },
                                                                    _r2_:int,
                                                                    _r3_:int
                                                                    } @ { Collection }})))
                                                             {key:empty {
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int
                                                              } @ { Seq },
                                                              value:empty {
                                                              _r1_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r2_:int,
                                                              _r3_:int
                                                              } @ { Collection }}).iterate
                                                            ((\_b1_ -> 
                                                              bind _b1_ as {
                                                              key:ip,
                                                              value:_b3_} in 
                                                              bind _b3_ as {
                                                              key:vid_send_list,
                                                              value:tuple} in 
                                                            (insert_S_rcv_corrective_s7_m_ATIMESD_mS1,
                                                              ip)<- {
                                                              _r1_:corrective_vid,
                                                              _r2_:vid_send_list,
                                                              _r3_:tuple}))
                                                        else
                                                          if stmt_id == 6
                                                          then
                                                            ((vid_list.fold
                                                                ((\__acc_ext ->
                                                                (\vid -> 
                                                                  __acc_ext.combine
                                                                (bind 
                                                                log_get_bound_insert_S
                                                                  vid as {
                                                                _r1_:vid,
                                                                _r2_:S_B,
                                                                _r3_:S_C} in 
                                                                (shuffle_ATIMESD_mS1_to_ATIMESD
                                                                   {_r1_:(),
                                                                    _r2_:delta_tuples,
                                                                    _r3_:false}).fold
                                                                  ((\__acc_map ->
                                                                  (\_b3_ -> 
                                                                    bind _b3_ as {
                                                                    key:ip,
                                                                    value:tuples} in 
                                                                    __acc_map.combine
                                                                  ({|
                                                                  _r1_:address,
                                                                  _r2_:{
                                                                  _r1_:int,
                                                                  _r2_:int,
                                                                  _r3_:int },
                                                                  _r3_:collection {
                                                                  _r1_:{
                                                                  _r1_:int,
                                                                  _r2_:int,
                                                                  _r3_:int },
                                                                  _r2_:int,
                                                                  _r3_:int
                                                                  } @ { Collection }
                                                                  |
                                                                  {_r1_:ip,
                                                                   _r2_:vid,
                                                                   _r3_:tuples}|} @ { Collection }))))
                                                                  empty {
                                                                  _r1_:address,
                                                                  _r2_:{
                                                                  _r1_:int,
                                                                  _r2_:int,
                                                                  _r3_:int },
                                                                  _r3_:collection {
                                                                  _r1_:{
                                                                  _r1_:int,
                                                                  _r2_:int,
                                                                  _r3_:int },
                                                                  _r2_:int,
                                                                  _r3_:int
                                                                  } @ { Collection }
                                                                  } @ { Collection }))))
                                                                empty {
                                                                _r1_:address,
                                                                _r2_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r3_:collection {
                                                                _r1_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r2_:int,
                                                                _r3_:int
                                                                } @ { Collection }
                                                                } @ { Collection }).groupBy
                                                               ((\_b1_ -> 
                                                                 bind _b1_ as {
                                                                 _r1_:ip,
                                                                 _r2_:vid,
                                                                 _r3_:tuples} in 
                                                                 ip))
                                                               ((\_b2_ ->
                                                               (\_b5_ -> 
                                                                 bind _b2_ as {
                                                                 key:acc_vid,
                                                                 value:acc_tuples} in 
                                                                 bind _b5_ as {
                                                                 _r1_:ip,
                                                                 _r2_:vid,
                                                                 _r3_:tuples} in 
                                                                 {key:acc_vid.combine
                                                                  ({|
                                                                  _r1_:int,
                                                                  _r2_:int,
                                                                  _r3_:int |
                                                                  vid|} @ { Seq }),
                                                                  value:
                                                                  ((acc_tuples.combine
                                                                    tuples).groupBy
                                                                    ((\tuple ->
                                                                     
                                                                    tuple))
                                                                    ((\_ ->
                                                                    (\_ -> 
                                                                    ()))) ()).fold
                                                                    ((\__acc_map ->
                                                                    (\_b3_ -> 
                                                                    bind _b3_ as {
                                                                    key:__1,
                                                                    value:__2} in 
                                                                    __acc_map.combine
                                                                    ({|
                                                                    _r1_:{
                                                                    _r1_:int,
                                                                    _r2_:int,
                                                                    _r3_:int },
                                                                    _r2_:int,
                                                                    _r3_:int |
                                                                    __1|} @ { Collection }))))
                                                                    empty {
                                                                    _r1_:{
                                                                    _r1_:int,
                                                                    _r2_:int,
                                                                    _r3_:int },
                                                                    _r2_:int,
                                                                    _r3_:int
                                                                    } @ { Collection }})))
                                                               {key:empty {
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int
                                                                } @ { Seq },
                                                                value:empty {
                                                                _r1_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r2_:int,
                                                                _r3_:int
                                                                } @ { Collection }}).iterate
                                                              ((\_b1_ -> 
                                                                bind _b1_ as {
                                                                key:ip,
                                                                value:_b3_} in 
                                                                bind _b3_ as {
                                                                key:vid_send_list,
                                                                value:tuple} in 
                                                              (insert_S_rcv_corrective_s6_m_ATIMESD_mS1,
                                                                ip)<- {
                                                                _r1_:corrective_vid,
                                                                _r2_:vid_send_list,
                                                                _r3_:tuple}))
                                                          else ())))

trigger ATIMESD_mT1_mR1_send_correctives : {
key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
} @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {key:corrective_vid, value:delta_tuples} in let corrective_list =
                                                               filter_corrective_list
                                                                 {key:corrective_vid,
                                                                  value:{|
                                                                  key:int,
                                                                  value:int |
                                                                  {key:5,
                                                                   value:18},
                                                                  {key:4,
                                                                   value:15},
                                                                  {key:1,
                                                                   value:5},
                                                                  {key:0,
                                                                   value:2}|} @ { Collection }}
                                                               in
  corrective_list.iterate
    ((\_b1_ -> 
      bind _b1_ as {key:stmt_id, value:vid_list} in if stmt_id == 18
                                                    then
                                                      ((vid_list.fold
                                                          ((\__acc_ext ->
                                                          (\vid -> 
                                                            __acc_ext.combine
                                                          (bind log_get_bound_delete_R
                                                                  vid as {
                                                          _r1_:vid, _r2_:R_A,
                                                          _r3_:R_B} in 
                                                          (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mT1_bind_0t1
                                                             {_r1_:None immut,
                                                              _r2_:delta_tuples,
                                                              _r3_:false}).fold
                                                            ((\__acc_map ->
                                                            (\_b3_ -> 
                                                              bind _b3_ as {
                                                              key:ip,
                                                              value:tuples} in __acc_map.combine
                                                            ({|
                                                            _r1_:address,
                                                            _r2_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r3_:collection {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int,
                                                            _r4_:int
                                                            } @ { Collection }
                                                            |
                                                            {_r1_:ip, _r2_:vid,
                                                             _r3_:tuples}|} @ { Collection }))))
                                                            empty {
                                                            _r1_:address,
                                                            _r2_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r3_:collection {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int,
                                                            _r4_:int
                                                            } @ { Collection }
                                                            } @ { Collection }))))
                                                          empty {
                                                          _r1_:address, _r2_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int },
                                                          _r3_:collection {
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int, _r4_:int
                                                          } @ { Collection }
                                                          } @ { Collection }).groupBy
                                                         ((\_b1_ -> 
                                                           bind _b1_ as {
                                                           _r1_:ip, _r2_:vid,
                                                           _r3_:tuples} in ip))
                                                         ((\_b2_ -> (\_b5_ -> 
                                                           bind _b2_ as {
                                                           key:acc_vid,
                                                           value:acc_tuples} in 
                                                           bind _b5_ as {
                                                           _r1_:ip, _r2_:vid,
                                                           _r3_:tuples} in {
                                                         key:acc_vid.combine
                                                         ({|
                                                         _r1_:int, _r2_:int,
                                                         _r3_:int |
                                                         vid|} @ { Seq }),
                                                         value:((acc_tuples.combine
                                                                  tuples).groupBy
                                                                  ((\tuple -> 
                                                                    tuple))
                                                                  ((\_ ->
                                                                  (\_ ->  
                                                                  ()))) ()).fold
                                                                 ((\__acc_map ->
                                                                 (\_b3_ -> 
                                                                   bind _b3_ as {
                                                                   key:__1,
                                                                   value:__2} in 
                                                                   __acc_map.combine
                                                                 ({|
                                                                 _r1_:{
                                                                 _r1_:int,
                                                                 _r2_:int,
                                                                 _r3_:int },
                                                                 _r2_:int,
                                                                 _r3_:int,
                                                                 _r4_:int |
                                                                 __1|} @ { Collection }))))
                                                                 empty {
                                                                 _r1_:{
                                                                 _r1_:int,
                                                                 _r2_:int,
                                                                 _r3_:int },
                                                                 _r2_:int,
                                                                 _r3_:int,
                                                                 _r4_:int
                                                                 } @ { Collection }})))
                                                         {key:empty {
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int } @ { Seq },
                                                          value:empty {
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int, _r4_:int
                                                          } @ { Collection }}).iterate
                                                        ((\_b1_ -> 
                                                          bind _b1_ as {
                                                          key:ip, value:_b3_} in 
                                                          bind _b3_ as {
                                                          key:vid_send_list,
                                                          value:tuple} in 
                                                        (delete_R_rcv_corrective_s18_m_ATIMESD_mT1_mR1,
                                                          ip)<- {_r1_:corrective_vid,
                                                                 _r2_:vid_send_list,
                                                                 _r3_:tuple}))
                                                    else
                                                      if stmt_id == 15
                                                      then
                                                        ((vid_list.fold
                                                            ((\__acc_ext ->
                                                            (\vid -> 
                                                              __acc_ext.combine
                                                            (bind log_get_bound_insert_R
                                                                    vid as {
                                                            _r1_:vid, _r2_:R_A,
                                                            _r3_:R_B} in 
                                                            (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mT1_bind_0t1
                                                               {_r1_:None immut,
                                                                _r2_:delta_tuples,
                                                                _r3_:false}).fold
                                                              ((\__acc_map ->
                                                              (\_b3_ -> 
                                                                bind _b3_ as {
                                                                key:ip,
                                                                value:tuples} in 
                                                                __acc_map.combine
                                                              ({|
                                                              _r1_:address,
                                                              _r2_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r3_:collection {
                                                              _r1_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r2_:int,
                                                              _r3_:int,
                                                              _r4_:int
                                                              } @ { Collection }
                                                              |
                                                              {_r1_:ip,
                                                               _r2_:vid,
                                                               _r3_:tuples}|} @ { Collection }))))
                                                              empty {
                                                              _r1_:address,
                                                              _r2_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r3_:collection {
                                                              _r1_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r2_:int,
                                                              _r3_:int,
                                                              _r4_:int
                                                              } @ { Collection }
                                                              } @ { Collection }))))
                                                            empty {
                                                            _r1_:address,
                                                            _r2_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r3_:collection {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int,
                                                            _r4_:int
                                                            } @ { Collection }
                                                            } @ { Collection }).groupBy
                                                           ((\_b1_ -> 
                                                             bind _b1_ as {
                                                             _r1_:ip, _r2_:vid,
                                                             _r3_:tuples} in ip))
                                                           ((\_b2_ -> (\_b5_ ->
                                                           
                                                             bind _b2_ as {
                                                             key:acc_vid,
                                                             value:acc_tuples} in 
                                                             bind _b5_ as {
                                                             _r1_:ip, _r2_:vid,
                                                             _r3_:tuples} in {
                                                           key:acc_vid.combine
                                                           ({|
                                                           _r1_:int, _r2_:int,
                                                           _r3_:int |
                                                           vid|} @ { Seq }),
                                                           value:((acc_tuples.combine
                                                                    tuples).groupBy
                                                                    ((\tuple ->
                                                                     
                                                                    tuple))
                                                                    ((\_ ->
                                                                    (\_ -> 
                                                                    ()))) ()).fold
                                                                   ((\__acc_map ->
                                                                   (\_b3_ -> 
                                                                    bind _b3_ as {
                                                                    key:__1,
                                                                    value:__2} in 
                                                                    __acc_map.combine
                                                                   ({|
                                                                   _r1_:{
                                                                   _r1_:int,
                                                                   _r2_:int,
                                                                   _r3_:int },
                                                                   _r2_:int,
                                                                   _r3_:int,
                                                                   _r4_:int |
                                                                   __1|} @ { Collection }))))
                                                                   empty {
                                                                   _r1_:{
                                                                   _r1_:int,
                                                                   _r2_:int,
                                                                   _r3_:int },
                                                                   _r2_:int,
                                                                   _r3_:int,
                                                                   _r4_:int
                                                                   } @ { Collection }})))
                                                           {key:empty {
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int
                                                            } @ { Seq },
                                                            value:empty {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int,
                                                            _r4_:int
                                                            } @ { Collection }}).iterate
                                                          ((\_b1_ -> 
                                                            bind _b1_ as {
                                                            key:ip, value:_b3_} in 
                                                            bind _b3_ as {
                                                            key:vid_send_list,
                                                            value:tuple} in 
                                                          (insert_R_rcv_corrective_s15_m_ATIMESD_mT1_mR1,
                                                            ip)<- {_r1_:corrective_vid,
                                                                   _r2_:vid_send_list,
                                                                   _r3_:tuple}))
                                                      else
                                                        if stmt_id == 5
                                                        then
                                                          ((vid_list.fold
                                                              ((\__acc_ext ->
                                                              (\vid -> 
                                                                __acc_ext.combine
                                                              (bind log_get_bound_delete_T
                                                                    vid as {
                                                              _r1_:vid,
                                                              _r2_:T_C,
                                                              _r3_:T_D} in 
                                                              (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mR1_bind_0t0
                                                                 {_r1_:None immut,
                                                                  _r2_:delta_tuples,
                                                                  _r3_:false}).fold
                                                                ((\__acc_map ->
                                                                (\_b3_ -> 
                                                                  bind _b3_ as {
                                                                  key:ip,
                                                                  value:tuples} in 
                                                                  __acc_map.combine
                                                                ({|
                                                                _r1_:address,
                                                                _r2_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r3_:collection {
                                                                _r1_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r2_:int,
                                                                _r3_:int,
                                                                _r4_:int
                                                                } @ { Collection }
                                                                |
                                                                {_r1_:ip,
                                                                 _r2_:vid,
                                                                 _r3_:tuples}|} @ { Collection }))))
                                                                empty {
                                                                _r1_:address,
                                                                _r2_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r3_:collection {
                                                                _r1_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r2_:int,
                                                                _r3_:int,
                                                                _r4_:int
                                                                } @ { Collection }
                                                                } @ { Collection }))))
                                                              empty {
                                                              _r1_:address,
                                                              _r2_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r3_:collection {
                                                              _r1_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r2_:int,
                                                              _r3_:int,
                                                              _r4_:int
                                                              } @ { Collection }
                                                              } @ { Collection }).groupBy
                                                             ((\_b1_ -> 
                                                               bind _b1_ as {
                                                               _r1_:ip,
                                                               _r2_:vid,
                                                               _r3_:tuples} in ip))
                                                             ((\_b2_ ->
                                                             (\_b5_ -> 
                                                               bind _b2_ as {
                                                               key:acc_vid,
                                                               value:acc_tuples} in 
                                                               bind _b5_ as {
                                                               _r1_:ip,
                                                               _r2_:vid,
                                                               _r3_:tuples} in {
                                                             key:acc_vid.combine
                                                             ({|
                                                             _r1_:int,
                                                             _r2_:int, _r3_:int
                                                             | vid|} @ { Seq }),
                                                             value:((acc_tuples.combine
                                                                    tuples).groupBy
                                                                    ((\tuple ->
                                                                     
                                                                    tuple))
                                                                    ((\_ ->
                                                                    (\_ -> 
                                                                    ()))) ()).fold
                                                                    ((\__acc_map ->
                                                                    (\_b3_ -> 
                                                                    bind _b3_ as {
                                                                    key:__1,
                                                                    value:__2} in 
                                                                    __acc_map.combine
                                                                    ({|
                                                                    _r1_:{
                                                                    _r1_:int,
                                                                    _r2_:int,
                                                                    _r3_:int },
                                                                    _r2_:int,
                                                                    _r3_:int,
                                                                    _r4_:int |
                                                                    __1|} @ { Collection }))))
                                                                    empty {
                                                                    _r1_:{
                                                                    _r1_:int,
                                                                    _r2_:int,
                                                                    _r3_:int },
                                                                    _r2_:int,
                                                                    _r3_:int,
                                                                    _r4_:int
                                                                    } @ { Collection }})))
                                                             {key:empty {
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int
                                                              } @ { Seq },
                                                              value:empty {
                                                              _r1_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r2_:int,
                                                              _r3_:int,
                                                              _r4_:int
                                                              } @ { Collection }}).iterate
                                                            ((\_b1_ -> 
                                                              bind _b1_ as {
                                                              key:ip,
                                                              value:_b3_} in 
                                                              bind _b3_ as {
                                                              key:vid_send_list,
                                                              value:tuple} in 
                                                            (delete_T_rcv_corrective_s5_m_ATIMESD_mT1_mR1,
                                                              ip)<- {
                                                              _r1_:corrective_vid,
                                                              _r2_:vid_send_list,
                                                              _r3_:tuple}))
                                                        else
                                                          if stmt_id == 2
                                                          then
                                                            ((vid_list.fold
                                                                ((\__acc_ext ->
                                                                (\vid -> 
                                                                  __acc_ext.combine
                                                                (bind 
                                                                log_get_bound_insert_T
                                                                  vid as {
                                                                _r1_:vid,
                                                                _r2_:T_C,
                                                                _r3_:T_D} in 
                                                                (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mR1_bind_0t0
                                                                   {_r1_:None immut,
                                                                    _r2_:delta_tuples,
                                                                    _r3_:false}).fold
                                                                  ((\__acc_map ->
                                                                  (\_b3_ -> 
                                                                    bind _b3_ as {
                                                                    key:ip,
                                                                    value:tuples} in 
                                                                    __acc_map.combine
                                                                  ({|
                                                                  _r1_:address,
                                                                  _r2_:{
                                                                  _r1_:int,
                                                                  _r2_:int,
                                                                  _r3_:int },
                                                                  _r3_:collection {
                                                                  _r1_:{
                                                                  _r1_:int,
                                                                  _r2_:int,
                                                                  _r3_:int },
                                                                  _r2_:int,
                                                                  _r3_:int,
                                                                  _r4_:int
                                                                  } @ { Collection }
                                                                  |
                                                                  {_r1_:ip,
                                                                   _r2_:vid,
                                                                   _r3_:tuples}|} @ { Collection }))))
                                                                  empty {
                                                                  _r1_:address,
                                                                  _r2_:{
                                                                  _r1_:int,
                                                                  _r2_:int,
                                                                  _r3_:int },
                                                                  _r3_:collection {
                                                                  _r1_:{
                                                                  _r1_:int,
                                                                  _r2_:int,
                                                                  _r3_:int },
                                                                  _r2_:int,
                                                                  _r3_:int,
                                                                  _r4_:int
                                                                  } @ { Collection }
                                                                  } @ { Collection }))))
                                                                empty {
                                                                _r1_:address,
                                                                _r2_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r3_:collection {
                                                                _r1_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r2_:int,
                                                                _r3_:int,
                                                                _r4_:int
                                                                } @ { Collection }
                                                                } @ { Collection }).groupBy
                                                               ((\_b1_ -> 
                                                                 bind _b1_ as {
                                                                 _r1_:ip,
                                                                 _r2_:vid,
                                                                 _r3_:tuples} in 
                                                                 ip))
                                                               ((\_b2_ ->
                                                               (\_b5_ -> 
                                                                 bind _b2_ as {
                                                                 key:acc_vid,
                                                                 value:acc_tuples} in 
                                                                 bind _b5_ as {
                                                                 _r1_:ip,
                                                                 _r2_:vid,
                                                                 _r3_:tuples} in 
                                                                 {key:acc_vid.combine
                                                                  ({|
                                                                  _r1_:int,
                                                                  _r2_:int,
                                                                  _r3_:int |
                                                                  vid|} @ { Seq }),
                                                                  value:
                                                                  ((acc_tuples.combine
                                                                    tuples).groupBy
                                                                    ((\tuple ->
                                                                     
                                                                    tuple))
                                                                    ((\_ ->
                                                                    (\_ -> 
                                                                    ()))) ()).fold
                                                                    ((\__acc_map ->
                                                                    (\_b3_ -> 
                                                                    bind _b3_ as {
                                                                    key:__1,
                                                                    value:__2} in 
                                                                    __acc_map.combine
                                                                    ({|
                                                                    _r1_:{
                                                                    _r1_:int,
                                                                    _r2_:int,
                                                                    _r3_:int },
                                                                    _r2_:int,
                                                                    _r3_:int,
                                                                    _r4_:int |
                                                                    __1|} @ { Collection }))))
                                                                    empty {
                                                                    _r1_:{
                                                                    _r1_:int,
                                                                    _r2_:int,
                                                                    _r3_:int },
                                                                    _r2_:int,
                                                                    _r3_:int,
                                                                    _r4_:int
                                                                    } @ { Collection }})))
                                                               {key:empty {
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int
                                                                } @ { Seq },
                                                                value:empty {
                                                                _r1_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r2_:int,
                                                                _r3_:int,
                                                                _r4_:int
                                                                } @ { Collection }}).iterate
                                                              ((\_b1_ -> 
                                                                bind _b1_ as {
                                                                key:ip,
                                                                value:_b3_} in 
                                                                bind _b3_ as {
                                                                key:vid_send_list,
                                                                value:tuple} in 
                                                              (insert_T_rcv_corrective_s2_m_ATIMESD_mT1_mR1,
                                                                ip)<- {
                                                                _r1_:corrective_vid,
                                                                _r2_:vid_send_list,
                                                                _r3_:tuple}))
                                                          else ())))

trigger ATIMESD_mT1_send_correctives : {
key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {key:corrective_vid, value:delta_tuples} in let corrective_list =
                                                               filter_corrective_list
                                                                 {key:corrective_vid,
                                                                  value:{|
                                                                  key:int,
                                                                  value:int |
                                                                  {key:1,
                                                                   value:3},
                                                                  {key:0,
                                                                   value:0}|} @ { Collection }}
                                                               in
  corrective_list.iterate
    ((\_b1_ -> 
      bind _b1_ as {key:stmt_id, value:vid_list} in if stmt_id == 3
                                                    then
                                                      ((vid_list.fold
                                                          ((\__acc_ext ->
                                                          (\vid -> 
                                                            __acc_ext.combine
                                                          (bind log_get_bound_delete_T
                                                                  vid as {
                                                          _r1_:vid, _r2_:T_C,
                                                          _r3_:T_D} in 
                                                          (shuffle_ATIMESD_mT1_to_ATIMESD
                                                             {_r1_:(),
                                                              _r2_:delta_tuples,
                                                              _r3_:false}).fold
                                                            ((\__acc_map ->
                                                            (\_b3_ -> 
                                                              bind _b3_ as {
                                                              key:ip,
                                                              value:tuples} in __acc_map.combine
                                                            ({|
                                                            _r1_:address,
                                                            _r2_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r3_:collection {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int
                                                            } @ { Collection }
                                                            |
                                                            {_r1_:ip, _r2_:vid,
                                                             _r3_:tuples}|} @ { Collection }))))
                                                            empty {
                                                            _r1_:address,
                                                            _r2_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r3_:collection {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int
                                                            } @ { Collection }
                                                            } @ { Collection }))))
                                                          empty {
                                                          _r1_:address, _r2_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int },
                                                          _r3_:collection {
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int
                                                          } @ { Collection }
                                                          } @ { Collection }).groupBy
                                                         ((\_b1_ -> 
                                                           bind _b1_ as {
                                                           _r1_:ip, _r2_:vid,
                                                           _r3_:tuples} in ip))
                                                         ((\_b2_ -> (\_b5_ -> 
                                                           bind _b2_ as {
                                                           key:acc_vid,
                                                           value:acc_tuples} in 
                                                           bind _b5_ as {
                                                           _r1_:ip, _r2_:vid,
                                                           _r3_:tuples} in {
                                                         key:acc_vid.combine
                                                         ({|
                                                         _r1_:int, _r2_:int,
                                                         _r3_:int |
                                                         vid|} @ { Seq }),
                                                         value:((acc_tuples.combine
                                                                  tuples).groupBy
                                                                  ((\tuple -> 
                                                                    tuple))
                                                                  ((\_ ->
                                                                  (\_ ->  
                                                                  ()))) ()).fold
                                                                 ((\__acc_map ->
                                                                 (\_b3_ -> 
                                                                   bind _b3_ as {
                                                                   key:__1,
                                                                   value:__2} in 
                                                                   __acc_map.combine
                                                                 ({|
                                                                 _r1_:{
                                                                 _r1_:int,
                                                                 _r2_:int,
                                                                 _r3_:int },
                                                                 _r2_:int,
                                                                 _r3_:int |
                                                                 __1|} @ { Collection }))))
                                                                 empty {
                                                                 _r1_:{
                                                                 _r1_:int,
                                                                 _r2_:int,
                                                                 _r3_:int },
                                                                 _r2_:int,
                                                                 _r3_:int
                                                                 } @ { Collection }})))
                                                         {key:empty {
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int } @ { Seq },
                                                          value:empty {
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int
                                                          } @ { Collection }}).iterate
                                                        ((\_b1_ -> 
                                                          bind _b1_ as {
                                                          key:ip, value:_b3_} in 
                                                          bind _b3_ as {
                                                          key:vid_send_list,
                                                          value:tuple} in 
                                                        (delete_T_rcv_corrective_s3_m_ATIMESD_mT1,
                                                          ip)<- {_r1_:corrective_vid,
                                                                 _r2_:vid_send_list,
                                                                 _r3_:tuple}))
                                                    else
                                                      if stmt_id == 0
                                                      then
                                                        ((vid_list.fold
                                                            ((\__acc_ext ->
                                                            (\vid -> 
                                                              __acc_ext.combine
                                                            (bind log_get_bound_insert_T
                                                                    vid as {
                                                            _r1_:vid, _r2_:T_C,
                                                            _r3_:T_D} in 
                                                            (shuffle_ATIMESD_mT1_to_ATIMESD
                                                               {_r1_:(),
                                                                _r2_:delta_tuples,
                                                                _r3_:false}).fold
                                                              ((\__acc_map ->
                                                              (\_b3_ -> 
                                                                bind _b3_ as {
                                                                key:ip,
                                                                value:tuples} in 
                                                                __acc_map.combine
                                                              ({|
                                                              _r1_:address,
                                                              _r2_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r3_:collection {
                                                              _r1_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r2_:int,
                                                              _r3_:int
                                                              } @ { Collection }
                                                              |
                                                              {_r1_:ip,
                                                               _r2_:vid,
                                                               _r3_:tuples}|} @ { Collection }))))
                                                              empty {
                                                              _r1_:address,
                                                              _r2_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r3_:collection {
                                                              _r1_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r2_:int,
                                                              _r3_:int
                                                              } @ { Collection }
                                                              } @ { Collection }))))
                                                            empty {
                                                            _r1_:address,
                                                            _r2_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r3_:collection {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int
                                                            } @ { Collection }
                                                            } @ { Collection }).groupBy
                                                           ((\_b1_ -> 
                                                             bind _b1_ as {
                                                             _r1_:ip, _r2_:vid,
                                                             _r3_:tuples} in ip))
                                                           ((\_b2_ -> (\_b5_ ->
                                                           
                                                             bind _b2_ as {
                                                             key:acc_vid,
                                                             value:acc_tuples} in 
                                                             bind _b5_ as {
                                                             _r1_:ip, _r2_:vid,
                                                             _r3_:tuples} in {
                                                           key:acc_vid.combine
                                                           ({|
                                                           _r1_:int, _r2_:int,
                                                           _r3_:int |
                                                           vid|} @ { Seq }),
                                                           value:((acc_tuples.combine
                                                                    tuples).groupBy
                                                                    ((\tuple ->
                                                                     
                                                                    tuple))
                                                                    ((\_ ->
                                                                    (\_ -> 
                                                                    ()))) ()).fold
                                                                   ((\__acc_map ->
                                                                   (\_b3_ -> 
                                                                    bind _b3_ as {
                                                                    key:__1,
                                                                    value:__2} in 
                                                                    __acc_map.combine
                                                                   ({|
                                                                   _r1_:{
                                                                   _r1_:int,
                                                                   _r2_:int,
                                                                   _r3_:int },
                                                                   _r2_:int,
                                                                   _r3_:int |
                                                                   __1|} @ { Collection }))))
                                                                   empty {
                                                                   _r1_:{
                                                                   _r1_:int,
                                                                   _r2_:int,
                                                                   _r3_:int },
                                                                   _r2_:int,
                                                                   _r3_:int
                                                                   } @ { Collection }})))
                                                           {key:empty {
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int
                                                            } @ { Seq },
                                                            value:empty {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int
                                                            } @ { Collection }}).iterate
                                                          ((\_b1_ -> 
                                                            bind _b1_ as {
                                                            key:ip, value:_b3_} in 
                                                            bind _b3_ as {
                                                            key:vid_send_list,
                                                            value:tuple} in 
                                                          (insert_T_rcv_corrective_s0_m_ATIMESD_mT1,
                                                            ip)<- {_r1_:corrective_vid,
                                                                   _r2_:vid_send_list,
                                                                   _r3_:tuple}))
                                                      else ())))

trigger ATIMESD_mR1_send_correctives : {
key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {key:corrective_vid, value:delta_tuples} in let corrective_list =
                                                               filter_corrective_list
                                                                 {key:corrective_vid,
                                                                  value:{|
                                                                  key:int,
                                                                  value:int |
                                                                  {key:5,
                                                                   value:17},
                                                                  {key:4,
                                                                   value:14}|} @ { Collection }}
                                                               in
  corrective_list.iterate
    ((\_b1_ -> 
      bind _b1_ as {key:stmt_id, value:vid_list} in if stmt_id == 17
                                                    then
                                                      ((vid_list.fold
                                                          ((\__acc_ext ->
                                                          (\vid -> 
                                                            __acc_ext.combine
                                                          (bind log_get_bound_delete_R
                                                                  vid as {
                                                          _r1_:vid, _r2_:R_A,
                                                          _r3_:R_B} in 
                                                          (shuffle_ATIMESD_mR1_to_ATIMESD
                                                             {_r1_:(),
                                                              _r2_:delta_tuples,
                                                              _r3_:false}).fold
                                                            ((\__acc_map ->
                                                            (\_b3_ -> 
                                                              bind _b3_ as {
                                                              key:ip,
                                                              value:tuples} in __acc_map.combine
                                                            ({|
                                                            _r1_:address,
                                                            _r2_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r3_:collection {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int
                                                            } @ { Collection }
                                                            |
                                                            {_r1_:ip, _r2_:vid,
                                                             _r3_:tuples}|} @ { Collection }))))
                                                            empty {
                                                            _r1_:address,
                                                            _r2_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r3_:collection {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int
                                                            } @ { Collection }
                                                            } @ { Collection }))))
                                                          empty {
                                                          _r1_:address, _r2_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int },
                                                          _r3_:collection {
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int
                                                          } @ { Collection }
                                                          } @ { Collection }).groupBy
                                                         ((\_b1_ -> 
                                                           bind _b1_ as {
                                                           _r1_:ip, _r2_:vid,
                                                           _r3_:tuples} in ip))
                                                         ((\_b2_ -> (\_b5_ -> 
                                                           bind _b2_ as {
                                                           key:acc_vid,
                                                           value:acc_tuples} in 
                                                           bind _b5_ as {
                                                           _r1_:ip, _r2_:vid,
                                                           _r3_:tuples} in {
                                                         key:acc_vid.combine
                                                         ({|
                                                         _r1_:int, _r2_:int,
                                                         _r3_:int |
                                                         vid|} @ { Seq }),
                                                         value:((acc_tuples.combine
                                                                  tuples).groupBy
                                                                  ((\tuple -> 
                                                                    tuple))
                                                                  ((\_ ->
                                                                  (\_ ->  
                                                                  ()))) ()).fold
                                                                 ((\__acc_map ->
                                                                 (\_b3_ -> 
                                                                   bind _b3_ as {
                                                                   key:__1,
                                                                   value:__2} in 
                                                                   __acc_map.combine
                                                                 ({|
                                                                 _r1_:{
                                                                 _r1_:int,
                                                                 _r2_:int,
                                                                 _r3_:int },
                                                                 _r2_:int,
                                                                 _r3_:int |
                                                                 __1|} @ { Collection }))))
                                                                 empty {
                                                                 _r1_:{
                                                                 _r1_:int,
                                                                 _r2_:int,
                                                                 _r3_:int },
                                                                 _r2_:int,
                                                                 _r3_:int
                                                                 } @ { Collection }})))
                                                         {key:empty {
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int } @ { Seq },
                                                          value:empty {
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int
                                                          } @ { Collection }}).iterate
                                                        ((\_b1_ -> 
                                                          bind _b1_ as {
                                                          key:ip, value:_b3_} in 
                                                          bind _b3_ as {
                                                          key:vid_send_list,
                                                          value:tuple} in 
                                                        (delete_R_rcv_corrective_s17_m_ATIMESD_mR1,
                                                          ip)<- {_r1_:corrective_vid,
                                                                 _r2_:vid_send_list,
                                                                 _r3_:tuple}))
                                                    else
                                                      if stmt_id == 14
                                                      then
                                                        ((vid_list.fold
                                                            ((\__acc_ext ->
                                                            (\vid -> 
                                                              __acc_ext.combine
                                                            (bind log_get_bound_insert_R
                                                                    vid as {
                                                            _r1_:vid, _r2_:R_A,
                                                            _r3_:R_B} in 
                                                            (shuffle_ATIMESD_mR1_to_ATIMESD
                                                               {_r1_:(),
                                                                _r2_:delta_tuples,
                                                                _r3_:false}).fold
                                                              ((\__acc_map ->
                                                              (\_b3_ -> 
                                                                bind _b3_ as {
                                                                key:ip,
                                                                value:tuples} in 
                                                                __acc_map.combine
                                                              ({|
                                                              _r1_:address,
                                                              _r2_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r3_:collection {
                                                              _r1_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r2_:int,
                                                              _r3_:int
                                                              } @ { Collection }
                                                              |
                                                              {_r1_:ip,
                                                               _r2_:vid,
                                                               _r3_:tuples}|} @ { Collection }))))
                                                              empty {
                                                              _r1_:address,
                                                              _r2_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r3_:collection {
                                                              _r1_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r2_:int,
                                                              _r3_:int
                                                              } @ { Collection }
                                                              } @ { Collection }))))
                                                            empty {
                                                            _r1_:address,
                                                            _r2_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r3_:collection {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int
                                                            } @ { Collection }
                                                            } @ { Collection }).groupBy
                                                           ((\_b1_ -> 
                                                             bind _b1_ as {
                                                             _r1_:ip, _r2_:vid,
                                                             _r3_:tuples} in ip))
                                                           ((\_b2_ -> (\_b5_ ->
                                                           
                                                             bind _b2_ as {
                                                             key:acc_vid,
                                                             value:acc_tuples} in 
                                                             bind _b5_ as {
                                                             _r1_:ip, _r2_:vid,
                                                             _r3_:tuples} in {
                                                           key:acc_vid.combine
                                                           ({|
                                                           _r1_:int, _r2_:int,
                                                           _r3_:int |
                                                           vid|} @ { Seq }),
                                                           value:((acc_tuples.combine
                                                                    tuples).groupBy
                                                                    ((\tuple ->
                                                                     
                                                                    tuple))
                                                                    ((\_ ->
                                                                    (\_ -> 
                                                                    ()))) ()).fold
                                                                   ((\__acc_map ->
                                                                   (\_b3_ -> 
                                                                    bind _b3_ as {
                                                                    key:__1,
                                                                    value:__2} in 
                                                                    __acc_map.combine
                                                                   ({|
                                                                   _r1_:{
                                                                   _r1_:int,
                                                                   _r2_:int,
                                                                   _r3_:int },
                                                                   _r2_:int,
                                                                   _r3_:int |
                                                                   __1|} @ { Collection }))))
                                                                   empty {
                                                                   _r1_:{
                                                                   _r1_:int,
                                                                   _r2_:int,
                                                                   _r3_:int },
                                                                   _r2_:int,
                                                                   _r3_:int
                                                                   } @ { Collection }})))
                                                           {key:empty {
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int
                                                            } @ { Seq },
                                                            value:empty {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int
                                                            } @ { Collection }}).iterate
                                                          ((\_b1_ -> 
                                                            bind _b1_ as {
                                                            key:ip, value:_b3_} in 
                                                            bind _b3_ as {
                                                            key:vid_send_list,
                                                            value:tuple} in 
                                                          (insert_R_rcv_corrective_s14_m_ATIMESD_mR1,
                                                            ip)<- {_r1_:corrective_vid,
                                                                   _r2_:vid_send_list,
                                                                   _r3_:tuple}))
                                                      else ())))

trigger ATIMESD_mS2_send_correctives : {
key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {key:corrective_vid, value:delta_tuples} in let corrective_list =
                                                               filter_corrective_list
                                                                 {key:corrective_vid,
                                                                  value:{|
                                                                  key:int,
                                                                  value:int |
                                                                  {key:3,
                                                                   value:13},
                                                                  {key:3,
                                                                   value:10},
                                                                  {key:2,
                                                                   value:9},
                                                                  {key:2,
                                                                   value:6}|} @ { Collection }}
                                                               in
  corrective_list.iterate
    ((\_b1_ -> 
      bind _b1_ as {key:stmt_id, value:vid_list} in if stmt_id == 13
                                                    then
                                                      ((vid_list.fold
                                                          ((\__acc_ext ->
                                                          (\vid -> 
                                                            __acc_ext.combine
                                                          (bind log_get_bound_delete_S
                                                                  vid as {
                                                          _r1_:vid, _r2_:S_B,
                                                          _r3_:S_C} in 
                                                          (shuffle_ATIMESD_mS2_to_ATIMESD_mR1
                                                             {_r1_:Some S_B,
                                                              _r2_:delta_tuples,
                                                              _r3_:false}).fold
                                                            ((\__acc_map ->
                                                            (\_b3_ -> 
                                                              bind _b3_ as {
                                                              key:ip,
                                                              value:tuples} in __acc_map.combine
                                                            ({|
                                                            _r1_:address,
                                                            _r2_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r3_:collection {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int
                                                            } @ { Collection }
                                                            |
                                                            {_r1_:ip, _r2_:vid,
                                                             _r3_:tuples}|} @ { Collection }))))
                                                            empty {
                                                            _r1_:address,
                                                            _r2_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r3_:collection {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int
                                                            } @ { Collection }
                                                            } @ { Collection }))))
                                                          empty {
                                                          _r1_:address, _r2_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int },
                                                          _r3_:collection {
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int
                                                          } @ { Collection }
                                                          } @ { Collection }).groupBy
                                                         ((\_b1_ -> 
                                                           bind _b1_ as {
                                                           _r1_:ip, _r2_:vid,
                                                           _r3_:tuples} in ip))
                                                         ((\_b2_ -> (\_b5_ -> 
                                                           bind _b2_ as {
                                                           key:acc_vid,
                                                           value:acc_tuples} in 
                                                           bind _b5_ as {
                                                           _r1_:ip, _r2_:vid,
                                                           _r3_:tuples} in {
                                                         key:acc_vid.combine
                                                         ({|
                                                         _r1_:int, _r2_:int,
                                                         _r3_:int |
                                                         vid|} @ { Seq }),
                                                         value:((acc_tuples.combine
                                                                  tuples).groupBy
                                                                  ((\tuple -> 
                                                                    tuple))
                                                                  ((\_ ->
                                                                  (\_ ->  
                                                                  ()))) ()).fold
                                                                 ((\__acc_map ->
                                                                 (\_b3_ -> 
                                                                   bind _b3_ as {
                                                                   key:__1,
                                                                   value:__2} in 
                                                                   __acc_map.combine
                                                                 ({|
                                                                 _r1_:{
                                                                 _r1_:int,
                                                                 _r2_:int,
                                                                 _r3_:int },
                                                                 _r2_:int,
                                                                 _r3_:int |
                                                                 __1|} @ { Collection }))))
                                                                 empty {
                                                                 _r1_:{
                                                                 _r1_:int,
                                                                 _r2_:int,
                                                                 _r3_:int },
                                                                 _r2_:int,
                                                                 _r3_:int
                                                                 } @ { Collection }})))
                                                         {key:empty {
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int } @ { Seq },
                                                          value:empty {
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int
                                                          } @ { Collection }}).iterate
                                                        ((\_b1_ -> 
                                                          bind _b1_ as {
                                                          key:ip, value:_b3_} in 
                                                          bind _b3_ as {
                                                          key:vid_send_list,
                                                          value:tuple} in 
                                                        (delete_S_rcv_corrective_s13_m_ATIMESD_mS2,
                                                          ip)<- {_r1_:corrective_vid,
                                                                 _r2_:vid_send_list,
                                                                 _r3_:tuple}))
                                                    else
                                                      if stmt_id == 10
                                                      then
                                                        ((vid_list.fold
                                                            ((\__acc_ext ->
                                                            (\vid -> 
                                                              __acc_ext.combine
                                                            (bind log_get_bound_delete_S
                                                                    vid as {
                                                            _r1_:vid, _r2_:S_B,
                                                            _r3_:S_C} in 
                                                            (shuffle_ATIMESD_mS2_to_ATIMESD
                                                               {_r1_:(),
                                                                _r2_:delta_tuples,
                                                                _r3_:false}).fold
                                                              ((\__acc_map ->
                                                              (\_b3_ -> 
                                                                bind _b3_ as {
                                                                key:ip,
                                                                value:tuples} in 
                                                                __acc_map.combine
                                                              ({|
                                                              _r1_:address,
                                                              _r2_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r3_:collection {
                                                              _r1_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r2_:int,
                                                              _r3_:int
                                                              } @ { Collection }
                                                              |
                                                              {_r1_:ip,
                                                               _r2_:vid,
                                                               _r3_:tuples}|} @ { Collection }))))
                                                              empty {
                                                              _r1_:address,
                                                              _r2_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r3_:collection {
                                                              _r1_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r2_:int,
                                                              _r3_:int
                                                              } @ { Collection }
                                                              } @ { Collection }))))
                                                            empty {
                                                            _r1_:address,
                                                            _r2_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r3_:collection {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int
                                                            } @ { Collection }
                                                            } @ { Collection }).groupBy
                                                           ((\_b1_ -> 
                                                             bind _b1_ as {
                                                             _r1_:ip, _r2_:vid,
                                                             _r3_:tuples} in ip))
                                                           ((\_b2_ -> (\_b5_ ->
                                                           
                                                             bind _b2_ as {
                                                             key:acc_vid,
                                                             value:acc_tuples} in 
                                                             bind _b5_ as {
                                                             _r1_:ip, _r2_:vid,
                                                             _r3_:tuples} in {
                                                           key:acc_vid.combine
                                                           ({|
                                                           _r1_:int, _r2_:int,
                                                           _r3_:int |
                                                           vid|} @ { Seq }),
                                                           value:((acc_tuples.combine
                                                                    tuples).groupBy
                                                                    ((\tuple ->
                                                                     
                                                                    tuple))
                                                                    ((\_ ->
                                                                    (\_ -> 
                                                                    ()))) ()).fold
                                                                   ((\__acc_map ->
                                                                   (\_b3_ -> 
                                                                    bind _b3_ as {
                                                                    key:__1,
                                                                    value:__2} in 
                                                                    __acc_map.combine
                                                                   ({|
                                                                   _r1_:{
                                                                   _r1_:int,
                                                                   _r2_:int,
                                                                   _r3_:int },
                                                                   _r2_:int,
                                                                   _r3_:int |
                                                                   __1|} @ { Collection }))))
                                                                   empty {
                                                                   _r1_:{
                                                                   _r1_:int,
                                                                   _r2_:int,
                                                                   _r3_:int },
                                                                   _r2_:int,
                                                                   _r3_:int
                                                                   } @ { Collection }})))
                                                           {key:empty {
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int
                                                            } @ { Seq },
                                                            value:empty {
                                                            _r1_:{
                                                            _r1_:int, _r2_:int,
                                                            _r3_:int },
                                                            _r2_:int, _r3_:int
                                                            } @ { Collection }}).iterate
                                                          ((\_b1_ -> 
                                                            bind _b1_ as {
                                                            key:ip, value:_b3_} in 
                                                            bind _b3_ as {
                                                            key:vid_send_list,
                                                            value:tuple} in 
                                                          (delete_S_rcv_corrective_s10_m_ATIMESD_mS2,
                                                            ip)<- {_r1_:corrective_vid,
                                                                   _r2_:vid_send_list,
                                                                   _r3_:tuple}))
                                                      else
                                                        if stmt_id == 9
                                                        then
                                                          ((vid_list.fold
                                                              ((\__acc_ext ->
                                                              (\vid -> 
                                                                __acc_ext.combine
                                                              (bind log_get_bound_insert_S
                                                                    vid as {
                                                              _r1_:vid,
                                                              _r2_:S_B,
                                                              _r3_:S_C} in 
                                                              (shuffle_ATIMESD_mS2_to_ATIMESD_mR1
                                                                 {_r1_:Some S_B,
                                                                  _r2_:delta_tuples,
                                                                  _r3_:false}).fold
                                                                ((\__acc_map ->
                                                                (\_b3_ -> 
                                                                  bind _b3_ as {
                                                                  key:ip,
                                                                  value:tuples} in 
                                                                  __acc_map.combine
                                                                ({|
                                                                _r1_:address,
                                                                _r2_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r3_:collection {
                                                                _r1_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r2_:int,
                                                                _r3_:int
                                                                } @ { Collection }
                                                                |
                                                                {_r1_:ip,
                                                                 _r2_:vid,
                                                                 _r3_:tuples}|} @ { Collection }))))
                                                                empty {
                                                                _r1_:address,
                                                                _r2_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r3_:collection {
                                                                _r1_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r2_:int,
                                                                _r3_:int
                                                                } @ { Collection }
                                                                } @ { Collection }))))
                                                              empty {
                                                              _r1_:address,
                                                              _r2_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r3_:collection {
                                                              _r1_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r2_:int,
                                                              _r3_:int
                                                              } @ { Collection }
                                                              } @ { Collection }).groupBy
                                                             ((\_b1_ -> 
                                                               bind _b1_ as {
                                                               _r1_:ip,
                                                               _r2_:vid,
                                                               _r3_:tuples} in ip))
                                                             ((\_b2_ ->
                                                             (\_b5_ -> 
                                                               bind _b2_ as {
                                                               key:acc_vid,
                                                               value:acc_tuples} in 
                                                               bind _b5_ as {
                                                               _r1_:ip,
                                                               _r2_:vid,
                                                               _r3_:tuples} in {
                                                             key:acc_vid.combine
                                                             ({|
                                                             _r1_:int,
                                                             _r2_:int, _r3_:int
                                                             | vid|} @ { Seq }),
                                                             value:((acc_tuples.combine
                                                                    tuples).groupBy
                                                                    ((\tuple ->
                                                                     
                                                                    tuple))
                                                                    ((\_ ->
                                                                    (\_ -> 
                                                                    ()))) ()).fold
                                                                    ((\__acc_map ->
                                                                    (\_b3_ -> 
                                                                    bind _b3_ as {
                                                                    key:__1,
                                                                    value:__2} in 
                                                                    __acc_map.combine
                                                                    ({|
                                                                    _r1_:{
                                                                    _r1_:int,
                                                                    _r2_:int,
                                                                    _r3_:int },
                                                                    _r2_:int,
                                                                    _r3_:int |
                                                                    __1|} @ { Collection }))))
                                                                    empty {
                                                                    _r1_:{
                                                                    _r1_:int,
                                                                    _r2_:int,
                                                                    _r3_:int },
                                                                    _r2_:int,
                                                                    _r3_:int
                                                                    } @ { Collection }})))
                                                             {key:empty {
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int
                                                              } @ { Seq },
                                                              value:empty {
                                                              _r1_:{
                                                              _r1_:int,
                                                              _r2_:int,
                                                              _r3_:int },
                                                              _r2_:int,
                                                              _r3_:int
                                                              } @ { Collection }}).iterate
                                                            ((\_b1_ -> 
                                                              bind _b1_ as {
                                                              key:ip,
                                                              value:_b3_} in 
                                                              bind _b3_ as {
                                                              key:vid_send_list,
                                                              value:tuple} in 
                                                            (insert_S_rcv_corrective_s9_m_ATIMESD_mS2,
                                                              ip)<- {
                                                              _r1_:corrective_vid,
                                                              _r2_:vid_send_list,
                                                              _r3_:tuple}))
                                                        else
                                                          if stmt_id == 6
                                                          then
                                                            ((vid_list.fold
                                                                ((\__acc_ext ->
                                                                (\vid -> 
                                                                  __acc_ext.combine
                                                                (bind 
                                                                log_get_bound_insert_S
                                                                  vid as {
                                                                _r1_:vid,
                                                                _r2_:S_B,
                                                                _r3_:S_C} in 
                                                                (shuffle_ATIMESD_mS2_to_ATIMESD
                                                                   {_r1_:(),
                                                                    _r2_:delta_tuples,
                                                                    _r3_:false}).fold
                                                                  ((\__acc_map ->
                                                                  (\_b3_ -> 
                                                                    bind _b3_ as {
                                                                    key:ip,
                                                                    value:tuples} in 
                                                                    __acc_map.combine
                                                                  ({|
                                                                  _r1_:address,
                                                                  _r2_:{
                                                                  _r1_:int,
                                                                  _r2_:int,
                                                                  _r3_:int },
                                                                  _r3_:collection {
                                                                  _r1_:{
                                                                  _r1_:int,
                                                                  _r2_:int,
                                                                  _r3_:int },
                                                                  _r2_:int,
                                                                  _r3_:int
                                                                  } @ { Collection }
                                                                  |
                                                                  {_r1_:ip,
                                                                   _r2_:vid,
                                                                   _r3_:tuples}|} @ { Collection }))))
                                                                  empty {
                                                                  _r1_:address,
                                                                  _r2_:{
                                                                  _r1_:int,
                                                                  _r2_:int,
                                                                  _r3_:int },
                                                                  _r3_:collection {
                                                                  _r1_:{
                                                                  _r1_:int,
                                                                  _r2_:int,
                                                                  _r3_:int },
                                                                  _r2_:int,
                                                                  _r3_:int
                                                                  } @ { Collection }
                                                                  } @ { Collection }))))
                                                                empty {
                                                                _r1_:address,
                                                                _r2_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r3_:collection {
                                                                _r1_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r2_:int,
                                                                _r3_:int
                                                                } @ { Collection }
                                                                } @ { Collection }).groupBy
                                                               ((\_b1_ -> 
                                                                 bind _b1_ as {
                                                                 _r1_:ip,
                                                                 _r2_:vid,
                                                                 _r3_:tuples} in 
                                                                 ip))
                                                               ((\_b2_ ->
                                                               (\_b5_ -> 
                                                                 bind _b2_ as {
                                                                 key:acc_vid,
                                                                 value:acc_tuples} in 
                                                                 bind _b5_ as {
                                                                 _r1_:ip,
                                                                 _r2_:vid,
                                                                 _r3_:tuples} in 
                                                                 {key:acc_vid.combine
                                                                  ({|
                                                                  _r1_:int,
                                                                  _r2_:int,
                                                                  _r3_:int |
                                                                  vid|} @ { Seq }),
                                                                  value:
                                                                  ((acc_tuples.combine
                                                                    tuples).groupBy
                                                                    ((\tuple ->
                                                                     
                                                                    tuple))
                                                                    ((\_ ->
                                                                    (\_ -> 
                                                                    ()))) ()).fold
                                                                    ((\__acc_map ->
                                                                    (\_b3_ -> 
                                                                    bind _b3_ as {
                                                                    key:__1,
                                                                    value:__2} in 
                                                                    __acc_map.combine
                                                                    ({|
                                                                    _r1_:{
                                                                    _r1_:int,
                                                                    _r2_:int,
                                                                    _r3_:int },
                                                                    _r2_:int,
                                                                    _r3_:int |
                                                                    __1|} @ { Collection }))))
                                                                    empty {
                                                                    _r1_:{
                                                                    _r1_:int,
                                                                    _r2_:int,
                                                                    _r3_:int },
                                                                    _r2_:int,
                                                                    _r3_:int
                                                                    } @ { Collection }})))
                                                               {key:empty {
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int
                                                                } @ { Seq },
                                                                value:empty {
                                                                _r1_:{
                                                                _r1_:int,
                                                                _r2_:int,
                                                                _r3_:int },
                                                                _r2_:int,
                                                                _r3_:int
                                                                } @ { Collection }}).iterate
                                                              ((\_b1_ -> 
                                                                bind _b1_ as {
                                                                key:ip,
                                                                value:_b3_} in 
                                                                bind _b3_ as {
                                                                key:vid_send_list,
                                                                value:tuple} in 
                                                              (insert_S_rcv_corrective_s6_m_ATIMESD_mS2,
                                                                ip)<- {
                                                                _r1_:corrective_vid,
                                                                _r2_:vid_send_list,
                                                                _r3_:tuple}))
                                                          else ())))

trigger node_dummy : int
=
  (\x ->  ())

trigger switch_main : {
_r1_:string, _r2_:option { key:int, value:int }, _r3_:option {
key:int, value:int }, _r4_:option { key:int, value:int }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:trigger_id, _r2_:insert_R_args, _r3_:insert_S_args,
                  _r4_:insert_T_args} in if trigger_id == "insert_R"
                                         then
                                           (insert_R, me)<- let insert_R_args_unwrap = case insert_R_args of
                                             { Some x -> x }
                                             { None -> error () } in
                                             insert_R_args_unwrap
                                         else
                                           if trigger_id == "insert_S"
                                           then
                                             (insert_S, me)<- let insert_S_args_unwrap = case insert_S_args of
                                               { Some x -> x }
                                               { None -> error () } in
                                               insert_S_args_unwrap
                                           else
                                             if trigger_id == "insert_T"
                                             then
                                               (insert_T, me)<- let insert_T_args_unwrap = case insert_T_args of
                                                 { Some x -> x }
                                                 { None -> error () } in
                                                 insert_T_args_unwrap
                                             else ())

source s1 : {
_r1_:string, _r2_:option { key:int, value:int }, _r3_:option {
key:int, value:int }, _r4_:option { key:int, value:int }
} = file "rst.csv" k3
feed s1 |> switch_main

