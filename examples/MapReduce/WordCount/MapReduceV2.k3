include "Annotation/Collection.k3"

declare wordsList :          mut collection {word : string} @ { Collection } = { |word : string| "foo", "bar", "baz", "foo", "bar"|} @ { Collection }

declare numOfWords :         mut int = 5
declare currNumWords :       mut int = 0
declare numOfShufflers :     mut int = 3
declare currNumShufflers :   mut int = 0

/* fields for splitting wordsList */
declare count :              mut int = 0
declare mapperLst1 :         mut collection {word : string} @ { Collection }
declare mapperLst2 :         mut collection {word : string} @ { Collection }
declare mapperLst3 :         mut collection {word : string} @ { Collection }
declare master :             immut address = 127.0.0.1:40000
declare mappersList :        mut collection {mapper : address} @ { Collection } = { |mapper : address| 127.0.0.1:51000, 127.0.0.1:52000, 127.0.0.1:53000| } @ { Collection }

declare shufflersTable :     mut collection {shuffler : address, word : string} @ { Collection } = { |shuffler : address, word : string| {shuffler : 127.0.0.1:61000, word : "foo" }, {shuffler : 127.0.0.1:62000, word : "bar" }, {shuffler : 127.0.0.1:63000, word : "baz"} | } @ { Collection }
declare reducer :            immut address = 127.0.0.1:70000

/* wordsLs for node to store local wordLst */
declare localLst :           mut collection {word : string} @ { Collection }

/* shuffer's intermediate wordsMap */
declare wordsMap1 :          mut collection { word : string, count : int } @ { Collection } = { |word : string, count : int| {word : "foo", count : 0} |} @ { Collection }
declare wordsMap2 :          mut collection { word : string, count : int } @ { Collection } = { |word : string, count : int| {word : "bar", count : 0} |} @ { Collection }
declare wordsMap3 :          mut collection { word : string, count : int } @ { Collection } = { |word : string, count : int| {word : "baz", count : 0} |} @ { Collection }
declare finalWordsMap :      mut collection { word : string, count : int } @ { Collection }
declare count1 :             mut int = 0
declare count2 :             mut int = 0
declare count3 :             mut int = 0
/* fields for bootstrap */
declare totalNodes :        immut int = 8
declare currentNodes :      mut int = 0

/* fields for debug */
declare test :              mut int = 0
declare allMappersDone :    mut bool = false
declare done :              mut bool = false
declare wordTest :          mut string = "init"
declare countTest :         mut int = 0

trigger join : () = \_ -> (register, master) <- ()

trigger register : () = \_ -> (
  currentNodes = currentNodes + 1;
  if currentNodes == totalNodes
  then (splitWordLst, me) <- ()
  else ()
)

trigger splitWordLst : ()= \_ -> (
   
  wordsList.iterate (\wordRecord -> (
      count = count + 1;
      if count < 3
	  then mapperLst1.insert{word : wordRecord.word}
	  else if count < 5
	       then mapperLst2.insert{word : wordRecord.word}
	       else mapperLst3.insert{word : wordRecord.word}
    )  
  );
	
  (wordMap, 127.0.0.1:51000) <- mapperLst1;
  (wordMap, 127.0.0.1:52000) <- mapperLst2;
  (wordMap, 127.0.0.1:53000) <- mapperLst3
)  				   

trigger wordMap : (collection { word : string } @ { Collection }) = \wordLst -> (

  localLst = wordLst;
  localLst.iterate (\wordRecord -> 
    if wordRecord.word == "foo"
    then ((shuffle1, 127.0.0.1:61000) <- "word";
	      (shuffle2, 127.0.0.1:62000) <- "none";
	      (shuffle3, 127.0.0.1:63000) <- "none")
  	else if wordRecord.word == "bar"
  	     then ((shuffle1, 127.0.0.1:61000) <- "none";
	           (shuffle2, 127.0.0.1:62000) <- "word";
		       (shuffle3, 127.0.0.1:63000) <- "none")
  	     else ((shuffle1, 127.0.0.1:61000) <- "none";
	           (shuffle2, 127.0.0.1:62000) <- "none";
		       (shuffle3, 127.0.0.1:63000) <- "word")
  );		 
    
  test = localLst.fold(\acc -> (\_ -> acc + 1)) 0 
  
)

trigger shuffle1 : string = \msg -> (
  
  (if msg == "word"
   then (wordsMap1.delete {word : "foo", count : count1}; 
         count1 = count1 + 1;
         wordsMap1.insert {word : "foo", count : count1})
   else ());
  currNumWords = currNumWords + 1;
  if currNumWords == numOfWords
  then (reduce, reducer) <- wordsMap1
  else()		
)

trigger shuffle2 : string =\msg -> (
  (if msg == "word"
   then (wordsMap2.delete {word : "bar", count : count2}; 
         count2 = count2 + 1;
         wordsMap2.insert {word : "bar", count : count2})
   else ());
  currNumWords = currNumWords + 1;
  if currNumWords == numOfWords
  then (reduce, reducer) <- wordsMap2
  else()				 		 
)

trigger shuffle3 : string =\msg -> (
  (if msg == "word"
   then (wordsMap3.delete {word : "baz", count : count3}; 
         count3 = count3 + 1;
         wordsMap3.insert {word : "baz", count : count3})
   else ());
  currNumWords = currNumWords + 1;
  if currNumWords == numOfWords
  then (reduce, reducer) <- wordsMap3
  else()
)

trigger reduce : (collection { word : string, count : int } @ { Collection }) = \wordMap -> (

  finalWordsMap = finalWordsMap.combine wordMap;

  currNumShufflers = currNumShufflers + 1;
  (if currNumShufflers == numOfShufflers
   then done = true
   else ());
   
  finalWordsMap.iterate (\wordRecord -> (
      if wordRecord.word == "foo"   
      then (wordTest = wordRecord.word;   
            countTest = wordRecord.count)
	  else ()
    ) 
  )
	
)


source go : () = value ()

feed go |> join
