declare __map_ids__ : collection { _r1_:int, _r2_:string, _r3_:int
  } @ { Collection } = {| _r1_:int, _r2_:string, _r3_:int |
  {_r1_:1, _r2_:"__SQL_SUM_AGGREGATE_1", _r3_:1},
  {_r1_:2, _r2_:"__SQL_SUM_AGGREGATE_1_mS1", _r3_:2},
  {_r1_:3, _r2_:"__SQL_SUM_AGGREGATE_1_mR1", _r3_:2},
  {_r1_:4, _r2_:"__SQL_SUM_AGGREGATE_2", _r3_:1},
  {_r1_:5, _r2_:"__SQL_SUM_AGGREGATE_2_mS3", _r3_:2},
  {_r1_:6, _r2_:"__SQL_SUM_AGGREGATE_2_mR1", _r3_:2}|} @ { Collection }

declare __vid_counter__ : collection {i:int} @ { Collection } = {|i:int|
  1|} @ { Collection }

declare __epoch__ : collection {i:int} @ { Collection } = {|i:int|
  0|} @ { Collection }

declare __init_vid__ : { _r1_:int, _r2_:int, _r3_:int } =
  {_r1_:0, _r2_:0, _r3_:hash me}

declare __SQL_SUM_AGGREGATE_1 : ind collection {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:int } @ { Collection } = ind {|
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
  {key:__init_vid__, value:0}|} @ { Collection }

declare __SQL_SUM_AGGREGATE_1_mS1 : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare __SQL_SUM_AGGREGATE_1_mR1 : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare __SQL_SUM_AGGREGATE_2 : ind collection {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:int } @ { Collection } = ind {|
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
  {key:__init_vid__, value:0}|} @ { Collection }

declare __SQL_SUM_AGGREGATE_2_mS3 : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare __SQL_SUM_AGGREGATE_2_mR1 : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map___SQL_SUM_AGGREGATE_1_mS1_s0_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map___SQL_SUM_AGGREGATE_2_mS3_s2_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map___SQL_SUM_AGGREGATE_1_mS1_s2_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map___SQL_SUM_AGGREGATE_1_mS1_s4_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map___SQL_SUM_AGGREGATE_2_mS3_s6_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map___SQL_SUM_AGGREGATE_1_mS1_s6_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map___SQL_SUM_AGGREGATE_1_mR1_s8_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map___SQL_SUM_AGGREGATE_1_mR1_s10_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map___SQL_SUM_AGGREGATE_2_mR1_s10_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map___SQL_SUM_AGGREGATE_1_mR1_s12_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map___SQL_SUM_AGGREGATE_1_mR1_s14_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare map___SQL_SUM_AGGREGATE_2_mR1_s14_buf : ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare __stmt_cntrs__ : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare log__master : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare log_insert_S : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare log_delete_S : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare log_insert_R : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare log_delete_R : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }

declare vid_eq : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in l0 == r0 and (l1 == r1 and l2
    == r2))

declare vid_neq : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in not (l0 == r0 and (l1 == r1 and
    l2 == r2)))

declare vid_lt : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in l0 < r0 or (l0 == r0 and (l1 <
    r1 or (l1 == r1 and l2 < r2))))

declare vid_gt : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in l0 > r0 or (l0 == r0 and (l1 >
    r1 or (l1 == r1 and l2 > r2))))

declare vid_leq : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in not (l0 > r0 or (l0 == r0 and
    (l1 > r1 or (l1 == r1 and l2 > r2)))))

declare vid_geq : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in not (l0 < r0 or (l0 == r0 and
    (l1 < r1 or (l1 == r1 and l2 < r2)))))

declare frontier_int : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:int } @ { Collection }
  } -> collection { key:{ _r1_:int, _r2_:int, _r3_:int }, value:int
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {key:vid, value:input_map} in 
    bind input_map.fold
           ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
             bind _b5_ as {key:map_vid, value:__map_val} in 
             if vid_lt {key:map_vid, value:vid}
             then
               if vid_eq {key:map_vid, value:max_vid}
               then
                 {key:({| key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
                  {key:map_vid, value:__map_val}|} @ { Collection }).combine
                  acc, value:max_vid}
               else
                 if vid_gt {key:map_vid, value:max_vid}
                 then
                   {key:{| key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
                    {key:map_vid, value:__map_val}|} @ { Collection },
                    value:map_vid}
                 else {key:acc, value:max_vid}
             else {key:acc, value:max_vid})))
           {key:empty { key:{ _r1_:int, _r2_:int, _r3_:int }, value:int
            } @ { Collection }, value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1,
                                                                    value:__2} in 
    __1)

declare frontier_int_int : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
  } -> collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {key:vid, value:input_map} in 
    (input_map.groupBy
       ((\_b1_ -> 
         bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in __map_0))
       ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
         bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
         if vid_lt {key:map_vid, value:vid}
         then
           if vid_eq {key:map_vid, value:max_vid}
           then
             {key:({| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
              |
              {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Collection }).combine
              acc, value:max_vid}
           else
             if vid_gt {key:map_vid, value:max_vid}
             then
               {key:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
                {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Collection },
                value:map_vid}
             else {key:acc, value:max_vid}
         else {key:acc, value:max_vid})))
       {key:empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
        } @ { Collection }, value:{_r1_:0, _r2_:0, _r3_:0}}).fold
      ((\__acc_ext -> (\_b3_ -> 
        bind _b3_ as {key:_, value:_b4_} in 
        bind _b4_ as {key:project, value:_} in __acc_ext.combine project)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Collection })

declare log_read_geq : { _r1_:int, _r2_:int, _r3_:int } -> collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
  } @ { Collection } = (\vid -> 
    (log__master.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:vid2, _r2_:trig, _r3_:stmt} in 
        vid_geq {key:vid2, value:vid}))))

declare check_and_update_stmt_cntr_index : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:int } -> bool = (\_b1_ -> 
    bind _b1_ as {key:vid, value:stmt_id} in 
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == stmt_id)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Collection }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id))).peek ()) of { Some x -> x }
          { None -> error () }) (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:stmt_id, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id))).peek ()) of { Some x -> x } { None -> error () }
          == {_r1_:vid, _r2_:stmt_id, _r3_:0}
        then true
        else false
        )
    else ( __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:-1};false ))

declare add_delta_to_int : {
  _r1_:ind collection { key:{ _r1_:int, _r2_:int, _r3_:int }, value:int
  } @ { Collection }, _r2_:bool, _r3_:{ _r1_:int, _r2_:int, _r3_:int },
  _r4_:collection { key:{ _r1_:int, _r2_:int, _r3_:int }, value:int
  } @ { Collection } } -> () = (\_b1_ -> 
    bind _b1_ as {_r1_:target_map, _r2_:corrective, _r3_:min_vid,
                  _r4_:delta_tuples} in (
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {key:vid, value:__map_val} in 
          let lookup_value =
            if corrective
            then (bind target_map as ind __x in __x).filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == vid))
            else empty { key:{ _r1_:int, _r2_:int, _r3_:int }, value:int
              } @ { Collection } in
          if not (lookup_value == empty {
            key:{ _r1_:int, _r2_:int, _r3_:int }, value:int } @ { Collection })
          then
            let update_value = __map_val + bind case (lookup_value.peek 
              ()) of { Some x -> x }
              { None -> error () } as {key:__1, value:__2} in __2 in
            (bind
              target_map
              as ind __x
              in __x).insert
              {key:vid, value:update_value}
          else
            let lookup_value =
              frontier_int {key:vid, value:bind target_map as ind __x in __x} in
            let update_value = __map_val +
              if lookup_value == empty {
                key:{ _r1_:int, _r2_:int, _r3_:int }, value:int
                } @ { Collection }
              then 0
              else bind case (lookup_value.peek ()) of { Some x -> x }
                { None -> error () } as {key:__1, value:__2} in __2 in
            (bind
              target_map
              as ind __x
              in __x).insert
              {key:vid, value:update_value}));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {key:vid_arg, value:__arg_val} in 
          let filtered =
            ((bind
              target_map
              as ind __x
              in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {key:vid, value:__map_val} in vid > min_vid))) in
          filtered.iterate
            ((\_b1_ -> 
              bind _b1_ as {key:vid, value:__map_val} in 
              (bind
                target_map
                as ind __x
                in __x).update
                {key:vid, value:__map_val}
                {key:vid, value:__map_val + __arg_val}))))
      ))

declare add_delta_to_int_int : {
  _r1_:ind collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection },
  _r2_:bool, _r3_:{ _r1_:int, _r2_:int, _r3_:int }, _r4_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
  } -> () = (\_b1_ -> 
    bind _b1_ as {_r1_:target_map, _r2_:corrective, _r3_:min_vid,
                  _r4_:delta_tuples} in (
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
          let lookup_value =
            if corrective
            then (bind target_map as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid
                and _r2_ == __map_0))
            else empty {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
              } @ { Collection } in
          if not (lookup_value == empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Collection })
          then
            let update_value = __map_val + bind case (lookup_value.peek 
              ()) of { Some x -> x }
              { None -> error () } as {_r1_:__1, _r2_:__2, _r3_:__3} in __3 in
            (bind
              target_map
              as ind __x
              in __x).insert
              {_r1_:vid, _r2_:__map_0, _r3_:update_value}
          else
            let lookup_value =
              frontier_int_int
                {key:vid, value:(bind target_map as ind __x in __x).filter
                 ((\_b1_ -> 
                   bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                   __map_0))} in
            let update_value = __map_val +
              if lookup_value == empty {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                } @ { Collection }
              then 0
              else bind case (lookup_value.peek ()) of { Some x -> x }
                { None -> error () } as {_r1_:__1, _r2_:__2, _r3_:__3} in __3 in
            (bind
              target_map
              as ind __x
              in __x).insert
              {_r1_:vid, _r2_:__map_0, _r3_:update_value}));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          let filtered =
            (((bind
              target_map
              as ind __x
              in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                __arg_0))).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
                min_vid))) in
          filtered.iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              (bind
                target_map
                as ind __x
                in __x).update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare log_master_write : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = (\_b1_ ->
  
    bind _b1_ as {_r1_:vid, _r2_:trig_id, _r3_:stmt_id} in 
    log__master.insert {_r1_:vid, _r2_:trig_id, _r3_:stmt_id})

declare log_write_insert_S : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = (\_b1_ ->
  
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in 
    log_insert_S.insert {_r1_:vid, _r2_:S_B, _r3_:S_C})

declare log_write_delete_S : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = (\_b1_ ->
  
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in 
    log_delete_S.insert {_r1_:vid, _r2_:S_B, _r3_:S_C})

declare log_write_insert_R : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = (\_b1_ ->
  
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in 
    log_insert_R.insert {_r1_:vid, _r2_:R_A, _r3_:R_B})

declare log_write_delete_R : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = (\_b1_ ->
  
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in 
    log_delete_R.insert {_r1_:vid, _r2_:R_A, _r3_:R_B})

declare log_get_bound_insert_S : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } = (\vid -> 
    case ((log_insert_S.filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid))).peek
    ()) of { Some x -> x } { None -> error () })

declare log_get_bound_delete_S : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } = (\vid -> 
    case ((log_delete_S.filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid))).peek
    ()) of { Some x -> x } { None -> error () })

declare log_get_bound_insert_R : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } = (\vid -> 
    case ((log_insert_R.filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid))).peek
    ()) of { Some x -> x } { None -> error () })

declare log_get_bound_delete_R : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } = (\vid -> 
    case ((log_delete_R.filter
    ((\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid))).peek
    ()) of { Some x -> x } { None -> error () })

declare node_ring : collection {
  _r1_:address, _r2_:string, _r3_:string, _r4_:int } @ { Seq }

declare replicas : collection {i:int} @ { Set } = {|i:int| 8|} @ { Set }

declare set_replicas : int -> () = (\n -> 
    replicas.update
      ({i:case (replicas.peek ()) of { Some x -> x.i } { None -> error () }})
      {i:n})

declare add_node : { _r1_:address, _r2_:string, _r3_:string } -> () = (\_b1_ ->
  
    bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name} in 
    let rng =
      range (case (replicas.peek ()) of { Some x -> x.i } { None -> error () }) in
    let new_elems =
      rng.fold
        ((\__acc_map -> (\_b3_ -> 
          bind _b3_ as {i:i} in __acc_map.combine
          ({| _r1_:address, _r2_:string, _r3_:string, _r4_:int |
          {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash (i + hash addr)}|} @ { Seq }))))
        empty { _r1_:address, _r2_:string, _r3_:string, _r4_:int } @ { Seq } in
    (
      new_elems.iterate ((\x ->  node_ring.insert x));
      let temp_ring = node_ring.sort
        ((\_b2_ ->
        bind _b2_ as {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash1} in (\_b7_ ->
        
          bind _b7_ as {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash2} in 
          if hash1 > hash2 then -1 else 1))) in
      (
        node_ring.iterate ((\node ->  node_ring.erase node));
        temp_ring.iterate ((\node ->  node_ring.insert node))
        )
      ))

declare remove_node : { _r1_:address, _r2_:string, _r3_:string } -> () =
  (\_b1_ -> 
    bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name} in 
    let nodes_to_delete = node_ring.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in (_r1_ ==
        addr and _r3_ == name) and _r2_ == _role_)) in
    nodes_to_delete.iterate ((\x ->  node_ring.erase x)))

declare get_ring_node : { key:int, value:int } -> address = (\_b1_ -> 
    bind _b1_ as {key:data, value:max_val} in 
    let scaled =
      truncate
        (real_of_int (get_max_int ()) * (real_of_int data /
        real_of_int max_val)) in
    let results =
      (node_ring.filter
        ((\_b1_ -> 
          bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash} in hash
          >= scaled))) in
    bind if results == empty { _r1_:address, _r2_:string, _r3_:string, _r4_:int
           } @ { Seq }
         then case (node_ring.peek ()) of { Some x -> x } { None -> error () }
         else case (results.peek ()) of { Some x -> x } { None -> error () } as {
    _r1_:addr, _r2_:_, _r3_:_, _r4_:_} in addr)

declare get_all_uniq_nodes : () -> collection {i:address} @ { Collection } =
  (\_ -> 
    (node_ring.groupBy
       ((\_b1_ -> 
         bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash} in addr))
       ((\_ -> (\_ ->  ()))) empty {i:address} @ { Seq }).fold
      ((\__acc_map -> (\_b3_ -> 
        bind _b3_ as {key:__1, value:__2} in __acc_map.combine
        ({|i:address| __1|} @ { Collection }))))
      empty {i:address} @ { Collection })

declare pmap_data : collection {
  key:int, value:collection { key:int, value:int } @ { Seq } } @ { Seq } =
  pmap_input.fold
    ((\__acc_map -> (\_b3_ -> 
      bind _b3_ as {key:map_name, value:map_types} in __acc_map.combine
      ({| key:int, value:collection { key:int, value:int } @ { Seq } |
      {key:bind case ((__map_ids__.filter
       ((\_b1_ -> 
         bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == map_name))).peek
       ()) of { Some x -> x }
       { None -> error () } as {_r1_:__1, _r2_:__2, _r3_:__3} in __1,
       value:map_types}|} @ { Seq })))) empty {
    key:int, value:collection { key:int, value:int } @ { Seq } } @ { Seq }

declare calc_dim_bounds : collection { key:int, value:int } @ { Seq } -> {
  key:collection { key:int, value:int } @ { Seq }, value:int } = (\pmap -> 
    pmap.fold
      ((\_b2_ -> bind _b2_ as {key:xs, value:acc_size} in (\_b5_ -> 
        bind _b5_ as {key:pos, value:bin_size} in 
        {key:xs.combine
         ({| key:int, value:int | {key:pos, value:acc_size}|} @ { Seq }),
         value:bin_size * acc_size})))
      {key:empty { key:int, value:int } @ { Seq }, value:1})

declare route_to_int : { key:int, value:option int
  } -> collection {i:address} @ { Collection } = (\_b1_ -> 
    bind _b1_ as {key:map_id, value:key_0} in 
    let pmap = bind case ((pmap_data.filter
      ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == map_id))).peek
      ()) of { Some x -> x } { None -> error () } as {key:__1, value:__2} in 
      __2 in
    if pmap == empty { key:int, value:int } @ { Seq }
    then get_all_uniq_nodes ()
    else bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in 
      let bound_bucket =
        (if key_0 == None immut
         then 0
         else
           let pmap_slice = pmap.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0)) in
           if pmap_slice == empty { key:int, value:int } @ { Seq }
           then 0
           else let key_0_unwrap = case key_0 of { Some x -> x }
             { None -> error () } in
             let value = hash key_0_unwrap % bind case (pmap_slice.peek 
               ()) of { Some x -> x }
               { None -> error () } as {key:__1, value:__2} in __2 in value *
             bind case ((dim_bounds.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).peek
             ()) of { Some x -> x }
             { None -> error () } as {key:__1, value:__2} in __2) + 0 in
      let free_dims =
        (if key_0 != None immut
         then empty { key:int, value:int } @ { Seq }
         else pmap.filter
           ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).combine
        empty { key:int, value:int } @ { Seq } in
      let free_domains =
        free_dims.fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {key:i, value:b_i} in __acc_map.combine
            ({| key:int, value:collection {i:int} @ { Seq } |
            {key:i, value:range b_i}|} @ { Seq })))) empty {
          key:int, value:collection {i:int} @ { Seq } } @ { Seq } in
      let free_cart_prod =
        free_domains.fold
          ((\prev_cart_prod -> (\_b3_ -> 
            bind _b3_ as {key:i, value:domain} in 
            domain.fold
              ((\__acc_ext -> (\_b3_ -> 
                bind _b3_ as {i:domain_element} in __acc_ext.combine
                (if prev_cart_prod == empty {i:collection { key:int, value:int
                   } @ { Seq }} @ { Seq }
                 then {|i:collection { key:int, value:int } @ { Seq }| {|
                   key:int, value:int |
                   {key:i, value:domain_element}|} @ { Seq }|} @ { Seq }
                 else
                   prev_cart_prod.fold
                     ((\__acc_map -> (\_b3_ -> 
                       bind _b3_ as {i:rest_tup} in __acc_map.combine
                       ({|i:collection { key:int, value:int } @ { Seq }|
                       rest_tup.combine
                       ({| key:int, value:int |
                       {key:i, value:domain_element}|} @ { Seq })|} @ { Seq }))))
                     empty {i:collection { key:int, value:int
                     } @ { Seq }} @ { Seq })))) empty {i:collection {
              key:int, value:int } @ { Seq }} @ { Seq })))
          empty {i:collection { key:int, value:int } @ { Seq }} @ { Seq } in
      let sorted_ip_list =
        (free_cart_prod.fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {i:free_bucket} in __acc_map.combine
             ({|i:address|
             get_ring_node
               {key:free_bucket.fold
                      ((\acc -> (\_b3_ -> 
                        bind _b3_ as {key:i, value:val} in acc + (val *
                        bind case ((dim_bounds.filter
                        ((\_b1_ -> 
                          bind _b1_ as {key:key, value:value} in key == i))).peek
                        ()) of { Some x -> x }
                        { None -> error () } as {key:__1, value:__2} in __2))))
                      bound_bucket, value:max_val}|} @ { Seq }))))
           empty {i:address} @ { Seq }).groupBy
          ((\_b1_ ->  bind _b1_ as {i:ip} in ip)) ((\_ -> (\_ ->  ()))) () in
      if sorted_ip_list == empty { key:address, value:() } @ { Collection }
      then {|i:address|
        get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
      else
        sorted_ip_list.fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {key:__1, value:__2} in __acc_map.combine
            ({|i:address| __1|} @ { Collection }))))
          empty {i:address} @ { Collection })

declare route_to_ : { key:int, value:()
  } -> collection {i:address} @ { Collection } = (\_b1_ -> 
    bind _b1_ as {key:_, value:_} in {|i:address|
    get_ring_node {key:1, value:1}|} @ { Collection })

declare shuffle___SQL_SUM_AGGREGATE_1_mS1_to___SQL_SUM_AGGREGATE_1 : {
  _r1_:(), _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection },
  _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:_, _r2_:tuples, _r3_:shuffle_on_empty} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_ {key:1, value:()}).fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {i:ip} in __acc_map.combine
            ({|
            key:address, value:collection {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Collection } |
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection }}|} @ { Collection })))) empty {
          key:address, value:collection {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection } } @ { Collection }
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
        } @ { Collection } } @ { Collection } in
    (all_targets.combine
      (tuples.fold
         ((\__acc_ext -> (\r_tuple -> 
           __acc_ext.combine
           (bind r_tuple as {_r1_:rkey_0, _r2_:rkey_1, _r3_:rkey_2} in 
           (route_to_ {key:1, value:()}).fold
             ((\__acc_map -> (\_b3_ -> 
               bind _b3_ as {i:ip} in __acc_map.combine
               ({|
               key:address, value:collection {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
               } @ { Collection } |
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
                r_tuple|} @ { Collection }}|} @ { Collection })))) empty {
             key:address, value:collection {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection } } @ { Collection })))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Collection })

declare shuffle___SQL_SUM_AGGREGATE_2_mS3_to___SQL_SUM_AGGREGATE_2 : {
  _r1_:(), _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection },
  _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:_, _r2_:tuples, _r3_:shuffle_on_empty} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_ {key:4, value:()}).fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {i:ip} in __acc_map.combine
            ({|
            key:address, value:collection {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Collection } |
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection }}|} @ { Collection })))) empty {
          key:address, value:collection {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection } } @ { Collection }
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
        } @ { Collection } } @ { Collection } in
    (all_targets.combine
      (tuples.fold
         ((\__acc_ext -> (\r_tuple -> 
           __acc_ext.combine
           (bind r_tuple as {_r1_:rkey_0, _r2_:rkey_1, _r3_:rkey_2} in 
           (route_to_ {key:4, value:()}).fold
             ((\__acc_map -> (\_b3_ -> 
               bind _b3_ as {i:ip} in __acc_map.combine
               ({|
               key:address, value:collection {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
               } @ { Collection } |
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
                r_tuple|} @ { Collection }}|} @ { Collection })))) empty {
             key:address, value:collection {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection } } @ { Collection })))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Collection })

declare shuffle___SQL_SUM_AGGREGATE_1_mS1_to___SQL_SUM_AGGREGATE_2 : {
  _r1_:(), _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection },
  _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:_, _r2_:tuples, _r3_:shuffle_on_empty} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_ {key:4, value:()}).fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {i:ip} in __acc_map.combine
            ({|
            key:address, value:collection {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Collection } |
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection }}|} @ { Collection })))) empty {
          key:address, value:collection {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection } } @ { Collection }
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
        } @ { Collection } } @ { Collection } in
    (all_targets.combine
      (tuples.fold
         ((\__acc_ext -> (\r_tuple -> 
           __acc_ext.combine
           (bind r_tuple as {_r1_:rkey_0, _r2_:rkey_1, _r3_:rkey_2} in 
           (route_to_ {key:4, value:()}).fold
             ((\__acc_map -> (\_b3_ -> 
               bind _b3_ as {i:ip} in __acc_map.combine
               ({|
               key:address, value:collection {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
               } @ { Collection } |
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
                r_tuple|} @ { Collection }}|} @ { Collection })))) empty {
             key:address, value:collection {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection } } @ { Collection })))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Collection })

declare shuffle___SQL_SUM_AGGREGATE_1_mR1_to___SQL_SUM_AGGREGATE_1 : {
  _r1_:(), _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection },
  _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:_, _r2_:tuples, _r3_:shuffle_on_empty} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_ {key:1, value:()}).fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {i:ip} in __acc_map.combine
            ({|
            key:address, value:collection {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Collection } |
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection }}|} @ { Collection })))) empty {
          key:address, value:collection {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection } } @ { Collection }
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
        } @ { Collection } } @ { Collection } in
    (all_targets.combine
      (tuples.fold
         ((\__acc_ext -> (\r_tuple -> 
           __acc_ext.combine
           (bind r_tuple as {_r1_:rkey_0, _r2_:rkey_1, _r3_:rkey_2} in 
           (route_to_ {key:1, value:()}).fold
             ((\__acc_map -> (\_b3_ -> 
               bind _b3_ as {i:ip} in __acc_map.combine
               ({|
               key:address, value:collection {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
               } @ { Collection } |
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
                r_tuple|} @ { Collection }}|} @ { Collection })))) empty {
             key:address, value:collection {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection } } @ { Collection })))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Collection })

declare shuffle___SQL_SUM_AGGREGATE_2_mR1_to___SQL_SUM_AGGREGATE_2 : {
  _r1_:(), _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection },
  _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:_, _r2_:tuples, _r3_:shuffle_on_empty} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_ {key:4, value:()}).fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {i:ip} in __acc_map.combine
            ({|
            key:address, value:collection {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Collection } |
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection }}|} @ { Collection })))) empty {
          key:address, value:collection {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection } } @ { Collection }
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
        } @ { Collection } } @ { Collection } in
    (all_targets.combine
      (tuples.fold
         ((\__acc_ext -> (\r_tuple -> 
           __acc_ext.combine
           (bind r_tuple as {_r1_:rkey_0, _r2_:rkey_1, _r3_:rkey_2} in 
           (route_to_ {key:4, value:()}).fold
             ((\__acc_map -> (\_b3_ -> 
               bind _b3_ as {i:ip} in __acc_map.combine
               ({|
               key:address, value:collection {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
               } @ { Collection } |
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
                r_tuple|} @ { Collection }}|} @ { Collection })))) empty {
             key:address, value:collection {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection } } @ { Collection })))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Collection })

declare shuffle___SQL_SUM_AGGREGATE_1_mR1_to___SQL_SUM_AGGREGATE_2 : {
  _r1_:(), _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection },
  _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:_, _r2_:tuples, _r3_:shuffle_on_empty} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_ {key:4, value:()}).fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {i:ip} in __acc_map.combine
            ({|
            key:address, value:collection {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Collection } |
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection }}|} @ { Collection })))) empty {
          key:address, value:collection {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection } } @ { Collection }
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
        } @ { Collection } } @ { Collection } in
    (all_targets.combine
      (tuples.fold
         ((\__acc_ext -> (\r_tuple -> 
           __acc_ext.combine
           (bind r_tuple as {_r1_:rkey_0, _r2_:rkey_1, _r3_:rkey_2} in 
           (route_to_ {key:4, value:()}).fold
             ((\__acc_map -> (\_b3_ -> 
               bind _b3_ as {i:ip} in __acc_map.combine
               ({|
               key:address, value:collection {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
               } @ { Collection } |
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
                r_tuple|} @ { Collection }}|} @ { Collection })))) empty {
             key:address, value:collection {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection } } @ { Collection })))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
         } @ { Collection } } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Collection })

declare init : () = (
    my_peers.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name} in 
        if _role_ != "switch"
        then add_node {_r1_:addr, _r2_:_role_, _r3_:name}
        else ()))
    )

declare filter_corrective_list : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection { key:int, value:int
  } @ { Collection } } -> collection {
  key:int, value:collection { _r1_:int, _r2_:int, _r3_:int } @ { Seq }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {key:request_vid, value:trig_stmt_list} in 
    let log_entries = log_read_geq request_vid in
    ((log_entries.fold
        ((\__acc_map -> (\_b3_ -> 
          bind _b3_ as {_r1_:vid, _r2_:trig_id, _r3_:stmt_id} in 
          __acc_map.combine
          ({| key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
          {key:vid, value:stmt_id}|} @ { Collection })))) empty {
        key:{ _r1_:int, _r2_:int, _r3_:int }, value:int } @ { Collection }).sort
      ((\_b2_ -> bind _b2_ as {key:vid1, value:stmt1} in (\_b5_ -> 
        bind _b5_ as {key:vid2, value:stmt2} in 
        if vid_lt {key:vid1, value:vid2} then -1 else 1)))).groupBy
      ((\_b1_ ->  bind _b1_ as {key:_, value:stmt_id} in stmt_id))
      ((\vid_list -> (\_b3_ -> 
        bind _b3_ as {key:vid, value:_} in vid_list.combine
        ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq })))) empty {
      _r1_:int, _r2_:int, _r3_:int } @ { Seq })

trigger insert_S : {
key:int, value:int
}
= (\_b1_ ->

  bind _b1_ as {key:S_B, value:S_C} in (
    let vid =
      {_r1_:case (__epoch__.peek ()) of { Some x -> x.i } { None -> error () },
       _r2_:case (__vid_counter__.peek ()) of { Some x -> x.i }
       { None -> error () }, _r3_:hash me} in
    (
      (insert_S_send_fetch, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C};
      __vid_counter__.update
        ({i:case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
        ({i:1 + case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
      )
    ))

trigger insert_S_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    (route_to_int {key:3, value:Some S_B}).iterate
      ((\_b1_ -> 
        bind _b1_ as {i:ip} in 
        (insert_S_do_complete_s1, ip)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}));
    (route_to_int {key:6, value:Some S_B}).iterate
      ((\_b1_ -> 
        bind _b1_ as {i:ip} in 
        (insert_S_do_complete_s3, ip)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}));
    ((((empty {
        _r1_:address, _r2_:int, _r3_:int
        } @ { Collection }).combine
        (let sender_count =
           (route_to_int {key:2, value:Some S_B}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle___SQL_SUM_AGGREGATE_1_mS1_to___SQL_SUM_AGGREGATE_1
            {_r1_:(), _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection }, _r3_:true}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
             ({| _r1_:address, _r2_:int, _r3_:int |
             {_r1_:ip, _r2_:0, _r3_:sender_count}|} @ { Collection }))))
           empty { _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
        (let sender_count =
           (route_to_int {key:5, value:Some S_B}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle___SQL_SUM_AGGREGATE_2_mS3_to___SQL_SUM_AGGREGATE_2
            {_r1_:(), _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection }, _r3_:true}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
             ({| _r1_:address, _r2_:int, _r3_:int |
             {_r1_:ip, _r2_:2, _r3_:sender_count}|} @ { Collection }))))
           empty { _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
        (let sender_count =
           (route_to_int {key:2, value:Some S_B}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        (shuffle___SQL_SUM_AGGREGATE_1_mS1_to___SQL_SUM_AGGREGATE_2
           {_r1_:(), _r2_:empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Collection }, _r3_:true}).fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
            ({| _r1_:address, _r2_:int, _r3_:int |
            {_r1_:ip, _r2_:2, _r3_:sender_count}|} @ { Collection })))) empty {
          _r1_:address, _r2_:int, _r3_:int } @ { Collection })))).groupBy
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in 
          {key:ip, value:stmt_id})) ((\acc -> (\_b3_ -> 
          bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupBy
       ((\_b1_ -> 
         bind _b1_ as {key:_b2_, value:count} in 
         bind _b2_ as {key:ip, value:stmt_id} in ip)) ((\acc -> (\_b3_ -> 
         bind _b3_ as {key:ip_and_stmt_id, value:count} in 
         bind ip_and_stmt_id as {key:ip, value:stmt_id} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:count}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_id_cnt_list} in (
          (insert_S_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list, _r3_:vid,
                                    _r4_:S_B, _r5_:S_C}
          )));
    ((((route_to_int {key:2, value:Some S_B}).fold
         ((\__acc_map -> (\_b3_ -> 
           bind _b3_ as {i:ip} in __acc_map.combine
           ({| _r1_:int, _r2_:int, _r3_:address |
           {_r1_:2, _r2_:2, _r3_:ip}|} @ { Collection })))) empty {
         _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
       (((route_to_int {key:5, value:Some S_B}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {i:ip} in __acc_map.combine
             ({| _r1_:int, _r2_:int, _r3_:address |
             {_r1_:2, _r2_:5, _r3_:ip}|} @ { Collection })))) empty {
           _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
       (((route_to_int {key:2, value:Some S_B}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {i:ip} in __acc_map.combine
             ({| _r1_:int, _r2_:int, _r3_:address |
             {_r1_:0, _r2_:2, _r3_:ip}|} @ { Collection })))) empty {
           _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
       empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection }))).groupBy
       ((\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip))
       ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:map_id}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_map_ids} in 
        (insert_S_rcv_fetch, ip)<- {_r1_:stmt_map_ids, _r2_:vid, _r3_:S_B,
                                    _r4_:S_C}))
    ))

trigger insert_S_rcv_put : {
_r1_:address, _r2_:collection { key:int, value:int } @ { Collection }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid, _r4_:S_B,
                _r5_:S_C} in (
    stmt_id_cnt_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:count} in 
        if __stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }
        then bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:_, _r2_:_, _r3_:old_count} in 
          let new_count = old_count + count in (
            __stmt_cntrs__.update
              {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
              {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
            if new_count == 0
            then
              if stmt_id == 3
              then
                (insert_S_do_complete_s3, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
              else
                if stmt_id == 2
                then
                  (insert_S_do_complete_s2, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
                else
                  if stmt_id == 1
                  then
                    (insert_S_do_complete_s1, me)<- {_r1_:vid, _r2_:S_B,
                                                     _r3_:S_C}
                  else
                    if stmt_id == 0
                    then
                      (insert_S_do_complete_s0, me)<- {_r1_:vid, _r2_:S_B,
                                                       _r3_:S_C}
                    else ()
            else ()
            )
        else __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count}))
    ))

trigger insert_S_rcv_fetch : {
_r1_:collection { key:int, value:int } @ { Collection }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_insert_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    stmts_and_map_ids.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:map_id} in 
        if stmt_id == 0
        then
          if map_id == 2
          then
            (insert_S_send_push_s0_m___SQL_SUM_AGGREGATE_1_mS1, me)<- {
              _r1_:vid, _r2_:S_B, _r3_:S_C}
          else ()
        else
          if stmt_id == 2
          then
            if map_id == 5
            then
              (insert_S_send_push_s2_m___SQL_SUM_AGGREGATE_2_mS3, me)<- {
                _r1_:vid, _r2_:S_B, _r3_:S_C}
            else
              if map_id == 2
              then
                (insert_S_send_push_s2_m___SQL_SUM_AGGREGATE_1_mS1, me)<- {
                  _r1_:vid, _r2_:S_B, _r3_:S_C}
              else ()
          else ()))
    ))

trigger insert_S_send_push_s0_m___SQL_SUM_AGGREGATE_1_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    log_master_write {_r1_:vid, _r2_:0, _r3_:0};
    (shuffle___SQL_SUM_AGGREGATE_1_mS1_to___SQL_SUM_AGGREGATE_1
       {_r1_:(),
        _r2_:frontier_int_int
               {key:vid, value:(bind __SQL_SUM_AGGREGATE_1_mS1 as ind __x
                in __x).filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B))},
        _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_S_rcv_push_s0_m___SQL_SUM_AGGREGATE_1_mS1, ip)<- {_r1_:tuples,
                                                                  _r2_:vid,
                                                                  _r3_:S_B,
                                                                  _r4_:S_C}))
    ))

trigger insert_S_send_push_s2_m___SQL_SUM_AGGREGATE_2_mS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    log_master_write {_r1_:vid, _r2_:0, _r3_:2};
    (shuffle___SQL_SUM_AGGREGATE_2_mS3_to___SQL_SUM_AGGREGATE_2
       {_r1_:(),
        _r2_:frontier_int_int
               {key:vid, value:(bind __SQL_SUM_AGGREGATE_2_mS3 as ind __x
                in __x).filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B))},
        _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_S_rcv_push_s2_m___SQL_SUM_AGGREGATE_2_mS3, ip)<- {_r1_:tuples,
                                                                  _r2_:vid,
                                                                  _r3_:S_B,
                                                                  _r4_:S_C}))
    ))

trigger insert_S_send_push_s2_m___SQL_SUM_AGGREGATE_1_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    log_master_write {_r1_:vid, _r2_:0, _r3_:2};
    (shuffle___SQL_SUM_AGGREGATE_1_mS1_to___SQL_SUM_AGGREGATE_2
       {_r1_:(),
        _r2_:frontier_int_int
               {key:vid, value:(bind __SQL_SUM_AGGREGATE_1_mS1 as ind __x
                in __x).filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B))},
        _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_S_rcv_push_s2_m___SQL_SUM_AGGREGATE_1_mS1, ip)<- {_r1_:tuples,
                                                                  _r2_:vid,
                                                                  _r3_:S_B,
                                                                  _r4_:S_C}))
    ))

trigger insert_S_rcv_push_s0_m___SQL_SUM_AGGREGATE_1_mS1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_insert_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    tuples.iterate
      ((\tuple -> 
        if (bind map___SQL_SUM_AGGREGATE_1_mS1_s0_buf as ind __x in __x).filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }
        then
          (bind
            map___SQL_SUM_AGGREGATE_1_mS1_s0_buf
            as ind __x
            in __x).update
            (case (((bind map___SQL_SUM_AGGREGATE_1_mS1_s0_buf as ind __x
            in __x).filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else
          (bind
            map___SQL_SUM_AGGREGATE_1_mS1_s0_buf
            as ind __x
            in __x).insert
            tuple));
    if check_and_update_stmt_cntr_index {key:vid, value:0}
    then (insert_S_do_complete_s0, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
    else ()
    ))

trigger insert_S_rcv_push_s2_m___SQL_SUM_AGGREGATE_2_mS3 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_insert_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    tuples.iterate
      ((\tuple -> 
        if (bind map___SQL_SUM_AGGREGATE_2_mS3_s2_buf as ind __x in __x).filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }
        then
          (bind
            map___SQL_SUM_AGGREGATE_2_mS3_s2_buf
            as ind __x
            in __x).update
            (case (((bind map___SQL_SUM_AGGREGATE_2_mS3_s2_buf as ind __x
            in __x).filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else
          (bind
            map___SQL_SUM_AGGREGATE_2_mS3_s2_buf
            as ind __x
            in __x).insert
            tuple));
    if check_and_update_stmt_cntr_index {key:vid, value:2}
    then (insert_S_do_complete_s2, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
    else ()
    ))

trigger insert_S_rcv_push_s2_m___SQL_SUM_AGGREGATE_1_mS1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_insert_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    tuples.iterate
      ((\tuple -> 
        if (bind map___SQL_SUM_AGGREGATE_1_mS1_s2_buf as ind __x in __x).filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }
        then
          (bind
            map___SQL_SUM_AGGREGATE_1_mS1_s2_buf
            as ind __x
            in __x).update
            (case (((bind map___SQL_SUM_AGGREGATE_1_mS1_s2_buf as ind __x
            in __x).filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else
          (bind
            map___SQL_SUM_AGGREGATE_1_mS1_s2_buf
            as ind __x
            in __x).insert
            tuple));
    if check_and_update_stmt_cntr_index {key:vid, value:2}
    then (insert_S_do_complete_s2, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
    else ()
    ))

trigger insert_S_do_complete_s0 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in 
    let __prod_ret__1 =
      (let wrapped_lookup_value =
         (frontier_int_int
            {key:vid, value:(bind map___SQL_SUM_AGGREGATE_1_mS1_s0_buf
             as ind __x in __x).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B))}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
             __acc_map.combine
             ({| key:int, value:int |
             {key:__map_0, value:__map_val}|} @ { Collection })))) empty {
           key:int, value:int } @ { Collection } in
      if wrapped_lookup_value == empty { key:int, value:int } @ { Collection }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) * S_C in (
      add_delta_to_int
        {_r1_:__SQL_SUM_AGGREGATE_1, _r2_:false, _r3_:vid, _r4_:{|
         key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
         {key:vid, value:__prod_ret__1}|} @ { Collection }}
      ))

trigger insert_S_do_complete_s1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in let __val_ret__2 = S_C in (
      add_delta_to_int_int
        {_r1_:__SQL_SUM_AGGREGATE_1_mR1, _r2_:false, _r3_:vid, _r4_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:S_B, _r3_:__val_ret__2}|} @ { Collection }};
      (__SQL_SUM_AGGREGATE_1_mR1_send_correctives, me)<- {key:vid, value:{|
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int |
                                                          {_r1_:vid, _r2_:S_B,
                                                           _r3_:__val_ret__2}|} @ { Collection }}
      ))

trigger insert_S_do_complete_s2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in 
    let __sum_ret__1 =
      (let wrapped_lookup_value =
         (frontier_int_int
            {key:vid, value:(bind map___SQL_SUM_AGGREGATE_1_mS1_s2_buf
             as ind __x in __x).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B))}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
             __acc_map.combine
             ({| key:int, value:int |
             {key:__map_0, value:__map_val}|} @ { Collection })))) empty {
           key:int, value:int } @ { Collection } in
      if wrapped_lookup_value == empty { key:int, value:int } @ { Collection }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) +
      ((let wrapped_lookup_value =
          (frontier_int_int
             {key:vid, value:(bind map___SQL_SUM_AGGREGATE_2_mS3_s2_buf
              as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B))}).fold
            ((\__acc_map -> (\_b3_ -> 
              bind _b3_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
              __acc_map.combine
              ({| key:int, value:int |
              {key:__map_0, value:__map_val}|} @ { Collection })))) empty {
            key:int, value:int } @ { Collection } in
      if wrapped_lookup_value == empty { key:int, value:int } @ { Collection }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) * S_C) in (
      add_delta_to_int
        {_r1_:__SQL_SUM_AGGREGATE_2, _r2_:false, _r3_:vid, _r4_:{|
         key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
         {key:vid, value:__sum_ret__1}|} @ { Collection }}
      ))

trigger insert_S_do_complete_s3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in let __val_ret__4 = 1 in (
      add_delta_to_int_int
        {_r1_:__SQL_SUM_AGGREGATE_2_mR1, _r2_:false, _r3_:vid, _r4_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:S_B, _r3_:__val_ret__4}|} @ { Collection }};
      (__SQL_SUM_AGGREGATE_2_mR1_send_correctives, me)<- {key:vid, value:{|
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int |
                                                          {_r1_:vid, _r2_:S_B,
                                                           _r3_:__val_ret__4}|} @ { Collection }}
      ))

trigger insert_S_rcv_corrective_s0_m___SQL_SUM_AGGREGATE_1_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_int_int
      {_r1_:map___SQL_SUM_AGGREGATE_1_mS1_s0_buf, _r2_:false, _r3_:vid,
       _r4_:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 0))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:0, _r3_:0}
        then
          bind log_get_bound_insert_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C} in 
          (insert_S_do_corrective_s0_m___SQL_SUM_AGGREGATE_1_mS1, me)<- {
            _r1_:compute_vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples}
        else ()))
    ))

trigger insert_S_rcv_corrective_s2_m___SQL_SUM_AGGREGATE_2_mS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_int_int
      {_r1_:map___SQL_SUM_AGGREGATE_2_mS3_s2_buf, _r2_:false, _r3_:vid,
       _r4_:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 2))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:2, _r3_:0}
        then
          bind log_get_bound_insert_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C} in 
          (insert_S_do_corrective_s2_m___SQL_SUM_AGGREGATE_2_mS3, me)<- {
            _r1_:compute_vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples}
        else ()))
    ))

trigger insert_S_rcv_corrective_s2_m___SQL_SUM_AGGREGATE_1_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_int_int
      {_r1_:map___SQL_SUM_AGGREGATE_1_mS1_s2_buf, _r2_:false, _r3_:vid,
       _r4_:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 2))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:2, _r3_:0}
        then
          bind log_get_bound_insert_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C} in 
          (insert_S_do_corrective_s2_m___SQL_SUM_AGGREGATE_1_mS1, me)<- {
            _r1_:compute_vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples}
        else ()))
    ))

trigger insert_S_do_corrective_s0_m___SQL_SUM_AGGREGATE_1_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta___SQL_SUM_AGGREGATE_1_mSS_B,
                      _r3_:delta___SQL_SUM_AGGREGATE_1_mS1} in 
        let __prod_ret__37 =
          ((if S_B == delta___SQL_SUM_AGGREGATE_1_mSS_B then 1 else 0) *
          delta___SQL_SUM_AGGREGATE_1_mS1) * S_C in (
          add_delta_to_int
            {_r1_:__SQL_SUM_AGGREGATE_1, _r2_:true, _r3_:vid, _r4_:{|
             key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
             {key:vid, value:__prod_ret__37}|} @ { Collection }}
          ))))

trigger insert_S_do_corrective_s2_m___SQL_SUM_AGGREGATE_2_mS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta___SQL_SUM_AGGREGATE_2_mSS_B,
                      _r3_:delta___SQL_SUM_AGGREGATE_2_mS3} in 
        let __prod_ret__43 =
          ((if S_B == delta___SQL_SUM_AGGREGATE_2_mSS_B then 1 else 0) *
          delta___SQL_SUM_AGGREGATE_2_mS3) * S_C in (
          add_delta_to_int
            {_r1_:__SQL_SUM_AGGREGATE_2, _r2_:true, _r3_:vid, _r4_:{|
             key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
             {key:vid, value:__prod_ret__43}|} @ { Collection }}
          ))))

trigger insert_S_do_corrective_s2_m___SQL_SUM_AGGREGATE_1_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta___SQL_SUM_AGGREGATE_1_mSS_B,
                      _r3_:delta___SQL_SUM_AGGREGATE_1_mS1} in 
        let __prod_ret__38 =
          (if S_B == delta___SQL_SUM_AGGREGATE_1_mSS_B then 1 else 0) *
          delta___SQL_SUM_AGGREGATE_1_mS1 in (
          add_delta_to_int
            {_r1_:__SQL_SUM_AGGREGATE_2, _r2_:true, _r3_:vid, _r4_:{|
             key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
             {key:vid, value:__prod_ret__38}|} @ { Collection }}
          ))))

trigger delete_S : {
key:int, value:int
}
= (\_b1_ ->

  bind _b1_ as {key:S_B, value:S_C} in (
    let vid =
      {_r1_:case (__epoch__.peek ()) of { Some x -> x.i } { None -> error () },
       _r2_:case (__vid_counter__.peek ()) of { Some x -> x.i }
       { None -> error () }, _r3_:hash me} in
    (
      (delete_S_send_fetch, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C};
      __vid_counter__.update
        ({i:case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
        ({i:1 + case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
      )
    ))

trigger delete_S_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    (route_to_int {key:3, value:Some S_B}).iterate
      ((\_b1_ -> 
        bind _b1_ as {i:ip} in 
        (delete_S_do_complete_s5, ip)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}));
    (route_to_int {key:6, value:Some S_B}).iterate
      ((\_b1_ -> 
        bind _b1_ as {i:ip} in 
        (delete_S_do_complete_s7, ip)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}));
    ((((empty {
        _r1_:address, _r2_:int, _r3_:int
        } @ { Collection }).combine
        (let sender_count =
           (route_to_int {key:2, value:Some S_B}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle___SQL_SUM_AGGREGATE_1_mS1_to___SQL_SUM_AGGREGATE_1
            {_r1_:(), _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection }, _r3_:true}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
             ({| _r1_:address, _r2_:int, _r3_:int |
             {_r1_:ip, _r2_:4, _r3_:sender_count}|} @ { Collection }))))
           empty { _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
        (let sender_count =
           (route_to_int {key:5, value:Some S_B}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle___SQL_SUM_AGGREGATE_2_mS3_to___SQL_SUM_AGGREGATE_2
            {_r1_:(), _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection }, _r3_:true}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
             ({| _r1_:address, _r2_:int, _r3_:int |
             {_r1_:ip, _r2_:6, _r3_:sender_count}|} @ { Collection }))))
           empty { _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
        (let sender_count =
           (route_to_int {key:2, value:Some S_B}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        (shuffle___SQL_SUM_AGGREGATE_1_mS1_to___SQL_SUM_AGGREGATE_2
           {_r1_:(), _r2_:empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Collection }, _r3_:true}).fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
            ({| _r1_:address, _r2_:int, _r3_:int |
            {_r1_:ip, _r2_:6, _r3_:sender_count}|} @ { Collection })))) empty {
          _r1_:address, _r2_:int, _r3_:int } @ { Collection })))).groupBy
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in 
          {key:ip, value:stmt_id})) ((\acc -> (\_b3_ -> 
          bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupBy
       ((\_b1_ -> 
         bind _b1_ as {key:_b2_, value:count} in 
         bind _b2_ as {key:ip, value:stmt_id} in ip)) ((\acc -> (\_b3_ -> 
         bind _b3_ as {key:ip_and_stmt_id, value:count} in 
         bind ip_and_stmt_id as {key:ip, value:stmt_id} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:count}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_id_cnt_list} in (
          (delete_S_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list, _r3_:vid,
                                    _r4_:S_B, _r5_:S_C}
          )));
    ((((route_to_int {key:2, value:Some S_B}).fold
         ((\__acc_map -> (\_b3_ -> 
           bind _b3_ as {i:ip} in __acc_map.combine
           ({| _r1_:int, _r2_:int, _r3_:address |
           {_r1_:6, _r2_:2, _r3_:ip}|} @ { Collection })))) empty {
         _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
       (((route_to_int {key:5, value:Some S_B}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {i:ip} in __acc_map.combine
             ({| _r1_:int, _r2_:int, _r3_:address |
             {_r1_:6, _r2_:5, _r3_:ip}|} @ { Collection })))) empty {
           _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
       (((route_to_int {key:2, value:Some S_B}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {i:ip} in __acc_map.combine
             ({| _r1_:int, _r2_:int, _r3_:address |
             {_r1_:4, _r2_:2, _r3_:ip}|} @ { Collection })))) empty {
           _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
       empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection }))).groupBy
       ((\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip))
       ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:map_id}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_map_ids} in 
        (delete_S_rcv_fetch, ip)<- {_r1_:stmt_map_ids, _r2_:vid, _r3_:S_B,
                                    _r4_:S_C}))
    ))

trigger delete_S_rcv_put : {
_r1_:address, _r2_:collection { key:int, value:int } @ { Collection }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid, _r4_:S_B,
                _r5_:S_C} in (
    stmt_id_cnt_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:count} in 
        if __stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }
        then bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:_, _r2_:_, _r3_:old_count} in 
          let new_count = old_count + count in (
            __stmt_cntrs__.update
              {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
              {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
            if new_count == 0
            then
              if stmt_id == 7
              then
                (delete_S_do_complete_s7, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
              else
                if stmt_id == 6
                then
                  (delete_S_do_complete_s6, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
                else
                  if stmt_id == 5
                  then
                    (delete_S_do_complete_s5, me)<- {_r1_:vid, _r2_:S_B,
                                                     _r3_:S_C}
                  else
                    if stmt_id == 4
                    then
                      (delete_S_do_complete_s4, me)<- {_r1_:vid, _r2_:S_B,
                                                       _r3_:S_C}
                    else ()
            else ()
            )
        else __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count}))
    ))

trigger delete_S_rcv_fetch : {
_r1_:collection { key:int, value:int } @ { Collection }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_delete_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    stmts_and_map_ids.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:map_id} in 
        if stmt_id == 4
        then
          if map_id == 2
          then
            (delete_S_send_push_s4_m___SQL_SUM_AGGREGATE_1_mS1, me)<- {
              _r1_:vid, _r2_:S_B, _r3_:S_C}
          else ()
        else
          if stmt_id == 6
          then
            if map_id == 5
            then
              (delete_S_send_push_s6_m___SQL_SUM_AGGREGATE_2_mS3, me)<- {
                _r1_:vid, _r2_:S_B, _r3_:S_C}
            else
              if map_id == 2
              then
                (delete_S_send_push_s6_m___SQL_SUM_AGGREGATE_1_mS1, me)<- {
                  _r1_:vid, _r2_:S_B, _r3_:S_C}
              else ()
          else ()))
    ))

trigger delete_S_send_push_s4_m___SQL_SUM_AGGREGATE_1_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    log_master_write {_r1_:vid, _r2_:1, _r3_:4};
    (shuffle___SQL_SUM_AGGREGATE_1_mS1_to___SQL_SUM_AGGREGATE_1
       {_r1_:(),
        _r2_:frontier_int_int
               {key:vid, value:(bind __SQL_SUM_AGGREGATE_1_mS1 as ind __x
                in __x).filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B))},
        _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_S_rcv_push_s4_m___SQL_SUM_AGGREGATE_1_mS1, ip)<- {_r1_:tuples,
                                                                  _r2_:vid,
                                                                  _r3_:S_B,
                                                                  _r4_:S_C}))
    ))

trigger delete_S_send_push_s6_m___SQL_SUM_AGGREGATE_2_mS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    log_master_write {_r1_:vid, _r2_:1, _r3_:6};
    (shuffle___SQL_SUM_AGGREGATE_2_mS3_to___SQL_SUM_AGGREGATE_2
       {_r1_:(),
        _r2_:frontier_int_int
               {key:vid, value:(bind __SQL_SUM_AGGREGATE_2_mS3 as ind __x
                in __x).filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B))},
        _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_S_rcv_push_s6_m___SQL_SUM_AGGREGATE_2_mS3, ip)<- {_r1_:tuples,
                                                                  _r2_:vid,
                                                                  _r3_:S_B,
                                                                  _r4_:S_C}))
    ))

trigger delete_S_send_push_s6_m___SQL_SUM_AGGREGATE_1_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    log_master_write {_r1_:vid, _r2_:1, _r3_:6};
    (shuffle___SQL_SUM_AGGREGATE_1_mS1_to___SQL_SUM_AGGREGATE_2
       {_r1_:(),
        _r2_:frontier_int_int
               {key:vid, value:(bind __SQL_SUM_AGGREGATE_1_mS1 as ind __x
                in __x).filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B))},
        _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_S_rcv_push_s6_m___SQL_SUM_AGGREGATE_1_mS1, ip)<- {_r1_:tuples,
                                                                  _r2_:vid,
                                                                  _r3_:S_B,
                                                                  _r4_:S_C}))
    ))

trigger delete_S_rcv_push_s4_m___SQL_SUM_AGGREGATE_1_mS1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_delete_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    tuples.iterate
      ((\tuple -> 
        if (bind map___SQL_SUM_AGGREGATE_1_mS1_s4_buf as ind __x in __x).filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }
        then
          (bind
            map___SQL_SUM_AGGREGATE_1_mS1_s4_buf
            as ind __x
            in __x).update
            (case (((bind map___SQL_SUM_AGGREGATE_1_mS1_s4_buf as ind __x
            in __x).filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else
          (bind
            map___SQL_SUM_AGGREGATE_1_mS1_s4_buf
            as ind __x
            in __x).insert
            tuple));
    if check_and_update_stmt_cntr_index {key:vid, value:4}
    then (delete_S_do_complete_s4, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
    else ()
    ))

trigger delete_S_rcv_push_s6_m___SQL_SUM_AGGREGATE_2_mS3 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_delete_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    tuples.iterate
      ((\tuple -> 
        if (bind map___SQL_SUM_AGGREGATE_2_mS3_s6_buf as ind __x in __x).filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }
        then
          (bind
            map___SQL_SUM_AGGREGATE_2_mS3_s6_buf
            as ind __x
            in __x).update
            (case (((bind map___SQL_SUM_AGGREGATE_2_mS3_s6_buf as ind __x
            in __x).filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else
          (bind
            map___SQL_SUM_AGGREGATE_2_mS3_s6_buf
            as ind __x
            in __x).insert
            tuple));
    if check_and_update_stmt_cntr_index {key:vid, value:6}
    then (delete_S_do_complete_s6, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
    else ()
    ))

trigger delete_S_rcv_push_s6_m___SQL_SUM_AGGREGATE_1_mS1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_delete_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    tuples.iterate
      ((\tuple -> 
        if (bind map___SQL_SUM_AGGREGATE_1_mS1_s6_buf as ind __x in __x).filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }
        then
          (bind
            map___SQL_SUM_AGGREGATE_1_mS1_s6_buf
            as ind __x
            in __x).update
            (case (((bind map___SQL_SUM_AGGREGATE_1_mS1_s6_buf as ind __x
            in __x).filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else
          (bind
            map___SQL_SUM_AGGREGATE_1_mS1_s6_buf
            as ind __x
            in __x).insert
            tuple));
    if check_and_update_stmt_cntr_index {key:vid, value:6}
    then (delete_S_do_complete_s6, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
    else ()
    ))

trigger delete_S_do_complete_s4 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in 
    let __prod_ret__4 =
      (let wrapped_lookup_value =
         (frontier_int_int
            {key:vid, value:(bind map___SQL_SUM_AGGREGATE_1_mS1_s4_buf
             as ind __x in __x).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B))}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
             __acc_map.combine
             ({| key:int, value:int |
             {key:__map_0, value:__map_val}|} @ { Collection })))) empty {
           key:int, value:int } @ { Collection } in
      if wrapped_lookup_value == empty { key:int, value:int } @ { Collection }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) * -S_C in (
      add_delta_to_int
        {_r1_:__SQL_SUM_AGGREGATE_1, _r2_:false, _r3_:vid, _r4_:{|
         key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
         {key:vid, value:__prod_ret__4}|} @ { Collection }}
      ))

trigger delete_S_do_complete_s5 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in let __prod_ret__5 = -S_C in
    (
      add_delta_to_int_int
        {_r1_:__SQL_SUM_AGGREGATE_1_mR1, _r2_:false, _r3_:vid, _r4_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:S_B, _r3_:__prod_ret__5}|} @ { Collection }};
      (__SQL_SUM_AGGREGATE_1_mR1_send_correctives, me)<- {key:vid, value:{|
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int |
                                                          {_r1_:vid, _r2_:S_B,
                                                           _r3_:__prod_ret__5}|} @ { Collection }}
      ))

trigger delete_S_do_complete_s6 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in 
    let __prod_ret__7 =
      ((let wrapped_lookup_value =
          (frontier_int_int
             {key:vid, value:(bind map___SQL_SUM_AGGREGATE_1_mS1_s6_buf
              as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B))}).fold
            ((\__acc_map -> (\_b3_ -> 
              bind _b3_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
              __acc_map.combine
              ({| key:int, value:int |
              {key:__map_0, value:__map_val}|} @ { Collection })))) empty {
            key:int, value:int } @ { Collection } in
      if wrapped_lookup_value == empty { key:int, value:int } @ { Collection }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) +
      ((let wrapped_lookup_value =
          (frontier_int_int
             {key:vid, value:(bind map___SQL_SUM_AGGREGATE_2_mS3_s6_buf
              as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B))}).fold
            ((\__acc_map -> (\_b3_ -> 
              bind _b3_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
              __acc_map.combine
              ({| key:int, value:int |
              {key:__map_0, value:__map_val}|} @ { Collection })))) empty {
            key:int, value:int } @ { Collection } in
      if wrapped_lookup_value == empty { key:int, value:int } @ { Collection }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) * S_C)) * -1 in (
      add_delta_to_int
        {_r1_:__SQL_SUM_AGGREGATE_2, _r2_:false, _r3_:vid, _r4_:{|
         key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
         {key:vid, value:__prod_ret__7}|} @ { Collection }}
      ))

trigger delete_S_do_complete_s7 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in let __val_ret__11 = -1 in (
      add_delta_to_int_int
        {_r1_:__SQL_SUM_AGGREGATE_2_mR1, _r2_:false, _r3_:vid, _r4_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:S_B, _r3_:__val_ret__11}|} @ { Collection }};
      (__SQL_SUM_AGGREGATE_2_mR1_send_correctives, me)<- {key:vid, value:{|
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int |
                                                          {_r1_:vid, _r2_:S_B,
                                                           _r3_:__val_ret__11}|} @ { Collection }}
      ))

trigger delete_S_rcv_corrective_s4_m___SQL_SUM_AGGREGATE_1_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_int_int
      {_r1_:map___SQL_SUM_AGGREGATE_1_mS1_s4_buf, _r2_:false, _r3_:vid,
       _r4_:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 4))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:4, _r3_:0}
        then
          bind log_get_bound_delete_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C} in 
          (delete_S_do_corrective_s4_m___SQL_SUM_AGGREGATE_1_mS1, me)<- {
            _r1_:compute_vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples}
        else ()))
    ))

trigger delete_S_rcv_corrective_s6_m___SQL_SUM_AGGREGATE_2_mS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_int_int
      {_r1_:map___SQL_SUM_AGGREGATE_2_mS3_s6_buf, _r2_:false, _r3_:vid,
       _r4_:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 6))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:6, _r3_:0}
        then
          bind log_get_bound_delete_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C} in 
          (delete_S_do_corrective_s6_m___SQL_SUM_AGGREGATE_2_mS3, me)<- {
            _r1_:compute_vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples}
        else ()))
    ))

trigger delete_S_rcv_corrective_s6_m___SQL_SUM_AGGREGATE_1_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_int_int
      {_r1_:map___SQL_SUM_AGGREGATE_1_mS1_s6_buf, _r2_:false, _r3_:vid,
       _r4_:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 6))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:6, _r3_:0}
        then
          bind log_get_bound_delete_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C} in 
          (delete_S_do_corrective_s6_m___SQL_SUM_AGGREGATE_1_mS1, me)<- {
            _r1_:compute_vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples}
        else ()))
    ))

trigger delete_S_do_corrective_s4_m___SQL_SUM_AGGREGATE_1_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta___SQL_SUM_AGGREGATE_1_mSS_B,
                      _r3_:delta___SQL_SUM_AGGREGATE_1_mS1} in 
        let __prod_ret__46 =
          (if S_B == delta___SQL_SUM_AGGREGATE_1_mSS_B then 1 else 0) *
          (-delta___SQL_SUM_AGGREGATE_1_mS1 * S_C) in (
          add_delta_to_int
            {_r1_:__SQL_SUM_AGGREGATE_1, _r2_:true, _r3_:vid, _r4_:{|
             key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
             {key:vid, value:__prod_ret__46}|} @ { Collection }}
          ))))

trigger delete_S_do_corrective_s6_m___SQL_SUM_AGGREGATE_2_mS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta___SQL_SUM_AGGREGATE_2_mSS_B,
                      _r3_:delta___SQL_SUM_AGGREGATE_2_mS3} in 
        let __prod_ret__56 =
          (if S_B == delta___SQL_SUM_AGGREGATE_2_mSS_B then 1 else 0) *
          (-delta___SQL_SUM_AGGREGATE_2_mS3 * S_C) in (
          add_delta_to_int
            {_r1_:__SQL_SUM_AGGREGATE_2, _r2_:true, _r3_:vid, _r4_:{|
             key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
             {key:vid, value:__prod_ret__56}|} @ { Collection }}
          ))))

trigger delete_S_do_corrective_s6_m___SQL_SUM_AGGREGATE_1_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta___SQL_SUM_AGGREGATE_1_mSS_B,
                      _r3_:delta___SQL_SUM_AGGREGATE_1_mS1} in 
        let __prod_ret__48 =
          (if S_B == delta___SQL_SUM_AGGREGATE_1_mSS_B then 1 else 0) *
          -delta___SQL_SUM_AGGREGATE_1_mS1 in (
          add_delta_to_int
            {_r1_:__SQL_SUM_AGGREGATE_2, _r2_:true, _r3_:vid, _r4_:{|
             key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
             {key:vid, value:__prod_ret__48}|} @ { Collection }}
          ))))

trigger insert_R : {
key:int, value:int
}
= (\_b1_ ->

  bind _b1_ as {key:R_A, value:R_B} in (
    let vid =
      {_r1_:case (__epoch__.peek ()) of { Some x -> x.i } { None -> error () },
       _r2_:case (__vid_counter__.peek ()) of { Some x -> x.i }
       { None -> error () }, _r3_:hash me} in
    (
      (insert_R_send_fetch, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B};
      __vid_counter__.update
        ({i:case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
        ({i:1 + case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
      )
    ))

trigger insert_R_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
    (route_to_int {key:2, value:Some R_B}).iterate
      ((\_b1_ -> 
        bind _b1_ as {i:ip} in 
        (insert_R_do_complete_s9, ip)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}));
    (route_to_int {key:5, value:Some R_B}).iterate
      ((\_b1_ -> 
        bind _b1_ as {i:ip} in 
        (insert_R_do_complete_s11, ip)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}));
    ((((empty {
        _r1_:address, _r2_:int, _r3_:int
        } @ { Collection }).combine
        (let sender_count =
           (route_to_int {key:3, value:Some R_B}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle___SQL_SUM_AGGREGATE_1_mR1_to___SQL_SUM_AGGREGATE_1
            {_r1_:(), _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection }, _r3_:true}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
             ({| _r1_:address, _r2_:int, _r3_:int |
             {_r1_:ip, _r2_:8, _r3_:sender_count}|} @ { Collection }))))
           empty { _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
        (let sender_count =
           (route_to_int {key:6, value:Some R_B}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle___SQL_SUM_AGGREGATE_2_mR1_to___SQL_SUM_AGGREGATE_2
            {_r1_:(), _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection }, _r3_:true}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
             ({| _r1_:address, _r2_:int, _r3_:int |
             {_r1_:ip, _r2_:10, _r3_:sender_count}|} @ { Collection }))))
           empty { _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
        (let sender_count =
           (route_to_int {key:3, value:Some R_B}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        (shuffle___SQL_SUM_AGGREGATE_1_mR1_to___SQL_SUM_AGGREGATE_2
           {_r1_:(), _r2_:empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Collection }, _r3_:true}).fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
            ({| _r1_:address, _r2_:int, _r3_:int |
            {_r1_:ip, _r2_:10, _r3_:sender_count}|} @ { Collection }))))
          empty { _r1_:address, _r2_:int, _r3_:int } @ { Collection })))).groupBy
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in 
          {key:ip, value:stmt_id})) ((\acc -> (\_b3_ -> 
          bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupBy
       ((\_b1_ -> 
         bind _b1_ as {key:_b2_, value:count} in 
         bind _b2_ as {key:ip, value:stmt_id} in ip)) ((\acc -> (\_b3_ -> 
         bind _b3_ as {key:ip_and_stmt_id, value:count} in 
         bind ip_and_stmt_id as {key:ip, value:stmt_id} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:count}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_id_cnt_list} in (
          (insert_R_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list, _r3_:vid,
                                    _r4_:R_A, _r5_:R_B}
          )));
    ((((route_to_int {key:6, value:Some R_B}).fold
         ((\__acc_map -> (\_b3_ -> 
           bind _b3_ as {i:ip} in __acc_map.combine
           ({| _r1_:int, _r2_:int, _r3_:address |
           {_r1_:10, _r2_:6, _r3_:ip}|} @ { Collection })))) empty {
         _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
       (((route_to_int {key:3, value:Some R_B}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {i:ip} in __acc_map.combine
             ({| _r1_:int, _r2_:int, _r3_:address |
             {_r1_:10, _r2_:3, _r3_:ip}|} @ { Collection })))) empty {
           _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
       (((route_to_int {key:3, value:Some R_B}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {i:ip} in __acc_map.combine
             ({| _r1_:int, _r2_:int, _r3_:address |
             {_r1_:8, _r2_:3, _r3_:ip}|} @ { Collection })))) empty {
           _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
       empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection }))).groupBy
       ((\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip))
       ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:map_id}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_map_ids} in 
        (insert_R_rcv_fetch, ip)<- {_r1_:stmt_map_ids, _r2_:vid, _r3_:R_A,
                                    _r4_:R_B}))
    ))

trigger insert_R_rcv_put : {
_r1_:address, _r2_:collection { key:int, value:int } @ { Collection }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid, _r4_:R_A,
                _r5_:R_B} in (
    stmt_id_cnt_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:count} in 
        if __stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }
        then bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:_, _r2_:_, _r3_:old_count} in 
          let new_count = old_count + count in (
            __stmt_cntrs__.update
              {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
              {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
            if new_count == 0
            then
              if stmt_id == 11
              then
                (insert_R_do_complete_s11, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
              else
                if stmt_id == 10
                then
                  (insert_R_do_complete_s10, me)<- {_r1_:vid, _r2_:R_A,
                                                    _r3_:R_B}
                else
                  if stmt_id == 9
                  then
                    (insert_R_do_complete_s9, me)<- {_r1_:vid, _r2_:R_A,
                                                     _r3_:R_B}
                  else
                    if stmt_id == 8
                    then
                      (insert_R_do_complete_s8, me)<- {_r1_:vid, _r2_:R_A,
                                                       _r3_:R_B}
                    else ()
            else ()
            )
        else __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count}))
    ))

trigger insert_R_rcv_fetch : {
_r1_:collection { key:int, value:int } @ { Collection }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
    log_write_insert_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
    stmts_and_map_ids.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:map_id} in 
        if stmt_id == 8
        then
          if map_id == 3
          then
            (insert_R_send_push_s8_m___SQL_SUM_AGGREGATE_1_mR1, me)<- {
              _r1_:vid, _r2_:R_A, _r3_:R_B}
          else ()
        else
          if stmt_id == 10
          then
            if map_id == 3
            then
              (insert_R_send_push_s10_m___SQL_SUM_AGGREGATE_1_mR1, me)<- {
                _r1_:vid, _r2_:R_A, _r3_:R_B}
            else
              if map_id == 6
              then
                (insert_R_send_push_s10_m___SQL_SUM_AGGREGATE_2_mR1, me)<- {
                  _r1_:vid, _r2_:R_A, _r3_:R_B}
              else ()
          else ()))
    ))

trigger insert_R_send_push_s8_m___SQL_SUM_AGGREGATE_1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
    log_master_write {_r1_:vid, _r2_:2, _r3_:8};
    (shuffle___SQL_SUM_AGGREGATE_1_mR1_to___SQL_SUM_AGGREGATE_1
       {_r1_:(),
        _r2_:frontier_int_int
               {key:vid, value:(bind __SQL_SUM_AGGREGATE_1_mR1 as ind __x
                in __x).filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == R_B))},
        _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_R_rcv_push_s8_m___SQL_SUM_AGGREGATE_1_mR1, ip)<- {_r1_:tuples,
                                                                  _r2_:vid,
                                                                  _r3_:R_A,
                                                                  _r4_:R_B}))
    ))

trigger insert_R_send_push_s10_m___SQL_SUM_AGGREGATE_2_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
    log_master_write {_r1_:vid, _r2_:2, _r3_:10};
    (shuffle___SQL_SUM_AGGREGATE_2_mR1_to___SQL_SUM_AGGREGATE_2
       {_r1_:(),
        _r2_:frontier_int_int
               {key:vid, value:(bind __SQL_SUM_AGGREGATE_2_mR1 as ind __x
                in __x).filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == R_B))},
        _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_R_rcv_push_s10_m___SQL_SUM_AGGREGATE_2_mR1, ip)<- {_r1_:tuples,
                                                                   _r2_:vid,
                                                                   _r3_:R_A,
                                                                   _r4_:R_B}))
    ))

trigger insert_R_send_push_s10_m___SQL_SUM_AGGREGATE_1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
    log_master_write {_r1_:vid, _r2_:2, _r3_:10};
    (shuffle___SQL_SUM_AGGREGATE_1_mR1_to___SQL_SUM_AGGREGATE_2
       {_r1_:(),
        _r2_:frontier_int_int
               {key:vid, value:(bind __SQL_SUM_AGGREGATE_1_mR1 as ind __x
                in __x).filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == R_B))},
        _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_R_rcv_push_s10_m___SQL_SUM_AGGREGATE_1_mR1, ip)<- {_r1_:tuples,
                                                                   _r2_:vid,
                                                                   _r3_:R_A,
                                                                   _r4_:R_B}))
    ))

trigger insert_R_rcv_push_s8_m___SQL_SUM_AGGREGATE_1_mR1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
    log_write_insert_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
    tuples.iterate
      ((\tuple -> 
        if (bind map___SQL_SUM_AGGREGATE_1_mR1_s8_buf as ind __x in __x).filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }
        then
          (bind
            map___SQL_SUM_AGGREGATE_1_mR1_s8_buf
            as ind __x
            in __x).update
            (case (((bind map___SQL_SUM_AGGREGATE_1_mR1_s8_buf as ind __x
            in __x).filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else
          (bind
            map___SQL_SUM_AGGREGATE_1_mR1_s8_buf
            as ind __x
            in __x).insert
            tuple));
    if check_and_update_stmt_cntr_index {key:vid, value:8}
    then (insert_R_do_complete_s8, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
    else ()
    ))

trigger insert_R_rcv_push_s10_m___SQL_SUM_AGGREGATE_1_mR1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
    log_write_insert_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
    tuples.iterate
      ((\tuple -> 
        if (bind map___SQL_SUM_AGGREGATE_1_mR1_s10_buf as ind __x
          in __x).filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }
        then
          (bind
            map___SQL_SUM_AGGREGATE_1_mR1_s10_buf
            as ind __x
            in __x).update
            (case (((bind map___SQL_SUM_AGGREGATE_1_mR1_s10_buf as ind __x
            in __x).filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else
          (bind
            map___SQL_SUM_AGGREGATE_1_mR1_s10_buf
            as ind __x
            in __x).insert
            tuple));
    if check_and_update_stmt_cntr_index {key:vid, value:10}
    then (insert_R_do_complete_s10, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
    else ()
    ))

trigger insert_R_rcv_push_s10_m___SQL_SUM_AGGREGATE_2_mR1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
    log_write_insert_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
    tuples.iterate
      ((\tuple -> 
        if (bind map___SQL_SUM_AGGREGATE_2_mR1_s10_buf as ind __x
          in __x).filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }
        then
          (bind
            map___SQL_SUM_AGGREGATE_2_mR1_s10_buf
            as ind __x
            in __x).update
            (case (((bind map___SQL_SUM_AGGREGATE_2_mR1_s10_buf as ind __x
            in __x).filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else
          (bind
            map___SQL_SUM_AGGREGATE_2_mR1_s10_buf
            as ind __x
            in __x).insert
            tuple));
    if check_and_update_stmt_cntr_index {key:vid, value:10}
    then (insert_R_do_complete_s10, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
    else ()
    ))

trigger insert_R_do_complete_s8 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in 
    let __prod_ret__8 =
      (let wrapped_lookup_value =
         (frontier_int_int
            {key:vid, value:(bind map___SQL_SUM_AGGREGATE_1_mR1_s8_buf
             as ind __x in __x).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == R_B))}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
             __acc_map.combine
             ({| key:int, value:int |
             {key:__map_0, value:__map_val}|} @ { Collection })))) empty {
           key:int, value:int } @ { Collection } in
      if wrapped_lookup_value == empty { key:int, value:int } @ { Collection }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) * R_A in (
      add_delta_to_int
        {_r1_:__SQL_SUM_AGGREGATE_1, _r2_:false, _r3_:vid, _r4_:{|
         key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
         {key:vid, value:__prod_ret__8}|} @ { Collection }}
      ))

trigger insert_R_do_complete_s9 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in let __val_ret__13 = R_A in (
      add_delta_to_int_int
        {_r1_:__SQL_SUM_AGGREGATE_1_mS1, _r2_:false, _r3_:vid, _r4_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:R_B, _r3_:__val_ret__13}|} @ { Collection }};
      (__SQL_SUM_AGGREGATE_1_mS1_send_correctives, me)<- {key:vid, value:{|
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int |
                                                          {_r1_:vid, _r2_:R_B,
                                                           _r3_:__val_ret__13}|} @ { Collection }}
      ))

trigger insert_R_do_complete_s10 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in 
    let __sum_ret__3 =
      ((let wrapped_lookup_value =
          (frontier_int_int
             {key:vid, value:(bind map___SQL_SUM_AGGREGATE_2_mR1_s10_buf
              as ind __x in __x).filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == R_B))}).fold
            ((\__acc_map -> (\_b3_ -> 
              bind _b3_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
              __acc_map.combine
              ({| key:int, value:int |
              {key:__map_0, value:__map_val}|} @ { Collection })))) empty {
            key:int, value:int } @ { Collection } in
      if wrapped_lookup_value == empty { key:int, value:int } @ { Collection }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) * R_A) +
      let wrapped_lookup_value =
        (frontier_int_int
           {key:vid, value:(bind map___SQL_SUM_AGGREGATE_1_mR1_s10_buf
            as ind __x in __x).filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == R_B))}).fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
            __acc_map.combine
            ({| key:int, value:int |
            {key:__map_0, value:__map_val}|} @ { Collection })))) empty {
          key:int, value:int } @ { Collection } in
      if wrapped_lookup_value == empty { key:int, value:int } @ { Collection }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field in (
      add_delta_to_int
        {_r1_:__SQL_SUM_AGGREGATE_2, _r2_:false, _r3_:vid, _r4_:{|
         key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
         {key:vid, value:__sum_ret__3}|} @ { Collection }}
      ))

trigger insert_R_do_complete_s11 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in let __val_ret__15 = 1 in (
      add_delta_to_int_int
        {_r1_:__SQL_SUM_AGGREGATE_2_mS3, _r2_:false, _r3_:vid, _r4_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:R_B, _r3_:__val_ret__15}|} @ { Collection }};
      (__SQL_SUM_AGGREGATE_2_mS3_send_correctives, me)<- {key:vid, value:{|
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int |
                                                          {_r1_:vid, _r2_:R_B,
                                                           _r3_:__val_ret__15}|} @ { Collection }}
      ))

trigger insert_R_rcv_corrective_s8_m___SQL_SUM_AGGREGATE_1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_int_int
      {_r1_:map___SQL_SUM_AGGREGATE_1_mR1_s8_buf, _r2_:false, _r3_:vid,
       _r4_:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 8))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:8, _r3_:0}
        then
          bind log_get_bound_insert_R compute_vid as {_r1_:vid, _r2_:R_A,
                                                      _r3_:R_B} in 
          (insert_R_do_corrective_s8_m___SQL_SUM_AGGREGATE_1_mR1, me)<- {
            _r1_:compute_vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples}
        else ()))
    ))

trigger insert_R_rcv_corrective_s10_m___SQL_SUM_AGGREGATE_1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_int_int
      {_r1_:map___SQL_SUM_AGGREGATE_1_mR1_s10_buf, _r2_:false, _r3_:vid,
       _r4_:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 10))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:10, _r3_:0}
        then
          bind log_get_bound_insert_R compute_vid as {_r1_:vid, _r2_:R_A,
                                                      _r3_:R_B} in 
          (insert_R_do_corrective_s10_m___SQL_SUM_AGGREGATE_1_mR1, me)<- {
            _r1_:compute_vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples}
        else ()))
    ))

trigger insert_R_rcv_corrective_s10_m___SQL_SUM_AGGREGATE_2_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_int_int
      {_r1_:map___SQL_SUM_AGGREGATE_2_mR1_s10_buf, _r2_:false, _r3_:vid,
       _r4_:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 10))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:10, _r3_:0}
        then
          bind log_get_bound_insert_R compute_vid as {_r1_:vid, _r2_:R_A,
                                                      _r3_:R_B} in 
          (insert_R_do_corrective_s10_m___SQL_SUM_AGGREGATE_2_mR1, me)<- {
            _r1_:compute_vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples}
        else ()))
    ))

trigger insert_R_do_corrective_s8_m___SQL_SUM_AGGREGATE_1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta___SQL_SUM_AGGREGATE_1_mRR_B,
                      _r3_:delta___SQL_SUM_AGGREGATE_1_mR1} in 
        let __prod_ret__16 =
          ((if R_B == delta___SQL_SUM_AGGREGATE_1_mRR_B then 1 else 0) *
          delta___SQL_SUM_AGGREGATE_1_mR1) * R_A in (
          add_delta_to_int
            {_r1_:__SQL_SUM_AGGREGATE_1, _r2_:true, _r3_:vid, _r4_:{|
             key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
             {key:vid, value:__prod_ret__16}|} @ { Collection }}
          ))))

trigger insert_R_do_corrective_s10_m___SQL_SUM_AGGREGATE_1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta___SQL_SUM_AGGREGATE_1_mRR_B,
                      _r3_:delta___SQL_SUM_AGGREGATE_1_mR1} in 
        let __prod_ret__17 =
          (if R_B == delta___SQL_SUM_AGGREGATE_1_mRR_B then 1 else 0) *
          delta___SQL_SUM_AGGREGATE_1_mR1 in (
          add_delta_to_int
            {_r1_:__SQL_SUM_AGGREGATE_2, _r2_:true, _r3_:vid, _r4_:{|
             key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
             {key:vid, value:__prod_ret__17}|} @ { Collection }}
          ))))

trigger insert_R_do_corrective_s10_m___SQL_SUM_AGGREGATE_2_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta___SQL_SUM_AGGREGATE_2_mRR_B,
                      _r3_:delta___SQL_SUM_AGGREGATE_2_mR1} in 
        let __prod_ret__22 =
          ((if R_B == delta___SQL_SUM_AGGREGATE_2_mRR_B then 1 else 0) *
          delta___SQL_SUM_AGGREGATE_2_mR1) * R_A in (
          add_delta_to_int
            {_r1_:__SQL_SUM_AGGREGATE_2, _r2_:true, _r3_:vid, _r4_:{|
             key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
             {key:vid, value:__prod_ret__22}|} @ { Collection }}
          ))))

trigger delete_R : {
key:int, value:int
}
= (\_b1_ ->

  bind _b1_ as {key:R_A, value:R_B} in (
    let vid =
      {_r1_:case (__epoch__.peek ()) of { Some x -> x.i } { None -> error () },
       _r2_:case (__vid_counter__.peek ()) of { Some x -> x.i }
       { None -> error () }, _r3_:hash me} in
    (
      (delete_R_send_fetch, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B};
      __vid_counter__.update
        ({i:case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
        ({i:1 + case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
      )
    ))

trigger delete_R_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
    (route_to_int {key:2, value:Some R_B}).iterate
      ((\_b1_ -> 
        bind _b1_ as {i:ip} in 
        (delete_R_do_complete_s13, ip)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}));
    (route_to_int {key:5, value:Some R_B}).iterate
      ((\_b1_ -> 
        bind _b1_ as {i:ip} in 
        (delete_R_do_complete_s15, ip)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}));
    ((((empty {
        _r1_:address, _r2_:int, _r3_:int
        } @ { Collection }).combine
        (let sender_count =
           (route_to_int {key:3, value:Some R_B}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle___SQL_SUM_AGGREGATE_1_mR1_to___SQL_SUM_AGGREGATE_1
            {_r1_:(), _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection }, _r3_:true}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
             ({| _r1_:address, _r2_:int, _r3_:int |
             {_r1_:ip, _r2_:12, _r3_:sender_count}|} @ { Collection }))))
           empty { _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
        (let sender_count =
           (route_to_int {key:6, value:Some R_B}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle___SQL_SUM_AGGREGATE_2_mR1_to___SQL_SUM_AGGREGATE_2
            {_r1_:(), _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Collection }, _r3_:true}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
             ({| _r1_:address, _r2_:int, _r3_:int |
             {_r1_:ip, _r2_:14, _r3_:sender_count}|} @ { Collection }))))
           empty { _r1_:address, _r2_:int, _r3_:int } @ { Collection }).combine
        (let sender_count =
           (route_to_int {key:3, value:Some R_B}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        (shuffle___SQL_SUM_AGGREGATE_1_mR1_to___SQL_SUM_AGGREGATE_2
           {_r1_:(), _r2_:empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Collection }, _r3_:true}).fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
            ({| _r1_:address, _r2_:int, _r3_:int |
            {_r1_:ip, _r2_:14, _r3_:sender_count}|} @ { Collection }))))
          empty { _r1_:address, _r2_:int, _r3_:int } @ { Collection })))).groupBy
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in 
          {key:ip, value:stmt_id})) ((\acc -> (\_b3_ -> 
          bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupBy
       ((\_b1_ -> 
         bind _b1_ as {key:_b2_, value:count} in 
         bind _b2_ as {key:ip, value:stmt_id} in ip)) ((\acc -> (\_b3_ -> 
         bind _b3_ as {key:ip_and_stmt_id, value:count} in 
         bind ip_and_stmt_id as {key:ip, value:stmt_id} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:count}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_id_cnt_list} in (
          (delete_R_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list, _r3_:vid,
                                    _r4_:R_A, _r5_:R_B}
          )));
    ((((route_to_int {key:6, value:Some R_B}).fold
         ((\__acc_map -> (\_b3_ -> 
           bind _b3_ as {i:ip} in __acc_map.combine
           ({| _r1_:int, _r2_:int, _r3_:address |
           {_r1_:14, _r2_:6, _r3_:ip}|} @ { Collection })))) empty {
         _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
       (((route_to_int {key:3, value:Some R_B}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {i:ip} in __acc_map.combine
             ({| _r1_:int, _r2_:int, _r3_:address |
             {_r1_:14, _r2_:3, _r3_:ip}|} @ { Collection })))) empty {
           _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
       (((route_to_int {key:3, value:Some R_B}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {i:ip} in __acc_map.combine
             ({| _r1_:int, _r2_:int, _r3_:address |
             {_r1_:12, _r2_:3, _r3_:ip}|} @ { Collection })))) empty {
           _r1_:int, _r2_:int, _r3_:address } @ { Collection }).combine
       empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection }))).groupBy
       ((\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip))
       ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:map_id}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_map_ids} in 
        (delete_R_rcv_fetch, ip)<- {_r1_:stmt_map_ids, _r2_:vid, _r3_:R_A,
                                    _r4_:R_B}))
    ))

trigger delete_R_rcv_put : {
_r1_:address, _r2_:collection { key:int, value:int } @ { Collection }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid, _r4_:R_A,
                _r5_:R_B} in (
    stmt_id_cnt_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:count} in 
        if __stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }
        then bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:_, _r2_:_, _r3_:old_count} in 
          let new_count = old_count + count in (
            __stmt_cntrs__.update
              {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
              {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
            if new_count == 0
            then
              if stmt_id == 15
              then
                (delete_R_do_complete_s15, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
              else
                if stmt_id == 14
                then
                  (delete_R_do_complete_s14, me)<- {_r1_:vid, _r2_:R_A,
                                                    _r3_:R_B}
                else
                  if stmt_id == 13
                  then
                    (delete_R_do_complete_s13, me)<- {_r1_:vid, _r2_:R_A,
                                                      _r3_:R_B}
                  else
                    if stmt_id == 12
                    then
                      (delete_R_do_complete_s12, me)<- {_r1_:vid, _r2_:R_A,
                                                        _r3_:R_B}
                    else ()
            else ()
            )
        else __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count}))
    ))

trigger delete_R_rcv_fetch : {
_r1_:collection { key:int, value:int } @ { Collection }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
    log_write_delete_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
    stmts_and_map_ids.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:map_id} in 
        if stmt_id == 12
        then
          if map_id == 3
          then
            (delete_R_send_push_s12_m___SQL_SUM_AGGREGATE_1_mR1, me)<- {
              _r1_:vid, _r2_:R_A, _r3_:R_B}
          else ()
        else
          if stmt_id == 14
          then
            if map_id == 3
            then
              (delete_R_send_push_s14_m___SQL_SUM_AGGREGATE_1_mR1, me)<- {
                _r1_:vid, _r2_:R_A, _r3_:R_B}
            else
              if map_id == 6
              then
                (delete_R_send_push_s14_m___SQL_SUM_AGGREGATE_2_mR1, me)<- {
                  _r1_:vid, _r2_:R_A, _r3_:R_B}
              else ()
          else ()))
    ))

trigger delete_R_send_push_s12_m___SQL_SUM_AGGREGATE_1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
    log_master_write {_r1_:vid, _r2_:3, _r3_:12};
    (shuffle___SQL_SUM_AGGREGATE_1_mR1_to___SQL_SUM_AGGREGATE_1
       {_r1_:(),
        _r2_:frontier_int_int
               {key:vid, value:(bind __SQL_SUM_AGGREGATE_1_mR1 as ind __x
                in __x).filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == R_B))},
        _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_R_rcv_push_s12_m___SQL_SUM_AGGREGATE_1_mR1, ip)<- {_r1_:tuples,
                                                                   _r2_:vid,
                                                                   _r3_:R_A,
                                                                   _r4_:R_B}))
    ))

trigger delete_R_send_push_s14_m___SQL_SUM_AGGREGATE_2_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
    log_master_write {_r1_:vid, _r2_:3, _r3_:14};
    (shuffle___SQL_SUM_AGGREGATE_2_mR1_to___SQL_SUM_AGGREGATE_2
       {_r1_:(),
        _r2_:frontier_int_int
               {key:vid, value:(bind __SQL_SUM_AGGREGATE_2_mR1 as ind __x
                in __x).filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == R_B))},
        _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_R_rcv_push_s14_m___SQL_SUM_AGGREGATE_2_mR1, ip)<- {_r1_:tuples,
                                                                   _r2_:vid,
                                                                   _r3_:R_A,
                                                                   _r4_:R_B}))
    ))

trigger delete_R_send_push_s14_m___SQL_SUM_AGGREGATE_1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
    log_master_write {_r1_:vid, _r2_:3, _r3_:14};
    (shuffle___SQL_SUM_AGGREGATE_1_mR1_to___SQL_SUM_AGGREGATE_2
       {_r1_:(),
        _r2_:frontier_int_int
               {key:vid, value:(bind __SQL_SUM_AGGREGATE_1_mR1 as ind __x
                in __x).filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == R_B))},
        _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_R_rcv_push_s14_m___SQL_SUM_AGGREGATE_1_mR1, ip)<- {_r1_:tuples,
                                                                   _r2_:vid,
                                                                   _r3_:R_A,
                                                                   _r4_:R_B}))
    ))

trigger delete_R_rcv_push_s12_m___SQL_SUM_AGGREGATE_1_mR1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
    log_write_delete_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
    tuples.iterate
      ((\tuple -> 
        if (bind map___SQL_SUM_AGGREGATE_1_mR1_s12_buf as ind __x
          in __x).filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }
        then
          (bind
            map___SQL_SUM_AGGREGATE_1_mR1_s12_buf
            as ind __x
            in __x).update
            (case (((bind map___SQL_SUM_AGGREGATE_1_mR1_s12_buf as ind __x
            in __x).filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else
          (bind
            map___SQL_SUM_AGGREGATE_1_mR1_s12_buf
            as ind __x
            in __x).insert
            tuple));
    if check_and_update_stmt_cntr_index {key:vid, value:12}
    then (delete_R_do_complete_s12, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
    else ()
    ))

trigger delete_R_rcv_push_s14_m___SQL_SUM_AGGREGATE_1_mR1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
    log_write_delete_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
    tuples.iterate
      ((\tuple -> 
        if (bind map___SQL_SUM_AGGREGATE_1_mR1_s14_buf as ind __x
          in __x).filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }
        then
          (bind
            map___SQL_SUM_AGGREGATE_1_mR1_s14_buf
            as ind __x
            in __x).update
            (case (((bind map___SQL_SUM_AGGREGATE_1_mR1_s14_buf as ind __x
            in __x).filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else
          (bind
            map___SQL_SUM_AGGREGATE_1_mR1_s14_buf
            as ind __x
            in __x).insert
            tuple));
    if check_and_update_stmt_cntr_index {key:vid, value:14}
    then (delete_R_do_complete_s14, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
    else ()
    ))

trigger delete_R_rcv_push_s14_m___SQL_SUM_AGGREGATE_2_mR1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Collection }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
    log_write_delete_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
    tuples.iterate
      ((\tuple -> 
        if (bind map___SQL_SUM_AGGREGATE_2_mR1_s14_buf as ind __x
          in __x).filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
          } @ { Collection }
        then
          (bind
            map___SQL_SUM_AGGREGATE_2_mR1_s14_buf
            as ind __x
            in __x).update
            (case (((bind map___SQL_SUM_AGGREGATE_2_mR1_s14_buf as ind __x
            in __x).filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else
          (bind
            map___SQL_SUM_AGGREGATE_2_mR1_s14_buf
            as ind __x
            in __x).insert
            tuple));
    if check_and_update_stmt_cntr_index {key:vid, value:14}
    then (delete_R_do_complete_s14, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
    else ()
    ))

trigger delete_R_do_complete_s12 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in 
    let __prod_ret__11 =
      (let wrapped_lookup_value =
         (frontier_int_int
            {key:vid, value:(bind map___SQL_SUM_AGGREGATE_1_mR1_s12_buf
             as ind __x in __x).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == R_B))}).fold
           ((\__acc_map -> (\_b3_ -> 
             bind _b3_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
             __acc_map.combine
             ({| key:int, value:int |
             {key:__map_0, value:__map_val}|} @ { Collection })))) empty {
           key:int, value:int } @ { Collection } in
      if wrapped_lookup_value == empty { key:int, value:int } @ { Collection }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) * -R_A in (
      add_delta_to_int
        {_r1_:__SQL_SUM_AGGREGATE_1, _r2_:false, _r3_:vid, _r4_:{|
         key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
         {key:vid, value:__prod_ret__11}|} @ { Collection }}
      ))

trigger delete_R_do_complete_s13 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in let __prod_ret__12 = -R_A in
    (
      add_delta_to_int_int
        {_r1_:__SQL_SUM_AGGREGATE_1_mS1, _r2_:false, _r3_:vid, _r4_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:R_B, _r3_:__prod_ret__12}|} @ { Collection }};
      (__SQL_SUM_AGGREGATE_1_mS1_send_correctives, me)<- {key:vid, value:{|
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int |
                                                          {_r1_:vid, _r2_:R_B,
                                                           _r3_:__prod_ret__12}|} @ { Collection }}
      ))

trigger delete_R_do_complete_s14 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in 
    let __prod_ret__14 =
      (((let wrapped_lookup_value =
           (frontier_int_int
              {key:vid, value:(bind map___SQL_SUM_AGGREGATE_2_mR1_s14_buf
               as ind __x in __x).filter
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == R_B))}).fold
             ((\__acc_map -> (\_b3_ -> 
               bind _b3_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
               __acc_map.combine
               ({| key:int, value:int |
               {key:__map_0, value:__map_val}|} @ { Collection })))) empty {
             key:int, value:int } @ { Collection } in
      if wrapped_lookup_value == empty { key:int, value:int } @ { Collection }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) * R_A) +
      let wrapped_lookup_value =
        (frontier_int_int
           {key:vid, value:(bind map___SQL_SUM_AGGREGATE_1_mR1_s14_buf
            as ind __x in __x).filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == R_B))}).fold
          ((\__acc_map -> (\_b3_ -> 
            bind _b3_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
            __acc_map.combine
            ({| key:int, value:int |
            {key:__map_0, value:__map_val}|} @ { Collection })))) empty {
          key:int, value:int } @ { Collection } in
      if wrapped_lookup_value == empty { key:int, value:int } @ { Collection }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) * -1 in (
      add_delta_to_int
        {_r1_:__SQL_SUM_AGGREGATE_2, _r2_:false, _r3_:vid, _r4_:{|
         key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
         {key:vid, value:__prod_ret__14}|} @ { Collection }}
      ))

trigger delete_R_do_complete_s15 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in let __val_ret__22 = -1 in (
      add_delta_to_int_int
        {_r1_:__SQL_SUM_AGGREGATE_2_mS3, _r2_:false, _r3_:vid, _r4_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:R_B, _r3_:__val_ret__22}|} @ { Collection }};
      (__SQL_SUM_AGGREGATE_2_mS3_send_correctives, me)<- {key:vid, value:{|
                                                          _r1_:{
                                                          _r1_:int, _r2_:int,
                                                          _r3_:int }, _r2_:int,
                                                          _r3_:int |
                                                          {_r1_:vid, _r2_:R_B,
                                                           _r3_:__val_ret__22}|} @ { Collection }}
      ))

trigger delete_R_rcv_corrective_s12_m___SQL_SUM_AGGREGATE_1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_int_int
      {_r1_:map___SQL_SUM_AGGREGATE_1_mR1_s12_buf, _r2_:false, _r3_:vid,
       _r4_:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 12))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:12, _r3_:0}
        then
          bind log_get_bound_delete_R compute_vid as {_r1_:vid, _r2_:R_A,
                                                      _r3_:R_B} in 
          (delete_R_do_corrective_s12_m___SQL_SUM_AGGREGATE_1_mR1, me)<- {
            _r1_:compute_vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples}
        else ()))
    ))

trigger delete_R_rcv_corrective_s14_m___SQL_SUM_AGGREGATE_1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_int_int
      {_r1_:map___SQL_SUM_AGGREGATE_1_mR1_s14_buf, _r2_:false, _r3_:vid,
       _r4_:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 14))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:14, _r3_:0}
        then
          bind log_get_bound_delete_R compute_vid as {_r1_:vid, _r2_:R_A,
                                                      _r3_:R_B} in 
          (delete_R_do_corrective_s14_m___SQL_SUM_AGGREGATE_1_mR1, me)<- {
            _r1_:compute_vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples}
        else ()))
    ))

trigger delete_R_rcv_corrective_s14_m___SQL_SUM_AGGREGATE_2_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_int_int
      {_r1_:map___SQL_SUM_AGGREGATE_2_mR1_s14_buf, _r2_:false, _r3_:vid,
       _r4_:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 14))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:14, _r3_:0}
        then
          bind log_get_bound_delete_R compute_vid as {_r1_:vid, _r2_:R_A,
                                                      _r3_:R_B} in 
          (delete_R_do_corrective_s14_m___SQL_SUM_AGGREGATE_2_mR1, me)<- {
            _r1_:compute_vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples}
        else ()))
    ))

trigger delete_R_do_corrective_s12_m___SQL_SUM_AGGREGATE_1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta___SQL_SUM_AGGREGATE_1_mRR_B,
                      _r3_:delta___SQL_SUM_AGGREGATE_1_mR1} in 
        let __prod_ret__25 =
          (if R_B == delta___SQL_SUM_AGGREGATE_1_mRR_B then 1 else 0) *
          (-delta___SQL_SUM_AGGREGATE_1_mR1 * R_A) in (
          add_delta_to_int
            {_r1_:__SQL_SUM_AGGREGATE_1, _r2_:true, _r3_:vid, _r4_:{|
             key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
             {key:vid, value:__prod_ret__25}|} @ { Collection }}
          ))))

trigger delete_R_do_corrective_s14_m___SQL_SUM_AGGREGATE_1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta___SQL_SUM_AGGREGATE_1_mRR_B,
                      _r3_:delta___SQL_SUM_AGGREGATE_1_mR1} in 
        let __prod_ret__27 =
          (if R_B == delta___SQL_SUM_AGGREGATE_1_mRR_B then 1 else 0) *
          -delta___SQL_SUM_AGGREGATE_1_mR1 in (
          add_delta_to_int
            {_r1_:__SQL_SUM_AGGREGATE_2, _r2_:true, _r3_:vid, _r4_:{|
             key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
             {key:vid, value:__prod_ret__27}|} @ { Collection }}
          ))))

trigger delete_R_do_corrective_s14_m___SQL_SUM_AGGREGATE_2_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta___SQL_SUM_AGGREGATE_2_mRR_B,
                      _r3_:delta___SQL_SUM_AGGREGATE_2_mR1} in 
        let __prod_ret__35 =
          (if R_B == delta___SQL_SUM_AGGREGATE_2_mRR_B then 1 else 0) *
          (-delta___SQL_SUM_AGGREGATE_2_mR1 * R_A) in (
          add_delta_to_int
            {_r1_:__SQL_SUM_AGGREGATE_2, _r2_:true, _r3_:vid, _r4_:{|
             key:{ _r1_:int, _r2_:int, _r3_:int }, value:int |
             {key:vid, value:__prod_ret__35}|} @ { Collection }}
          ))))

trigger __SQL_SUM_AGGREGATE_1_mS1_send_correctives : {
key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {key:corrective_vid, value:delta_tuples} in 
    let corrective_list =
      filter_corrective_list
        {key:corrective_vid, value:{| key:int, value:int | {key:1, value:6},
         {key:1, value:4}, {key:0, value:2},
         {key:0, value:0}|} @ { Collection }} in
    corrective_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:vid_list} in 
        if stmt_id == 6
        then
          ((vid_list.fold
              ((\__acc_ext -> (\vid -> 
                __acc_ext.combine
                (bind log_get_bound_delete_S vid as {_r1_:vid, _r2_:S_B,
                                                     _r3_:S_C} in 
                (shuffle___SQL_SUM_AGGREGATE_1_mS1_to___SQL_SUM_AGGREGATE_2
                   {_r1_:(), _r2_:delta_tuples, _r3_:false}).fold
                  ((\__acc_map -> (\_b3_ -> 
                    bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
                    ({|
                    _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                    _r3_:collection {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                    } @ { Collection } |
                    {_r1_:ip, _r2_:vid, _r3_:tuples}|} @ { Collection }))))
                  empty {
                  _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                  _r3_:collection {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                  } @ { Collection } } @ { Collection })))) empty {
              _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
              _r3_:collection {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
              } @ { Collection } } @ { Collection }).groupBy
             ((\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
             ((\_b2_ ->
             bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
               bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
               {key:acc_vid.combine
                ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                value:((acc_tuples.combine
                         tuples).groupBy
                         ((\tuple ->  tuple)) ((\_ -> (\_ ->  ()))) ()).fold
                        ((\__acc_map -> (\_b3_ -> 
                          bind _b3_ as {key:__1, value:__2} in 
                          __acc_map.combine
                          ({|
                          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                          _r3_:int | __1|} @ { Collection })))) empty {
                        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                        _r3_:int } @ { Collection }})))
             {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
              value:empty {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
              } @ { Collection }}).iterate
            ((\_b1_ -> 
              bind _b1_ as {key:ip, value:_b3_} in 
              bind _b3_ as {key:vid_send_list, value:tuple} in 
              (delete_S_rcv_corrective_s6_m___SQL_SUM_AGGREGATE_1_mS1, ip)<- {
                _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
        else
          if stmt_id == 4
          then
            ((vid_list.fold
                ((\__acc_ext -> (\vid -> 
                  __acc_ext.combine
                  (bind log_get_bound_delete_S vid as {_r1_:vid, _r2_:S_B,
                                                       _r3_:S_C} in 
                  (shuffle___SQL_SUM_AGGREGATE_1_mS1_to___SQL_SUM_AGGREGATE_1
                     {_r1_:(), _r2_:delta_tuples, _r3_:false}).fold
                    ((\__acc_map -> (\_b3_ -> 
                      bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
                      ({|
                      _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                      _r3_:collection {
                      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                      } @ { Collection } |
                      {_r1_:ip, _r2_:vid, _r3_:tuples}|} @ { Collection }))))
                    empty {
                    _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                    _r3_:collection {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                    } @ { Collection } } @ { Collection })))) empty {
                _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                _r3_:collection {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                } @ { Collection } } @ { Collection }).groupBy
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
               ((\_b2_ ->
               bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                 bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                 {key:acc_vid.combine
                  ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                  value:((acc_tuples.combine
                           tuples).groupBy
                           ((\tuple ->  tuple)) ((\_ -> (\_ ->  ()))) ()).fold
                          ((\__acc_map -> (\_b3_ -> 
                            bind _b3_ as {key:__1, value:__2} in 
                            __acc_map.combine
                            ({|
                            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                            _r3_:int | __1|} @ { Collection })))) empty {
                          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                          _r3_:int } @ { Collection }})))
               {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                value:empty {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                } @ { Collection }}).iterate
              ((\_b1_ -> 
                bind _b1_ as {key:ip, value:_b3_} in 
                bind _b3_ as {key:vid_send_list, value:tuple} in 
                (delete_S_rcv_corrective_s4_m___SQL_SUM_AGGREGATE_1_mS1, ip)<- {
                  _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
          else
            if stmt_id == 2
            then
              ((vid_list.fold
                  ((\__acc_ext -> (\vid -> 
                    __acc_ext.combine
                    (bind log_get_bound_insert_S vid as {_r1_:vid, _r2_:S_B,
                                                         _r3_:S_C} in 
                    (shuffle___SQL_SUM_AGGREGATE_1_mS1_to___SQL_SUM_AGGREGATE_2
                       {_r1_:(), _r2_:delta_tuples, _r3_:false}).fold
                      ((\__acc_map -> (\_b3_ -> 
                        bind _b3_ as {key:ip, value:tuples} in 
                        __acc_map.combine
                        ({|
                        _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                        _r3_:collection {
                        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                        _r3_:int } @ { Collection } |
                        {_r1_:ip, _r2_:vid, _r3_:tuples}|} @ { Collection }))))
                      empty {
                      _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                      _r3_:collection {
                      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                      } @ { Collection } } @ { Collection })))) empty {
                  _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                  _r3_:collection {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                  } @ { Collection } } @ { Collection }).groupBy
                 ((\_b1_ -> 
                   bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
                 ((\_b2_ ->
                 bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                   bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                   {key:acc_vid.combine
                    ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                    value:((acc_tuples.combine
                             tuples).groupBy
                             ((\tuple ->  tuple)) ((\_ -> (\_ ->  ()))) ()).fold
                            ((\__acc_map -> (\_b3_ -> 
                              bind _b3_ as {key:__1, value:__2} in 
                              __acc_map.combine
                              ({|
                              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                              _r3_:int | __1|} @ { Collection })))) empty {
                            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                            _r3_:int } @ { Collection }})))
                 {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                  value:empty {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                  } @ { Collection }}).iterate
                ((\_b1_ -> 
                  bind _b1_ as {key:ip, value:_b3_} in 
                  bind _b3_ as {key:vid_send_list, value:tuple} in 
                  (insert_S_rcv_corrective_s2_m___SQL_SUM_AGGREGATE_1_mS1, ip)<- {
                    _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
            else
              if stmt_id == 0
              then
                ((vid_list.fold
                    ((\__acc_ext -> (\vid -> 
                      __acc_ext.combine
                      (bind log_get_bound_insert_S vid as {_r1_:vid, _r2_:S_B,
                                                           _r3_:S_C} in 
                      (shuffle___SQL_SUM_AGGREGATE_1_mS1_to___SQL_SUM_AGGREGATE_1
                         {_r1_:(), _r2_:delta_tuples, _r3_:false}).fold
                        ((\__acc_map -> (\_b3_ -> 
                          bind _b3_ as {key:ip, value:tuples} in 
                          __acc_map.combine
                          ({|
                          _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                          _r3_:collection {
                          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                          _r3_:int } @ { Collection } |
                          {_r1_:ip, _r2_:vid, _r3_:tuples}|} @ { Collection }))))
                        empty {
                        _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                        _r3_:collection {
                        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                        _r3_:int } @ { Collection } } @ { Collection }))))
                    empty {
                    _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                    _r3_:collection {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                    } @ { Collection } } @ { Collection }).groupBy
                   ((\_b1_ -> 
                     bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
                   ((\_b2_ ->
                   bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                     bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                     {key:acc_vid.combine
                      ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                      value:((acc_tuples.combine
                               tuples).groupBy
                               ((\tuple ->  tuple)) ((\_ -> (\_ ->  ()))) ()).fold
                              ((\__acc_map -> (\_b3_ -> 
                                bind _b3_ as {key:__1, value:__2} in 
                                __acc_map.combine
                                ({|
                                _r1_:{ _r1_:int, _r2_:int, _r3_:int },
                                _r2_:int, _r3_:int | __1|} @ { Collection }))))
                              empty {
                              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                              _r3_:int } @ { Collection }})))
                   {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                    value:empty {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                    } @ { Collection }}).iterate
                  ((\_b1_ -> 
                    bind _b1_ as {key:ip, value:_b3_} in 
                    bind _b3_ as {key:vid_send_list, value:tuple} in 
                    (insert_S_rcv_corrective_s0_m___SQL_SUM_AGGREGATE_1_mS1,
                      ip)<- {_r1_:corrective_vid, _r2_:vid_send_list,
                             _r3_:tuple}))
              else ())))

trigger __SQL_SUM_AGGREGATE_2_mR1_send_correctives : {
key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {key:corrective_vid, value:delta_tuples} in 
    let corrective_list =
      filter_corrective_list
        {key:corrective_vid, value:{| key:int, value:int | {key:3, value:14},
         {key:2, value:10}|} @ { Collection }} in
    corrective_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:vid_list} in 
        if stmt_id == 14
        then
          ((vid_list.fold
              ((\__acc_ext -> (\vid -> 
                __acc_ext.combine
                (bind log_get_bound_delete_R vid as {_r1_:vid, _r2_:R_A,
                                                     _r3_:R_B} in 
                (shuffle___SQL_SUM_AGGREGATE_2_mR1_to___SQL_SUM_AGGREGATE_2
                   {_r1_:(), _r2_:delta_tuples, _r3_:false}).fold
                  ((\__acc_map -> (\_b3_ -> 
                    bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
                    ({|
                    _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                    _r3_:collection {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                    } @ { Collection } |
                    {_r1_:ip, _r2_:vid, _r3_:tuples}|} @ { Collection }))))
                  empty {
                  _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                  _r3_:collection {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                  } @ { Collection } } @ { Collection })))) empty {
              _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
              _r3_:collection {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
              } @ { Collection } } @ { Collection }).groupBy
             ((\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
             ((\_b2_ ->
             bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
               bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
               {key:acc_vid.combine
                ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                value:((acc_tuples.combine
                         tuples).groupBy
                         ((\tuple ->  tuple)) ((\_ -> (\_ ->  ()))) ()).fold
                        ((\__acc_map -> (\_b3_ -> 
                          bind _b3_ as {key:__1, value:__2} in 
                          __acc_map.combine
                          ({|
                          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                          _r3_:int | __1|} @ { Collection })))) empty {
                        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                        _r3_:int } @ { Collection }})))
             {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
              value:empty {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
              } @ { Collection }}).iterate
            ((\_b1_ -> 
              bind _b1_ as {key:ip, value:_b3_} in 
              bind _b3_ as {key:vid_send_list, value:tuple} in 
              (delete_R_rcv_corrective_s14_m___SQL_SUM_AGGREGATE_2_mR1, ip)<- {
                _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
        else
          if stmt_id == 10
          then
            ((vid_list.fold
                ((\__acc_ext -> (\vid -> 
                  __acc_ext.combine
                  (bind log_get_bound_insert_R vid as {_r1_:vid, _r2_:R_A,
                                                       _r3_:R_B} in 
                  (shuffle___SQL_SUM_AGGREGATE_2_mR1_to___SQL_SUM_AGGREGATE_2
                     {_r1_:(), _r2_:delta_tuples, _r3_:false}).fold
                    ((\__acc_map -> (\_b3_ -> 
                      bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
                      ({|
                      _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                      _r3_:collection {
                      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                      } @ { Collection } |
                      {_r1_:ip, _r2_:vid, _r3_:tuples}|} @ { Collection }))))
                    empty {
                    _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                    _r3_:collection {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                    } @ { Collection } } @ { Collection })))) empty {
                _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                _r3_:collection {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                } @ { Collection } } @ { Collection }).groupBy
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
               ((\_b2_ ->
               bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                 bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                 {key:acc_vid.combine
                  ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                  value:((acc_tuples.combine
                           tuples).groupBy
                           ((\tuple ->  tuple)) ((\_ -> (\_ ->  ()))) ()).fold
                          ((\__acc_map -> (\_b3_ -> 
                            bind _b3_ as {key:__1, value:__2} in 
                            __acc_map.combine
                            ({|
                            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                            _r3_:int | __1|} @ { Collection })))) empty {
                          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                          _r3_:int } @ { Collection }})))
               {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                value:empty {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                } @ { Collection }}).iterate
              ((\_b1_ -> 
                bind _b1_ as {key:ip, value:_b3_} in 
                bind _b3_ as {key:vid_send_list, value:tuple} in 
                (insert_R_rcv_corrective_s10_m___SQL_SUM_AGGREGATE_2_mR1, ip)<- {
                  _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
          else ())))

trigger __SQL_SUM_AGGREGATE_1_mR1_send_correctives : {
key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {key:corrective_vid, value:delta_tuples} in 
    let corrective_list =
      filter_corrective_list
        {key:corrective_vid, value:{| key:int, value:int | {key:3, value:14},
         {key:3, value:12}, {key:2, value:10},
         {key:2, value:8}|} @ { Collection }} in
    corrective_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:vid_list} in 
        if stmt_id == 14
        then
          ((vid_list.fold
              ((\__acc_ext -> (\vid -> 
                __acc_ext.combine
                (bind log_get_bound_delete_R vid as {_r1_:vid, _r2_:R_A,
                                                     _r3_:R_B} in 
                (shuffle___SQL_SUM_AGGREGATE_1_mR1_to___SQL_SUM_AGGREGATE_2
                   {_r1_:(), _r2_:delta_tuples, _r3_:false}).fold
                  ((\__acc_map -> (\_b3_ -> 
                    bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
                    ({|
                    _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                    _r3_:collection {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                    } @ { Collection } |
                    {_r1_:ip, _r2_:vid, _r3_:tuples}|} @ { Collection }))))
                  empty {
                  _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                  _r3_:collection {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                  } @ { Collection } } @ { Collection })))) empty {
              _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
              _r3_:collection {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
              } @ { Collection } } @ { Collection }).groupBy
             ((\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
             ((\_b2_ ->
             bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
               bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
               {key:acc_vid.combine
                ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                value:((acc_tuples.combine
                         tuples).groupBy
                         ((\tuple ->  tuple)) ((\_ -> (\_ ->  ()))) ()).fold
                        ((\__acc_map -> (\_b3_ -> 
                          bind _b3_ as {key:__1, value:__2} in 
                          __acc_map.combine
                          ({|
                          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                          _r3_:int | __1|} @ { Collection })))) empty {
                        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                        _r3_:int } @ { Collection }})))
             {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
              value:empty {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
              } @ { Collection }}).iterate
            ((\_b1_ -> 
              bind _b1_ as {key:ip, value:_b3_} in 
              bind _b3_ as {key:vid_send_list, value:tuple} in 
              (delete_R_rcv_corrective_s14_m___SQL_SUM_AGGREGATE_1_mR1, ip)<- {
                _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
        else
          if stmt_id == 12
          then
            ((vid_list.fold
                ((\__acc_ext -> (\vid -> 
                  __acc_ext.combine
                  (bind log_get_bound_delete_R vid as {_r1_:vid, _r2_:R_A,
                                                       _r3_:R_B} in 
                  (shuffle___SQL_SUM_AGGREGATE_1_mR1_to___SQL_SUM_AGGREGATE_1
                     {_r1_:(), _r2_:delta_tuples, _r3_:false}).fold
                    ((\__acc_map -> (\_b3_ -> 
                      bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
                      ({|
                      _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                      _r3_:collection {
                      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                      } @ { Collection } |
                      {_r1_:ip, _r2_:vid, _r3_:tuples}|} @ { Collection }))))
                    empty {
                    _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                    _r3_:collection {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                    } @ { Collection } } @ { Collection })))) empty {
                _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                _r3_:collection {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                } @ { Collection } } @ { Collection }).groupBy
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
               ((\_b2_ ->
               bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                 bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                 {key:acc_vid.combine
                  ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                  value:((acc_tuples.combine
                           tuples).groupBy
                           ((\tuple ->  tuple)) ((\_ -> (\_ ->  ()))) ()).fold
                          ((\__acc_map -> (\_b3_ -> 
                            bind _b3_ as {key:__1, value:__2} in 
                            __acc_map.combine
                            ({|
                            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                            _r3_:int | __1|} @ { Collection })))) empty {
                          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                          _r3_:int } @ { Collection }})))
               {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                value:empty {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                } @ { Collection }}).iterate
              ((\_b1_ -> 
                bind _b1_ as {key:ip, value:_b3_} in 
                bind _b3_ as {key:vid_send_list, value:tuple} in 
                (delete_R_rcv_corrective_s12_m___SQL_SUM_AGGREGATE_1_mR1, ip)<- {
                  _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
          else
            if stmt_id == 10
            then
              ((vid_list.fold
                  ((\__acc_ext -> (\vid -> 
                    __acc_ext.combine
                    (bind log_get_bound_insert_R vid as {_r1_:vid, _r2_:R_A,
                                                         _r3_:R_B} in 
                    (shuffle___SQL_SUM_AGGREGATE_1_mR1_to___SQL_SUM_AGGREGATE_2
                       {_r1_:(), _r2_:delta_tuples, _r3_:false}).fold
                      ((\__acc_map -> (\_b3_ -> 
                        bind _b3_ as {key:ip, value:tuples} in 
                        __acc_map.combine
                        ({|
                        _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                        _r3_:collection {
                        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                        _r3_:int } @ { Collection } |
                        {_r1_:ip, _r2_:vid, _r3_:tuples}|} @ { Collection }))))
                      empty {
                      _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                      _r3_:collection {
                      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                      } @ { Collection } } @ { Collection })))) empty {
                  _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                  _r3_:collection {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                  } @ { Collection } } @ { Collection }).groupBy
                 ((\_b1_ -> 
                   bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
                 ((\_b2_ ->
                 bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                   bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                   {key:acc_vid.combine
                    ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                    value:((acc_tuples.combine
                             tuples).groupBy
                             ((\tuple ->  tuple)) ((\_ -> (\_ ->  ()))) ()).fold
                            ((\__acc_map -> (\_b3_ -> 
                              bind _b3_ as {key:__1, value:__2} in 
                              __acc_map.combine
                              ({|
                              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                              _r3_:int | __1|} @ { Collection })))) empty {
                            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                            _r3_:int } @ { Collection }})))
                 {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                  value:empty {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                  } @ { Collection }}).iterate
                ((\_b1_ -> 
                  bind _b1_ as {key:ip, value:_b3_} in 
                  bind _b3_ as {key:vid_send_list, value:tuple} in 
                  (insert_R_rcv_corrective_s10_m___SQL_SUM_AGGREGATE_1_mR1, ip)<- {
                    _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
            else
              if stmt_id == 8
              then
                ((vid_list.fold
                    ((\__acc_ext -> (\vid -> 
                      __acc_ext.combine
                      (bind log_get_bound_insert_R vid as {_r1_:vid, _r2_:R_A,
                                                           _r3_:R_B} in 
                      (shuffle___SQL_SUM_AGGREGATE_1_mR1_to___SQL_SUM_AGGREGATE_1
                         {_r1_:(), _r2_:delta_tuples, _r3_:false}).fold
                        ((\__acc_map -> (\_b3_ -> 
                          bind _b3_ as {key:ip, value:tuples} in 
                          __acc_map.combine
                          ({|
                          _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                          _r3_:collection {
                          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                          _r3_:int } @ { Collection } |
                          {_r1_:ip, _r2_:vid, _r3_:tuples}|} @ { Collection }))))
                        empty {
                        _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                        _r3_:collection {
                        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                        _r3_:int } @ { Collection } } @ { Collection }))))
                    empty {
                    _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                    _r3_:collection {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                    } @ { Collection } } @ { Collection }).groupBy
                   ((\_b1_ -> 
                     bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
                   ((\_b2_ ->
                   bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                     bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                     {key:acc_vid.combine
                      ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                      value:((acc_tuples.combine
                               tuples).groupBy
                               ((\tuple ->  tuple)) ((\_ -> (\_ ->  ()))) ()).fold
                              ((\__acc_map -> (\_b3_ -> 
                                bind _b3_ as {key:__1, value:__2} in 
                                __acc_map.combine
                                ({|
                                _r1_:{ _r1_:int, _r2_:int, _r3_:int },
                                _r2_:int, _r3_:int | __1|} @ { Collection }))))
                              empty {
                              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                              _r3_:int } @ { Collection }})))
                   {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                    value:empty {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                    } @ { Collection }}).iterate
                  ((\_b1_ -> 
                    bind _b1_ as {key:ip, value:_b3_} in 
                    bind _b3_ as {key:vid_send_list, value:tuple} in 
                    (insert_R_rcv_corrective_s8_m___SQL_SUM_AGGREGATE_1_mR1,
                      ip)<- {_r1_:corrective_vid, _r2_:vid_send_list,
                             _r3_:tuple}))
              else ())))

trigger __SQL_SUM_AGGREGATE_2_mS3_send_correctives : {
key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Collection }
}
=
  (\_b1_ -> 
    bind _b1_ as {key:corrective_vid, value:delta_tuples} in 
    let corrective_list =
      filter_corrective_list
        {key:corrective_vid, value:{| key:int, value:int | {key:1, value:6},
         {key:0, value:2}|} @ { Collection }} in
    corrective_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:vid_list} in 
        if stmt_id == 6
        then
          ((vid_list.fold
              ((\__acc_ext -> (\vid -> 
                __acc_ext.combine
                (bind log_get_bound_delete_S vid as {_r1_:vid, _r2_:S_B,
                                                     _r3_:S_C} in 
                (shuffle___SQL_SUM_AGGREGATE_2_mS3_to___SQL_SUM_AGGREGATE_2
                   {_r1_:(), _r2_:delta_tuples, _r3_:false}).fold
                  ((\__acc_map -> (\_b3_ -> 
                    bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
                    ({|
                    _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                    _r3_:collection {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                    } @ { Collection } |
                    {_r1_:ip, _r2_:vid, _r3_:tuples}|} @ { Collection }))))
                  empty {
                  _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                  _r3_:collection {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                  } @ { Collection } } @ { Collection })))) empty {
              _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
              _r3_:collection {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
              } @ { Collection } } @ { Collection }).groupBy
             ((\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
             ((\_b2_ ->
             bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
               bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
               {key:acc_vid.combine
                ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                value:((acc_tuples.combine
                         tuples).groupBy
                         ((\tuple ->  tuple)) ((\_ -> (\_ ->  ()))) ()).fold
                        ((\__acc_map -> (\_b3_ -> 
                          bind _b3_ as {key:__1, value:__2} in 
                          __acc_map.combine
                          ({|
                          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                          _r3_:int | __1|} @ { Collection })))) empty {
                        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                        _r3_:int } @ { Collection }})))
             {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
              value:empty {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
              } @ { Collection }}).iterate
            ((\_b1_ -> 
              bind _b1_ as {key:ip, value:_b3_} in 
              bind _b3_ as {key:vid_send_list, value:tuple} in 
              (delete_S_rcv_corrective_s6_m___SQL_SUM_AGGREGATE_2_mS3, ip)<- {
                _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
        else
          if stmt_id == 2
          then
            ((vid_list.fold
                ((\__acc_ext -> (\vid -> 
                  __acc_ext.combine
                  (bind log_get_bound_insert_S vid as {_r1_:vid, _r2_:S_B,
                                                       _r3_:S_C} in 
                  (shuffle___SQL_SUM_AGGREGATE_2_mS3_to___SQL_SUM_AGGREGATE_2
                     {_r1_:(), _r2_:delta_tuples, _r3_:false}).fold
                    ((\__acc_map -> (\_b3_ -> 
                      bind _b3_ as {key:ip, value:tuples} in __acc_map.combine
                      ({|
                      _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                      _r3_:collection {
                      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                      } @ { Collection } |
                      {_r1_:ip, _r2_:vid, _r3_:tuples}|} @ { Collection }))))
                    empty {
                    _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                    _r3_:collection {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                    } @ { Collection } } @ { Collection })))) empty {
                _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                _r3_:collection {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                } @ { Collection } } @ { Collection }).groupBy
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
               ((\_b2_ ->
               bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                 bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                 {key:acc_vid.combine
                  ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                  value:((acc_tuples.combine
                           tuples).groupBy
                           ((\tuple ->  tuple)) ((\_ -> (\_ ->  ()))) ()).fold
                          ((\__acc_map -> (\_b3_ -> 
                            bind _b3_ as {key:__1, value:__2} in 
                            __acc_map.combine
                            ({|
                            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                            _r3_:int | __1|} @ { Collection })))) empty {
                          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                          _r3_:int } @ { Collection }})))
               {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                value:empty {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                } @ { Collection }}).iterate
              ((\_b1_ -> 
                bind _b1_ as {key:ip, value:_b3_} in 
                bind _b3_ as {key:vid_send_list, value:tuple} in 
                (insert_S_rcv_corrective_s2_m___SQL_SUM_AGGREGATE_2_mS3, ip)<- {
                  _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
          else ())))

trigger node_dummy : int
=
  (\x ->  ())

trigger switch_main : {
_r1_:string, _r2_:option { key:int, value:int }, _r3_:option {
key:int, value:int }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:trigger_id, _r2_:insert_R_args, _r3_:insert_S_args} in 
    if trigger_id == "insert_R"
    then
      (insert_R, me)<- let insert_R_args_unwrap = case insert_R_args of
        { Some x -> x }
        { None -> error () } in
        insert_R_args_unwrap
    else
      if trigger_id == "insert_S"
      then
        (insert_S, me)<- let insert_S_args_unwrap = case insert_S_args of
          { Some x -> x }
          { None -> error () } in
          insert_S_args_unwrap
      else ())

source s1 : {
_r1_:string, _r2_:option { key:int, value:int }, _r3_:option {
key:int, value:int }
} = file "rs.csv" k3
feed s1 |> switch_main

