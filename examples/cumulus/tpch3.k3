declare __map_ids__ : collection { _r1_:int, _r2_:string, _r3_:int
  } @ { Set } = {| _r1_:int, _r2_:string, _r3_:int |
  {_r1_:1, _r2_:"QUERY3", _r3_:4}, {_r1_:2, _r2_:"QUERY3_mLINEITEM1", _r3_:4},
  {_r1_:3, _r2_:"QUERY3_mLINEITEM1_mCUSTOMER2", _r3_:5},
  {_r1_:4, _r2_:"QUERY3_mORDERS1", _r3_:2},
  {_r1_:5, _r2_:"QUERY3_mORDERS3", _r3_:2},
  {_r1_:6, _r2_:"QUERY3_mORDERS6", _r3_:2},
  {_r1_:7, _r2_:"QUERY3_mCUSTOMER2", _r3_:5},
  {_r1_:8, _r2_:"QUERY3_mCUSTOMER4", _r3_:5}|} @ { Set }

declare __vid_counter__ : collection {i:int} @ { Set } = {|i:int| 1|} @ { Set }

declare __epoch__ : collection {i:int} @ { Set } = {|i:int| 0|} @ { Set }

declare __init_vid__ : { _r1_:int, _r2_:int, _r3_:int } =
  {_r1_:0, _r2_:0, _r3_:hash me}

declare QUERY3 : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:real } @ { Set }

declare QUERY3_mLINEITEM1 : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int
  } @ { Set }

declare QUERY3_mLINEITEM1_mCUSTOMER2 : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set }

declare QUERY3_mORDERS1 : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare QUERY3_mORDERS3 : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare QUERY3_mORDERS6 : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare QUERY3_mCUSTOMER2 : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set }

declare QUERY3_mCUSTOMER4 : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set }

declare map_QUERY3_mCUSTOMER2_s0_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set }

declare map_QUERY3_mCUSTOMER4_s0_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set }

declare map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set }

declare map_QUERY3_mCUSTOMER2_s3_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set }

declare map_QUERY3_mCUSTOMER4_s3_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set }

declare map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set }

declare map_QUERY3_mORDERS1_s6_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_QUERY3_mORDERS3_s6_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare map_QUERY3_mORDERS6_s6_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare map_QUERY3_mORDERS1_s7_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_QUERY3_mORDERS3_s9_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare map_QUERY3_mORDERS6_s10_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare map_QUERY3_mORDERS1_s11_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_QUERY3_mORDERS3_s11_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare map_QUERY3_mORDERS6_s11_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare map_QUERY3_mORDERS1_s12_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_QUERY3_mORDERS3_s14_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare map_QUERY3_mORDERS6_s15_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare map_QUERY3_mLINEITEM1_s16_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int
  } @ { Set }

declare map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set }

declare map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set }

declare map_QUERY3_mLINEITEM1_s21_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int
  } @ { Set }

declare map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set }

declare map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set }

declare map_QUERY3_mORDERS3_s36_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare map_QUERY3_mORDERS6_s36_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare map_QUERY3_mORDERS3_s38_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare map_QUERY3_mORDERS6_s38_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare map_QUERY3_mORDERS1_s40_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_QUERY3_mORDERS1_s42_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_QUERY3_mORDERS1_s44_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_QUERY3_mORDERS1_s46_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_QUERY3_mORDERS3_s48_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare map_QUERY3_mORDERS6_s48_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare map_QUERY3_mORDERS3_s50_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare map_QUERY3_mORDERS6_s50_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }

declare map_QUERY3_mORDERS1_s52_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_QUERY3_mORDERS1_s54_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_QUERY3_mORDERS1_s56_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_QUERY3_mORDERS1_s58_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare __stmt_cntrs__ : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare log__master : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare log_insert_CUSTOMER : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
  _r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string } @ { Set }

declare log_delete_CUSTOMER : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
  _r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string } @ { Set }

declare log_insert_ORDERS : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
  _r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
  } @ { Set }

declare log_delete_ORDERS : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
  _r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
  } @ { Set }

declare log_insert_LINEITEM : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string,
  _r11_:string, _r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string,
  _r17_:string } @ { Set }

declare log_delete_LINEITEM : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string,
  _r11_:string, _r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string,
  _r17_:string } @ { Set }

declare vid_eq : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in l0 == r0 and (l1 == r1 and l2
    == r2))

declare vid_neq : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in not (l0 == r0 and (l1 == r1 and
    l2 == r2)))

declare vid_lt : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in l0 < r0 or (l0 == r0 and (l1 <
    r1 or (l1 == r1 and l2 < r2))))

declare vid_gt : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in l0 > r0 or (l0 == r0 and (l1 >
    r1 or (l1 == r1 and l2 > r2))))

declare vid_leq : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in not (l0 > r0 or (l0 == r0 and
    (l1 > r1 or (l1 == r1 and l2 > r2)))))

declare vid_geq : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = (\_b1_ -> 
    bind _b1_ as {key:_b2_, value:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in not (l0 < r0 or (l0 == r0 and
    (l1 < r1 or (l1 == r1 and l2 < r2)))))

declare log_read_geq : { _r1_:int, _r2_:int, _r3_:int } -> collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set } =
  (\vid -> 
    (log__master.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:vid2, _r2_:trig, _r3_:stmt} in 
        vid_geq {key:vid2, value:vid}))).map
      ((\_b1_ -> 
        bind _b1_ as {_r1_:vid2, _r2_:trig, _r3_:stmt} in 
        {_r1_:vid2, _r2_:trig, _r3_:stmt})))

declare add_delta_to_QUERY3 : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:real } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = QUERY3 in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__2} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_, _r5_:_r5_} in (_r2_ ==
                        ORDERS_ORDERKEY and _r4_ == ORDERS_SHIPPRIORITY) and
                        _r3_ == ORDERS_ORDERDATE))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_2, _r5_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:real |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                              _r4_:__map_val}|} @ { Set }).combine acc,
                             value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:real |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_val}|} @ { Set }, value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:real
                       } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
               key:__1, value:__2} in __1 in
            if wrapped_lookup_value == empty {
              _r1_:int, _r2_:int, _r3_:int, _r4_:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:_,
                                       _r4_:projected_field} in projected_field)
            + __prod_ret__2 in (
            QUERY3.insert
              {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
               _r4_:ORDERS_SHIPPRIORITY, _r5_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_val} in 
          (((QUERY3.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_} in (_r2_ == __arg_0 and _r4_ ==
               __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_val} in vid > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3, _r5_:__id_4}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_val} in 
              QUERY3.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_val + __arg_val}))))
      ))

declare add_delta_to_QUERY3_mLINEITEM1 : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int
  } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = QUERY3_mLINEITEM1 in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                        _r3_:ORDERS_ORDERDATE, _r4_:ORDERS_SHIPPRIORITY,
                        _r5_:__prod_ret__3} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_, _r5_:_r5_} in (_r2_ ==
                        QUERY3_mLINEITEMLINEITEM_ORDERKEY and _r4_ ==
                        ORDERS_SHIPPRIORITY) and _r3_ == ORDERS_ORDERDATE))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_2, _r5_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:int |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                              _r4_:__map_val}|} @ { Set }).combine acc,
                             value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:int |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_val}|} @ { Set }, value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:int
                       } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
               key:__1, value:__2} in __1 in
            if wrapped_lookup_value == empty {
              _r1_:int, _r2_:int, _r3_:int, _r4_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:_,
                                       _r4_:projected_field} in projected_field)
            + __prod_ret__3 in (
            QUERY3_mLINEITEM1.insert
              {_r1_:vid, _r2_:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
               _r3_:ORDERS_ORDERDATE, _r4_:ORDERS_SHIPPRIORITY,
               _r5_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_val} in 
          (((QUERY3_mLINEITEM1.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_} in (_r2_ == __arg_0 and _r4_ ==
               __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_val} in vid > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3, _r5_:__id_4}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_val} in 
              QUERY3_mLINEITEM1.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_val + __arg_val}))))
      ))

declare add_delta_to_QUERY3_mLINEITEM1_mCUSTOMER2 : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = QUERY3_mLINEITEM1_mCUSTOMER2 in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                        _r6_:__cmp_ret__9} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_, _r5_:_r5_, _r6_:_r6_} in 
                        ((_r2_ == ORDERS_ORDERKEY and _r5_ == ORDERS_CUSTKEY)
                        and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
                        ORDERS_ORDERDATE))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_2, _r5_:__map_3,
                                      _r6_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({|
                             _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                              _r4_:__map_3, _r5_:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{|
                               _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
                               |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_3, _r5_:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty {
                       _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
                       } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
               key:__1, value:__2} in __1 in
            if wrapped_lookup_value == empty {
              _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:_, _r4_:_,
                                       _r5_:projected_field} in projected_field)
            + __cmp_ret__9 in (
            QUERY3_mLINEITEM1_mCUSTOMER2.insert
              {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
               _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_3, _r6_:__arg_val} in 
          (((QUERY3_mLINEITEM1_mCUSTOMER2.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in ((_r2_ == __arg_0 and
               _r5_ == __arg_3) and _r4_ == __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in vid
               > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4, _r6_:__id_5} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3,
                _r5_:__id_4, _r6_:__id_5}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_3, _r6_:__map_val} in 
              QUERY3_mLINEITEM1_mCUSTOMER2.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val + __arg_val}))))
      ))

declare add_delta_to_QUERY3_mORDERS1 : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = QUERY3_mORDERS1 in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:__cmp_ret__3} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == CUSTOMER_CUSTKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:int |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:int |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:int } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __cmp_ret__3 in (
            QUERY3_mORDERS1.insert
              {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((QUERY3_mORDERS1.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              QUERY3_mORDERS1.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_QUERY3_mORDERS3 : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = QUERY3_mORDERS3 in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__prod_ret__28} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __prod_ret__28 in (
            QUERY3_mORDERS3.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((QUERY3_mORDERS3.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              QUERY3_mORDERS3.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_QUERY3_mORDERS6 : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = QUERY3_mORDERS6 in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __val_ret__17 in (
            QUERY3_mORDERS6.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((QUERY3_mORDERS6.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              QUERY3_mORDERS6.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_QUERY3_mCUSTOMER2 : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = QUERY3_mCUSTOMER2 in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                        _r6_:__prod_ret__13} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_, _r5_:_r5_, _r6_:_r6_} in 
                        ((_r2_ == ORDERS_ORDERKEY and _r5_ == ORDERS_CUSTKEY)
                        and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
                        ORDERS_ORDERDATE))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_2, _r5_:__map_3,
                                      _r6_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({|
                             _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                             |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                              _r4_:__map_3, _r5_:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{|
                               _r1_:int, _r2_:int, _r3_:int, _r4_:int,
                               _r5_:real |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_3, _r5_:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty {
                       _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                       } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
               key:__1, value:__2} in __1 in
            if wrapped_lookup_value == empty {
              _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:_, _r4_:_,
                                       _r5_:projected_field} in projected_field)
            + __prod_ret__13 in (
            QUERY3_mCUSTOMER2.insert
              {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
               _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_3, _r6_:__arg_val} in 
          (((QUERY3_mCUSTOMER2.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in ((_r2_ == __arg_0 and
               _r5_ == __arg_3) and _r4_ == __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in vid
               > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4, _r6_:__id_5} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3,
                _r5_:__id_4, _r6_:__id_5}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_3, _r6_:__map_val} in 
              QUERY3_mCUSTOMER2.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val + __arg_val}))))
      ))

declare add_delta_to_QUERY3_mCUSTOMER4 : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = QUERY3_mCUSTOMER4 in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                        _r6_:__prod_ret__14} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_, _r5_:_r5_, _r6_:_r6_} in 
                        ((_r2_ == ORDERS_ORDERKEY and _r5_ == ORDERS_CUSTKEY)
                        and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
                        ORDERS_ORDERDATE))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_2, _r5_:__map_3,
                                      _r6_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({|
                             _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                             |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                              _r4_:__map_3, _r5_:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{|
                               _r1_:int, _r2_:int, _r3_:int, _r4_:int,
                               _r5_:real |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_3, _r5_:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty {
                       _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                       } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
               key:__1, value:__2} in __1 in
            if wrapped_lookup_value == empty {
              _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:_, _r4_:_,
                                       _r5_:projected_field} in projected_field)
            + __prod_ret__14 in (
            QUERY3_mCUSTOMER4.insert
              {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
               _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_3, _r6_:__arg_val} in 
          (((QUERY3_mCUSTOMER4.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in ((_r2_ == __arg_0 and
               _r5_ == __arg_3) and _r4_ == __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in vid
               > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4, _r6_:__id_5} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3,
                _r5_:__id_4, _r6_:__id_5}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_3, _r6_:__map_val} in 
              QUERY3_mCUSTOMER4.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val + __arg_val}))))
      ))

declare cond_add_delta_to_QUERY3 : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:real } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = QUERY3 in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__2} in 
          let lhs_slice = QUERY3.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_} in ((_r1_ == vid and _r4_ ==
              ORDERS_SHIPPRIORITY) and _r3_ == ORDERS_ORDERDATE) and _r2_ ==
              ORDERS_ORDERKEY)) in
          if lhs_slice != empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
            _r4_:int, _r5_:real } @ { Set }
          then
            QUERY3.update
              (case (lhs_slice.peek ()) of { Some x -> x }
              { None -> error () }) (bind case (lhs_slice.peek ()) of
              { Some x -> x }
              { None -> error () } as {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2,
                                       _r4_:lhs3, _r5_:lhs4} in 
              {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2, _r4_:lhs3, _r5_:lhs4 +
               __prod_ret__2})
          else
            let update_value =
              (let wrapped_lookup_value =
                 bind (existing_out_tier.filter
                        ((\_b1_ -> 
                          bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                        _r4_:_r4_, _r5_:_r5_} in (_r2_ ==
                          ORDERS_ORDERKEY and _r4_ == ORDERS_SHIPPRIORITY) and
                          _r3_ == ORDERS_ORDERDATE))).fold
                        ((\_b2_ ->
                        bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                          bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                        _r3_:__map_1, _r4_:__map_2,
                                        _r5_:__map_val} in 
                          if vid_lt {key:map_vid, value:vid}
                          then
                            if vid_eq {key:map_vid, value:max_vid}
                            then
                              {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:real
                               |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_val}|} @ { Set }).combine 
                               acc, value:max_vid}
                            else
                              if vid_gt {key:map_vid, value:max_vid}
                              then
                                {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:real
                                 |
                                 {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                  _r4_:__map_val}|} @ { Set }, value:map_vid}
                              else {key:acc, value:max_vid}
                          else {key:acc, value:max_vid})))
                        {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:real
                         } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
                 key:__1, value:__2} in __1 in
              if wrapped_lookup_value == empty {
                _r1_:int, _r2_:int, _r3_:int, _r4_:real } @ { Set }
              then 0
              else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
                { None -> error () } as {_r1_:_, _r2_:_, _r3_:_,
                                         _r4_:projected_field} in 
                projected_field) + __prod_ret__2 in (
              QUERY3.insert
                {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                 _r4_:ORDERS_SHIPPRIORITY, _r5_:update_value}
              )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_val} in 
          (((QUERY3.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_} in (_r2_ == __arg_0 and _r4_ ==
               __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_val} in vid > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3, _r5_:__id_4}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_val} in 
              QUERY3.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_val + __arg_val}))))
      ))

declare cond_add_delta_to_QUERY3_mLINEITEM1 : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int
  } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = QUERY3_mLINEITEM1 in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                        _r3_:ORDERS_ORDERDATE, _r4_:ORDERS_SHIPPRIORITY,
                        _r5_:__prod_ret__3} in 
          let lhs_slice = QUERY3_mLINEITEM1.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_} in ((_r1_ == vid and _r4_ ==
              ORDERS_SHIPPRIORITY) and _r3_ == ORDERS_ORDERDATE) and _r2_ ==
              QUERY3_mLINEITEMLINEITEM_ORDERKEY)) in
          if lhs_slice != empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
            _r4_:int, _r5_:int } @ { Set }
          then
            QUERY3_mLINEITEM1.update
              (case (lhs_slice.peek ()) of { Some x -> x }
              { None -> error () }) (bind case (lhs_slice.peek ()) of
              { Some x -> x }
              { None -> error () } as {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2,
                                       _r4_:lhs3, _r5_:lhs4} in 
              {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2, _r4_:lhs3, _r5_:lhs4 +
               __prod_ret__3})
          else
            let update_value =
              (let wrapped_lookup_value =
                 bind (existing_out_tier.filter
                        ((\_b1_ -> 
                          bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                        _r4_:_r4_, _r5_:_r5_} in (_r2_ ==
                          QUERY3_mLINEITEMLINEITEM_ORDERKEY and _r4_ ==
                          ORDERS_SHIPPRIORITY) and _r3_ == ORDERS_ORDERDATE))).fold
                        ((\_b2_ ->
                        bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                          bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                        _r3_:__map_1, _r4_:__map_2,
                                        _r5_:__map_val} in 
                          if vid_lt {key:map_vid, value:vid}
                          then
                            if vid_eq {key:map_vid, value:max_vid}
                            then
                              {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:int |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_val}|} @ { Set }).combine 
                               acc, value:max_vid}
                            else
                              if vid_gt {key:map_vid, value:max_vid}
                              then
                                {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:int
                                 |
                                 {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                  _r4_:__map_val}|} @ { Set }, value:map_vid}
                              else {key:acc, value:max_vid}
                          else {key:acc, value:max_vid})))
                        {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:int
                         } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
                 key:__1, value:__2} in __1 in
              if wrapped_lookup_value == empty {
                _r1_:int, _r2_:int, _r3_:int, _r4_:int } @ { Set }
              then 0
              else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
                { None -> error () } as {_r1_:_, _r2_:_, _r3_:_,
                                         _r4_:projected_field} in 
                projected_field) + __prod_ret__3 in (
              QUERY3_mLINEITEM1.insert
                {_r1_:vid, _r2_:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                 _r3_:ORDERS_ORDERDATE, _r4_:ORDERS_SHIPPRIORITY,
                 _r5_:update_value}
              )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_val} in 
          (((QUERY3_mLINEITEM1.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_} in (_r2_ == __arg_0 and _r4_ ==
               __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_val} in vid > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3, _r5_:__id_4}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_val} in 
              QUERY3_mLINEITEM1.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_val + __arg_val}))))
      ))

declare cond_add_delta_to_QUERY3_mLINEITEM1_mCUSTOMER2 : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = QUERY3_mLINEITEM1_mCUSTOMER2 in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                        _r6_:__cmp_ret__9} in 
          let lhs_slice = QUERY3_mLINEITEM1_mCUSTOMER2.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_, _r6_:_r6_} in (((_r1_ == vid and _r5_ ==
              ORDERS_CUSTKEY) and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
              ORDERS_ORDERDATE) and _r2_ == ORDERS_ORDERKEY)) in
          if lhs_slice != empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
            _r4_:int, _r5_:int, _r6_:int } @ { Set }
          then
            QUERY3_mLINEITEM1_mCUSTOMER2.update
              (case (lhs_slice.peek ()) of { Some x -> x }
              { None -> error () }) (bind case (lhs_slice.peek ()) of
              { Some x -> x }
              { None -> error () } as {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2,
                                       _r4_:lhs3, _r5_:lhs4, _r6_:lhs5} in 
              {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2, _r4_:lhs3, _r5_:lhs4, _r6_:lhs5
               + __cmp_ret__9})
          else
            let update_value =
              (let wrapped_lookup_value =
                 bind (existing_out_tier.filter
                        ((\_b1_ -> 
                          bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                        _r4_:_r4_, _r5_:_r5_, _r6_:_r6_} in 
                          ((_r2_ == ORDERS_ORDERKEY and _r5_ == ORDERS_CUSTKEY)
                          and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
                          ORDERS_ORDERDATE))).fold
                        ((\_b2_ ->
                        bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                          bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                        _r3_:__map_1, _r4_:__map_2,
                                        _r5_:__map_3, _r6_:__map_val} in 
                          if vid_lt {key:map_vid, value:vid}
                          then
                            if vid_eq {key:map_vid, value:max_vid}
                            then
                              {key:({|
                               _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
                               |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_3, _r5_:__map_val}|} @ { Set }).combine
                               acc, value:max_vid}
                            else
                              if vid_gt {key:map_vid, value:max_vid}
                              then
                                {key:{|
                                 _r1_:int, _r2_:int, _r3_:int, _r4_:int,
                                 _r5_:int |
                                 {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                  _r4_:__map_3, _r5_:__map_val}|} @ { Set },
                                 value:map_vid}
                              else {key:acc, value:max_vid}
                          else {key:acc, value:max_vid})))
                        {key:empty {
                         _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
                         } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
                 key:__1, value:__2} in __1 in
              if wrapped_lookup_value == empty {
                _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int } @ { Set }
              then 0
              else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
                { None -> error () } as {_r1_:_, _r2_:_, _r3_:_, _r4_:_,
                                         _r5_:projected_field} in 
                projected_field) + __cmp_ret__9 in (
              QUERY3_mLINEITEM1_mCUSTOMER2.insert
                {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                 _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                 _r6_:update_value}
              )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_3, _r6_:__arg_val} in 
          (((QUERY3_mLINEITEM1_mCUSTOMER2.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in ((_r2_ == __arg_0 and
               _r5_ == __arg_3) and _r4_ == __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in vid
               > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4, _r6_:__id_5} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3,
                _r5_:__id_4, _r6_:__id_5}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_3, _r6_:__map_val} in 
              QUERY3_mLINEITEM1_mCUSTOMER2.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val + __arg_val}))))
      ))

declare cond_add_delta_to_QUERY3_mORDERS1 : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = QUERY3_mORDERS1 in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:__cmp_ret__3} in 
          let lhs_slice = QUERY3_mORDERS1.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
              _r2_ == CUSTOMER_CUSTKEY)) in
          if lhs_slice != empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Set }
          then
            QUERY3_mORDERS1.update
              (case (lhs_slice.peek ()) of { Some x -> x }
              { None -> error () }) (bind case (lhs_slice.peek ()) of
              { Some x -> x }
              { None -> error () } as {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2} in 
              {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2 + __cmp_ret__3})
          else
            let update_value =
              (let wrapped_lookup_value =
                 bind (existing_out_tier.filter
                        ((\_b1_ -> 
                          bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
                          _r2_ == CUSTOMER_CUSTKEY))).fold
                        ((\_b2_ ->
                        bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                          bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                        _r3_:__map_val} in 
                          if vid_lt {key:map_vid, value:vid}
                          then
                            if vid_eq {key:map_vid, value:max_vid}
                            then
                              {key:({| key:int, value:int |
                               {key:__map_0, value:__map_val}|} @ { Set }).combine
                               acc, value:max_vid}
                            else
                              if vid_gt {key:map_vid, value:max_vid}
                              then
                                {key:{| key:int, value:int |
                                 {key:__map_0, value:__map_val}|} @ { Set },
                                 value:map_vid}
                              else {key:acc, value:max_vid}
                          else {key:acc, value:max_vid})))
                        {key:empty { key:int, value:int } @ { Set },
                         value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
                 __1 in
              if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
              then 0
              else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
                { None -> error () } as {key:_, value:projected_field} in 
                projected_field) + __cmp_ret__3 in (
              QUERY3_mORDERS1.insert
                {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:update_value}
              )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((QUERY3_mORDERS1.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              QUERY3_mORDERS1.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare cond_add_delta_to_QUERY3_mORDERS3 : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = QUERY3_mORDERS3 in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__prod_ret__28} in 
          let lhs_slice = QUERY3_mORDERS3.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
              _r2_ == LINEITEM_ORDERKEY)) in
          if lhs_slice != empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
            } @ { Set }
          then
            QUERY3_mORDERS3.update
              (case (lhs_slice.peek ()) of { Some x -> x }
              { None -> error () }) (bind case (lhs_slice.peek ()) of
              { Some x -> x }
              { None -> error () } as {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2} in 
              {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2 + __prod_ret__28})
          else
            let update_value =
              (let wrapped_lookup_value =
                 bind (existing_out_tier.filter
                        ((\_b1_ -> 
                          bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
                          _r2_ == LINEITEM_ORDERKEY))).fold
                        ((\_b2_ ->
                        bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                          bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                        _r3_:__map_val} in 
                          if vid_lt {key:map_vid, value:vid}
                          then
                            if vid_eq {key:map_vid, value:max_vid}
                            then
                              {key:({| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set }).combine
                               acc, value:max_vid}
                            else
                              if vid_gt {key:map_vid, value:max_vid}
                              then
                                {key:{| key:int, value:real |
                                 {key:__map_0, value:__map_val}|} @ { Set },
                                 value:map_vid}
                              else {key:acc, value:max_vid}
                          else {key:acc, value:max_vid})))
                        {key:empty { key:int, value:real } @ { Set },
                         value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
                 __1 in
              if wrapped_lookup_value == empty { key:int, value:real
                } @ { Set }
              then 0
              else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
                { None -> error () } as {key:_, value:projected_field} in 
                projected_field) + __prod_ret__28 in (
              QUERY3_mORDERS3.insert
                {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
              )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((QUERY3_mORDERS3.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              QUERY3_mORDERS3.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare cond_add_delta_to_QUERY3_mORDERS6 : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = QUERY3_mORDERS6 in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__val_ret__17} in 
          let lhs_slice = QUERY3_mORDERS6.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
              _r2_ == LINEITEM_ORDERKEY)) in
          if lhs_slice != empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
            } @ { Set }
          then
            QUERY3_mORDERS6.update
              (case (lhs_slice.peek ()) of { Some x -> x }
              { None -> error () }) (bind case (lhs_slice.peek ()) of
              { Some x -> x }
              { None -> error () } as {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2} in 
              {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2 + __val_ret__17})
          else
            let update_value =
              (let wrapped_lookup_value =
                 bind (existing_out_tier.filter
                        ((\_b1_ -> 
                          bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
                          _r2_ == LINEITEM_ORDERKEY))).fold
                        ((\_b2_ ->
                        bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                          bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                        _r3_:__map_val} in 
                          if vid_lt {key:map_vid, value:vid}
                          then
                            if vid_eq {key:map_vid, value:max_vid}
                            then
                              {key:({| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set }).combine
                               acc, value:max_vid}
                            else
                              if vid_gt {key:map_vid, value:max_vid}
                              then
                                {key:{| key:int, value:real |
                                 {key:__map_0, value:__map_val}|} @ { Set },
                                 value:map_vid}
                              else {key:acc, value:max_vid}
                          else {key:acc, value:max_vid})))
                        {key:empty { key:int, value:real } @ { Set },
                         value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
                 __1 in
              if wrapped_lookup_value == empty { key:int, value:real
                } @ { Set }
              then 0
              else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
                { None -> error () } as {key:_, value:projected_field} in 
                projected_field) + __val_ret__17 in (
              QUERY3_mORDERS6.insert
                {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
              )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((QUERY3_mORDERS6.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              QUERY3_mORDERS6.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare cond_add_delta_to_QUERY3_mCUSTOMER2 : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = QUERY3_mCUSTOMER2 in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                        _r6_:__prod_ret__13} in 
          let lhs_slice = QUERY3_mCUSTOMER2.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_, _r6_:_r6_} in (((_r1_ == vid and _r5_ ==
              ORDERS_CUSTKEY) and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
              ORDERS_ORDERDATE) and _r2_ == ORDERS_ORDERKEY)) in
          if lhs_slice != empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
            _r4_:int, _r5_:int, _r6_:real } @ { Set }
          then
            QUERY3_mCUSTOMER2.update
              (case (lhs_slice.peek ()) of { Some x -> x }
              { None -> error () }) (bind case (lhs_slice.peek ()) of
              { Some x -> x }
              { None -> error () } as {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2,
                                       _r4_:lhs3, _r5_:lhs4, _r6_:lhs5} in 
              {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2, _r4_:lhs3, _r5_:lhs4, _r6_:lhs5
               + __prod_ret__13})
          else
            let update_value =
              (let wrapped_lookup_value =
                 bind (existing_out_tier.filter
                        ((\_b1_ -> 
                          bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                        _r4_:_r4_, _r5_:_r5_, _r6_:_r6_} in 
                          ((_r2_ == ORDERS_ORDERKEY and _r5_ == ORDERS_CUSTKEY)
                          and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
                          ORDERS_ORDERDATE))).fold
                        ((\_b2_ ->
                        bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                          bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                        _r3_:__map_1, _r4_:__map_2,
                                        _r5_:__map_3, _r6_:__map_val} in 
                          if vid_lt {key:map_vid, value:vid}
                          then
                            if vid_eq {key:map_vid, value:max_vid}
                            then
                              {key:({|
                               _r1_:int, _r2_:int, _r3_:int, _r4_:int,
                               _r5_:real |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_3, _r5_:__map_val}|} @ { Set }).combine
                               acc, value:max_vid}
                            else
                              if vid_gt {key:map_vid, value:max_vid}
                              then
                                {key:{|
                                 _r1_:int, _r2_:int, _r3_:int, _r4_:int,
                                 _r5_:real |
                                 {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                  _r4_:__map_3, _r5_:__map_val}|} @ { Set },
                                 value:map_vid}
                              else {key:acc, value:max_vid}
                          else {key:acc, value:max_vid})))
                        {key:empty {
                         _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                         } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
                 key:__1, value:__2} in __1 in
              if wrapped_lookup_value == empty {
                _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real } @ { Set }
              then 0
              else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
                { None -> error () } as {_r1_:_, _r2_:_, _r3_:_, _r4_:_,
                                         _r5_:projected_field} in 
                projected_field) + __prod_ret__13 in (
              QUERY3_mCUSTOMER2.insert
                {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                 _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                 _r6_:update_value}
              )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_3, _r6_:__arg_val} in 
          (((QUERY3_mCUSTOMER2.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in ((_r2_ == __arg_0 and
               _r5_ == __arg_3) and _r4_ == __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in vid
               > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4, _r6_:__id_5} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3,
                _r5_:__id_4, _r6_:__id_5}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_3, _r6_:__map_val} in 
              QUERY3_mCUSTOMER2.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val + __arg_val}))))
      ))

declare cond_add_delta_to_QUERY3_mCUSTOMER4 : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = QUERY3_mCUSTOMER4 in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                        _r6_:__prod_ret__14} in 
          let lhs_slice = QUERY3_mCUSTOMER4.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_, _r6_:_r6_} in (((_r1_ == vid and _r5_ ==
              ORDERS_CUSTKEY) and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
              ORDERS_ORDERDATE) and _r2_ == ORDERS_ORDERKEY)) in
          if lhs_slice != empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
            _r4_:int, _r5_:int, _r6_:real } @ { Set }
          then
            QUERY3_mCUSTOMER4.update
              (case (lhs_slice.peek ()) of { Some x -> x }
              { None -> error () }) (bind case (lhs_slice.peek ()) of
              { Some x -> x }
              { None -> error () } as {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2,
                                       _r4_:lhs3, _r5_:lhs4, _r6_:lhs5} in 
              {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2, _r4_:lhs3, _r5_:lhs4, _r6_:lhs5
               + __prod_ret__14})
          else
            let update_value =
              (let wrapped_lookup_value =
                 bind (existing_out_tier.filter
                        ((\_b1_ -> 
                          bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                        _r4_:_r4_, _r5_:_r5_, _r6_:_r6_} in 
                          ((_r2_ == ORDERS_ORDERKEY and _r5_ == ORDERS_CUSTKEY)
                          and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
                          ORDERS_ORDERDATE))).fold
                        ((\_b2_ ->
                        bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                          bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                        _r3_:__map_1, _r4_:__map_2,
                                        _r5_:__map_3, _r6_:__map_val} in 
                          if vid_lt {key:map_vid, value:vid}
                          then
                            if vid_eq {key:map_vid, value:max_vid}
                            then
                              {key:({|
                               _r1_:int, _r2_:int, _r3_:int, _r4_:int,
                               _r5_:real |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_3, _r5_:__map_val}|} @ { Set }).combine
                               acc, value:max_vid}
                            else
                              if vid_gt {key:map_vid, value:max_vid}
                              then
                                {key:{|
                                 _r1_:int, _r2_:int, _r3_:int, _r4_:int,
                                 _r5_:real |
                                 {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                  _r4_:__map_3, _r5_:__map_val}|} @ { Set },
                                 value:map_vid}
                              else {key:acc, value:max_vid}
                          else {key:acc, value:max_vid})))
                        {key:empty {
                         _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                         } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
                 key:__1, value:__2} in __1 in
              if wrapped_lookup_value == empty {
                _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real } @ { Set }
              then 0
              else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
                { None -> error () } as {_r1_:_, _r2_:_, _r3_:_, _r4_:_,
                                         _r5_:projected_field} in 
                projected_field) + __prod_ret__14 in (
              QUERY3_mCUSTOMER4.insert
                {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                 _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                 _r6_:update_value}
              )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_3, _r6_:__arg_val} in 
          (((QUERY3_mCUSTOMER4.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in ((_r2_ == __arg_0 and
               _r5_ == __arg_3) and _r4_ == __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in vid
               > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4, _r6_:__id_5} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3,
                _r5_:__id_4, _r6_:__id_5}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_3, _r6_:__map_val} in 
              QUERY3_mCUSTOMER4.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mCUSTOMER2_s0_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mCUSTOMER2_s0_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                        _r6_:__prod_ret__13} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_, _r5_:_r5_, _r6_:_r6_} in 
                        ((_r2_ == ORDERS_ORDERKEY and _r5_ == ORDERS_CUSTKEY)
                        and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
                        ORDERS_ORDERDATE))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_2, _r5_:__map_3,
                                      _r6_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({|
                             _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                             |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                              _r4_:__map_3, _r5_:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{|
                               _r1_:int, _r2_:int, _r3_:int, _r4_:int,
                               _r5_:real |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_3, _r5_:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty {
                       _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                       } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
               key:__1, value:__2} in __1 in
            if wrapped_lookup_value == empty {
              _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:_, _r4_:_,
                                       _r5_:projected_field} in projected_field)
            + __prod_ret__13 in (
            map_QUERY3_mCUSTOMER2_s0_buf.insert
              {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
               _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_3, _r6_:__arg_val} in 
          (((map_QUERY3_mCUSTOMER2_s0_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in ((_r2_ == __arg_0 and
               _r5_ == __arg_3) and _r4_ == __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in vid
               > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4, _r6_:__id_5} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3,
                _r5_:__id_4, _r6_:__id_5}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_3, _r6_:__map_val} in 
              map_QUERY3_mCUSTOMER2_s0_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mCUSTOMER4_s0_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mCUSTOMER4_s0_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                        _r6_:__prod_ret__14} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_, _r5_:_r5_, _r6_:_r6_} in 
                        ((_r2_ == ORDERS_ORDERKEY and _r5_ == ORDERS_CUSTKEY)
                        and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
                        ORDERS_ORDERDATE))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_2, _r5_:__map_3,
                                      _r6_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({|
                             _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                             |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                              _r4_:__map_3, _r5_:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{|
                               _r1_:int, _r2_:int, _r3_:int, _r4_:int,
                               _r5_:real |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_3, _r5_:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty {
                       _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                       } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
               key:__1, value:__2} in __1 in
            if wrapped_lookup_value == empty {
              _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:_, _r4_:_,
                                       _r5_:projected_field} in projected_field)
            + __prod_ret__14 in (
            map_QUERY3_mCUSTOMER4_s0_buf.insert
              {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
               _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_3, _r6_:__arg_val} in 
          (((map_QUERY3_mCUSTOMER4_s0_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in ((_r2_ == __arg_0 and
               _r5_ == __arg_3) and _r4_ == __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in vid
               > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4, _r6_:__id_5} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3,
                _r5_:__id_4, _r6_:__id_5}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_3, _r6_:__map_val} in 
              map_QUERY3_mCUSTOMER4_s0_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                        _r6_:__cmp_ret__9} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_, _r5_:_r5_, _r6_:_r6_} in 
                        ((_r2_ == ORDERS_ORDERKEY and _r5_ == ORDERS_CUSTKEY)
                        and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
                        ORDERS_ORDERDATE))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_2, _r5_:__map_3,
                                      _r6_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({|
                             _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                              _r4_:__map_3, _r5_:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{|
                               _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
                               |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_3, _r5_:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty {
                       _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
                       } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
               key:__1, value:__2} in __1 in
            if wrapped_lookup_value == empty {
              _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:_, _r4_:_,
                                       _r5_:projected_field} in projected_field)
            + __cmp_ret__9 in (
            map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf.insert
              {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
               _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_3, _r6_:__arg_val} in 
          (((map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in ((_r2_ == __arg_0 and
               _r5_ == __arg_3) and _r4_ == __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in vid
               > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4, _r6_:__id_5} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3,
                _r5_:__id_4, _r6_:__id_5}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_3, _r6_:__map_val} in 
              map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mCUSTOMER2_s3_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mCUSTOMER2_s3_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                        _r6_:__prod_ret__13} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_, _r5_:_r5_, _r6_:_r6_} in 
                        ((_r2_ == ORDERS_ORDERKEY and _r5_ == ORDERS_CUSTKEY)
                        and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
                        ORDERS_ORDERDATE))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_2, _r5_:__map_3,
                                      _r6_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({|
                             _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                             |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                              _r4_:__map_3, _r5_:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{|
                               _r1_:int, _r2_:int, _r3_:int, _r4_:int,
                               _r5_:real |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_3, _r5_:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty {
                       _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                       } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
               key:__1, value:__2} in __1 in
            if wrapped_lookup_value == empty {
              _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:_, _r4_:_,
                                       _r5_:projected_field} in projected_field)
            + __prod_ret__13 in (
            map_QUERY3_mCUSTOMER2_s3_buf.insert
              {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
               _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_3, _r6_:__arg_val} in 
          (((map_QUERY3_mCUSTOMER2_s3_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in ((_r2_ == __arg_0 and
               _r5_ == __arg_3) and _r4_ == __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in vid
               > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4, _r6_:__id_5} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3,
                _r5_:__id_4, _r6_:__id_5}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_3, _r6_:__map_val} in 
              map_QUERY3_mCUSTOMER2_s3_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mCUSTOMER4_s3_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mCUSTOMER4_s3_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                        _r6_:__prod_ret__14} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_, _r5_:_r5_, _r6_:_r6_} in 
                        ((_r2_ == ORDERS_ORDERKEY and _r5_ == ORDERS_CUSTKEY)
                        and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
                        ORDERS_ORDERDATE))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_2, _r5_:__map_3,
                                      _r6_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({|
                             _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                             |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                              _r4_:__map_3, _r5_:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{|
                               _r1_:int, _r2_:int, _r3_:int, _r4_:int,
                               _r5_:real |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_3, _r5_:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty {
                       _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                       } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
               key:__1, value:__2} in __1 in
            if wrapped_lookup_value == empty {
              _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:_, _r4_:_,
                                       _r5_:projected_field} in projected_field)
            + __prod_ret__14 in (
            map_QUERY3_mCUSTOMER4_s3_buf.insert
              {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
               _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_3, _r6_:__arg_val} in 
          (((map_QUERY3_mCUSTOMER4_s3_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in ((_r2_ == __arg_0 and
               _r5_ == __arg_3) and _r4_ == __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in vid
               > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4, _r6_:__id_5} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3,
                _r5_:__id_4, _r6_:__id_5}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_3, _r6_:__map_val} in 
              map_QUERY3_mCUSTOMER4_s3_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                        _r6_:__cmp_ret__9} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_, _r5_:_r5_, _r6_:_r6_} in 
                        ((_r2_ == ORDERS_ORDERKEY and _r5_ == ORDERS_CUSTKEY)
                        and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
                        ORDERS_ORDERDATE))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_2, _r5_:__map_3,
                                      _r6_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({|
                             _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                              _r4_:__map_3, _r5_:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{|
                               _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
                               |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_3, _r5_:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty {
                       _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
                       } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
               key:__1, value:__2} in __1 in
            if wrapped_lookup_value == empty {
              _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:_, _r4_:_,
                                       _r5_:projected_field} in projected_field)
            + __cmp_ret__9 in (
            map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf.insert
              {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
               _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_3, _r6_:__arg_val} in 
          (((map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in ((_r2_ == __arg_0 and
               _r5_ == __arg_3) and _r4_ == __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in vid
               > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4, _r6_:__id_5} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3,
                _r5_:__id_4, _r6_:__id_5}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_3, _r6_:__map_val} in 
              map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS1_s6_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS1_s6_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:__cmp_ret__3} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == CUSTOMER_CUSTKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:int |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:int |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:int } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __cmp_ret__3 in (
            map_QUERY3_mORDERS1_s6_buf.insert
              {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS1_s6_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS1_s6_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS3_s6_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS3_s6_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__prod_ret__28} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __prod_ret__28 in (
            map_QUERY3_mORDERS3_s6_buf.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS3_s6_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS3_s6_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS6_s6_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS6_s6_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __val_ret__17 in (
            map_QUERY3_mORDERS6_s6_buf.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS6_s6_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS6_s6_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS1_s7_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS1_s7_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:__cmp_ret__3} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == CUSTOMER_CUSTKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:int |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:int |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:int } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __cmp_ret__3 in (
            map_QUERY3_mORDERS1_s7_buf.insert
              {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS1_s7_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS1_s7_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS3_s9_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS3_s9_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__prod_ret__28} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __prod_ret__28 in (
            map_QUERY3_mORDERS3_s9_buf.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS3_s9_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS3_s9_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS6_s10_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS6_s10_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __val_ret__17 in (
            map_QUERY3_mORDERS6_s10_buf.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS6_s10_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS6_s10_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS1_s11_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS1_s11_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:__cmp_ret__3} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == CUSTOMER_CUSTKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:int |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:int |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:int } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __cmp_ret__3 in (
            map_QUERY3_mORDERS1_s11_buf.insert
              {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS1_s11_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS1_s11_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS3_s11_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS3_s11_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__prod_ret__28} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __prod_ret__28 in (
            map_QUERY3_mORDERS3_s11_buf.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS3_s11_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS3_s11_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS6_s11_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS6_s11_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __val_ret__17 in (
            map_QUERY3_mORDERS6_s11_buf.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS6_s11_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS6_s11_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS1_s12_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS1_s12_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:__cmp_ret__3} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == CUSTOMER_CUSTKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:int |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:int |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:int } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __cmp_ret__3 in (
            map_QUERY3_mORDERS1_s12_buf.insert
              {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS1_s12_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS1_s12_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS3_s14_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS3_s14_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__prod_ret__28} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __prod_ret__28 in (
            map_QUERY3_mORDERS3_s14_buf.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS3_s14_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS3_s14_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS6_s15_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS6_s15_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __val_ret__17 in (
            map_QUERY3_mORDERS6_s15_buf.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS6_s15_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS6_s15_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mLINEITEM1_s16_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int
  } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mLINEITEM1_s16_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                        _r3_:ORDERS_ORDERDATE, _r4_:ORDERS_SHIPPRIORITY,
                        _r5_:__prod_ret__3} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_, _r5_:_r5_} in (_r2_ ==
                        QUERY3_mLINEITEMLINEITEM_ORDERKEY and _r4_ ==
                        ORDERS_SHIPPRIORITY) and _r3_ == ORDERS_ORDERDATE))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_2, _r5_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:int |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                              _r4_:__map_val}|} @ { Set }).combine acc,
                             value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:int |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_val}|} @ { Set }, value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:int
                       } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
               key:__1, value:__2} in __1 in
            if wrapped_lookup_value == empty {
              _r1_:int, _r2_:int, _r3_:int, _r4_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:_,
                                       _r4_:projected_field} in projected_field)
            + __prod_ret__3 in (
            map_QUERY3_mLINEITEM1_s16_buf.insert
              {_r1_:vid, _r2_:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
               _r3_:ORDERS_ORDERDATE, _r4_:ORDERS_SHIPPRIORITY,
               _r5_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_val} in 
          (((map_QUERY3_mLINEITEM1_s16_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_} in (_r2_ == __arg_0 and _r4_ ==
               __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_val} in vid > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3, _r5_:__id_4}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_val} in 
              map_QUERY3_mLINEITEM1_s16_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                        _r6_:__cmp_ret__9} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_, _r5_:_r5_, _r6_:_r6_} in 
                        ((_r2_ == ORDERS_ORDERKEY and _r5_ == ORDERS_CUSTKEY)
                        and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
                        ORDERS_ORDERDATE))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_2, _r5_:__map_3,
                                      _r6_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({|
                             _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                              _r4_:__map_3, _r5_:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{|
                               _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
                               |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_3, _r5_:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty {
                       _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
                       } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
               key:__1, value:__2} in __1 in
            if wrapped_lookup_value == empty {
              _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:_, _r4_:_,
                                       _r5_:projected_field} in projected_field)
            + __cmp_ret__9 in (
            map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf.insert
              {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
               _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_3, _r6_:__arg_val} in 
          (((map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in ((_r2_ == __arg_0 and
               _r5_ == __arg_3) and _r4_ == __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in vid
               > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4, _r6_:__id_5} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3,
                _r5_:__id_4, _r6_:__id_5}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_3, _r6_:__map_val} in 
              map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                        _r6_:__cmp_ret__9} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_, _r5_:_r5_, _r6_:_r6_} in 
                        ((_r2_ == ORDERS_ORDERKEY and _r5_ == ORDERS_CUSTKEY)
                        and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
                        ORDERS_ORDERDATE))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_2, _r5_:__map_3,
                                      _r6_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({|
                             _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                              _r4_:__map_3, _r5_:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{|
                               _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
                               |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_3, _r5_:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty {
                       _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
                       } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
               key:__1, value:__2} in __1 in
            if wrapped_lookup_value == empty {
              _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:_, _r4_:_,
                                       _r5_:projected_field} in projected_field)
            + __cmp_ret__9 in (
            map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf.insert
              {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
               _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_3, _r6_:__arg_val} in 
          (((map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in ((_r2_ == __arg_0 and
               _r5_ == __arg_3) and _r4_ == __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in vid
               > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4, _r6_:__id_5} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3,
                _r5_:__id_4, _r6_:__id_5}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_3, _r6_:__map_val} in 
              map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mLINEITEM1_s21_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int
  } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mLINEITEM1_s21_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                        _r3_:ORDERS_ORDERDATE, _r4_:ORDERS_SHIPPRIORITY,
                        _r5_:__prod_ret__3} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_, _r5_:_r5_} in (_r2_ ==
                        QUERY3_mLINEITEMLINEITEM_ORDERKEY and _r4_ ==
                        ORDERS_SHIPPRIORITY) and _r3_ == ORDERS_ORDERDATE))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_2, _r5_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:int |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                              _r4_:__map_val}|} @ { Set }).combine acc,
                             value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:int |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_val}|} @ { Set }, value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:int
                       } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
               key:__1, value:__2} in __1 in
            if wrapped_lookup_value == empty {
              _r1_:int, _r2_:int, _r3_:int, _r4_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:_,
                                       _r4_:projected_field} in projected_field)
            + __prod_ret__3 in (
            map_QUERY3_mLINEITEM1_s21_buf.insert
              {_r1_:vid, _r2_:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
               _r3_:ORDERS_ORDERDATE, _r4_:ORDERS_SHIPPRIORITY,
               _r5_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_val} in 
          (((map_QUERY3_mLINEITEM1_s21_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_} in (_r2_ == __arg_0 and _r4_ ==
               __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_val} in vid > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3, _r5_:__id_4}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_val} in 
              map_QUERY3_mLINEITEM1_s21_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                        _r6_:__cmp_ret__9} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_, _r5_:_r5_, _r6_:_r6_} in 
                        ((_r2_ == ORDERS_ORDERKEY and _r5_ == ORDERS_CUSTKEY)
                        and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
                        ORDERS_ORDERDATE))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_2, _r5_:__map_3,
                                      _r6_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({|
                             _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                              _r4_:__map_3, _r5_:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{|
                               _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
                               |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_3, _r5_:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty {
                       _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
                       } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
               key:__1, value:__2} in __1 in
            if wrapped_lookup_value == empty {
              _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:_, _r4_:_,
                                       _r5_:projected_field} in projected_field)
            + __cmp_ret__9 in (
            map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf.insert
              {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
               _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_3, _r6_:__arg_val} in 
          (((map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in ((_r2_ == __arg_0 and
               _r5_ == __arg_3) and _r4_ == __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in vid
               > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4, _r6_:__id_5} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3,
                _r5_:__id_4, _r6_:__id_5}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_3, _r6_:__map_val} in 
              map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set } } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
                        _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
                        _r6_:__cmp_ret__9} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_, _r5_:_r5_, _r6_:_r6_} in 
                        ((_r2_ == ORDERS_ORDERKEY and _r5_ == ORDERS_CUSTKEY)
                        and _r4_ == ORDERS_SHIPPRIORITY) and _r3_ ==
                        ORDERS_ORDERDATE))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_2, _r5_:__map_3,
                                      _r6_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({|
                             _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                              _r4_:__map_3, _r5_:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{|
                               _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
                               |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2,
                                _r4_:__map_3, _r5_:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty {
                       _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
                       } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
               key:__1, value:__2} in __1 in
            if wrapped_lookup_value == empty {
              _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:_, _r4_:_,
                                       _r5_:projected_field} in projected_field)
            + __cmp_ret__9 in (
            map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf.insert
              {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
               _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1, _r4_:__arg_2,
                        _r5_:__arg_3, _r6_:__arg_val} in 
          (((map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in ((_r2_ == __arg_0 and
               _r5_ == __arg_3) and _r4_ == __arg_2) and _r3_ == __arg_1))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in vid
               > min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2,
                             _r4_:__id_3, _r5_:__id_4, _r6_:__id_5} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3,
                _r5_:__id_4, _r6_:__id_5}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                            _r5_:__map_3, _r6_:__map_val} in 
              map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                 _r5_:__map_3, _r6_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS3_s36_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS3_s36_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__prod_ret__28} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __prod_ret__28 in (
            map_QUERY3_mORDERS3_s36_buf.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS3_s36_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS3_s36_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS6_s36_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS6_s36_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __val_ret__17 in (
            map_QUERY3_mORDERS6_s36_buf.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS6_s36_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS6_s36_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS3_s38_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS3_s38_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__prod_ret__28} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __prod_ret__28 in (
            map_QUERY3_mORDERS3_s38_buf.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS3_s38_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS3_s38_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS6_s38_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS6_s38_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __val_ret__17 in (
            map_QUERY3_mORDERS6_s38_buf.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS6_s38_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS6_s38_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS1_s40_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS1_s40_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:__cmp_ret__3} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == CUSTOMER_CUSTKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:int |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:int |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:int } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __cmp_ret__3 in (
            map_QUERY3_mORDERS1_s40_buf.insert
              {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS1_s40_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS1_s40_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS1_s42_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS1_s42_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:__cmp_ret__3} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == CUSTOMER_CUSTKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:int |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:int |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:int } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __cmp_ret__3 in (
            map_QUERY3_mORDERS1_s42_buf.insert
              {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS1_s42_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS1_s42_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS1_s44_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS1_s44_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:__cmp_ret__3} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == CUSTOMER_CUSTKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:int |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:int |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:int } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __cmp_ret__3 in (
            map_QUERY3_mORDERS1_s44_buf.insert
              {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS1_s44_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS1_s44_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS1_s46_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS1_s46_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:__cmp_ret__3} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == CUSTOMER_CUSTKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:int |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:int |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:int } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __cmp_ret__3 in (
            map_QUERY3_mORDERS1_s46_buf.insert
              {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS1_s46_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS1_s46_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS3_s48_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS3_s48_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__prod_ret__28} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __prod_ret__28 in (
            map_QUERY3_mORDERS3_s48_buf.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS3_s48_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS3_s48_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS6_s48_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS6_s48_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __val_ret__17 in (
            map_QUERY3_mORDERS6_s48_buf.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS6_s48_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS6_s48_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS3_s50_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS3_s50_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__prod_ret__28} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __prod_ret__28 in (
            map_QUERY3_mORDERS3_s50_buf.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS3_s50_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS3_s50_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS6_s50_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS6_s50_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == LINEITEM_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __val_ret__17 in (
            map_QUERY3_mORDERS6_s50_buf.insert
              {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS6_s50_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS6_s50_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS1_s52_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS1_s52_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:__cmp_ret__3} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == CUSTOMER_CUSTKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:int |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:int |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:int } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __cmp_ret__3 in (
            map_QUERY3_mORDERS1_s52_buf.insert
              {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS1_s52_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS1_s52_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS1_s54_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS1_s54_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:__cmp_ret__3} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == CUSTOMER_CUSTKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:int |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:int |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:int } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __cmp_ret__3 in (
            map_QUERY3_mORDERS1_s54_buf.insert
              {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS1_s54_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS1_s54_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS1_s56_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS1_s56_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:__cmp_ret__3} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == CUSTOMER_CUSTKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:int |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:int |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:int } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __cmp_ret__3 in (
            map_QUERY3_mORDERS1_s56_buf.insert
              {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS1_s56_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS1_s56_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare add_delta_to_map_QUERY3_mORDERS1_s58_buf : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = (\_b1_ -> 
    bind _b1_ as {key:min_vid, value:delta_tuples} in (
      let existing_out_tier = map_QUERY3_mORDERS1_s58_buf in
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:__cmp_ret__3} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == CUSTOMER_CUSTKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:int |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:int |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:int } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
            if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {key:_, value:projected_field} in 
              projected_field) + __cmp_ret__3 in (
            map_QUERY3_mORDERS1_s58_buf.insert
              {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:update_value}
            )));
      delta_tuples.iterate
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_QUERY3_mORDERS1_s58_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0))).filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid))).map
             ((\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2}))).iterate
            ((\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_QUERY3_mORDERS1_s58_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))))
      ))

declare log_master_write : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = (\_b1_ ->
  
    bind _b1_ as {_r1_:vid, _r2_:trig_id, _r3_:stmt_id} in 
    log__master.insert {_r1_:vid, _r2_:trig_id, _r3_:stmt_id})

declare log_write_insert_CUSTOMER : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
  _r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string } -> () =
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                  _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                  _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                  _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT} in 
    log_insert_CUSTOMER.insert
      {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
       _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY, _r6_:CUSTOMER_PHONE,
       _r7_:CUSTOMER_ACCTBAL, _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT})

declare log_write_delete_CUSTOMER : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
  _r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string } -> () =
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                  _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                  _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                  _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT} in 
    log_delete_CUSTOMER.insert
      {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
       _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY, _r6_:CUSTOMER_PHONE,
       _r7_:CUSTOMER_ACCTBAL, _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT})

declare log_write_insert_ORDERS : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
  _r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
  } -> () = (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT} in 
    log_insert_ORDERS.insert
      {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
       _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE, _r6_:ORDERS_ORDERDATE,
       _r7_:ORDERS_ORDERPRIORITY, _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
       _r10_:ORDERS_COMMENT})

declare log_write_delete_ORDERS : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
  _r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
  } -> () = (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT} in 
    log_delete_ORDERS.insert
      {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
       _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE, _r6_:ORDERS_ORDERDATE,
       _r7_:ORDERS_ORDERPRIORITY, _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
       _r10_:ORDERS_COMMENT})

declare log_write_insert_LINEITEM : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string,
  _r11_:string, _r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string,
  _r17_:string } -> () = (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in 
    log_insert_LINEITEM.insert
      {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
       _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER, _r6_:LINEITEM_QUANTITY,
       _r7_:LINEITEM_EXTENDEDPRICE, _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
       _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
       _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
       _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
       _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT})

declare log_write_delete_LINEITEM : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string,
  _r11_:string, _r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string,
  _r17_:string } -> () = (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in 
    log_delete_LINEITEM.insert
      {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
       _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER, _r6_:LINEITEM_QUANTITY,
       _r7_:LINEITEM_EXTENDEDPRICE, _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
       _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
       _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
       _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
       _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT})

declare log_get_bound_insert_CUSTOMER : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
  _r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string } = (\vid -> 
    case ((log_insert_CUSTOMER.filter
    ((\_b1_ -> 
      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_, _r5_:_r5_,
                    _r6_:_r6_, _r7_:_r7_, _r8_:_r8_, _r9_:_r9_} in _r1_ == vid))).peek
    ()) of { Some x -> x } { None -> error () })

declare log_get_bound_delete_CUSTOMER : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
  _r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string } = (\vid -> 
    case ((log_delete_CUSTOMER.filter
    ((\_b1_ -> 
      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_, _r5_:_r5_,
                    _r6_:_r6_, _r7_:_r7_, _r8_:_r8_, _r9_:_r9_} in _r1_ == vid))).peek
    ()) of { Some x -> x } { None -> error () })

declare log_get_bound_insert_ORDERS : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
  _r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string } =
  (\vid -> 
    case ((log_insert_ORDERS.filter
    ((\_b1_ -> 
      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_, _r5_:_r5_,
                    _r6_:_r6_, _r7_:_r7_, _r8_:_r8_, _r9_:_r9_, _r10_:_r10_} in 
      _r1_ == vid))).peek ()) of { Some x -> x } { None -> error () })

declare log_get_bound_delete_ORDERS : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
  _r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string } =
  (\vid -> 
    case ((log_delete_ORDERS.filter
    ((\_b1_ -> 
      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_, _r5_:_r5_,
                    _r6_:_r6_, _r7_:_r7_, _r8_:_r8_, _r9_:_r9_, _r10_:_r10_} in 
      _r1_ == vid))).peek ()) of { Some x -> x } { None -> error () })

declare log_get_bound_insert_LINEITEM : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string,
  _r11_:string, _r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string,
  _r17_:string } = (\vid -> 
    case ((log_insert_LINEITEM.filter
    ((\_b1_ -> 
      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_, _r5_:_r5_,
                    _r6_:_r6_, _r7_:_r7_, _r8_:_r8_, _r9_:_r9_, _r10_:_r10_,
                    _r11_:_r11_, _r12_:_r12_, _r13_:_r13_, _r14_:_r14_,
                    _r15_:_r15_, _r16_:_r16_, _r17_:_r17_} in _r1_ == vid))).peek
    ()) of { Some x -> x } { None -> error () })

declare log_get_bound_delete_LINEITEM : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string,
  _r11_:string, _r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string,
  _r17_:string } = (\vid -> 
    case ((log_delete_LINEITEM.filter
    ((\_b1_ -> 
      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_, _r5_:_r5_,
                    _r6_:_r6_, _r7_:_r7_, _r8_:_r8_, _r9_:_r9_, _r10_:_r10_,
                    _r11_:_r11_, _r12_:_r12_, _r13_:_r13_, _r14_:_r14_,
                    _r15_:_r15_, _r16_:_r16_, _r17_:_r17_} in _r1_ == vid))).peek
    ()) of { Some x -> x } { None -> error () })

declare node_ring : collection {
  _r1_:address, _r2_:string, _r3_:string, _r4_:int } @ { Seq }

declare replicas : collection {i:int} @ { Set } = {|i:int| 8|} @ { Set }

declare set_replicas : int -> () = (\n -> 
    replicas.update
      ({i:case (replicas.peek ()) of { Some x -> x.i } { None -> error () }})
      {i:n})

declare add_node : { _r1_:address, _r2_:string, _r3_:string } -> () = (\_b1_ ->
  
    bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name} in 
    let rng =
      range
        (case ((replicas).peek ()) of { Some x -> x.i } { None -> error () }) in
    let new_elems =
      rng.map
        ((\_b1_ -> 
          bind _b1_ as {i:i} in 
          {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash (i + hash addr)})) in (
      new_elems.iterate ((\x ->  node_ring.insert x));
      let temp_ring = node_ring.sort
        ((\_b2_ ->
        bind _b2_ as {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash1} in (\_b7_ ->
        
          bind _b7_ as {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash2} in 
          if hash1 > hash2 then -1 else 1))) in
      (
        node_ring.iterate ((\node ->  node_ring.delete node));
        temp_ring.iterate ((\node ->  node_ring.insert node))
        )
      ))

declare remove_node : { _r1_:address, _r2_:string, _r3_:string } -> () =
  (\_b1_ -> 
    bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name} in 
    let nodes_to_delete = node_ring.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in (_r1_ ==
        addr and _r3_ == name) and _r2_ == _role_)) in
    nodes_to_delete.iterate ((\x ->  node_ring.delete x)))

declare get_ring_node : { key:int, value:int } -> address = (\_b1_ -> 
    bind _b1_ as {key:data, value:max_val} in 
    let scaled =
      int_of_real
        (real_of_int (get_max_int ()) * (real_of_int data /
        real_of_int max_val)) in
    let results =
      (node_ring.filter
        ((\_b1_ -> 
          bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash} in hash
          >= scaled))).map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3} in 
          {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3})) in
    bind if results == empty { _r1_:address, _r2_:string, _r3_:string, _r4_:int
           } @ { Seq }
         then case (node_ring.peek ()) of { Some x -> x } { None -> error () }
         else case (results.peek ()) of { Some x -> x } { None -> error () } as {
    _r1_:addr, _r2_:_, _r3_:_, _r4_:_} in addr)

declare get_all_uniq_nodes : () -> collection {i:address} @ { Seq } = (\_ -> 
    (node_ring.groupBy
       ((\_b1_ -> 
         bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash} in addr))
       ((\_ -> (\_ ->  ()))) empty {i:address} @ { Seq }).map
      ((\_b1_ ->  bind _b1_ as {key:__1, value:__2} in {i:__1})))

declare pmap_data : collection {
  key:int, value:collection { key:int, value:int } @ { Seq } } @ { Seq } =
  pmap_input.map
    ((\_b1_ -> 
      bind _b1_ as {key:map_name, value:map_types} in 
      {key:bind case ((__map_ids__.filter
       ((\_b1_ -> 
         bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == map_name))).peek
       ()) of { Some x -> x }
       { None -> error () } as {_r1_:__1, _r2_:__2, _r3_:__3} in __1,
       value:map_types}))

declare calc_dim_bounds : collection { key:int, value:int } @ { Seq } -> {
  key:collection { key:int, value:int } @ { Seq }, value:int } = (\pmap -> 
    pmap.fold
      ((\_b2_ -> bind _b2_ as {key:xs, value:acc_size} in (\_b5_ -> 
        bind _b5_ as {key:pos, value:bin_size} in 
        {key:xs.combine
         ({| key:int, value:int | {key:pos, value:acc_size}|} @ { Seq }),
         value:bin_size * acc_size})))
      {key:empty { key:int, value:int } @ { Seq }, value:1})

declare route_to_QUERY3 : { _r1_:option int, _r2_:option int, _r3_:option int
  } -> collection {i:address} @ { Collection } = (\key -> 
    let pmap = bind case ((pmap_data.filter
      ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1))).peek
      ()) of { Some x -> x } { None -> error () } as {key:__1, value:__2} in 
      __2 in
    if pmap == empty { key:int, value:int } @ { Seq }
    then get_all_uniq_nodes ()
    else bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in 
      bind key as {_r1_:key_id_0, _r2_:key_id_1, _r3_:key_id_2} in 
      let bound_bucket =
        (if key_id_2 == None immut
         then 0
         else
           let pmap_slice = pmap.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 2)) in
           if pmap_slice == empty { key:int, value:int } @ { Seq }
           then 0
           else let key_id_2_unwrap = case key_id_2 of { Some x -> x }
             { None -> error () } in
             let value = hash key_id_2_unwrap % bind case (pmap_slice.peek
               ()) of { Some x -> x }
               { None -> error () } as {key:__1, value:__2} in __2 in value *
             bind case ((dim_bounds.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 2))).peek
             ()) of { Some x -> x }
             { None -> error () } as {key:__1, value:__2} in __2) +
        ((if key_id_1 == None immut
          then 0
          else
            let pmap_slice = pmap.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1)) in
            if pmap_slice == empty { key:int, value:int } @ { Seq }
            then 0
            else let key_id_1_unwrap = case key_id_1 of { Some x -> x }
              { None -> error () } in
              let value = hash key_id_1_unwrap % bind case (pmap_slice.peek
                ()) of { Some x -> x }
                { None -> error () } as {key:__1, value:__2} in __2 in value *
              bind case ((dim_bounds.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1))).peek
              ()) of { Some x -> x }
              { None -> error () } as {key:__1, value:__2} in __2) +
        ((if key_id_0 == None immut
          then 0
          else
            let pmap_slice = pmap.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0)) in
            if pmap_slice == empty { key:int, value:int } @ { Seq }
            then 0
            else let key_id_0_unwrap = case key_id_0 of { Some x -> x }
              { None -> error () } in
              let value = hash key_id_0_unwrap % bind case (pmap_slice.peek
                ()) of { Some x -> x }
                { None -> error () } as {key:__1, value:__2} in __2 in value *
              bind case ((dim_bounds.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).peek
              ()) of { Some x -> x }
              { None -> error () } as {key:__1, value:__2} in __2) + 0)) in
      let free_dims =
        (if key_id_2 != None immut
         then empty { key:int, value:int } @ { Seq }
         else pmap.filter
           ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 2))).combine
        ((if key_id_1 != None immut
          then empty { key:int, value:int } @ { Seq }
          else pmap.filter
            ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1))).combine
        ((if key_id_0 != None immut
          then empty { key:int, value:int } @ { Seq }
          else pmap.filter
            ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).combine
        empty { key:int, value:int } @ { Seq })) in
      let free_domains =
        free_dims.map
          ((\_b1_ -> 
            bind _b1_ as {key:i, value:b_i} in {key:i, value:range b_i})) in
      let free_cart_prod =
        free_domains.fold
          ((\prev_cart_prod -> (\_b3_ -> 
            bind _b3_ as {key:i, value:domain} in 
            domain.ext
              ((\_b1_ -> 
                bind _b1_ as {i:domain_element} in 
                if prev_cart_prod == empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq }
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int |
                  {key:i, value:domain_element}|} @ { Seq }|} @ { Seq }
                else
                  prev_cart_prod.map
                    ((\_b1_ -> 
                      bind _b1_ as {i:rest_tup} in 
                      {i:rest_tup.combine
                       ({| key:int, value:int |
                       {key:i, value:domain_element}|} @ { Seq })}))))
              empty {i:collection { key:int, value:int
              } @ { Seq }} @ { Collection }))) empty {i:collection {
          key:int, value:int } @ { Seq }} @ { Seq } in
      let sorted_ip_list = (empty { key:address, value:()
        } @ { Collection }).combine
        ((free_cart_prod.map
            ((\_b1_ -> 
              bind _b1_ as {i:free_bucket} in 
              {i:get_ring_node
                   {key:free_bucket.fold
                          ((\acc -> (\_b3_ -> 
                            bind _b3_ as {key:i, value:val} in acc + (val *
                            bind case ((dim_bounds.filter
                            ((\_b1_ -> 
                              bind _b1_ as {key:key, value:value} in key == i))).peek
                            ()) of { Some x -> x }
                            { None -> error () } as {key:__1, value:__2} in 
                            __2)))) bound_bucket, value:max_val}}))).groupBy
           ((\_b1_ ->  bind _b1_ as {i:ip} in ip)) ((\_ -> (\_ ->  ()))) ()) in
      if sorted_ip_list == empty { key:address, value:() } @ { Collection }
      then {|i:address|
        get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
      else
        sorted_ip_list.map
          ((\_b1_ ->  bind _b1_ as {key:__1, value:__2} in {i:__1})))

declare route_to_QUERY3_mLINEITEM1 : {
  _r1_:option int, _r2_:option int, _r3_:option int
  } -> collection {i:address} @ { Collection } = (\key -> 
    let pmap = bind case ((pmap_data.filter
      ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 2))).peek
      ()) of { Some x -> x } { None -> error () } as {key:__1, value:__2} in 
      __2 in
    if pmap == empty { key:int, value:int } @ { Seq }
    then get_all_uniq_nodes ()
    else bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in 
      bind key as {_r1_:key_id_0, _r2_:key_id_1, _r3_:key_id_2} in 
      let bound_bucket =
        (if key_id_2 == None immut
         then 0
         else
           let pmap_slice = pmap.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 2)) in
           if pmap_slice == empty { key:int, value:int } @ { Seq }
           then 0
           else let key_id_2_unwrap = case key_id_2 of { Some x -> x }
             { None -> error () } in
             let value = hash key_id_2_unwrap % bind case (pmap_slice.peek
               ()) of { Some x -> x }
               { None -> error () } as {key:__1, value:__2} in __2 in value *
             bind case ((dim_bounds.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 2))).peek
             ()) of { Some x -> x }
             { None -> error () } as {key:__1, value:__2} in __2) +
        ((if key_id_1 == None immut
          then 0
          else
            let pmap_slice = pmap.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1)) in
            if pmap_slice == empty { key:int, value:int } @ { Seq }
            then 0
            else let key_id_1_unwrap = case key_id_1 of { Some x -> x }
              { None -> error () } in
              let value = hash key_id_1_unwrap % bind case (pmap_slice.peek
                ()) of { Some x -> x }
                { None -> error () } as {key:__1, value:__2} in __2 in value *
              bind case ((dim_bounds.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1))).peek
              ()) of { Some x -> x }
              { None -> error () } as {key:__1, value:__2} in __2) +
        ((if key_id_0 == None immut
          then 0
          else
            let pmap_slice = pmap.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0)) in
            if pmap_slice == empty { key:int, value:int } @ { Seq }
            then 0
            else let key_id_0_unwrap = case key_id_0 of { Some x -> x }
              { None -> error () } in
              let value = hash key_id_0_unwrap % bind case (pmap_slice.peek
                ()) of { Some x -> x }
                { None -> error () } as {key:__1, value:__2} in __2 in value *
              bind case ((dim_bounds.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).peek
              ()) of { Some x -> x }
              { None -> error () } as {key:__1, value:__2} in __2) + 0)) in
      let free_dims =
        (if key_id_2 != None immut
         then empty { key:int, value:int } @ { Seq }
         else pmap.filter
           ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 2))).combine
        ((if key_id_1 != None immut
          then empty { key:int, value:int } @ { Seq }
          else pmap.filter
            ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1))).combine
        ((if key_id_0 != None immut
          then empty { key:int, value:int } @ { Seq }
          else pmap.filter
            ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).combine
        empty { key:int, value:int } @ { Seq })) in
      let free_domains =
        free_dims.map
          ((\_b1_ -> 
            bind _b1_ as {key:i, value:b_i} in {key:i, value:range b_i})) in
      let free_cart_prod =
        free_domains.fold
          ((\prev_cart_prod -> (\_b3_ -> 
            bind _b3_ as {key:i, value:domain} in 
            domain.ext
              ((\_b1_ -> 
                bind _b1_ as {i:domain_element} in 
                if prev_cart_prod == empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq }
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int |
                  {key:i, value:domain_element}|} @ { Seq }|} @ { Seq }
                else
                  prev_cart_prod.map
                    ((\_b1_ -> 
                      bind _b1_ as {i:rest_tup} in 
                      {i:rest_tup.combine
                       ({| key:int, value:int |
                       {key:i, value:domain_element}|} @ { Seq })}))))
              empty {i:collection { key:int, value:int
              } @ { Seq }} @ { Collection }))) empty {i:collection {
          key:int, value:int } @ { Seq }} @ { Seq } in
      let sorted_ip_list = (empty { key:address, value:()
        } @ { Collection }).combine
        ((free_cart_prod.map
            ((\_b1_ -> 
              bind _b1_ as {i:free_bucket} in 
              {i:get_ring_node
                   {key:free_bucket.fold
                          ((\acc -> (\_b3_ -> 
                            bind _b3_ as {key:i, value:val} in acc + (val *
                            bind case ((dim_bounds.filter
                            ((\_b1_ -> 
                              bind _b1_ as {key:key, value:value} in key == i))).peek
                            ()) of { Some x -> x }
                            { None -> error () } as {key:__1, value:__2} in 
                            __2)))) bound_bucket, value:max_val}}))).groupBy
           ((\_b1_ ->  bind _b1_ as {i:ip} in ip)) ((\_ -> (\_ ->  ()))) ()) in
      if sorted_ip_list == empty { key:address, value:() } @ { Collection }
      then {|i:address|
        get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
      else
        sorted_ip_list.map
          ((\_b1_ ->  bind _b1_ as {key:__1, value:__2} in {i:__1})))

declare route_to_QUERY3_mLINEITEM1_mCUSTOMER2 : {
  _r1_:option int, _r2_:option int, _r3_:option int, _r4_:option int
  } -> collection {i:address} @ { Collection } = (\key -> 
    let pmap = bind case ((pmap_data.filter
      ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 3))).peek
      ()) of { Some x -> x } { None -> error () } as {key:__1, value:__2} in 
      __2 in
    if pmap == empty { key:int, value:int } @ { Seq }
    then get_all_uniq_nodes ()
    else bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in 
      bind key as {_r1_:key_id_0, _r2_:key_id_1, _r3_:key_id_2, _r4_:key_id_3} in 
      let bound_bucket =
        (if key_id_3 == None immut
         then 0
         else
           let pmap_slice = pmap.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 3)) in
           if pmap_slice == empty { key:int, value:int } @ { Seq }
           then 0
           else let key_id_3_unwrap = case key_id_3 of { Some x -> x }
             { None -> error () } in
             let value = hash key_id_3_unwrap % bind case (pmap_slice.peek
               ()) of { Some x -> x }
               { None -> error () } as {key:__1, value:__2} in __2 in value *
             bind case ((dim_bounds.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 3))).peek
             ()) of { Some x -> x }
             { None -> error () } as {key:__1, value:__2} in __2) +
        ((if key_id_2 == None immut
          then 0
          else
            let pmap_slice = pmap.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 2)) in
            if pmap_slice == empty { key:int, value:int } @ { Seq }
            then 0
            else let key_id_2_unwrap = case key_id_2 of { Some x -> x }
              { None -> error () } in
              let value = hash key_id_2_unwrap % bind case (pmap_slice.peek
                ()) of { Some x -> x }
                { None -> error () } as {key:__1, value:__2} in __2 in value *
              bind case ((dim_bounds.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 2))).peek
              ()) of { Some x -> x }
              { None -> error () } as {key:__1, value:__2} in __2) +
        ((if key_id_1 == None immut
          then 0
          else
            let pmap_slice = pmap.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1)) in
            if pmap_slice == empty { key:int, value:int } @ { Seq }
            then 0
            else let key_id_1_unwrap = case key_id_1 of { Some x -> x }
              { None -> error () } in
              let value = hash key_id_1_unwrap % bind case (pmap_slice.peek
                ()) of { Some x -> x }
                { None -> error () } as {key:__1, value:__2} in __2 in value *
              bind case ((dim_bounds.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1))).peek
              ()) of { Some x -> x }
              { None -> error () } as {key:__1, value:__2} in __2) +
        ((if key_id_0 == None immut
          then 0
          else
            let pmap_slice = pmap.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0)) in
            if pmap_slice == empty { key:int, value:int } @ { Seq }
            then 0
            else let key_id_0_unwrap = case key_id_0 of { Some x -> x }
              { None -> error () } in
              let value = hash key_id_0_unwrap % bind case (pmap_slice.peek
                ()) of { Some x -> x }
                { None -> error () } as {key:__1, value:__2} in __2 in value *
              bind case ((dim_bounds.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).peek
              ()) of { Some x -> x }
              { None -> error () } as {key:__1, value:__2} in __2) + 0))) in
      let free_dims =
        (if key_id_3 != None immut
         then empty { key:int, value:int } @ { Seq }
         else pmap.filter
           ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 3))).combine
        ((if key_id_2 != None immut
          then empty { key:int, value:int } @ { Seq }
          else pmap.filter
            ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 2))).combine
        ((if key_id_1 != None immut
          then empty { key:int, value:int } @ { Seq }
          else pmap.filter
            ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1))).combine
        ((if key_id_0 != None immut
          then empty { key:int, value:int } @ { Seq }
          else pmap.filter
            ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).combine
        empty { key:int, value:int } @ { Seq }))) in
      let free_domains =
        free_dims.map
          ((\_b1_ -> 
            bind _b1_ as {key:i, value:b_i} in {key:i, value:range b_i})) in
      let free_cart_prod =
        free_domains.fold
          ((\prev_cart_prod -> (\_b3_ -> 
            bind _b3_ as {key:i, value:domain} in 
            domain.ext
              ((\_b1_ -> 
                bind _b1_ as {i:domain_element} in 
                if prev_cart_prod == empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq }
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int |
                  {key:i, value:domain_element}|} @ { Seq }|} @ { Seq }
                else
                  prev_cart_prod.map
                    ((\_b1_ -> 
                      bind _b1_ as {i:rest_tup} in 
                      {i:rest_tup.combine
                       ({| key:int, value:int |
                       {key:i, value:domain_element}|} @ { Seq })}))))
              empty {i:collection { key:int, value:int
              } @ { Seq }} @ { Collection }))) empty {i:collection {
          key:int, value:int } @ { Seq }} @ { Seq } in
      let sorted_ip_list = (empty { key:address, value:()
        } @ { Collection }).combine
        ((free_cart_prod.map
            ((\_b1_ -> 
              bind _b1_ as {i:free_bucket} in 
              {i:get_ring_node
                   {key:free_bucket.fold
                          ((\acc -> (\_b3_ -> 
                            bind _b3_ as {key:i, value:val} in acc + (val *
                            bind case ((dim_bounds.filter
                            ((\_b1_ -> 
                              bind _b1_ as {key:key, value:value} in key == i))).peek
                            ()) of { Some x -> x }
                            { None -> error () } as {key:__1, value:__2} in 
                            __2)))) bound_bucket, value:max_val}}))).groupBy
           ((\_b1_ ->  bind _b1_ as {i:ip} in ip)) ((\_ -> (\_ ->  ()))) ()) in
      if sorted_ip_list == empty { key:address, value:() } @ { Collection }
      then {|i:address|
        get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
      else
        sorted_ip_list.map
          ((\_b1_ ->  bind _b1_ as {key:__1, value:__2} in {i:__1})))

declare route_to_QUERY3_mORDERS1 :
  option int -> collection {i:address} @ { Collection } = (\key -> 
    let pmap = bind case ((pmap_data.filter
      ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 4))).peek
      ()) of { Some x -> x } { None -> error () } as {key:__1, value:__2} in 
      __2 in
    if pmap == empty { key:int, value:int } @ { Seq }
    then get_all_uniq_nodes ()
    else bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in 
      let key_id_0 = key in
      let bound_bucket =
        (if key_id_0 == None immut
         then 0
         else
           let pmap_slice = pmap.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0)) in
           if pmap_slice == empty { key:int, value:int } @ { Seq }
           then 0
           else let key_id_0_unwrap = case key_id_0 of { Some x -> x }
             { None -> error () } in
             let value = hash key_id_0_unwrap % bind case (pmap_slice.peek
               ()) of { Some x -> x }
               { None -> error () } as {key:__1, value:__2} in __2 in value *
             bind case ((dim_bounds.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).peek
             ()) of { Some x -> x }
             { None -> error () } as {key:__1, value:__2} in __2) + 0 in
      let free_dims =
        (if key_id_0 != None immut
         then empty { key:int, value:int } @ { Seq }
         else pmap.filter
           ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).combine
        empty { key:int, value:int } @ { Seq } in
      let free_domains =
        free_dims.map
          ((\_b1_ -> 
            bind _b1_ as {key:i, value:b_i} in {key:i, value:range b_i})) in
      let free_cart_prod =
        free_domains.fold
          ((\prev_cart_prod -> (\_b3_ -> 
            bind _b3_ as {key:i, value:domain} in 
            domain.ext
              ((\_b1_ -> 
                bind _b1_ as {i:domain_element} in 
                if prev_cart_prod == empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq }
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int |
                  {key:i, value:domain_element}|} @ { Seq }|} @ { Seq }
                else
                  prev_cart_prod.map
                    ((\_b1_ -> 
                      bind _b1_ as {i:rest_tup} in 
                      {i:rest_tup.combine
                       ({| key:int, value:int |
                       {key:i, value:domain_element}|} @ { Seq })}))))
              empty {i:collection { key:int, value:int
              } @ { Seq }} @ { Collection }))) empty {i:collection {
          key:int, value:int } @ { Seq }} @ { Seq } in
      let sorted_ip_list = (empty { key:address, value:()
        } @ { Collection }).combine
        ((free_cart_prod.map
            ((\_b1_ -> 
              bind _b1_ as {i:free_bucket} in 
              {i:get_ring_node
                   {key:free_bucket.fold
                          ((\acc -> (\_b3_ -> 
                            bind _b3_ as {key:i, value:val} in acc + (val *
                            bind case ((dim_bounds.filter
                            ((\_b1_ -> 
                              bind _b1_ as {key:key, value:value} in key == i))).peek
                            ()) of { Some x -> x }
                            { None -> error () } as {key:__1, value:__2} in 
                            __2)))) bound_bucket, value:max_val}}))).groupBy
           ((\_b1_ ->  bind _b1_ as {i:ip} in ip)) ((\_ -> (\_ ->  ()))) ()) in
      if sorted_ip_list == empty { key:address, value:() } @ { Collection }
      then {|i:address|
        get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
      else
        sorted_ip_list.map
          ((\_b1_ ->  bind _b1_ as {key:__1, value:__2} in {i:__1})))

declare route_to_QUERY3_mORDERS3 :
  option int -> collection {i:address} @ { Collection } = (\key -> 
    let pmap = bind case ((pmap_data.filter
      ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 5))).peek
      ()) of { Some x -> x } { None -> error () } as {key:__1, value:__2} in 
      __2 in
    if pmap == empty { key:int, value:int } @ { Seq }
    then get_all_uniq_nodes ()
    else bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in 
      let key_id_0 = key in
      let bound_bucket =
        (if key_id_0 == None immut
         then 0
         else
           let pmap_slice = pmap.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0)) in
           if pmap_slice == empty { key:int, value:int } @ { Seq }
           then 0
           else let key_id_0_unwrap = case key_id_0 of { Some x -> x }
             { None -> error () } in
             let value = hash key_id_0_unwrap % bind case (pmap_slice.peek
               ()) of { Some x -> x }
               { None -> error () } as {key:__1, value:__2} in __2 in value *
             bind case ((dim_bounds.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).peek
             ()) of { Some x -> x }
             { None -> error () } as {key:__1, value:__2} in __2) + 0 in
      let free_dims =
        (if key_id_0 != None immut
         then empty { key:int, value:int } @ { Seq }
         else pmap.filter
           ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).combine
        empty { key:int, value:int } @ { Seq } in
      let free_domains =
        free_dims.map
          ((\_b1_ -> 
            bind _b1_ as {key:i, value:b_i} in {key:i, value:range b_i})) in
      let free_cart_prod =
        free_domains.fold
          ((\prev_cart_prod -> (\_b3_ -> 
            bind _b3_ as {key:i, value:domain} in 
            domain.ext
              ((\_b1_ -> 
                bind _b1_ as {i:domain_element} in 
                if prev_cart_prod == empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq }
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int |
                  {key:i, value:domain_element}|} @ { Seq }|} @ { Seq }
                else
                  prev_cart_prod.map
                    ((\_b1_ -> 
                      bind _b1_ as {i:rest_tup} in 
                      {i:rest_tup.combine
                       ({| key:int, value:int |
                       {key:i, value:domain_element}|} @ { Seq })}))))
              empty {i:collection { key:int, value:int
              } @ { Seq }} @ { Collection }))) empty {i:collection {
          key:int, value:int } @ { Seq }} @ { Seq } in
      let sorted_ip_list = (empty { key:address, value:()
        } @ { Collection }).combine
        ((free_cart_prod.map
            ((\_b1_ -> 
              bind _b1_ as {i:free_bucket} in 
              {i:get_ring_node
                   {key:free_bucket.fold
                          ((\acc -> (\_b3_ -> 
                            bind _b3_ as {key:i, value:val} in acc + (val *
                            bind case ((dim_bounds.filter
                            ((\_b1_ -> 
                              bind _b1_ as {key:key, value:value} in key == i))).peek
                            ()) of { Some x -> x }
                            { None -> error () } as {key:__1, value:__2} in 
                            __2)))) bound_bucket, value:max_val}}))).groupBy
           ((\_b1_ ->  bind _b1_ as {i:ip} in ip)) ((\_ -> (\_ ->  ()))) ()) in
      if sorted_ip_list == empty { key:address, value:() } @ { Collection }
      then {|i:address|
        get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
      else
        sorted_ip_list.map
          ((\_b1_ ->  bind _b1_ as {key:__1, value:__2} in {i:__1})))

declare route_to_QUERY3_mORDERS6 :
  option int -> collection {i:address} @ { Collection } = (\key -> 
    let pmap = bind case ((pmap_data.filter
      ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 6))).peek
      ()) of { Some x -> x } { None -> error () } as {key:__1, value:__2} in 
      __2 in
    if pmap == empty { key:int, value:int } @ { Seq }
    then get_all_uniq_nodes ()
    else bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in 
      let key_id_0 = key in
      let bound_bucket =
        (if key_id_0 == None immut
         then 0
         else
           let pmap_slice = pmap.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0)) in
           if pmap_slice == empty { key:int, value:int } @ { Seq }
           then 0
           else let key_id_0_unwrap = case key_id_0 of { Some x -> x }
             { None -> error () } in
             let value = hash key_id_0_unwrap % bind case (pmap_slice.peek
               ()) of { Some x -> x }
               { None -> error () } as {key:__1, value:__2} in __2 in value *
             bind case ((dim_bounds.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).peek
             ()) of { Some x -> x }
             { None -> error () } as {key:__1, value:__2} in __2) + 0 in
      let free_dims =
        (if key_id_0 != None immut
         then empty { key:int, value:int } @ { Seq }
         else pmap.filter
           ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).combine
        empty { key:int, value:int } @ { Seq } in
      let free_domains =
        free_dims.map
          ((\_b1_ -> 
            bind _b1_ as {key:i, value:b_i} in {key:i, value:range b_i})) in
      let free_cart_prod =
        free_domains.fold
          ((\prev_cart_prod -> (\_b3_ -> 
            bind _b3_ as {key:i, value:domain} in 
            domain.ext
              ((\_b1_ -> 
                bind _b1_ as {i:domain_element} in 
                if prev_cart_prod == empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq }
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int |
                  {key:i, value:domain_element}|} @ { Seq }|} @ { Seq }
                else
                  prev_cart_prod.map
                    ((\_b1_ -> 
                      bind _b1_ as {i:rest_tup} in 
                      {i:rest_tup.combine
                       ({| key:int, value:int |
                       {key:i, value:domain_element}|} @ { Seq })}))))
              empty {i:collection { key:int, value:int
              } @ { Seq }} @ { Collection }))) empty {i:collection {
          key:int, value:int } @ { Seq }} @ { Seq } in
      let sorted_ip_list = (empty { key:address, value:()
        } @ { Collection }).combine
        ((free_cart_prod.map
            ((\_b1_ -> 
              bind _b1_ as {i:free_bucket} in 
              {i:get_ring_node
                   {key:free_bucket.fold
                          ((\acc -> (\_b3_ -> 
                            bind _b3_ as {key:i, value:val} in acc + (val *
                            bind case ((dim_bounds.filter
                            ((\_b1_ -> 
                              bind _b1_ as {key:key, value:value} in key == i))).peek
                            ()) of { Some x -> x }
                            { None -> error () } as {key:__1, value:__2} in 
                            __2)))) bound_bucket, value:max_val}}))).groupBy
           ((\_b1_ ->  bind _b1_ as {i:ip} in ip)) ((\_ -> (\_ ->  ()))) ()) in
      if sorted_ip_list == empty { key:address, value:() } @ { Collection }
      then {|i:address|
        get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
      else
        sorted_ip_list.map
          ((\_b1_ ->  bind _b1_ as {key:__1, value:__2} in {i:__1})))

declare route_to_QUERY3_mCUSTOMER2 : {
  _r1_:option int, _r2_:option int, _r3_:option int, _r4_:option int
  } -> collection {i:address} @ { Collection } = (\key -> 
    let pmap = bind case ((pmap_data.filter
      ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 7))).peek
      ()) of { Some x -> x } { None -> error () } as {key:__1, value:__2} in 
      __2 in
    if pmap == empty { key:int, value:int } @ { Seq }
    then get_all_uniq_nodes ()
    else bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in 
      bind key as {_r1_:key_id_0, _r2_:key_id_1, _r3_:key_id_2, _r4_:key_id_3} in 
      let bound_bucket =
        (if key_id_3 == None immut
         then 0
         else
           let pmap_slice = pmap.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 3)) in
           if pmap_slice == empty { key:int, value:int } @ { Seq }
           then 0
           else let key_id_3_unwrap = case key_id_3 of { Some x -> x }
             { None -> error () } in
             let value = hash key_id_3_unwrap % bind case (pmap_slice.peek
               ()) of { Some x -> x }
               { None -> error () } as {key:__1, value:__2} in __2 in value *
             bind case ((dim_bounds.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 3))).peek
             ()) of { Some x -> x }
             { None -> error () } as {key:__1, value:__2} in __2) +
        ((if key_id_2 == None immut
          then 0
          else
            let pmap_slice = pmap.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 2)) in
            if pmap_slice == empty { key:int, value:int } @ { Seq }
            then 0
            else let key_id_2_unwrap = case key_id_2 of { Some x -> x }
              { None -> error () } in
              let value = hash key_id_2_unwrap % bind case (pmap_slice.peek
                ()) of { Some x -> x }
                { None -> error () } as {key:__1, value:__2} in __2 in value *
              bind case ((dim_bounds.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 2))).peek
              ()) of { Some x -> x }
              { None -> error () } as {key:__1, value:__2} in __2) +
        ((if key_id_1 == None immut
          then 0
          else
            let pmap_slice = pmap.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1)) in
            if pmap_slice == empty { key:int, value:int } @ { Seq }
            then 0
            else let key_id_1_unwrap = case key_id_1 of { Some x -> x }
              { None -> error () } in
              let value = hash key_id_1_unwrap % bind case (pmap_slice.peek
                ()) of { Some x -> x }
                { None -> error () } as {key:__1, value:__2} in __2 in value *
              bind case ((dim_bounds.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1))).peek
              ()) of { Some x -> x }
              { None -> error () } as {key:__1, value:__2} in __2) +
        ((if key_id_0 == None immut
          then 0
          else
            let pmap_slice = pmap.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0)) in
            if pmap_slice == empty { key:int, value:int } @ { Seq }
            then 0
            else let key_id_0_unwrap = case key_id_0 of { Some x -> x }
              { None -> error () } in
              let value = hash key_id_0_unwrap % bind case (pmap_slice.peek
                ()) of { Some x -> x }
                { None -> error () } as {key:__1, value:__2} in __2 in value *
              bind case ((dim_bounds.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).peek
              ()) of { Some x -> x }
              { None -> error () } as {key:__1, value:__2} in __2) + 0))) in
      let free_dims =
        (if key_id_3 != None immut
         then empty { key:int, value:int } @ { Seq }
         else pmap.filter
           ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 3))).combine
        ((if key_id_2 != None immut
          then empty { key:int, value:int } @ { Seq }
          else pmap.filter
            ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 2))).combine
        ((if key_id_1 != None immut
          then empty { key:int, value:int } @ { Seq }
          else pmap.filter
            ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1))).combine
        ((if key_id_0 != None immut
          then empty { key:int, value:int } @ { Seq }
          else pmap.filter
            ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).combine
        empty { key:int, value:int } @ { Seq }))) in
      let free_domains =
        free_dims.map
          ((\_b1_ -> 
            bind _b1_ as {key:i, value:b_i} in {key:i, value:range b_i})) in
      let free_cart_prod =
        free_domains.fold
          ((\prev_cart_prod -> (\_b3_ -> 
            bind _b3_ as {key:i, value:domain} in 
            domain.ext
              ((\_b1_ -> 
                bind _b1_ as {i:domain_element} in 
                if prev_cart_prod == empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq }
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int |
                  {key:i, value:domain_element}|} @ { Seq }|} @ { Seq }
                else
                  prev_cart_prod.map
                    ((\_b1_ -> 
                      bind _b1_ as {i:rest_tup} in 
                      {i:rest_tup.combine
                       ({| key:int, value:int |
                       {key:i, value:domain_element}|} @ { Seq })}))))
              empty {i:collection { key:int, value:int
              } @ { Seq }} @ { Collection }))) empty {i:collection {
          key:int, value:int } @ { Seq }} @ { Seq } in
      let sorted_ip_list = (empty { key:address, value:()
        } @ { Collection }).combine
        ((free_cart_prod.map
            ((\_b1_ -> 
              bind _b1_ as {i:free_bucket} in 
              {i:get_ring_node
                   {key:free_bucket.fold
                          ((\acc -> (\_b3_ -> 
                            bind _b3_ as {key:i, value:val} in acc + (val *
                            bind case ((dim_bounds.filter
                            ((\_b1_ -> 
                              bind _b1_ as {key:key, value:value} in key == i))).peek
                            ()) of { Some x -> x }
                            { None -> error () } as {key:__1, value:__2} in 
                            __2)))) bound_bucket, value:max_val}}))).groupBy
           ((\_b1_ ->  bind _b1_ as {i:ip} in ip)) ((\_ -> (\_ ->  ()))) ()) in
      if sorted_ip_list == empty { key:address, value:() } @ { Collection }
      then {|i:address|
        get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
      else
        sorted_ip_list.map
          ((\_b1_ ->  bind _b1_ as {key:__1, value:__2} in {i:__1})))

declare route_to_QUERY3_mCUSTOMER4 : {
  _r1_:option int, _r2_:option int, _r3_:option int, _r4_:option int
  } -> collection {i:address} @ { Collection } = (\key -> 
    let pmap = bind case ((pmap_data.filter
      ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 8))).peek
      ()) of { Some x -> x } { None -> error () } as {key:__1, value:__2} in 
      __2 in
    if pmap == empty { key:int, value:int } @ { Seq }
    then get_all_uniq_nodes ()
    else bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in 
      bind key as {_r1_:key_id_0, _r2_:key_id_1, _r3_:key_id_2, _r4_:key_id_3} in 
      let bound_bucket =
        (if key_id_3 == None immut
         then 0
         else
           let pmap_slice = pmap.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 3)) in
           if pmap_slice == empty { key:int, value:int } @ { Seq }
           then 0
           else let key_id_3_unwrap = case key_id_3 of { Some x -> x }
             { None -> error () } in
             let value = hash key_id_3_unwrap % bind case (pmap_slice.peek
               ()) of { Some x -> x }
               { None -> error () } as {key:__1, value:__2} in __2 in value *
             bind case ((dim_bounds.filter
             ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 3))).peek
             ()) of { Some x -> x }
             { None -> error () } as {key:__1, value:__2} in __2) +
        ((if key_id_2 == None immut
          then 0
          else
            let pmap_slice = pmap.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 2)) in
            if pmap_slice == empty { key:int, value:int } @ { Seq }
            then 0
            else let key_id_2_unwrap = case key_id_2 of { Some x -> x }
              { None -> error () } in
              let value = hash key_id_2_unwrap % bind case (pmap_slice.peek
                ()) of { Some x -> x }
                { None -> error () } as {key:__1, value:__2} in __2 in value *
              bind case ((dim_bounds.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 2))).peek
              ()) of { Some x -> x }
              { None -> error () } as {key:__1, value:__2} in __2) +
        ((if key_id_1 == None immut
          then 0
          else
            let pmap_slice = pmap.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1)) in
            if pmap_slice == empty { key:int, value:int } @ { Seq }
            then 0
            else let key_id_1_unwrap = case key_id_1 of { Some x -> x }
              { None -> error () } in
              let value = hash key_id_1_unwrap % bind case (pmap_slice.peek
                ()) of { Some x -> x }
                { None -> error () } as {key:__1, value:__2} in __2 in value *
              bind case ((dim_bounds.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1))).peek
              ()) of { Some x -> x }
              { None -> error () } as {key:__1, value:__2} in __2) +
        ((if key_id_0 == None immut
          then 0
          else
            let pmap_slice = pmap.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0)) in
            if pmap_slice == empty { key:int, value:int } @ { Seq }
            then 0
            else let key_id_0_unwrap = case key_id_0 of { Some x -> x }
              { None -> error () } in
              let value = hash key_id_0_unwrap % bind case (pmap_slice.peek
                ()) of { Some x -> x }
                { None -> error () } as {key:__1, value:__2} in __2 in value *
              bind case ((dim_bounds.filter
              ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).peek
              ()) of { Some x -> x }
              { None -> error () } as {key:__1, value:__2} in __2) + 0))) in
      let free_dims =
        (if key_id_3 != None immut
         then empty { key:int, value:int } @ { Seq }
         else pmap.filter
           ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 3))).combine
        ((if key_id_2 != None immut
          then empty { key:int, value:int } @ { Seq }
          else pmap.filter
            ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 2))).combine
        ((if key_id_1 != None immut
          then empty { key:int, value:int } @ { Seq }
          else pmap.filter
            ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 1))).combine
        ((if key_id_0 != None immut
          then empty { key:int, value:int } @ { Seq }
          else pmap.filter
            ((\_b1_ ->  bind _b1_ as {key:key, value:value} in key == 0))).combine
        empty { key:int, value:int } @ { Seq }))) in
      let free_domains =
        free_dims.map
          ((\_b1_ -> 
            bind _b1_ as {key:i, value:b_i} in {key:i, value:range b_i})) in
      let free_cart_prod =
        free_domains.fold
          ((\prev_cart_prod -> (\_b3_ -> 
            bind _b3_ as {key:i, value:domain} in 
            domain.ext
              ((\_b1_ -> 
                bind _b1_ as {i:domain_element} in 
                if prev_cart_prod == empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq }
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int |
                  {key:i, value:domain_element}|} @ { Seq }|} @ { Seq }
                else
                  prev_cart_prod.map
                    ((\_b1_ -> 
                      bind _b1_ as {i:rest_tup} in 
                      {i:rest_tup.combine
                       ({| key:int, value:int |
                       {key:i, value:domain_element}|} @ { Seq })}))))
              empty {i:collection { key:int, value:int
              } @ { Seq }} @ { Collection }))) empty {i:collection {
          key:int, value:int } @ { Seq }} @ { Seq } in
      let sorted_ip_list = (empty { key:address, value:()
        } @ { Collection }).combine
        ((free_cart_prod.map
            ((\_b1_ -> 
              bind _b1_ as {i:free_bucket} in 
              {i:get_ring_node
                   {key:free_bucket.fold
                          ((\acc -> (\_b3_ -> 
                            bind _b3_ as {key:i, value:val} in acc + (val *
                            bind case ((dim_bounds.filter
                            ((\_b1_ -> 
                              bind _b1_ as {key:key, value:value} in key == i))).peek
                            ()) of { Some x -> x }
                            { None -> error () } as {key:__1, value:__2} in 
                            __2)))) bound_bucket, value:max_val}}))).groupBy
           ((\_b1_ ->  bind _b1_ as {i:ip} in ip)) ((\_ -> (\_ ->  ()))) ()) in
      if sorted_ip_list == empty { key:address, value:() } @ { Collection }
      then {|i:address|
        get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
      else
        sorted_ip_list.map
          ((\_b1_ ->  bind _b1_ as {key:__1, value:__2} in {i:__1})))

declare shuffle_QUERY3_mCUSTOMER4_QUERY3_0t0_1t1_2t2 : {
  _r1_:{ _r1_:option int, _r2_:option int, _r3_:option int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set }, _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set } } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:l_key, _r2_:tuples, _r3_:shuffle_on_empty} in 
    bind l_key as {_r1_:__id_l0, _r2_:__id_l1, _r3_:__id_l2} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_QUERY3 l_key).map
          ((\_b1_ -> 
            bind _b1_ as {i:ip} in 
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:real } @ { Set }}))
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
        _r5_:int, _r6_:real } @ { Set } } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         ((\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2,
                            _r4_:__id_r3, _r5_:__id_r4, _r6_:__id_r5} in 
           let full_lkey =
             {_r1_:Some __id_r1, _r2_:Some __id_r2, _r3_:Some __id_r3} in
           (route_to_QUERY3 full_lkey).map
             ((\_b1_ -> 
               bind _b1_ as {i:ip} in 
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                _r4_:int, _r5_:int, _r6_:real | r_tuple|} @ { Set }}))))
         empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
         _r5_:int, _r6_:real } @ { Set } } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
      _r5_:int, _r6_:real } @ { Set })

declare shuffle_QUERY3_mCUSTOMER2_QUERY3_0t0_1t1_2t2 : {
  _r1_:{ _r1_:option int, _r2_:option int, _r3_:option int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set }, _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:real } @ { Set } } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:l_key, _r2_:tuples, _r3_:shuffle_on_empty} in 
    bind l_key as {_r1_:__id_l0, _r2_:__id_l1, _r3_:__id_l2} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_QUERY3 l_key).map
          ((\_b1_ -> 
            bind _b1_ as {i:ip} in 
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:real } @ { Set }}))
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
        _r5_:int, _r6_:real } @ { Set } } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         ((\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2,
                            _r4_:__id_r3, _r5_:__id_r4, _r6_:__id_r5} in 
           let full_lkey =
             {_r1_:Some __id_r1, _r2_:Some __id_r2, _r3_:Some __id_r3} in
           (route_to_QUERY3 full_lkey).map
             ((\_b1_ -> 
               bind _b1_ as {i:ip} in 
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                _r4_:int, _r5_:int, _r6_:real | r_tuple|} @ { Set }}))))
         empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
         _r5_:int, _r6_:real } @ { Set } } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
      _r5_:int, _r6_:real } @ { Set })

declare shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mLINEITEM1_0t0_1t1_2t2 : {
  _r1_:{ _r1_:option int, _r2_:option int, _r3_:option int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set }, _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set } } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:l_key, _r2_:tuples, _r3_:shuffle_on_empty} in 
    bind l_key as {_r1_:__id_l0, _r2_:__id_l1, _r3_:__id_l2} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_QUERY3_mLINEITEM1 l_key).map
          ((\_b1_ -> 
            bind _b1_ as {i:ip} in 
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:int } @ { Set }}))
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
        _r5_:int, _r6_:int } @ { Set } } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         ((\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2,
                            _r4_:__id_r3, _r5_:__id_r4, _r6_:__id_r5} in 
           let full_lkey =
             {_r1_:Some __id_r1, _r2_:Some __id_r2, _r3_:Some __id_r3} in
           (route_to_QUERY3_mLINEITEM1 full_lkey).map
             ((\_b1_ -> 
               bind _b1_ as {i:ip} in 
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                _r4_:int, _r5_:int, _r6_:int | r_tuple|} @ { Set }})))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
         _r5_:int, _r6_:int } @ { Set } } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
      _r5_:int, _r6_:int } @ { Set })

declare shuffle_QUERY3_mORDERS3_QUERY3_0t0 : {
  _r1_:{ _r1_:option int, _r2_:option int, _r3_:option int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set },
  _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:l_key, _r2_:tuples, _r3_:shuffle_on_empty} in 
    bind l_key as {_r1_:__id_l0, _r2_:__id_l1, _r3_:__id_l2} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_QUERY3 l_key).map
          ((\_b1_ -> 
            bind _b1_ as {i:ip} in 
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
             } @ { Set }}))
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
        } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         ((\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2} in 
           let full_lkey = {_r1_:Some __id_r1, _r2_:__id_l1, _r3_:__id_l2} in
           (route_to_QUERY3 full_lkey).map
             ((\_b1_ -> 
               bind _b1_ as {i:ip} in 
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real |
                r_tuple|} @ { Set }})))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
         } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
      } @ { Set })

declare shuffle_QUERY3_mORDERS1_QUERY3 : {
  _r1_:{ _r1_:option int, _r2_:option int, _r3_:option int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set },
  _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:l_key, _r2_:tuples, _r3_:shuffle_on_empty} in 
    bind l_key as {_r1_:__id_l0, _r2_:__id_l1, _r3_:__id_l2} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_QUERY3 l_key).map
          ((\_b1_ -> 
            bind _b1_ as {i:ip} in 
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }}))
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         ((\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2} in 
           let full_lkey = {_r1_:__id_l0, _r2_:__id_l1, _r3_:__id_l2} in
           (route_to_QUERY3 full_lkey).map
             ((\_b1_ -> 
               bind _b1_ as {i:ip} in 
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
                r_tuple|} @ { Set }})))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
         } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Set })

declare shuffle_QUERY3_mORDERS6_QUERY3_0t0 : {
  _r1_:{ _r1_:option int, _r2_:option int, _r3_:option int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set },
  _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:l_key, _r2_:tuples, _r3_:shuffle_on_empty} in 
    bind l_key as {_r1_:__id_l0, _r2_:__id_l1, _r3_:__id_l2} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_QUERY3 l_key).map
          ((\_b1_ -> 
            bind _b1_ as {i:ip} in 
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
             } @ { Set }}))
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
        } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         ((\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2} in 
           let full_lkey = {_r1_:Some __id_r1, _r2_:__id_l1, _r3_:__id_l2} in
           (route_to_QUERY3 full_lkey).map
             ((\_b1_ -> 
               bind _b1_ as {i:ip} in 
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real |
                r_tuple|} @ { Set }})))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
         } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
      } @ { Set })

declare shuffle_QUERY3_mORDERS1_QUERY3_mLINEITEM1 : {
  _r1_:{ _r1_:option int, _r2_:option int, _r3_:option int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set },
  _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:l_key, _r2_:tuples, _r3_:shuffle_on_empty} in 
    bind l_key as {_r1_:__id_l0, _r2_:__id_l1, _r3_:__id_l2} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_QUERY3_mLINEITEM1 l_key).map
          ((\_b1_ -> 
            bind _b1_ as {i:ip} in 
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }}))
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         ((\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2} in 
           let full_lkey = {_r1_:__id_l0, _r2_:__id_l1, _r3_:__id_l2} in
           (route_to_QUERY3_mLINEITEM1 full_lkey).map
             ((\_b1_ -> 
               bind _b1_ as {i:ip} in 
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
                r_tuple|} @ { Set }})))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
         } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Set })

declare shuffle_QUERY3_mORDERS3_QUERY3_mCUSTOMER2_0t0 : {
  _r1_:{ _r1_:option int, _r2_:option int, _r3_:option int, _r4_:option int },
  _r2_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
  } @ { Set }, _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:l_key, _r2_:tuples, _r3_:shuffle_on_empty} in 
    bind l_key as {_r1_:__id_l0, _r2_:__id_l1, _r3_:__id_l2, _r4_:__id_l3} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_QUERY3_mCUSTOMER2 l_key).map
          ((\_b1_ -> 
            bind _b1_ as {i:ip} in 
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
             } @ { Set }}))
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
        } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         ((\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2} in 
           let full_lkey =
             {_r1_:Some __id_r1, _r2_:__id_l1, _r3_:__id_l2, _r4_:__id_l3} in
           (route_to_QUERY3_mCUSTOMER2 full_lkey).map
             ((\_b1_ -> 
               bind _b1_ as {i:ip} in 
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real |
                r_tuple|} @ { Set }})))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
         } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
      } @ { Set })

declare shuffle_QUERY3_mORDERS6_QUERY3_mCUSTOMER4_0t0 : {
  _r1_:{ _r1_:option int, _r2_:option int, _r3_:option int, _r4_:option int },
  _r2_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
  } @ { Set }, _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
  } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:l_key, _r2_:tuples, _r3_:shuffle_on_empty} in 
    bind l_key as {_r1_:__id_l0, _r2_:__id_l1, _r3_:__id_l2, _r4_:__id_l3} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_QUERY3_mCUSTOMER4 l_key).map
          ((\_b1_ -> 
            bind _b1_ as {i:ip} in 
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
             } @ { Set }}))
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
        } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         ((\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2} in 
           let full_lkey =
             {_r1_:Some __id_r1, _r2_:__id_l1, _r3_:__id_l2, _r4_:__id_l3} in
           (route_to_QUERY3_mCUSTOMER4 full_lkey).map
             ((\_b1_ -> 
               bind _b1_ as {i:ip} in 
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real |
                r_tuple|} @ { Set }})))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
         } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
      } @ { Set })

declare shuffle_QUERY3_mLINEITEM1_QUERY3_0t0_1t1_2t2 : {
  _r1_:{ _r1_:option int, _r2_:option int, _r3_:option int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int
  } @ { Set }, _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int
  } @ { Set } } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:l_key, _r2_:tuples, _r3_:shuffle_on_empty} in 
    bind l_key as {_r1_:__id_l0, _r2_:__id_l1, _r3_:__id_l2} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_QUERY3 l_key).map
          ((\_b1_ -> 
            bind _b1_ as {i:ip} in 
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int } @ { Set }}))
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
        _r5_:int } @ { Set } } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         ((\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2,
                            _r4_:__id_r3, _r5_:__id_r4} in 
           let full_lkey =
             {_r1_:Some __id_r1, _r2_:Some __id_r2, _r3_:Some __id_r3} in
           (route_to_QUERY3 full_lkey).map
             ((\_b1_ -> 
               bind _b1_ as {i:ip} in 
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                _r4_:int, _r5_:int | r_tuple|} @ { Set }})))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
         _r5_:int } @ { Set } } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
      _r5_:int } @ { Set })

declare shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mCUSTOMER2_0t0_1t1_2t2_3t3 :
  {
  _r1_:{ _r1_:option int, _r2_:option int, _r3_:option int, _r4_:option int },
  _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set }, _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set } } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:l_key, _r2_:tuples, _r3_:shuffle_on_empty} in 
    bind l_key as {_r1_:__id_l0, _r2_:__id_l1, _r3_:__id_l2, _r4_:__id_l3} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_QUERY3_mCUSTOMER2 l_key).map
          ((\_b1_ -> 
            bind _b1_ as {i:ip} in 
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:int } @ { Set }}))
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
        _r5_:int, _r6_:int } @ { Set } } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         ((\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2,
                            _r4_:__id_r3, _r5_:__id_r4, _r6_:__id_r5} in 
           let full_lkey =
             {_r1_:Some __id_r1, _r2_:Some __id_r2, _r3_:Some __id_r3,
              _r4_:Some __id_r4} in
           (route_to_QUERY3_mCUSTOMER2 full_lkey).map
             ((\_b1_ -> 
               bind _b1_ as {i:ip} in 
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                _r4_:int, _r5_:int, _r6_:int | r_tuple|} @ { Set }})))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
         _r5_:int, _r6_:int } @ { Set } } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
      _r5_:int, _r6_:int } @ { Set })

declare shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mCUSTOMER4_0t0_1t1_2t2_3t3 :
  {
  _r1_:{ _r1_:option int, _r2_:option int, _r3_:option int, _r4_:option int },
  _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set }, _r3_:bool } -> collection {
  key:address, value:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
  _r5_:int, _r6_:int } @ { Set } } @ { Collection } = (\_b1_ -> 
    bind _b1_ as {_r1_:l_key, _r2_:tuples, _r3_:shuffle_on_empty} in 
    bind l_key as {_r1_:__id_l0, _r2_:__id_l1, _r3_:__id_l2, _r4_:__id_l3} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_QUERY3_mCUSTOMER4 l_key).map
          ((\_b1_ -> 
            bind _b1_ as {i:ip} in 
            {key:ip, value:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:int } @ { Set }}))
      else empty {
        key:address, value:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
        _r5_:int, _r6_:int } @ { Set } } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         ((\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2,
                            _r4_:__id_r3, _r5_:__id_r4, _r6_:__id_r5} in 
           let full_lkey =
             {_r1_:Some __id_r1, _r2_:Some __id_r2, _r3_:Some __id_r3,
              _r4_:Some __id_r4} in
           (route_to_QUERY3_mCUSTOMER4 full_lkey).map
             ((\_b1_ -> 
               bind _b1_ as {i:ip} in 
               {key:ip, value:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                _r4_:int, _r5_:int, _r6_:int | r_tuple|} @ { Set }})))) empty {
         key:address, value:collection {
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
         _r5_:int, _r6_:int } @ { Set } } @ { Collection })).groupBy
      ((\_b1_ ->  bind _b1_ as {key:ip, value:tuple} in ip)) ((\acc ->
      (\_b3_ ->  bind _b3_ as {key:ip, value:tuple} in tuple.combine acc)))
      empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
      _r5_:int, _r6_:int } @ { Set })

declare init : () = (
    my_peers.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name} in 
        if _role_ != "switch"
        then add_node {_r1_:addr, _r2_:_role_, _r3_:name}
        else ()))
    )

declare filter_corrective_list : {
  key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection { key:int, value:int
  } @ { Seq } } -> collection {
  key:int, value:collection { _r1_:int, _r2_:int, _r3_:int } @ { Seq }
  } @ { Seq } = (\_b1_ -> 
    bind _b1_ as {key:request_vid, value:trig_stmt_list} in 
    let log_entries = (empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Seq }).combine (log_read_geq request_vid) in
    ((log_entries.map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:trig_id, _r3_:stmt_id} in 
          {key:vid, value:stmt_id}))).sort
      ((\_b2_ -> bind _b2_ as {key:vid1, value:stmt1} in (\_b5_ -> 
        bind _b5_ as {key:vid2, value:stmt2} in 
        if vid_lt {key:vid1, value:vid2} then -1 else 1)))).groupBy
      ((\_b1_ ->  bind _b1_ as {key:_, value:stmt_id} in stmt_id))
      ((\vid_list -> (\_b3_ -> 
        bind _b3_ as {key:vid, value:_} in vid_list.combine
        ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq })))) empty {
      _r1_:int, _r2_:int, _r3_:int } @ { Seq })

trigger insert_CUSTOMER : {
_r1_:int, _r2_:string, _r3_:string, _r4_:int, _r5_:string, _r6_:real,
_r7_:string, _r8_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:CUSTOMER_CUSTKEY, _r2_:CUSTOMER_NAME,
                _r3_:CUSTOMER_ADDRESS, _r4_:CUSTOMER_NATIONKEY,
                _r5_:CUSTOMER_PHONE, _r6_:CUSTOMER_ACCTBAL,
                _r7_:CUSTOMER_MKTSEGMENT, _r8_:CUSTOMER_COMMENT} in (
    let vid =
      {_r1_:case (__epoch__.peek ()) of { Some x -> x.i } { None -> error () },
       _r2_:case (__vid_counter__.peek ()) of { Some x -> x.i }
       { None -> error () }, _r3_:hash me} in
    (
      (insert_CUSTOMER_send_fetch, me)<- {_r1_:vid, _r2_:CUSTOMER_CUSTKEY,
                                          _r3_:CUSTOMER_NAME,
                                          _r4_:CUSTOMER_ADDRESS,
                                          _r5_:CUSTOMER_NATIONKEY,
                                          _r6_:CUSTOMER_PHONE,
                                          _r7_:CUSTOMER_ACCTBAL,
                                          _r8_:CUSTOMER_MKTSEGMENT,
                                          _r9_:CUSTOMER_COMMENT};
      __vid_counter__.update
        ({i:case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
        ({i:1 + case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
      )
    ))

trigger insert_CUSTOMER_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT} in (
    (route_to_QUERY3_mORDERS1 (Some CUSTOMER_CUSTKEY)).iterate
      ((\_b1_ -> 
        bind _b1_ as {i:ip} in 
        (insert_CUSTOMER_do_complete_s2, ip)<- {_r1_:vid,
                                                _r2_:CUSTOMER_CUSTKEY,
                                                _r3_:CUSTOMER_NAME,
                                                _r4_:CUSTOMER_ADDRESS,
                                                _r5_:CUSTOMER_NATIONKEY,
                                                _r6_:CUSTOMER_PHONE,
                                                _r7_:CUSTOMER_ACCTBAL,
                                                _r8_:CUSTOMER_MKTSEGMENT,
                                                _r9_:CUSTOMER_COMMENT}));
    ((((empty {
        _r1_:address, _r2_:int, _r3_:int
        } @ { Collection }).combine
        (let sender_count =
           (route_to_QUERY3_mCUSTOMER4
              {_r1_:None immut, _r2_:None immut, _r3_:None immut,
               _r4_:Some CUSTOMER_CUSTKEY}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mCUSTOMER4_QUERY3_0t0_1t1_2t2
            {_r1_:{_r1_:None immut, _r2_:None immut, _r3_:None immut},
             _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:real } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:0, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mCUSTOMER2
              {_r1_:None immut, _r2_:None immut, _r3_:None immut,
               _r4_:Some CUSTOMER_CUSTKEY}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mCUSTOMER2_QUERY3_0t0_1t1_2t2
            {_r1_:{_r1_:None immut, _r2_:None immut, _r3_:None immut},
             _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:real } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:0, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mLINEITEM1_mCUSTOMER2
              {_r1_:None immut, _r2_:None immut, _r3_:None immut,
               _r4_:Some CUSTOMER_CUSTKEY}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mLINEITEM1_0t0_1t1_2t2
           {_r1_:{_r1_:None immut, _r2_:None immut, _r3_:None immut},
            _r2_:empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
            _r4_:int, _r5_:int, _r6_:int } @ { Set }, _r3_:true}).map
          ((\_b1_ -> 
            bind _b1_ as {key:ip, value:tuples} in 
            {_r1_:ip, _r2_:1, _r3_:sender_count})))))).groupBy
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in 
          {key:ip, value:stmt_id})) ((\acc -> (\_b3_ -> 
          bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupBy
       ((\_b1_ -> 
         bind _b1_ as {key:_b2_, value:count} in 
         bind _b2_ as {key:ip, value:stmt_id} in ip)) ((\acc -> (\_b3_ -> 
         bind _b3_ as {key:ip_and_stmt_id, value:count} in 
         bind ip_and_stmt_id as {key:ip, value:stmt_id} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:count}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_id_cnt_list} in (
          (insert_CUSTOMER_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list,
                                           _r3_:vid, _r4_:CUSTOMER_CUSTKEY,
                                           _r5_:CUSTOMER_NAME,
                                           _r6_:CUSTOMER_ADDRESS,
                                           _r7_:CUSTOMER_NATIONKEY,
                                           _r8_:CUSTOMER_PHONE,
                                           _r9_:CUSTOMER_ACCTBAL,
                                           _r10_:CUSTOMER_MKTSEGMENT,
                                           _r11_:CUSTOMER_COMMENT}
          )));
    ((((route_to_QUERY3_mLINEITEM1_mCUSTOMER2
          {_r1_:None immut, _r2_:None immut, _r3_:None immut,
           _r4_:Some CUSTOMER_CUSTKEY}).map
         ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:1, _r2_:3, _r3_:ip}))).combine
       (((route_to_QUERY3_mCUSTOMER4
            {_r1_:None immut, _r2_:None immut, _r3_:None immut,
             _r4_:Some CUSTOMER_CUSTKEY}).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:0, _r2_:8, _r3_:ip}))).combine
       (((route_to_QUERY3_mCUSTOMER2
            {_r1_:None immut, _r2_:None immut, _r3_:None immut,
             _r4_:Some CUSTOMER_CUSTKEY}).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:0, _r2_:7, _r3_:ip}))).combine
       empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection }))).groupBy
       ((\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip))
       ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:map_id}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_map_ids} in 
        (insert_CUSTOMER_rcv_fetch, ip)<- {_r1_:stmt_map_ids, _r2_:vid,
                                           _r3_:CUSTOMER_CUSTKEY,
                                           _r4_:CUSTOMER_NAME,
                                           _r5_:CUSTOMER_ADDRESS,
                                           _r6_:CUSTOMER_NATIONKEY,
                                           _r7_:CUSTOMER_PHONE,
                                           _r8_:CUSTOMER_ACCTBAL,
                                           _r9_:CUSTOMER_MKTSEGMENT,
                                           _r10_:CUSTOMER_COMMENT}))
    ))

trigger insert_CUSTOMER_rcv_put : {
_r1_:address, _r2_:collection { key:int, value:int } @ { Set }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:string, _r6_:string, _r7_:int,
_r8_:string, _r9_:real, _r10_:string, _r11_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid,
                _r4_:CUSTOMER_CUSTKEY, _r5_:CUSTOMER_NAME,
                _r6_:CUSTOMER_ADDRESS, _r7_:CUSTOMER_NATIONKEY,
                _r8_:CUSTOMER_PHONE, _r9_:CUSTOMER_ACCTBAL,
                _r10_:CUSTOMER_MKTSEGMENT, _r11_:CUSTOMER_COMMENT} in (
    stmt_id_cnt_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:count} in 
        if __stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:_, _r2_:_, _r3_:old_count} in 
          let new_count = old_count + count in (
            __stmt_cntrs__.update
              {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
              {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
            if new_count == 0
            then
              if stmt_id == 2
              then
                (insert_CUSTOMER_do_complete_s2, me)<- {_r1_:vid,
                                                        _r2_:CUSTOMER_CUSTKEY,
                                                        _r3_:CUSTOMER_NAME,
                                                        _r4_:CUSTOMER_ADDRESS,
                                                        _r5_:CUSTOMER_NATIONKEY,
                                                        _r6_:CUSTOMER_PHONE,
                                                        _r7_:CUSTOMER_ACCTBAL,
                                                        _r8_:CUSTOMER_MKTSEGMENT,
                                                        _r9_:CUSTOMER_COMMENT}
              else
                if stmt_id == 1
                then
                  (insert_CUSTOMER_do_complete_s1, me)<- {_r1_:vid,
                                                          _r2_:CUSTOMER_CUSTKEY,
                                                          _r3_:CUSTOMER_NAME,
                                                          _r4_:CUSTOMER_ADDRESS,
                                                          _r5_:CUSTOMER_NATIONKEY,
                                                          _r6_:CUSTOMER_PHONE,
                                                          _r7_:CUSTOMER_ACCTBAL,
                                                          _r8_:CUSTOMER_MKTSEGMENT,
                                                          _r9_:CUSTOMER_COMMENT}
                else
                  if stmt_id == 0
                  then
                    (insert_CUSTOMER_do_complete_s0, me)<- {_r1_:vid,
                                                            _r2_:CUSTOMER_CUSTKEY,
                                                            _r3_:CUSTOMER_NAME,
                                                            _r4_:CUSTOMER_ADDRESS,
                                                            _r5_:CUSTOMER_NATIONKEY,
                                                            _r6_:CUSTOMER_PHONE,
                                                            _r7_:CUSTOMER_ACCTBAL,
                                                            _r8_:CUSTOMER_MKTSEGMENT,
                                                            _r9_:CUSTOMER_COMMENT}
                  else ()
            else ()
            )
        else __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count}))
    ))

trigger insert_CUSTOMER_rcv_fetch : {
_r1_:collection { key:int, value:int } @ { Set }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:string, _r5_:string, _r6_:int,
_r7_:string, _r8_:real, _r9_:string, _r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:CUSTOMER_CUSTKEY,
                _r4_:CUSTOMER_NAME, _r5_:CUSTOMER_ADDRESS,
                _r6_:CUSTOMER_NATIONKEY, _r7_:CUSTOMER_PHONE,
                _r8_:CUSTOMER_ACCTBAL, _r9_:CUSTOMER_MKTSEGMENT,
                _r10_:CUSTOMER_COMMENT} in (
    log_write_insert_CUSTOMER
      {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
       _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY, _r6_:CUSTOMER_PHONE,
       _r7_:CUSTOMER_ACCTBAL, _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT};
    stmts_and_map_ids.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:map_id} in 
        if stmt_id == 0
        then
          if map_id == 7
          then
            (insert_CUSTOMER_send_push_s0_m_QUERY3_mCUSTOMER2, me)<- {
              _r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
              _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
              _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
              _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT}
          else
            if map_id == 8
            then
              (insert_CUSTOMER_send_push_s0_m_QUERY3_mCUSTOMER4, me)<- {
                _r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT}
            else ()
        else
          if stmt_id == 1
          then
            if map_id == 3
            then
              (insert_CUSTOMER_send_push_s1_m_QUERY3_mLINEITEM1_mCUSTOMER2, me)<- {
                _r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT}
            else ()
          else ()))
    ))

trigger insert_CUSTOMER_send_push_s0_m_QUERY3_mCUSTOMER4 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:0, _r3_:0};
    (shuffle_QUERY3_mCUSTOMER4_QUERY3_0t0_1t1_2t2
       {_r1_:{_r1_:None immut, _r2_:None immut, _r3_:None immut},
        _r2_:((QUERY3_mCUSTOMER4.filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                                _r5_:_r5_, _r6_:_r6_} in _r5_ ==
                  CUSTOMER_CUSTKEY))).groupBy
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
                ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  if vid_lt {key:map_vid, value:vid}
                  then
                    if vid_eq {key:map_vid, value:max_vid}
                    then
                      {key:({|
                       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                       _r3_:int, _r4_:int, _r5_:int, _r6_:real |
                       {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                        _r5_:__map_3, _r6_:__map_val}|} @ { Set }).combine 
                       acc, value:max_vid}
                    else
                      if vid_gt {key:map_vid, value:max_vid}
                      then
                        {key:{|
                         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                         _r3_:int, _r4_:int, _r5_:int, _r6_:real |
                         {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                          _r4_:__map_2, _r5_:__map_3, _r6_:__map_val}|} @ { Set },
                         value:map_vid}
                      else {key:acc, value:max_vid}
                  else {key:acc, value:max_vid})))
                {key:empty {
                 _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                 _r4_:int, _r5_:int, _r6_:real } @ { Set },
                 value:{_r1_:0, _r2_:0, _r3_:0}}).ext
               ((\_b1_ -> 
                 bind _b1_ as {key:_, value:_b2_} in 
                 bind _b2_ as {key:project, value:_} in project)) empty {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
               _r4_:int, _r5_:int, _r6_:real } @ { Collection }, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_CUSTOMER_rcv_push_s0_m_QUERY3_mCUSTOMER4, ip)<- {_r1_:tuples,
                                                                 _r2_:vid,
                                                                 _r3_:CUSTOMER_CUSTKEY,
                                                                 _r4_:CUSTOMER_NAME,
                                                                 _r5_:CUSTOMER_ADDRESS,
                                                                 _r6_:CUSTOMER_NATIONKEY,
                                                                 _r7_:CUSTOMER_PHONE,
                                                                 _r8_:CUSTOMER_ACCTBAL,
                                                                 _r9_:CUSTOMER_MKTSEGMENT,
                                                                 _r10_:CUSTOMER_COMMENT}))
    ))

trigger insert_CUSTOMER_send_push_s0_m_QUERY3_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:0, _r3_:0};
    (shuffle_QUERY3_mCUSTOMER2_QUERY3_0t0_1t1_2t2
       {_r1_:{_r1_:None immut, _r2_:None immut, _r3_:None immut},
        _r2_:((QUERY3_mCUSTOMER2.filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                                _r5_:_r5_, _r6_:_r6_} in _r5_ ==
                  CUSTOMER_CUSTKEY))).groupBy
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
                ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  if vid_lt {key:map_vid, value:vid}
                  then
                    if vid_eq {key:map_vid, value:max_vid}
                    then
                      {key:({|
                       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                       _r3_:int, _r4_:int, _r5_:int, _r6_:real |
                       {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                        _r5_:__map_3, _r6_:__map_val}|} @ { Set }).combine 
                       acc, value:max_vid}
                    else
                      if vid_gt {key:map_vid, value:max_vid}
                      then
                        {key:{|
                         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                         _r3_:int, _r4_:int, _r5_:int, _r6_:real |
                         {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                          _r4_:__map_2, _r5_:__map_3, _r6_:__map_val}|} @ { Set },
                         value:map_vid}
                      else {key:acc, value:max_vid}
                  else {key:acc, value:max_vid})))
                {key:empty {
                 _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                 _r4_:int, _r5_:int, _r6_:real } @ { Set },
                 value:{_r1_:0, _r2_:0, _r3_:0}}).ext
               ((\_b1_ -> 
                 bind _b1_ as {key:_, value:_b2_} in 
                 bind _b2_ as {key:project, value:_} in project)) empty {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
               _r4_:int, _r5_:int, _r6_:real } @ { Collection }, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_CUSTOMER_rcv_push_s0_m_QUERY3_mCUSTOMER2, ip)<- {_r1_:tuples,
                                                                 _r2_:vid,
                                                                 _r3_:CUSTOMER_CUSTKEY,
                                                                 _r4_:CUSTOMER_NAME,
                                                                 _r5_:CUSTOMER_ADDRESS,
                                                                 _r6_:CUSTOMER_NATIONKEY,
                                                                 _r7_:CUSTOMER_PHONE,
                                                                 _r8_:CUSTOMER_ACCTBAL,
                                                                 _r9_:CUSTOMER_MKTSEGMENT,
                                                                 _r10_:CUSTOMER_COMMENT}))
    ))

trigger insert_CUSTOMER_send_push_s1_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:0, _r3_:1};
    (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mLINEITEM1_0t0_1t1_2t2
       {_r1_:{_r1_:None immut, _r2_:None immut, _r3_:None immut},
        _r2_:((QUERY3_mLINEITEM1_mCUSTOMER2.filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                                _r5_:_r5_, _r6_:_r6_} in _r5_ ==
                  CUSTOMER_CUSTKEY))).groupBy
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
                ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  if vid_lt {key:map_vid, value:vid}
                  then
                    if vid_eq {key:map_vid, value:max_vid}
                    then
                      {key:({|
                       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                       _r3_:int, _r4_:int, _r5_:int, _r6_:int |
                       {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                        _r5_:__map_3, _r6_:__map_val}|} @ { Set }).combine 
                       acc, value:max_vid}
                    else
                      if vid_gt {key:map_vid, value:max_vid}
                      then
                        {key:{|
                         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                         _r3_:int, _r4_:int, _r5_:int, _r6_:int |
                         {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                          _r4_:__map_2, _r5_:__map_3, _r6_:__map_val}|} @ { Set },
                         value:map_vid}
                      else {key:acc, value:max_vid}
                  else {key:acc, value:max_vid})))
                {key:empty {
                 _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                 _r4_:int, _r5_:int, _r6_:int } @ { Set },
                 value:{_r1_:0, _r2_:0, _r3_:0}}).ext
               ((\_b1_ -> 
                 bind _b1_ as {key:_, value:_b2_} in 
                 bind _b2_ as {key:project, value:_} in project)) empty {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
               _r4_:int, _r5_:int, _r6_:int } @ { Collection }, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_CUSTOMER_rcv_push_s1_m_QUERY3_mLINEITEM1_mCUSTOMER2, ip)<- {
          _r1_:tuples, _r2_:vid, _r3_:CUSTOMER_CUSTKEY, _r4_:CUSTOMER_NAME,
          _r5_:CUSTOMER_ADDRESS, _r6_:CUSTOMER_NATIONKEY, _r7_:CUSTOMER_PHONE,
          _r8_:CUSTOMER_ACCTBAL, _r9_:CUSTOMER_MKTSEGMENT,
          _r10_:CUSTOMER_COMMENT}))
    ))

trigger insert_CUSTOMER_rcv_push_s0_m_QUERY3_mCUSTOMER2 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real } @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int,
_r4_:string, _r5_:string, _r6_:int, _r7_:string, _r8_:real, _r9_:string,
_r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:CUSTOMER_CUSTKEY,
                _r4_:CUSTOMER_NAME, _r5_:CUSTOMER_ADDRESS,
                _r6_:CUSTOMER_NATIONKEY, _r7_:CUSTOMER_PHONE,
                _r8_:CUSTOMER_ACCTBAL, _r9_:CUSTOMER_MKTSEGMENT,
                _r10_:CUSTOMER_COMMENT} in (
    log_write_insert_CUSTOMER
      {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
       _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY, _r6_:CUSTOMER_PHONE,
       _r7_:CUSTOMER_ACCTBAL, _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mCUSTOMER2_s0_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                          _r5_:_r5_, _r6_:_r6_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                           _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
            (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3) and
            _r3_ == __temp_2) and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
          _r5_:int, _r6_:real } @ { Set }
        then
          map_QUERY3_mCUSTOMER2_s0_buf.update
            (case ((map_QUERY3_mCUSTOMER2_s0_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_, _r6_:_r6_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                             _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
              (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3)
              and _r3_ == __temp_2) and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mCUSTOMER2_s0_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 0)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 0))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 0))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:0, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 0))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:0, _r3_:0}
        then
          (insert_CUSTOMER_do_complete_s0, me)<- {_r1_:vid,
                                                  _r2_:CUSTOMER_CUSTKEY,
                                                  _r3_:CUSTOMER_NAME,
                                                  _r4_:CUSTOMER_ADDRESS,
                                                  _r5_:CUSTOMER_NATIONKEY,
                                                  _r6_:CUSTOMER_PHONE,
                                                  _r7_:CUSTOMER_ACCTBAL,
                                                  _r8_:CUSTOMER_MKTSEGMENT,
                                                  _r9_:CUSTOMER_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:0, _r3_:-1}
    ))

trigger insert_CUSTOMER_rcv_push_s0_m_QUERY3_mCUSTOMER4 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real } @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int,
_r4_:string, _r5_:string, _r6_:int, _r7_:string, _r8_:real, _r9_:string,
_r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:CUSTOMER_CUSTKEY,
                _r4_:CUSTOMER_NAME, _r5_:CUSTOMER_ADDRESS,
                _r6_:CUSTOMER_NATIONKEY, _r7_:CUSTOMER_PHONE,
                _r8_:CUSTOMER_ACCTBAL, _r9_:CUSTOMER_MKTSEGMENT,
                _r10_:CUSTOMER_COMMENT} in (
    log_write_insert_CUSTOMER
      {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
       _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY, _r6_:CUSTOMER_PHONE,
       _r7_:CUSTOMER_ACCTBAL, _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mCUSTOMER4_s0_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                          _r5_:_r5_, _r6_:_r6_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                           _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
            (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3) and
            _r3_ == __temp_2) and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
          _r5_:int, _r6_:real } @ { Set }
        then
          map_QUERY3_mCUSTOMER4_s0_buf.update
            (case ((map_QUERY3_mCUSTOMER4_s0_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_, _r6_:_r6_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                             _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
              (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3)
              and _r3_ == __temp_2) and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mCUSTOMER4_s0_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 0)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 0))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 0))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:0, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 0))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:0, _r3_:0}
        then
          (insert_CUSTOMER_do_complete_s0, me)<- {_r1_:vid,
                                                  _r2_:CUSTOMER_CUSTKEY,
                                                  _r3_:CUSTOMER_NAME,
                                                  _r4_:CUSTOMER_ADDRESS,
                                                  _r5_:CUSTOMER_NATIONKEY,
                                                  _r6_:CUSTOMER_PHONE,
                                                  _r7_:CUSTOMER_ACCTBAL,
                                                  _r8_:CUSTOMER_MKTSEGMENT,
                                                  _r9_:CUSTOMER_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:0, _r3_:-1}
    ))

trigger insert_CUSTOMER_rcv_push_s1_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int,
_r4_:string, _r5_:string, _r6_:int, _r7_:string, _r8_:real, _r9_:string,
_r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:CUSTOMER_CUSTKEY,
                _r4_:CUSTOMER_NAME, _r5_:CUSTOMER_ADDRESS,
                _r6_:CUSTOMER_NATIONKEY, _r7_:CUSTOMER_PHONE,
                _r8_:CUSTOMER_ACCTBAL, _r9_:CUSTOMER_MKTSEGMENT,
                _r10_:CUSTOMER_COMMENT} in (
    log_write_insert_CUSTOMER
      {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
       _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY, _r6_:CUSTOMER_PHONE,
       _r7_:CUSTOMER_ACCTBAL, _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                          _r5_:_r5_, _r6_:_r6_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                           _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
            (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3) and
            _r3_ == __temp_2) and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
          _r5_:int, _r6_:int } @ { Set }
        then
          map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf.update
            (case ((map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_, _r6_:_r6_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                             _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
              (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3)
              and _r3_ == __temp_2) and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 1)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 1))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 1))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:1, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 1))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:1, _r3_:0}
        then
          (insert_CUSTOMER_do_complete_s1, me)<- {_r1_:vid,
                                                  _r2_:CUSTOMER_CUSTKEY,
                                                  _r3_:CUSTOMER_NAME,
                                                  _r4_:CUSTOMER_ADDRESS,
                                                  _r5_:CUSTOMER_NATIONKEY,
                                                  _r6_:CUSTOMER_PHONE,
                                                  _r7_:CUSTOMER_ACCTBAL,
                                                  _r8_:CUSTOMER_MKTSEGMENT,
                                                  _r9_:CUSTOMER_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:1, _r3_:-1}
    ))

trigger insert_CUSTOMER_do_complete_s0 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                  _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                  _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                  _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT} in 
    let existing_out_tier = QUERY3 in
    let __delta_values__ =
      ((((((map_QUERY3_mCUSTOMER2_s0_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in _r5_ == CUSTOMER_CUSTKEY))).groupBy
             ((\_b1_ -> 
               bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
             ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
               bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
               if vid_lt {key:map_vid, value:vid}
               then
                 if vid_eq {key:map_vid, value:max_vid}
                 then
                   {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real |
                    {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                     _r5_:__map_val}|} @ { Set }).combine acc, value:max_vid}
                 else
                   if vid_gt {key:map_vid, value:max_vid}
                   then
                     {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                      |
                      {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                       _r5_:__map_val}|} @ { Set }, value:map_vid}
                   else {key:acc, value:max_vid}
               else {key:acc, value:max_vid})))
             {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
              } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}}).ext
            ((\_b1_ -> 
              bind _b1_ as {key:_, value:_b2_} in 
              bind _b2_ as {key:project, value:_} in project)) empty {
            _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
            } @ { Collection }).map
           ((\_b1_ -> 
             bind _b1_ as {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
                           _r3_:ORDERS_SHIPPRIORITY, _r4_:CUSTOMER_CUSTKEY,
                           _r5_:__map_ret__1} in 
             {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
              _r3_:ORDERS_SHIPPRIORITY, _r4_:__map_ret__1}))).map
          ((\_b1_ -> 
            bind _b1_ as {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
                          _r3_:ORDERS_SHIPPRIORITY, _r4_:__map_ret__1} in 
            {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
             _r3_:ORDERS_SHIPPRIORITY, _r4_:__map_ret__1 * -1}))).combine
        ((((map_QUERY3_mCUSTOMER4_s0_buf.filter
             ((\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                             _r5_:_r5_, _r6_:_r6_} in _r5_ == CUSTOMER_CUSTKEY))).groupBy
             ((\_b1_ -> 
               bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
             ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
               bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
               if vid_lt {key:map_vid, value:vid}
               then
                 if vid_eq {key:map_vid, value:max_vid}
                 then
                   {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real |
                    {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                     _r5_:__map_val}|} @ { Set }).combine acc, value:max_vid}
                 else
                   if vid_gt {key:map_vid, value:max_vid}
                   then
                     {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                      |
                      {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                       _r5_:__map_val}|} @ { Set }, value:map_vid}
                   else {key:acc, value:max_vid}
               else {key:acc, value:max_vid})))
             {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
              } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}}).ext
            ((\_b1_ -> 
              bind _b1_ as {key:_, value:_b2_} in 
              bind _b2_ as {key:project, value:_} in project)) empty {
            _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
            } @ { Collection }).map
           ((\_b1_ -> 
             bind _b1_ as {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
                           _r3_:ORDERS_SHIPPRIORITY, _r4_:CUSTOMER_CUSTKEY,
                           _r5_:__map_ret__2} in 
             {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
              _r3_:ORDERS_SHIPPRIORITY, _r4_:__map_ret__2})))).map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
                        _r3_:ORDERS_SHIPPRIORITY, _r4_:__sum_ret__1} in 
          {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
           _r3_:ORDERS_SHIPPRIORITY, _r4_:__sum_ret__1 *
           if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0})) in
    let __delta_with_vid__ =
      __delta_values__.map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
                        _r3_:ORDERS_SHIPPRIORITY, _r4_:__prod_ret__2} in 
          {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
           _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__2})) in (
      add_delta_to_QUERY3 {key:vid, value:__delta_with_vid__} ))

trigger insert_CUSTOMER_do_complete_s1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                  _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                  _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                  _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT} in 
    let existing_out_tier = QUERY3_mLINEITEM1 in
    let __delta_values__ =
      ((((map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf.filter
           ((\_b1_ -> 
             bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                           _r5_:_r5_, _r6_:_r6_} in _r5_ == CUSTOMER_CUSTKEY))).groupBy
           ((\_b1_ -> 
             bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                           _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
           ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
             bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                           _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
             if vid_lt {key:map_vid, value:vid}
             then
               if vid_eq {key:map_vid, value:max_vid}
               then
                 {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                   _r5_:__map_val}|} @ { Set }).combine acc, value:max_vid}
               else
                 if vid_gt {key:map_vid, value:max_vid}
                 then
                   {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                    {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                     _r5_:__map_val}|} @ { Set }, value:map_vid}
                 else {key:acc, value:max_vid}
             else {key:acc, value:max_vid})))
           {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
            } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}}).ext
          ((\_b1_ -> 
            bind _b1_ as {key:_, value:_b2_} in 
            bind _b2_ as {key:project, value:_} in project)) empty {
          _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int } @ { Collection }).map
         ((\_b1_ -> 
           bind _b1_ as {_r1_:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                         _r2_:ORDERS_ORDERDATE, _r3_:ORDERS_SHIPPRIORITY,
                         _r4_:CUSTOMER_CUSTKEY, _r5_:__map_ret__3} in 
           {_r1_:QUERY3_mLINEITEMLINEITEM_ORDERKEY, _r2_:ORDERS_ORDERDATE,
            _r3_:ORDERS_SHIPPRIORITY, _r4_:__map_ret__3}))).map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                        _r2_:ORDERS_ORDERDATE, _r3_:ORDERS_SHIPPRIORITY,
                        _r4_:__map_ret__3} in 
          {_r1_:QUERY3_mLINEITEMLINEITEM_ORDERKEY, _r2_:ORDERS_ORDERDATE,
           _r3_:ORDERS_SHIPPRIORITY, _r4_:__map_ret__3 *
           if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0})) in
    let __delta_with_vid__ =
      __delta_values__.map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                        _r2_:ORDERS_ORDERDATE, _r3_:ORDERS_SHIPPRIORITY,
                        _r4_:__prod_ret__3} in 
          {_r1_:vid, _r2_:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
           _r3_:ORDERS_ORDERDATE, _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__3}))
      in (
      add_delta_to_QUERY3_mLINEITEM1 {key:vid, value:__delta_with_vid__};
      (QUERY3_mLINEITEM1_send_correctives, me)<- {key:vid,
                                                  value:__delta_with_vid__}
      ))

trigger insert_CUSTOMER_do_complete_s2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                  _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                  _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                  _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT} in 
    let existing_out_tier = QUERY3_mORDERS1 in
    let __cmp_ret__3 = if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0 in (
      add_delta_to_QUERY3_mORDERS1
        {key:vid, value:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:__cmp_ret__3}|} @ { Set }};
      (QUERY3_mORDERS1_send_correctives, me)<- {key:vid, value:{|
                                                _r1_:{
                                                _r1_:int, _r2_:int, _r3_:int },
                                                _r2_:int, _r3_:int |
                                                {_r1_:vid,
                                                 _r2_:CUSTOMER_CUSTKEY,
                                                 _r3_:__cmp_ret__3}|} @ { Set }}
      ))

trigger insert_CUSTOMER_rcv_corrective_s0_m_QUERY3_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mCUSTOMER2_s0_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 0))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:0, _r3_:0}
        then
          bind log_get_bound_insert_CUSTOMER compute_vid as {_r1_:vid,
                                                             _r2_:CUSTOMER_CUSTKEY,
                                                             _r3_:CUSTOMER_NAME,
                                                             _r4_:CUSTOMER_ADDRESS,
                                                             _r5_:CUSTOMER_NATIONKEY,
                                                             _r6_:CUSTOMER_PHONE,
                                                             _r7_:CUSTOMER_ACCTBAL,
                                                             _r8_:CUSTOMER_MKTSEGMENT,
                                                             _r9_:CUSTOMER_COMMENT} in 
          (insert_CUSTOMER_do_corrective_s0_m_QUERY3_mCUSTOMER2, me)<- {
            _r1_:compute_vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
            _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
            _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
            _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT, _r10_:delta_tuples}
        else ()))
    ))

trigger insert_CUSTOMER_rcv_corrective_s0_m_QUERY3_mCUSTOMER4 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mCUSTOMER4_s0_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 0))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:0, _r3_:0}
        then
          bind log_get_bound_insert_CUSTOMER compute_vid as {_r1_:vid,
                                                             _r2_:CUSTOMER_CUSTKEY,
                                                             _r3_:CUSTOMER_NAME,
                                                             _r4_:CUSTOMER_ADDRESS,
                                                             _r5_:CUSTOMER_NATIONKEY,
                                                             _r6_:CUSTOMER_PHONE,
                                                             _r7_:CUSTOMER_ACCTBAL,
                                                             _r8_:CUSTOMER_MKTSEGMENT,
                                                             _r9_:CUSTOMER_COMMENT} in 
          (insert_CUSTOMER_do_corrective_s0_m_QUERY3_mCUSTOMER4, me)<- {
            _r1_:compute_vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
            _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
            _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
            _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT, _r10_:delta_tuples}
        else ()))
    ))

trigger insert_CUSTOMER_rcv_corrective_s1_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf
      {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 1))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:1, _r3_:0}
        then
          bind log_get_bound_insert_CUSTOMER compute_vid as {_r1_:vid,
                                                             _r2_:CUSTOMER_CUSTKEY,
                                                             _r3_:CUSTOMER_NAME,
                                                             _r4_:CUSTOMER_ADDRESS,
                                                             _r5_:CUSTOMER_NATIONKEY,
                                                             _r6_:CUSTOMER_PHONE,
                                                             _r7_:CUSTOMER_ACCTBAL,
                                                             _r8_:CUSTOMER_MKTSEGMENT,
                                                             _r9_:CUSTOMER_COMMENT} in 
          (insert_CUSTOMER_do_corrective_s1_m_QUERY3_mLINEITEM1_mCUSTOMER2, me)<- {
            _r1_:compute_vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
            _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
            _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
            _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT, _r10_:delta_tuples}
        else ()))
    ))

trigger insert_CUSTOMER_do_corrective_s0_m_QUERY3_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string, _r10_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real } @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                  _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                  _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                  _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT,
                  _r10_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ORDERS_ORDERKEY,
                      _r3_:delta_ORDERS_ORDERDATE,
                      _r4_:delta_ORDERS_SHIPPRIORITY,
                      _r5_:delta_QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
                      _r6_:delta_QUERY3_mCUSTOMER2} in 
        let existing_out_tier = QUERY3 in
        let __prod_ret__149 =
          ((if CUSTOMER_CUSTKEY == delta_QUERY3_mCUSTOMERCUSTOMER_CUSTKEY
            then 1
            else 0) * if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0) *
          -delta_QUERY3_mCUSTOMER2 in (
          cond_add_delta_to_QUERY3
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:real |
             {_r1_:vid, _r2_:delta_ORDERS_ORDERKEY,
              _r3_:delta_ORDERS_ORDERDATE, _r4_:delta_ORDERS_SHIPPRIORITY,
              _r5_:__prod_ret__149}|} @ { Set }}
          ))))

trigger insert_CUSTOMER_do_corrective_s0_m_QUERY3_mCUSTOMER4 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string, _r10_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real } @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                  _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                  _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                  _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT,
                  _r10_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ORDERS_ORDERKEY,
                      _r3_:delta_ORDERS_ORDERDATE,
                      _r4_:delta_ORDERS_SHIPPRIORITY,
                      _r5_:delta_QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
                      _r6_:delta_QUERY3_mCUSTOMER4} in 
        let existing_out_tier = QUERY3 in
        let __prod_ret__151 =
          ((if CUSTOMER_CUSTKEY == delta_QUERY3_mCUSTOMERCUSTOMER_CUSTKEY
            then 1
            else 0) * if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0) *
          delta_QUERY3_mCUSTOMER4 in (
          cond_add_delta_to_QUERY3
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:real |
             {_r1_:vid, _r2_:delta_ORDERS_ORDERKEY,
              _r3_:delta_ORDERS_ORDERDATE, _r4_:delta_ORDERS_SHIPPRIORITY,
              _r5_:__prod_ret__151}|} @ { Set }}
          ))))

trigger insert_CUSTOMER_do_corrective_s1_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string, _r10_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                  _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                  _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                  _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT,
                  _r10_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                      _r3_:delta_ORDERS_ORDERDATE,
                      _r4_:delta_ORDERS_SHIPPRIORITY,
                      _r5_:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
                      _r6_:delta_QUERY3_mLINEITEM1_mCUSTOMER2} in 
        let existing_out_tier = QUERY3_mLINEITEM1 in
        let __prod_ret__153 =
          ((if CUSTOMER_CUSTKEY ==
              delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY
            then 1
            else 0) * if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0) *
          delta_QUERY3_mLINEITEM1_mCUSTOMER2 in (
          cond_add_delta_to_QUERY3_mLINEITEM1
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int |
             {_r1_:vid, _r2_:delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY,
              _r3_:delta_ORDERS_ORDERDATE, _r4_:delta_ORDERS_SHIPPRIORITY,
              _r5_:__prod_ret__153}|} @ { Set }};
          (QUERY3_mLINEITEM1_send_correctives, me)<- {key:vid, value:{|
                                                      _r1_:{
                                                      _r1_:int, _r2_:int,
                                                      _r3_:int }, _r2_:int,
                                                      _r3_:int, _r4_:int,
                                                      _r5_:int |
                                                      {_r1_:vid,
                                                       _r2_:delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                                                       _r3_:delta_ORDERS_ORDERDATE,
                                                       _r4_:delta_ORDERS_SHIPPRIORITY,
                                                       _r5_:__prod_ret__153}|} @ { Set }}
          ))))

trigger delete_CUSTOMER : {
_r1_:int, _r2_:string, _r3_:string, _r4_:int, _r5_:string, _r6_:real,
_r7_:string, _r8_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:CUSTOMER_CUSTKEY, _r2_:CUSTOMER_NAME,
                _r3_:CUSTOMER_ADDRESS, _r4_:CUSTOMER_NATIONKEY,
                _r5_:CUSTOMER_PHONE, _r6_:CUSTOMER_ACCTBAL,
                _r7_:CUSTOMER_MKTSEGMENT, _r8_:CUSTOMER_COMMENT} in (
    let vid =
      {_r1_:case (__epoch__.peek ()) of { Some x -> x.i } { None -> error () },
       _r2_:case (__vid_counter__.peek ()) of { Some x -> x.i }
       { None -> error () }, _r3_:hash me} in
    (
      (delete_CUSTOMER_send_fetch, me)<- {_r1_:vid, _r2_:CUSTOMER_CUSTKEY,
                                          _r3_:CUSTOMER_NAME,
                                          _r4_:CUSTOMER_ADDRESS,
                                          _r5_:CUSTOMER_NATIONKEY,
                                          _r6_:CUSTOMER_PHONE,
                                          _r7_:CUSTOMER_ACCTBAL,
                                          _r8_:CUSTOMER_MKTSEGMENT,
                                          _r9_:CUSTOMER_COMMENT};
      __vid_counter__.update
        ({i:case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
        ({i:1 + case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
      )
    ))

trigger delete_CUSTOMER_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT} in (
    (route_to_QUERY3_mORDERS1 (Some CUSTOMER_CUSTKEY)).iterate
      ((\_b1_ -> 
        bind _b1_ as {i:ip} in 
        (delete_CUSTOMER_do_complete_s5, ip)<- {_r1_:vid,
                                                _r2_:CUSTOMER_CUSTKEY,
                                                _r3_:CUSTOMER_NAME,
                                                _r4_:CUSTOMER_ADDRESS,
                                                _r5_:CUSTOMER_NATIONKEY,
                                                _r6_:CUSTOMER_PHONE,
                                                _r7_:CUSTOMER_ACCTBAL,
                                                _r8_:CUSTOMER_MKTSEGMENT,
                                                _r9_:CUSTOMER_COMMENT}));
    ((((empty {
        _r1_:address, _r2_:int, _r3_:int
        } @ { Collection }).combine
        (let sender_count =
           (route_to_QUERY3_mCUSTOMER4
              {_r1_:None immut, _r2_:None immut, _r3_:None immut,
               _r4_:Some CUSTOMER_CUSTKEY}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mCUSTOMER4_QUERY3_0t0_1t1_2t2
            {_r1_:{_r1_:None immut, _r2_:None immut, _r3_:None immut},
             _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:real } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:3, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mCUSTOMER2
              {_r1_:None immut, _r2_:None immut, _r3_:None immut,
               _r4_:Some CUSTOMER_CUSTKEY}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mCUSTOMER2_QUERY3_0t0_1t1_2t2
            {_r1_:{_r1_:None immut, _r2_:None immut, _r3_:None immut},
             _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:real } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:3, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mLINEITEM1_mCUSTOMER2
              {_r1_:None immut, _r2_:None immut, _r3_:None immut,
               _r4_:Some CUSTOMER_CUSTKEY}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mLINEITEM1_0t0_1t1_2t2
           {_r1_:{_r1_:None immut, _r2_:None immut, _r3_:None immut},
            _r2_:empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
            _r4_:int, _r5_:int, _r6_:int } @ { Set }, _r3_:true}).map
          ((\_b1_ -> 
            bind _b1_ as {key:ip, value:tuples} in 
            {_r1_:ip, _r2_:4, _r3_:sender_count})))))).groupBy
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in 
          {key:ip, value:stmt_id})) ((\acc -> (\_b3_ -> 
          bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupBy
       ((\_b1_ -> 
         bind _b1_ as {key:_b2_, value:count} in 
         bind _b2_ as {key:ip, value:stmt_id} in ip)) ((\acc -> (\_b3_ -> 
         bind _b3_ as {key:ip_and_stmt_id, value:count} in 
         bind ip_and_stmt_id as {key:ip, value:stmt_id} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:count}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_id_cnt_list} in (
          (delete_CUSTOMER_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list,
                                           _r3_:vid, _r4_:CUSTOMER_CUSTKEY,
                                           _r5_:CUSTOMER_NAME,
                                           _r6_:CUSTOMER_ADDRESS,
                                           _r7_:CUSTOMER_NATIONKEY,
                                           _r8_:CUSTOMER_PHONE,
                                           _r9_:CUSTOMER_ACCTBAL,
                                           _r10_:CUSTOMER_MKTSEGMENT,
                                           _r11_:CUSTOMER_COMMENT}
          )));
    ((((route_to_QUERY3_mLINEITEM1_mCUSTOMER2
          {_r1_:None immut, _r2_:None immut, _r3_:None immut,
           _r4_:Some CUSTOMER_CUSTKEY}).map
         ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:4, _r2_:3, _r3_:ip}))).combine
       (((route_to_QUERY3_mCUSTOMER4
            {_r1_:None immut, _r2_:None immut, _r3_:None immut,
             _r4_:Some CUSTOMER_CUSTKEY}).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:3, _r2_:8, _r3_:ip}))).combine
       (((route_to_QUERY3_mCUSTOMER2
            {_r1_:None immut, _r2_:None immut, _r3_:None immut,
             _r4_:Some CUSTOMER_CUSTKEY}).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:3, _r2_:7, _r3_:ip}))).combine
       empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection }))).groupBy
       ((\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip))
       ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:map_id}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_map_ids} in 
        (delete_CUSTOMER_rcv_fetch, ip)<- {_r1_:stmt_map_ids, _r2_:vid,
                                           _r3_:CUSTOMER_CUSTKEY,
                                           _r4_:CUSTOMER_NAME,
                                           _r5_:CUSTOMER_ADDRESS,
                                           _r6_:CUSTOMER_NATIONKEY,
                                           _r7_:CUSTOMER_PHONE,
                                           _r8_:CUSTOMER_ACCTBAL,
                                           _r9_:CUSTOMER_MKTSEGMENT,
                                           _r10_:CUSTOMER_COMMENT}))
    ))

trigger delete_CUSTOMER_rcv_put : {
_r1_:address, _r2_:collection { key:int, value:int } @ { Set }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:string, _r6_:string, _r7_:int,
_r8_:string, _r9_:real, _r10_:string, _r11_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid,
                _r4_:CUSTOMER_CUSTKEY, _r5_:CUSTOMER_NAME,
                _r6_:CUSTOMER_ADDRESS, _r7_:CUSTOMER_NATIONKEY,
                _r8_:CUSTOMER_PHONE, _r9_:CUSTOMER_ACCTBAL,
                _r10_:CUSTOMER_MKTSEGMENT, _r11_:CUSTOMER_COMMENT} in (
    stmt_id_cnt_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:count} in 
        if __stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:_, _r2_:_, _r3_:old_count} in 
          let new_count = old_count + count in (
            __stmt_cntrs__.update
              {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
              {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
            if new_count == 0
            then
              if stmt_id == 5
              then
                (delete_CUSTOMER_do_complete_s5, me)<- {_r1_:vid,
                                                        _r2_:CUSTOMER_CUSTKEY,
                                                        _r3_:CUSTOMER_NAME,
                                                        _r4_:CUSTOMER_ADDRESS,
                                                        _r5_:CUSTOMER_NATIONKEY,
                                                        _r6_:CUSTOMER_PHONE,
                                                        _r7_:CUSTOMER_ACCTBAL,
                                                        _r8_:CUSTOMER_MKTSEGMENT,
                                                        _r9_:CUSTOMER_COMMENT}
              else
                if stmt_id == 4
                then
                  (delete_CUSTOMER_do_complete_s4, me)<- {_r1_:vid,
                                                          _r2_:CUSTOMER_CUSTKEY,
                                                          _r3_:CUSTOMER_NAME,
                                                          _r4_:CUSTOMER_ADDRESS,
                                                          _r5_:CUSTOMER_NATIONKEY,
                                                          _r6_:CUSTOMER_PHONE,
                                                          _r7_:CUSTOMER_ACCTBAL,
                                                          _r8_:CUSTOMER_MKTSEGMENT,
                                                          _r9_:CUSTOMER_COMMENT}
                else
                  if stmt_id == 3
                  then
                    (delete_CUSTOMER_do_complete_s3, me)<- {_r1_:vid,
                                                            _r2_:CUSTOMER_CUSTKEY,
                                                            _r3_:CUSTOMER_NAME,
                                                            _r4_:CUSTOMER_ADDRESS,
                                                            _r5_:CUSTOMER_NATIONKEY,
                                                            _r6_:CUSTOMER_PHONE,
                                                            _r7_:CUSTOMER_ACCTBAL,
                                                            _r8_:CUSTOMER_MKTSEGMENT,
                                                            _r9_:CUSTOMER_COMMENT}
                  else ()
            else ()
            )
        else __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count}))
    ))

trigger delete_CUSTOMER_rcv_fetch : {
_r1_:collection { key:int, value:int } @ { Set }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:string, _r5_:string, _r6_:int,
_r7_:string, _r8_:real, _r9_:string, _r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:CUSTOMER_CUSTKEY,
                _r4_:CUSTOMER_NAME, _r5_:CUSTOMER_ADDRESS,
                _r6_:CUSTOMER_NATIONKEY, _r7_:CUSTOMER_PHONE,
                _r8_:CUSTOMER_ACCTBAL, _r9_:CUSTOMER_MKTSEGMENT,
                _r10_:CUSTOMER_COMMENT} in (
    log_write_delete_CUSTOMER
      {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
       _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY, _r6_:CUSTOMER_PHONE,
       _r7_:CUSTOMER_ACCTBAL, _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT};
    stmts_and_map_ids.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:map_id} in 
        if stmt_id == 3
        then
          if map_id == 7
          then
            (delete_CUSTOMER_send_push_s3_m_QUERY3_mCUSTOMER2, me)<- {
              _r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
              _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
              _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
              _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT}
          else
            if map_id == 8
            then
              (delete_CUSTOMER_send_push_s3_m_QUERY3_mCUSTOMER4, me)<- {
                _r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT}
            else ()
        else
          if stmt_id == 4
          then
            if map_id == 3
            then
              (delete_CUSTOMER_send_push_s4_m_QUERY3_mLINEITEM1_mCUSTOMER2, me)<- {
                _r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT}
            else ()
          else ()))
    ))

trigger delete_CUSTOMER_send_push_s3_m_QUERY3_mCUSTOMER4 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:1, _r3_:3};
    (shuffle_QUERY3_mCUSTOMER4_QUERY3_0t0_1t1_2t2
       {_r1_:{_r1_:None immut, _r2_:None immut, _r3_:None immut},
        _r2_:((QUERY3_mCUSTOMER4.filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                                _r5_:_r5_, _r6_:_r6_} in _r5_ ==
                  CUSTOMER_CUSTKEY))).groupBy
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
                ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  if vid_lt {key:map_vid, value:vid}
                  then
                    if vid_eq {key:map_vid, value:max_vid}
                    then
                      {key:({|
                       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                       _r3_:int, _r4_:int, _r5_:int, _r6_:real |
                       {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                        _r5_:__map_3, _r6_:__map_val}|} @ { Set }).combine 
                       acc, value:max_vid}
                    else
                      if vid_gt {key:map_vid, value:max_vid}
                      then
                        {key:{|
                         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                         _r3_:int, _r4_:int, _r5_:int, _r6_:real |
                         {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                          _r4_:__map_2, _r5_:__map_3, _r6_:__map_val}|} @ { Set },
                         value:map_vid}
                      else {key:acc, value:max_vid}
                  else {key:acc, value:max_vid})))
                {key:empty {
                 _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                 _r4_:int, _r5_:int, _r6_:real } @ { Set },
                 value:{_r1_:0, _r2_:0, _r3_:0}}).ext
               ((\_b1_ -> 
                 bind _b1_ as {key:_, value:_b2_} in 
                 bind _b2_ as {key:project, value:_} in project)) empty {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
               _r4_:int, _r5_:int, _r6_:real } @ { Collection }, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_CUSTOMER_rcv_push_s3_m_QUERY3_mCUSTOMER4, ip)<- {_r1_:tuples,
                                                                 _r2_:vid,
                                                                 _r3_:CUSTOMER_CUSTKEY,
                                                                 _r4_:CUSTOMER_NAME,
                                                                 _r5_:CUSTOMER_ADDRESS,
                                                                 _r6_:CUSTOMER_NATIONKEY,
                                                                 _r7_:CUSTOMER_PHONE,
                                                                 _r8_:CUSTOMER_ACCTBAL,
                                                                 _r9_:CUSTOMER_MKTSEGMENT,
                                                                 _r10_:CUSTOMER_COMMENT}))
    ))

trigger delete_CUSTOMER_send_push_s3_m_QUERY3_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:1, _r3_:3};
    (shuffle_QUERY3_mCUSTOMER2_QUERY3_0t0_1t1_2t2
       {_r1_:{_r1_:None immut, _r2_:None immut, _r3_:None immut},
        _r2_:((QUERY3_mCUSTOMER2.filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                                _r5_:_r5_, _r6_:_r6_} in _r5_ ==
                  CUSTOMER_CUSTKEY))).groupBy
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
                ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  if vid_lt {key:map_vid, value:vid}
                  then
                    if vid_eq {key:map_vid, value:max_vid}
                    then
                      {key:({|
                       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                       _r3_:int, _r4_:int, _r5_:int, _r6_:real |
                       {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                        _r5_:__map_3, _r6_:__map_val}|} @ { Set }).combine 
                       acc, value:max_vid}
                    else
                      if vid_gt {key:map_vid, value:max_vid}
                      then
                        {key:{|
                         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                         _r3_:int, _r4_:int, _r5_:int, _r6_:real |
                         {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                          _r4_:__map_2, _r5_:__map_3, _r6_:__map_val}|} @ { Set },
                         value:map_vid}
                      else {key:acc, value:max_vid}
                  else {key:acc, value:max_vid})))
                {key:empty {
                 _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                 _r4_:int, _r5_:int, _r6_:real } @ { Set },
                 value:{_r1_:0, _r2_:0, _r3_:0}}).ext
               ((\_b1_ -> 
                 bind _b1_ as {key:_, value:_b2_} in 
                 bind _b2_ as {key:project, value:_} in project)) empty {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
               _r4_:int, _r5_:int, _r6_:real } @ { Collection }, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_CUSTOMER_rcv_push_s3_m_QUERY3_mCUSTOMER2, ip)<- {_r1_:tuples,
                                                                 _r2_:vid,
                                                                 _r3_:CUSTOMER_CUSTKEY,
                                                                 _r4_:CUSTOMER_NAME,
                                                                 _r5_:CUSTOMER_ADDRESS,
                                                                 _r6_:CUSTOMER_NATIONKEY,
                                                                 _r7_:CUSTOMER_PHONE,
                                                                 _r8_:CUSTOMER_ACCTBAL,
                                                                 _r9_:CUSTOMER_MKTSEGMENT,
                                                                 _r10_:CUSTOMER_COMMENT}))
    ))

trigger delete_CUSTOMER_send_push_s4_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:1, _r3_:4};
    (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mLINEITEM1_0t0_1t1_2t2
       {_r1_:{_r1_:None immut, _r2_:None immut, _r3_:None immut},
        _r2_:((QUERY3_mLINEITEM1_mCUSTOMER2.filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                                _r5_:_r5_, _r6_:_r6_} in _r5_ ==
                  CUSTOMER_CUSTKEY))).groupBy
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
                ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  if vid_lt {key:map_vid, value:vid}
                  then
                    if vid_eq {key:map_vid, value:max_vid}
                    then
                      {key:({|
                       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                       _r3_:int, _r4_:int, _r5_:int, _r6_:int |
                       {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                        _r5_:__map_3, _r6_:__map_val}|} @ { Set }).combine 
                       acc, value:max_vid}
                    else
                      if vid_gt {key:map_vid, value:max_vid}
                      then
                        {key:{|
                         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                         _r3_:int, _r4_:int, _r5_:int, _r6_:int |
                         {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                          _r4_:__map_2, _r5_:__map_3, _r6_:__map_val}|} @ { Set },
                         value:map_vid}
                      else {key:acc, value:max_vid}
                  else {key:acc, value:max_vid})))
                {key:empty {
                 _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                 _r4_:int, _r5_:int, _r6_:int } @ { Set },
                 value:{_r1_:0, _r2_:0, _r3_:0}}).ext
               ((\_b1_ -> 
                 bind _b1_ as {key:_, value:_b2_} in 
                 bind _b2_ as {key:project, value:_} in project)) empty {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
               _r4_:int, _r5_:int, _r6_:int } @ { Collection }, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_CUSTOMER_rcv_push_s4_m_QUERY3_mLINEITEM1_mCUSTOMER2, ip)<- {
          _r1_:tuples, _r2_:vid, _r3_:CUSTOMER_CUSTKEY, _r4_:CUSTOMER_NAME,
          _r5_:CUSTOMER_ADDRESS, _r6_:CUSTOMER_NATIONKEY, _r7_:CUSTOMER_PHONE,
          _r8_:CUSTOMER_ACCTBAL, _r9_:CUSTOMER_MKTSEGMENT,
          _r10_:CUSTOMER_COMMENT}))
    ))

trigger delete_CUSTOMER_rcv_push_s3_m_QUERY3_mCUSTOMER2 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real } @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int,
_r4_:string, _r5_:string, _r6_:int, _r7_:string, _r8_:real, _r9_:string,
_r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:CUSTOMER_CUSTKEY,
                _r4_:CUSTOMER_NAME, _r5_:CUSTOMER_ADDRESS,
                _r6_:CUSTOMER_NATIONKEY, _r7_:CUSTOMER_PHONE,
                _r8_:CUSTOMER_ACCTBAL, _r9_:CUSTOMER_MKTSEGMENT,
                _r10_:CUSTOMER_COMMENT} in (
    log_write_delete_CUSTOMER
      {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
       _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY, _r6_:CUSTOMER_PHONE,
       _r7_:CUSTOMER_ACCTBAL, _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mCUSTOMER2_s3_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                          _r5_:_r5_, _r6_:_r6_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                           _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
            (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3) and
            _r3_ == __temp_2) and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
          _r5_:int, _r6_:real } @ { Set }
        then
          map_QUERY3_mCUSTOMER2_s3_buf.update
            (case ((map_QUERY3_mCUSTOMER2_s3_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_, _r6_:_r6_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                             _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
              (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3)
              and _r3_ == __temp_2) and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mCUSTOMER2_s3_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 3)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 3))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 3))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:3, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 3))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:3, _r3_:0}
        then
          (delete_CUSTOMER_do_complete_s3, me)<- {_r1_:vid,
                                                  _r2_:CUSTOMER_CUSTKEY,
                                                  _r3_:CUSTOMER_NAME,
                                                  _r4_:CUSTOMER_ADDRESS,
                                                  _r5_:CUSTOMER_NATIONKEY,
                                                  _r6_:CUSTOMER_PHONE,
                                                  _r7_:CUSTOMER_ACCTBAL,
                                                  _r8_:CUSTOMER_MKTSEGMENT,
                                                  _r9_:CUSTOMER_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:3, _r3_:-1}
    ))

trigger delete_CUSTOMER_rcv_push_s3_m_QUERY3_mCUSTOMER4 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real } @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int,
_r4_:string, _r5_:string, _r6_:int, _r7_:string, _r8_:real, _r9_:string,
_r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:CUSTOMER_CUSTKEY,
                _r4_:CUSTOMER_NAME, _r5_:CUSTOMER_ADDRESS,
                _r6_:CUSTOMER_NATIONKEY, _r7_:CUSTOMER_PHONE,
                _r8_:CUSTOMER_ACCTBAL, _r9_:CUSTOMER_MKTSEGMENT,
                _r10_:CUSTOMER_COMMENT} in (
    log_write_delete_CUSTOMER
      {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
       _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY, _r6_:CUSTOMER_PHONE,
       _r7_:CUSTOMER_ACCTBAL, _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mCUSTOMER4_s3_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                          _r5_:_r5_, _r6_:_r6_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                           _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
            (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3) and
            _r3_ == __temp_2) and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
          _r5_:int, _r6_:real } @ { Set }
        then
          map_QUERY3_mCUSTOMER4_s3_buf.update
            (case ((map_QUERY3_mCUSTOMER4_s3_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_, _r6_:_r6_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                             _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
              (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3)
              and _r3_ == __temp_2) and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mCUSTOMER4_s3_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 3)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 3))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 3))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:3, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 3))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:3, _r3_:0}
        then
          (delete_CUSTOMER_do_complete_s3, me)<- {_r1_:vid,
                                                  _r2_:CUSTOMER_CUSTKEY,
                                                  _r3_:CUSTOMER_NAME,
                                                  _r4_:CUSTOMER_ADDRESS,
                                                  _r5_:CUSTOMER_NATIONKEY,
                                                  _r6_:CUSTOMER_PHONE,
                                                  _r7_:CUSTOMER_ACCTBAL,
                                                  _r8_:CUSTOMER_MKTSEGMENT,
                                                  _r9_:CUSTOMER_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:3, _r3_:-1}
    ))

trigger delete_CUSTOMER_rcv_push_s4_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int,
_r4_:string, _r5_:string, _r6_:int, _r7_:string, _r8_:real, _r9_:string,
_r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:CUSTOMER_CUSTKEY,
                _r4_:CUSTOMER_NAME, _r5_:CUSTOMER_ADDRESS,
                _r6_:CUSTOMER_NATIONKEY, _r7_:CUSTOMER_PHONE,
                _r8_:CUSTOMER_ACCTBAL, _r9_:CUSTOMER_MKTSEGMENT,
                _r10_:CUSTOMER_COMMENT} in (
    log_write_delete_CUSTOMER
      {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
       _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY, _r6_:CUSTOMER_PHONE,
       _r7_:CUSTOMER_ACCTBAL, _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                          _r5_:_r5_, _r6_:_r6_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                           _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
            (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3) and
            _r3_ == __temp_2) and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
          _r5_:int, _r6_:int } @ { Set }
        then
          map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf.update
            (case ((map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_, _r6_:_r6_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                             _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
              (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3)
              and _r3_ == __temp_2) and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 4)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 4))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 4))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:4, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 4))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:4, _r3_:0}
        then
          (delete_CUSTOMER_do_complete_s4, me)<- {_r1_:vid,
                                                  _r2_:CUSTOMER_CUSTKEY,
                                                  _r3_:CUSTOMER_NAME,
                                                  _r4_:CUSTOMER_ADDRESS,
                                                  _r5_:CUSTOMER_NATIONKEY,
                                                  _r6_:CUSTOMER_PHONE,
                                                  _r7_:CUSTOMER_ACCTBAL,
                                                  _r8_:CUSTOMER_MKTSEGMENT,
                                                  _r9_:CUSTOMER_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:4, _r3_:-1}
    ))

trigger delete_CUSTOMER_do_complete_s3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                  _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                  _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                  _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT} in 
    let existing_out_tier = QUERY3 in
    let __delta_values__ =
      (((((map_QUERY3_mCUSTOMER2_s3_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_, _r6_:_r6_} in _r5_ == CUSTOMER_CUSTKEY))).groupBy
            ((\_b1_ -> 
              bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                            _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
              {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
            ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
              bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                            _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
              if vid_lt {key:map_vid, value:vid}
              then
                if vid_eq {key:map_vid, value:max_vid}
                then
                  {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real |
                   {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                    _r5_:__map_val}|} @ { Set }).combine acc, value:max_vid}
                else
                  if vid_gt {key:map_vid, value:max_vid}
                  then
                    {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real |
                     {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                      _r5_:__map_val}|} @ { Set }, value:map_vid}
                  else {key:acc, value:max_vid}
              else {key:acc, value:max_vid})))
            {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
             } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}}).ext
           ((\_b1_ -> 
             bind _b1_ as {key:_, value:_b2_} in 
             bind _b2_ as {key:project, value:_} in project)) empty {
           _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real } @ { Collection }).map
          ((\_b1_ -> 
            bind _b1_ as {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
                          _r3_:ORDERS_SHIPPRIORITY, _r4_:CUSTOMER_CUSTKEY,
                          _r5_:__map_ret__4} in 
            {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
             _r3_:ORDERS_SHIPPRIORITY, _r4_:__map_ret__4}))).combine
        (((((map_QUERY3_mCUSTOMER4_s3_buf.filter
              ((\_b1_ -> 
                bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                              _r5_:_r5_, _r6_:_r6_} in _r5_ == CUSTOMER_CUSTKEY))).groupBy
              ((\_b1_ -> 
                bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                              _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
              ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                              _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                if vid_lt {key:map_vid, value:vid}
                then
                  if vid_eq {key:map_vid, value:max_vid}
                  then
                    {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                     |
                     {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                      _r5_:__map_val}|} @ { Set }).combine acc, value:max_vid}
                  else
                    if vid_gt {key:map_vid, value:max_vid}
                    then
                      {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
                       |
                       {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                        _r5_:__map_val}|} @ { Set }, value:map_vid}
                    else {key:acc, value:max_vid}
                else {key:acc, value:max_vid})))
              {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
               } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}}).ext
             ((\_b1_ -> 
               bind _b1_ as {key:_, value:_b2_} in 
               bind _b2_ as {key:project, value:_} in project)) empty {
             _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real
             } @ { Collection }).map
            ((\_b1_ -> 
              bind _b1_ as {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
                            _r3_:ORDERS_SHIPPRIORITY, _r4_:CUSTOMER_CUSTKEY,
                            _r5_:__map_ret__5} in 
              {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
               _r3_:ORDERS_SHIPPRIORITY, _r4_:__map_ret__5}))).map
           ((\_b1_ -> 
             bind _b1_ as {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
                           _r3_:ORDERS_SHIPPRIORITY, _r4_:__map_ret__5} in 
             {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
              _r3_:ORDERS_SHIPPRIORITY, _r4_:__map_ret__5 * -1})))).map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
                        _r3_:ORDERS_SHIPPRIORITY, _r4_:__sum_ret__2} in 
          {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
           _r3_:ORDERS_SHIPPRIORITY, _r4_:__sum_ret__2 *
           if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0})) in
    let __delta_with_vid__ =
      __delta_values__.map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_ORDERDATE,
                        _r3_:ORDERS_SHIPPRIORITY, _r4_:__prod_ret__5} in 
          {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
           _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__5})) in (
      add_delta_to_QUERY3 {key:vid, value:__delta_with_vid__} ))

trigger delete_CUSTOMER_do_complete_s4 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                  _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                  _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                  _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT} in 
    let existing_out_tier = QUERY3_mLINEITEM1 in
    let __delta_values__ =
      (((((map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_, _r6_:_r6_} in _r5_ == CUSTOMER_CUSTKEY))).groupBy
            ((\_b1_ -> 
              bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                            _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
              {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
            ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
              bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                            _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
              if vid_lt {key:map_vid, value:vid}
              then
                if vid_eq {key:map_vid, value:max_vid}
                then
                  {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                   {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                    _r5_:__map_val}|} @ { Set }).combine acc, value:max_vid}
                else
                  if vid_gt {key:map_vid, value:max_vid}
                  then
                    {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                     {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                      _r5_:__map_val}|} @ { Set }, value:map_vid}
                  else {key:acc, value:max_vid}
              else {key:acc, value:max_vid})))
            {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
             } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}}).ext
           ((\_b1_ -> 
             bind _b1_ as {key:_, value:_b2_} in 
             bind _b2_ as {key:project, value:_} in project)) empty {
           _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int } @ { Collection }).map
          ((\_b1_ -> 
            bind _b1_ as {_r1_:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                          _r2_:ORDERS_ORDERDATE, _r3_:ORDERS_SHIPPRIORITY,
                          _r4_:CUSTOMER_CUSTKEY, _r5_:__map_ret__6} in 
            {_r1_:QUERY3_mLINEITEMLINEITEM_ORDERKEY, _r2_:ORDERS_ORDERDATE,
             _r3_:ORDERS_SHIPPRIORITY, _r4_:__map_ret__6}))).map
         ((\_b1_ -> 
           bind _b1_ as {_r1_:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                         _r2_:ORDERS_ORDERDATE, _r3_:ORDERS_SHIPPRIORITY,
                         _r4_:__map_ret__6} in 
           {_r1_:QUERY3_mLINEITEMLINEITEM_ORDERKEY, _r2_:ORDERS_ORDERDATE,
            _r3_:ORDERS_SHIPPRIORITY, _r4_:__map_ret__6 *
            if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0}))).map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                        _r2_:ORDERS_ORDERDATE, _r3_:ORDERS_SHIPPRIORITY,
                        _r4_:__prod_ret__6} in 
          {_r1_:QUERY3_mLINEITEMLINEITEM_ORDERKEY, _r2_:ORDERS_ORDERDATE,
           _r3_:ORDERS_SHIPPRIORITY, _r4_:__prod_ret__6 * -1})) in
    let __delta_with_vid__ =
      __delta_values__.map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                        _r2_:ORDERS_ORDERDATE, _r3_:ORDERS_SHIPPRIORITY,
                        _r4_:__prod_ret__7} in 
          {_r1_:vid, _r2_:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
           _r3_:ORDERS_ORDERDATE, _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__7}))
      in (
      add_delta_to_QUERY3_mLINEITEM1 {key:vid, value:__delta_with_vid__};
      (QUERY3_mLINEITEM1_send_correctives, me)<- {key:vid,
                                                  value:__delta_with_vid__}
      ))

trigger delete_CUSTOMER_do_complete_s5 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                  _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                  _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                  _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT} in 
    let existing_out_tier = QUERY3_mORDERS1 in
    let __prod_ret__8 = (if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0) *
      -1 in (
      add_delta_to_QUERY3_mORDERS1
        {key:vid, value:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:__prod_ret__8}|} @ { Set }};
      (QUERY3_mORDERS1_send_correctives, me)<- {key:vid, value:{|
                                                _r1_:{
                                                _r1_:int, _r2_:int, _r3_:int },
                                                _r2_:int, _r3_:int |
                                                {_r1_:vid,
                                                 _r2_:CUSTOMER_CUSTKEY,
                                                 _r3_:__prod_ret__8}|} @ { Set }}
      ))

trigger delete_CUSTOMER_rcv_corrective_s3_m_QUERY3_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mCUSTOMER2_s3_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 3))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:3, _r3_:0}
        then
          bind log_get_bound_delete_CUSTOMER compute_vid as {_r1_:vid,
                                                             _r2_:CUSTOMER_CUSTKEY,
                                                             _r3_:CUSTOMER_NAME,
                                                             _r4_:CUSTOMER_ADDRESS,
                                                             _r5_:CUSTOMER_NATIONKEY,
                                                             _r6_:CUSTOMER_PHONE,
                                                             _r7_:CUSTOMER_ACCTBAL,
                                                             _r8_:CUSTOMER_MKTSEGMENT,
                                                             _r9_:CUSTOMER_COMMENT} in 
          (delete_CUSTOMER_do_corrective_s3_m_QUERY3_mCUSTOMER2, me)<- {
            _r1_:compute_vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
            _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
            _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
            _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT, _r10_:delta_tuples}
        else ()))
    ))

trigger delete_CUSTOMER_rcv_corrective_s3_m_QUERY3_mCUSTOMER4 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mCUSTOMER4_s3_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 3))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:3, _r3_:0}
        then
          bind log_get_bound_delete_CUSTOMER compute_vid as {_r1_:vid,
                                                             _r2_:CUSTOMER_CUSTKEY,
                                                             _r3_:CUSTOMER_NAME,
                                                             _r4_:CUSTOMER_ADDRESS,
                                                             _r5_:CUSTOMER_NATIONKEY,
                                                             _r6_:CUSTOMER_PHONE,
                                                             _r7_:CUSTOMER_ACCTBAL,
                                                             _r8_:CUSTOMER_MKTSEGMENT,
                                                             _r9_:CUSTOMER_COMMENT} in 
          (delete_CUSTOMER_do_corrective_s3_m_QUERY3_mCUSTOMER4, me)<- {
            _r1_:compute_vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
            _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
            _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
            _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT, _r10_:delta_tuples}
        else ()))
    ))

trigger delete_CUSTOMER_rcv_corrective_s4_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf
      {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 4))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:4, _r3_:0}
        then
          bind log_get_bound_delete_CUSTOMER compute_vid as {_r1_:vid,
                                                             _r2_:CUSTOMER_CUSTKEY,
                                                             _r3_:CUSTOMER_NAME,
                                                             _r4_:CUSTOMER_ADDRESS,
                                                             _r5_:CUSTOMER_NATIONKEY,
                                                             _r6_:CUSTOMER_PHONE,
                                                             _r7_:CUSTOMER_ACCTBAL,
                                                             _r8_:CUSTOMER_MKTSEGMENT,
                                                             _r9_:CUSTOMER_COMMENT} in 
          (delete_CUSTOMER_do_corrective_s4_m_QUERY3_mLINEITEM1_mCUSTOMER2, me)<- {
            _r1_:compute_vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
            _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
            _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
            _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT, _r10_:delta_tuples}
        else ()))
    ))

trigger delete_CUSTOMER_do_corrective_s3_m_QUERY3_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string, _r10_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real } @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                  _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                  _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                  _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT,
                  _r10_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ORDERS_ORDERKEY,
                      _r3_:delta_ORDERS_ORDERDATE,
                      _r4_:delta_ORDERS_SHIPPRIORITY,
                      _r5_:delta_QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
                      _r6_:delta_QUERY3_mCUSTOMER2} in 
        let existing_out_tier = QUERY3 in
        let __prod_ret__155 =
          ((if CUSTOMER_CUSTKEY == delta_QUERY3_mCUSTOMERCUSTOMER_CUSTKEY
            then 1
            else 0) * if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0) *
          delta_QUERY3_mCUSTOMER2 in (
          cond_add_delta_to_QUERY3
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:real |
             {_r1_:vid, _r2_:delta_ORDERS_ORDERKEY,
              _r3_:delta_ORDERS_ORDERDATE, _r4_:delta_ORDERS_SHIPPRIORITY,
              _r5_:__prod_ret__155}|} @ { Set }}
          ))))

trigger delete_CUSTOMER_do_corrective_s3_m_QUERY3_mCUSTOMER4 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string, _r10_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real } @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                  _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                  _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                  _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT,
                  _r10_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ORDERS_ORDERKEY,
                      _r3_:delta_ORDERS_ORDERDATE,
                      _r4_:delta_ORDERS_SHIPPRIORITY,
                      _r5_:delta_QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
                      _r6_:delta_QUERY3_mCUSTOMER4} in 
        let existing_out_tier = QUERY3 in
        let __prod_ret__158 =
          ((if CUSTOMER_CUSTKEY == delta_QUERY3_mCUSTOMERCUSTOMER_CUSTKEY
            then 1
            else 0) * if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0) *
          -delta_QUERY3_mCUSTOMER4 in (
          cond_add_delta_to_QUERY3
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:real |
             {_r1_:vid, _r2_:delta_ORDERS_ORDERKEY,
              _r3_:delta_ORDERS_ORDERDATE, _r4_:delta_ORDERS_SHIPPRIORITY,
              _r5_:__prod_ret__158}|} @ { Set }}
          ))))

trigger delete_CUSTOMER_do_corrective_s4_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:string, _r4_:string,
_r5_:int, _r6_:string, _r7_:real, _r8_:string, _r9_:string, _r10_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                  _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                  _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                  _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT,
                  _r10_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                      _r3_:delta_ORDERS_ORDERDATE,
                      _r4_:delta_ORDERS_SHIPPRIORITY,
                      _r5_:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
                      _r6_:delta_QUERY3_mLINEITEM1_mCUSTOMER2} in 
        let existing_out_tier = QUERY3_mLINEITEM1 in
        let __prod_ret__161 =
          ((if CUSTOMER_CUSTKEY ==
              delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY
            then 1
            else 0) * if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0) *
          -delta_QUERY3_mLINEITEM1_mCUSTOMER2 in (
          cond_add_delta_to_QUERY3_mLINEITEM1
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int |
             {_r1_:vid, _r2_:delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY,
              _r3_:delta_ORDERS_ORDERDATE, _r4_:delta_ORDERS_SHIPPRIORITY,
              _r5_:__prod_ret__161}|} @ { Set }};
          (QUERY3_mLINEITEM1_send_correctives, me)<- {key:vid, value:{|
                                                      _r1_:{
                                                      _r1_:int, _r2_:int,
                                                      _r3_:int }, _r2_:int,
                                                      _r3_:int, _r4_:int,
                                                      _r5_:int |
                                                      {_r1_:vid,
                                                       _r2_:delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                                                       _r3_:delta_ORDERS_ORDERDATE,
                                                       _r4_:delta_ORDERS_SHIPPRIORITY,
                                                       _r5_:__prod_ret__161}|} @ { Set }}
          ))))

trigger insert_ORDERS : {
_r1_:int, _r2_:int, _r3_:string, _r4_:real, _r5_:int, _r6_:string, _r7_:string,
_r8_:int, _r9_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_CUSTKEY,
                _r3_:ORDERS_ORDERSTATUS, _r4_:ORDERS_TOTALPRICE,
                _r5_:ORDERS_ORDERDATE, _r6_:ORDERS_ORDERPRIORITY,
                _r7_:ORDERS_CLERK, _r8_:ORDERS_SHIPPRIORITY,
                _r9_:ORDERS_COMMENT} in (
    let vid =
      {_r1_:case (__epoch__.peek ()) of { Some x -> x.i } { None -> error () },
       _r2_:case (__vid_counter__.peek ()) of { Some x -> x.i }
       { None -> error () }, _r3_:hash me} in
    (
      (insert_ORDERS_send_fetch, me)<- {_r1_:vid, _r2_:ORDERS_ORDERKEY,
                                        _r3_:ORDERS_CUSTKEY,
                                        _r4_:ORDERS_ORDERSTATUS,
                                        _r5_:ORDERS_TOTALPRICE,
                                        _r6_:ORDERS_ORDERDATE,
                                        _r7_:ORDERS_ORDERPRIORITY,
                                        _r8_:ORDERS_CLERK,
                                        _r9_:ORDERS_SHIPPRIORITY,
                                        _r10_:ORDERS_COMMENT};
      __vid_counter__.update
        ({i:case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
        ({i:1 + case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
      )
    ))

trigger insert_ORDERS_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                _r10_:ORDERS_COMMENT} in (
    (route_to_QUERY3_mLINEITEM1_mCUSTOMER2
       {_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
        _r3_:Some ORDERS_SHIPPRIORITY, _r4_:Some ORDERS_CUSTKEY}).iterate
      ((\_b1_ -> 
        bind _b1_ as {i:ip} in 
        (insert_ORDERS_do_complete_s8, ip)<- {_r1_:vid, _r2_:ORDERS_ORDERKEY,
                                              _r3_:ORDERS_CUSTKEY,
                                              _r4_:ORDERS_ORDERSTATUS,
                                              _r5_:ORDERS_TOTALPRICE,
                                              _r6_:ORDERS_ORDERDATE,
                                              _r7_:ORDERS_ORDERPRIORITY,
                                              _r8_:ORDERS_CLERK,
                                              _r9_:ORDERS_SHIPPRIORITY,
                                              _r10_:ORDERS_COMMENT}));
    ((((empty {
        _r1_:address, _r2_:int, _r3_:int
        } @ { Collection }).combine
        (let sender_count =
           (route_to_QUERY3_mORDERS3 (Some ORDERS_ORDERKEY)).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mORDERS3_QUERY3_0t0
            {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
                   _r3_:Some ORDERS_SHIPPRIORITY}, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
             } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:6, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mORDERS1 (Some ORDERS_CUSTKEY)).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mORDERS1_QUERY3
            {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
                   _r3_:Some ORDERS_SHIPPRIORITY}, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:6, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mORDERS6 (Some ORDERS_ORDERKEY)).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mORDERS6_QUERY3_0t0
            {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
                   _r3_:Some ORDERS_SHIPPRIORITY}, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
             } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:6, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mORDERS1 (Some ORDERS_CUSTKEY)).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mORDERS1_QUERY3_mLINEITEM1
            {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
                   _r3_:Some ORDERS_SHIPPRIORITY}, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:7, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mORDERS3 (Some ORDERS_ORDERKEY)).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mORDERS3_QUERY3_mCUSTOMER2_0t0
            {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
                   _r3_:Some ORDERS_SHIPPRIORITY, _r4_:Some ORDERS_CUSTKEY},
             _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
             } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:9, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mORDERS6 (Some ORDERS_ORDERKEY)).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        (shuffle_QUERY3_mORDERS6_QUERY3_mCUSTOMER4_0t0
           {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
                  _r3_:Some ORDERS_SHIPPRIORITY, _r4_:Some ORDERS_CUSTKEY},
            _r2_:empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
            } @ { Set }, _r3_:true}).map
          ((\_b1_ -> 
            bind _b1_ as {key:ip, value:tuples} in 
            {_r1_:ip, _r2_:10, _r3_:sender_count}))))))))).groupBy
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in 
          {key:ip, value:stmt_id})) ((\acc -> (\_b3_ -> 
          bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupBy
       ((\_b1_ -> 
         bind _b1_ as {key:_b2_, value:count} in 
         bind _b2_ as {key:ip, value:stmt_id} in ip)) ((\acc -> (\_b3_ -> 
         bind _b3_ as {key:ip_and_stmt_id, value:count} in 
         bind ip_and_stmt_id as {key:ip, value:stmt_id} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:count}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_id_cnt_list} in (
          (insert_ORDERS_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list,
                                         _r3_:vid, _r4_:ORDERS_ORDERKEY,
                                         _r5_:ORDERS_CUSTKEY,
                                         _r6_:ORDERS_ORDERSTATUS,
                                         _r7_:ORDERS_TOTALPRICE,
                                         _r8_:ORDERS_ORDERDATE,
                                         _r9_:ORDERS_ORDERPRIORITY,
                                         _r10_:ORDERS_CLERK,
                                         _r11_:ORDERS_SHIPPRIORITY,
                                         _r12_:ORDERS_COMMENT}
          )));
    ((((route_to_QUERY3_mORDERS6 (Some ORDERS_ORDERKEY)).map
         ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:10, _r2_:6, _r3_:ip}))).combine
       (((route_to_QUERY3_mORDERS3 (Some ORDERS_ORDERKEY)).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:9, _r2_:5, _r3_:ip}))).combine
       (((route_to_QUERY3_mORDERS1 (Some ORDERS_CUSTKEY)).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:7, _r2_:4, _r3_:ip}))).combine
       (((route_to_QUERY3_mORDERS6 (Some ORDERS_ORDERKEY)).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:6, _r2_:6, _r3_:ip}))).combine
       (((route_to_QUERY3_mORDERS3 (Some ORDERS_ORDERKEY)).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:6, _r2_:5, _r3_:ip}))).combine
       (((route_to_QUERY3_mORDERS1 (Some ORDERS_CUSTKEY)).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:6, _r2_:4, _r3_:ip}))).combine
       empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection })))))).groupBy
       ((\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip))
       ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:map_id}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_map_ids} in 
        (insert_ORDERS_rcv_fetch, ip)<- {_r1_:stmt_map_ids, _r2_:vid,
                                         _r3_:ORDERS_ORDERKEY,
                                         _r4_:ORDERS_CUSTKEY,
                                         _r5_:ORDERS_ORDERSTATUS,
                                         _r6_:ORDERS_TOTALPRICE,
                                         _r7_:ORDERS_ORDERDATE,
                                         _r8_:ORDERS_ORDERPRIORITY,
                                         _r9_:ORDERS_CLERK,
                                         _r10_:ORDERS_SHIPPRIORITY,
                                         _r11_:ORDERS_COMMENT}))
    ))

trigger insert_ORDERS_rcv_put : {
_r1_:address, _r2_:collection { key:int, value:int } @ { Set }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int, _r6_:string, _r7_:real,
_r8_:int, _r9_:string, _r10_:string, _r11_:int, _r12_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid,
                _r4_:ORDERS_ORDERKEY, _r5_:ORDERS_CUSTKEY,
                _r6_:ORDERS_ORDERSTATUS, _r7_:ORDERS_TOTALPRICE,
                _r8_:ORDERS_ORDERDATE, _r9_:ORDERS_ORDERPRIORITY,
                _r10_:ORDERS_CLERK, _r11_:ORDERS_SHIPPRIORITY,
                _r12_:ORDERS_COMMENT} in (
    stmt_id_cnt_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:count} in 
        if __stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:_, _r2_:_, _r3_:old_count} in 
          let new_count = old_count + count in (
            __stmt_cntrs__.update
              {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
              {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
            if new_count == 0
            then
              if stmt_id == 10
              then
                (insert_ORDERS_do_complete_s10, me)<- {_r1_:vid,
                                                       _r2_:ORDERS_ORDERKEY,
                                                       _r3_:ORDERS_CUSTKEY,
                                                       _r4_:ORDERS_ORDERSTATUS,
                                                       _r5_:ORDERS_TOTALPRICE,
                                                       _r6_:ORDERS_ORDERDATE,
                                                       _r7_:ORDERS_ORDERPRIORITY,
                                                       _r8_:ORDERS_CLERK,
                                                       _r9_:ORDERS_SHIPPRIORITY,
                                                       _r10_:ORDERS_COMMENT}
              else
                if stmt_id == 9
                then
                  (insert_ORDERS_do_complete_s9, me)<- {_r1_:vid,
                                                        _r2_:ORDERS_ORDERKEY,
                                                        _r3_:ORDERS_CUSTKEY,
                                                        _r4_:ORDERS_ORDERSTATUS,
                                                        _r5_:ORDERS_TOTALPRICE,
                                                        _r6_:ORDERS_ORDERDATE,
                                                        _r7_:ORDERS_ORDERPRIORITY,
                                                        _r8_:ORDERS_CLERK,
                                                        _r9_:ORDERS_SHIPPRIORITY,
                                                        _r10_:ORDERS_COMMENT}
                else
                  if stmt_id == 8
                  then
                    (insert_ORDERS_do_complete_s8, me)<- {_r1_:vid,
                                                          _r2_:ORDERS_ORDERKEY,
                                                          _r3_:ORDERS_CUSTKEY,
                                                          _r4_:ORDERS_ORDERSTATUS,
                                                          _r5_:ORDERS_TOTALPRICE,
                                                          _r6_:ORDERS_ORDERDATE,
                                                          _r7_:ORDERS_ORDERPRIORITY,
                                                          _r8_:ORDERS_CLERK,
                                                          _r9_:ORDERS_SHIPPRIORITY,
                                                          _r10_:ORDERS_COMMENT}
                  else
                    if stmt_id == 7
                    then
                      (insert_ORDERS_do_complete_s7, me)<- {_r1_:vid,
                                                            _r2_:ORDERS_ORDERKEY,
                                                            _r3_:ORDERS_CUSTKEY,
                                                            _r4_:ORDERS_ORDERSTATUS,
                                                            _r5_:ORDERS_TOTALPRICE,
                                                            _r6_:ORDERS_ORDERDATE,
                                                            _r7_:ORDERS_ORDERPRIORITY,
                                                            _r8_:ORDERS_CLERK,
                                                            _r9_:ORDERS_SHIPPRIORITY,
                                                            _r10_:ORDERS_COMMENT}
                    else
                      if stmt_id == 6
                      then
                        (insert_ORDERS_do_complete_s6, me)<- {_r1_:vid,
                                                              _r2_:ORDERS_ORDERKEY,
                                                              _r3_:ORDERS_CUSTKEY,
                                                              _r4_:ORDERS_ORDERSTATUS,
                                                              _r5_:ORDERS_TOTALPRICE,
                                                              _r6_:ORDERS_ORDERDATE,
                                                              _r7_:ORDERS_ORDERPRIORITY,
                                                              _r8_:ORDERS_CLERK,
                                                              _r9_:ORDERS_SHIPPRIORITY,
                                                              _r10_:ORDERS_COMMENT}
                      else ()
            else ()
            )
        else __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count}))
    ))

trigger insert_ORDERS_rcv_fetch : {
_r1_:collection { key:int, value:int } @ { Set }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int, _r5_:string, _r6_:real,
_r7_:int, _r8_:string, _r9_:string, _r10_:int, _r11_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:ORDERS_ORDERKEY,
                _r4_:ORDERS_CUSTKEY, _r5_:ORDERS_ORDERSTATUS,
                _r6_:ORDERS_TOTALPRICE, _r7_:ORDERS_ORDERDATE,
                _r8_:ORDERS_ORDERPRIORITY, _r9_:ORDERS_CLERK,
                _r10_:ORDERS_SHIPPRIORITY, _r11_:ORDERS_COMMENT} in (
    log_write_insert_ORDERS
      {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
       _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE, _r6_:ORDERS_ORDERDATE,
       _r7_:ORDERS_ORDERPRIORITY, _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
       _r10_:ORDERS_COMMENT};
    stmts_and_map_ids.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:map_id} in 
        if stmt_id == 6
        then
          if map_id == 4
          then
            (insert_ORDERS_send_push_s6_m_QUERY3_mORDERS1, me)<- {_r1_:vid,
                                                                  _r2_:ORDERS_ORDERKEY,
                                                                  _r3_:ORDERS_CUSTKEY,
                                                                  _r4_:ORDERS_ORDERSTATUS,
                                                                  _r5_:ORDERS_TOTALPRICE,
                                                                  _r6_:ORDERS_ORDERDATE,
                                                                  _r7_:ORDERS_ORDERPRIORITY,
                                                                  _r8_:ORDERS_CLERK,
                                                                  _r9_:ORDERS_SHIPPRIORITY,
                                                                  _r10_:ORDERS_COMMENT}
          else
            if map_id == 5
            then
              (insert_ORDERS_send_push_s6_m_QUERY3_mORDERS3, me)<- {_r1_:vid,
                                                                    _r2_:ORDERS_ORDERKEY,
                                                                    _r3_:ORDERS_CUSTKEY,
                                                                    _r4_:ORDERS_ORDERSTATUS,
                                                                    _r5_:ORDERS_TOTALPRICE,
                                                                    _r6_:ORDERS_ORDERDATE,
                                                                    _r7_:ORDERS_ORDERPRIORITY,
                                                                    _r8_:ORDERS_CLERK,
                                                                    _r9_:ORDERS_SHIPPRIORITY,
                                                                    _r10_:ORDERS_COMMENT}
            else
              if map_id == 6
              then
                (insert_ORDERS_send_push_s6_m_QUERY3_mORDERS6, me)<- {
                  _r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT}
              else ()
        else
          if stmt_id == 7
          then
            if map_id == 4
            then
              (insert_ORDERS_send_push_s7_m_QUERY3_mORDERS1, me)<- {_r1_:vid,
                                                                    _r2_:ORDERS_ORDERKEY,
                                                                    _r3_:ORDERS_CUSTKEY,
                                                                    _r4_:ORDERS_ORDERSTATUS,
                                                                    _r5_:ORDERS_TOTALPRICE,
                                                                    _r6_:ORDERS_ORDERDATE,
                                                                    _r7_:ORDERS_ORDERPRIORITY,
                                                                    _r8_:ORDERS_CLERK,
                                                                    _r9_:ORDERS_SHIPPRIORITY,
                                                                    _r10_:ORDERS_COMMENT}
            else ()
          else
            if stmt_id == 9
            then
              if map_id == 5
              then
                (insert_ORDERS_send_push_s9_m_QUERY3_mORDERS3, me)<- {
                  _r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT}
              else ()
            else
              if stmt_id == 10
              then
                if map_id == 6
                then
                  (insert_ORDERS_send_push_s10_m_QUERY3_mORDERS6, me)<- {
                    _r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                    _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                    _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                    _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                    _r10_:ORDERS_COMMENT}
                else ()
              else ()))
    ))

trigger insert_ORDERS_send_push_s6_m_QUERY3_mORDERS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                _r10_:ORDERS_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:2, _r3_:6};
    (shuffle_QUERY3_mORDERS3_QUERY3_0t0
       {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
              _r3_:Some ORDERS_SHIPPRIORITY},
        _r2_:bind (QUERY3_mORDERS3.filter
                    ((\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      ORDERS_ORDERKEY))).fold
                    ((\_b2_ ->
                    bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {key:map_vid, value:vid}
                      then
                        if vid_eq {key:map_vid, value:max_vid}
                        then
                          {key:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:real |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, value:max_vid}
                        else
                          if vid_gt {key:map_vid, value:max_vid}
                          then
                            {key:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:real |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             value:map_vid}
                          else {key:acc, value:max_vid}
                      else {key:acc, value:max_vid})))
                    {key:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                     } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
        key:__1, value:__2} in __1, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_ORDERS_rcv_push_s6_m_QUERY3_mORDERS3, ip)<- {_r1_:tuples,
                                                             _r2_:vid,
                                                             _r3_:ORDERS_ORDERKEY,
                                                             _r4_:ORDERS_CUSTKEY,
                                                             _r5_:ORDERS_ORDERSTATUS,
                                                             _r6_:ORDERS_TOTALPRICE,
                                                             _r7_:ORDERS_ORDERDATE,
                                                             _r8_:ORDERS_ORDERPRIORITY,
                                                             _r9_:ORDERS_CLERK,
                                                             _r10_:ORDERS_SHIPPRIORITY,
                                                             _r11_:ORDERS_COMMENT}))
    ))

trigger insert_ORDERS_send_push_s6_m_QUERY3_mORDERS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                _r10_:ORDERS_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:2, _r3_:6};
    (shuffle_QUERY3_mORDERS1_QUERY3
       {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
              _r3_:Some ORDERS_SHIPPRIORITY},
        _r2_:bind (QUERY3_mORDERS1.filter
                    ((\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      ORDERS_CUSTKEY))).fold
                    ((\_b2_ ->
                    bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {key:map_vid, value:vid}
                      then
                        if vid_eq {key:map_vid, value:max_vid}
                        then
                          {key:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:int |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, value:max_vid}
                        else
                          if vid_gt {key:map_vid, value:max_vid}
                          then
                            {key:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:int |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             value:map_vid}
                          else {key:acc, value:max_vid}
                      else {key:acc, value:max_vid})))
                    {key:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                     } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
        key:__1, value:__2} in __1, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_ORDERS_rcv_push_s6_m_QUERY3_mORDERS1, ip)<- {_r1_:tuples,
                                                             _r2_:vid,
                                                             _r3_:ORDERS_ORDERKEY,
                                                             _r4_:ORDERS_CUSTKEY,
                                                             _r5_:ORDERS_ORDERSTATUS,
                                                             _r6_:ORDERS_TOTALPRICE,
                                                             _r7_:ORDERS_ORDERDATE,
                                                             _r8_:ORDERS_ORDERPRIORITY,
                                                             _r9_:ORDERS_CLERK,
                                                             _r10_:ORDERS_SHIPPRIORITY,
                                                             _r11_:ORDERS_COMMENT}))
    ))

trigger insert_ORDERS_send_push_s6_m_QUERY3_mORDERS6 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                _r10_:ORDERS_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:2, _r3_:6};
    (shuffle_QUERY3_mORDERS6_QUERY3_0t0
       {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
              _r3_:Some ORDERS_SHIPPRIORITY},
        _r2_:bind (QUERY3_mORDERS6.filter
                    ((\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      ORDERS_ORDERKEY))).fold
                    ((\_b2_ ->
                    bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {key:map_vid, value:vid}
                      then
                        if vid_eq {key:map_vid, value:max_vid}
                        then
                          {key:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:real |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, value:max_vid}
                        else
                          if vid_gt {key:map_vid, value:max_vid}
                          then
                            {key:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:real |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             value:map_vid}
                          else {key:acc, value:max_vid}
                      else {key:acc, value:max_vid})))
                    {key:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                     } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
        key:__1, value:__2} in __1, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_ORDERS_rcv_push_s6_m_QUERY3_mORDERS6, ip)<- {_r1_:tuples,
                                                             _r2_:vid,
                                                             _r3_:ORDERS_ORDERKEY,
                                                             _r4_:ORDERS_CUSTKEY,
                                                             _r5_:ORDERS_ORDERSTATUS,
                                                             _r6_:ORDERS_TOTALPRICE,
                                                             _r7_:ORDERS_ORDERDATE,
                                                             _r8_:ORDERS_ORDERPRIORITY,
                                                             _r9_:ORDERS_CLERK,
                                                             _r10_:ORDERS_SHIPPRIORITY,
                                                             _r11_:ORDERS_COMMENT}))
    ))

trigger insert_ORDERS_send_push_s7_m_QUERY3_mORDERS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                _r10_:ORDERS_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:2, _r3_:7};
    (shuffle_QUERY3_mORDERS1_QUERY3_mLINEITEM1
       {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
              _r3_:Some ORDERS_SHIPPRIORITY},
        _r2_:bind (QUERY3_mORDERS1.filter
                    ((\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      ORDERS_CUSTKEY))).fold
                    ((\_b2_ ->
                    bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {key:map_vid, value:vid}
                      then
                        if vid_eq {key:map_vid, value:max_vid}
                        then
                          {key:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:int |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, value:max_vid}
                        else
                          if vid_gt {key:map_vid, value:max_vid}
                          then
                            {key:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:int |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             value:map_vid}
                          else {key:acc, value:max_vid}
                      else {key:acc, value:max_vid})))
                    {key:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                     } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
        key:__1, value:__2} in __1, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_ORDERS_rcv_push_s7_m_QUERY3_mORDERS1, ip)<- {_r1_:tuples,
                                                             _r2_:vid,
                                                             _r3_:ORDERS_ORDERKEY,
                                                             _r4_:ORDERS_CUSTKEY,
                                                             _r5_:ORDERS_ORDERSTATUS,
                                                             _r6_:ORDERS_TOTALPRICE,
                                                             _r7_:ORDERS_ORDERDATE,
                                                             _r8_:ORDERS_ORDERPRIORITY,
                                                             _r9_:ORDERS_CLERK,
                                                             _r10_:ORDERS_SHIPPRIORITY,
                                                             _r11_:ORDERS_COMMENT}))
    ))

trigger insert_ORDERS_send_push_s9_m_QUERY3_mORDERS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                _r10_:ORDERS_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:2, _r3_:9};
    (shuffle_QUERY3_mORDERS3_QUERY3_mCUSTOMER2_0t0
       {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
              _r3_:Some ORDERS_SHIPPRIORITY, _r4_:Some ORDERS_CUSTKEY},
        _r2_:bind (QUERY3_mORDERS3.filter
                    ((\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      ORDERS_ORDERKEY))).fold
                    ((\_b2_ ->
                    bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {key:map_vid, value:vid}
                      then
                        if vid_eq {key:map_vid, value:max_vid}
                        then
                          {key:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:real |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, value:max_vid}
                        else
                          if vid_gt {key:map_vid, value:max_vid}
                          then
                            {key:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:real |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             value:map_vid}
                          else {key:acc, value:max_vid}
                      else {key:acc, value:max_vid})))
                    {key:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                     } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
        key:__1, value:__2} in __1, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_ORDERS_rcv_push_s9_m_QUERY3_mORDERS3, ip)<- {_r1_:tuples,
                                                             _r2_:vid,
                                                             _r3_:ORDERS_ORDERKEY,
                                                             _r4_:ORDERS_CUSTKEY,
                                                             _r5_:ORDERS_ORDERSTATUS,
                                                             _r6_:ORDERS_TOTALPRICE,
                                                             _r7_:ORDERS_ORDERDATE,
                                                             _r8_:ORDERS_ORDERPRIORITY,
                                                             _r9_:ORDERS_CLERK,
                                                             _r10_:ORDERS_SHIPPRIORITY,
                                                             _r11_:ORDERS_COMMENT}))
    ))

trigger insert_ORDERS_send_push_s10_m_QUERY3_mORDERS6 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                _r10_:ORDERS_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:2, _r3_:10};
    (shuffle_QUERY3_mORDERS6_QUERY3_mCUSTOMER4_0t0
       {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
              _r3_:Some ORDERS_SHIPPRIORITY, _r4_:Some ORDERS_CUSTKEY},
        _r2_:bind (QUERY3_mORDERS6.filter
                    ((\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      ORDERS_ORDERKEY))).fold
                    ((\_b2_ ->
                    bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {key:map_vid, value:vid}
                      then
                        if vid_eq {key:map_vid, value:max_vid}
                        then
                          {key:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:real |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, value:max_vid}
                        else
                          if vid_gt {key:map_vid, value:max_vid}
                          then
                            {key:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:real |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             value:map_vid}
                          else {key:acc, value:max_vid}
                      else {key:acc, value:max_vid})))
                    {key:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                     } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
        key:__1, value:__2} in __1, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_ORDERS_rcv_push_s10_m_QUERY3_mORDERS6, ip)<- {_r1_:tuples,
                                                              _r2_:vid,
                                                              _r3_:ORDERS_ORDERKEY,
                                                              _r4_:ORDERS_CUSTKEY,
                                                              _r5_:ORDERS_ORDERSTATUS,
                                                              _r6_:ORDERS_TOTALPRICE,
                                                              _r7_:ORDERS_ORDERDATE,
                                                              _r8_:ORDERS_ORDERPRIORITY,
                                                              _r9_:ORDERS_CLERK,
                                                              _r10_:ORDERS_SHIPPRIORITY,
                                                              _r11_:ORDERS_COMMENT}))
    ))

trigger insert_ORDERS_rcv_push_s6_m_QUERY3_mORDERS1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int,
_r5_:string, _r6_:real, _r7_:int, _r8_:string, _r9_:string, _r10_:int,
_r11_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:ORDERS_ORDERKEY,
                _r4_:ORDERS_CUSTKEY, _r5_:ORDERS_ORDERSTATUS,
                _r6_:ORDERS_TOTALPRICE, _r7_:ORDERS_ORDERDATE,
                _r8_:ORDERS_ORDERPRIORITY, _r9_:ORDERS_CLERK,
                _r10_:ORDERS_SHIPPRIORITY, _r11_:ORDERS_COMMENT} in (
    log_write_insert_ORDERS
      {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
       _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE, _r6_:ORDERS_ORDERDATE,
       _r7_:ORDERS_ORDERPRIORITY, _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
       _r10_:ORDERS_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mORDERS1_s6_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then
          map_QUERY3_mORDERS1_s6_buf.update
            (case ((map_QUERY3_mORDERS1_s6_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mORDERS1_s6_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 6)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 6))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 6))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:6, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 6))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:6, _r3_:0}
        then
          (insert_ORDERS_do_complete_s6, me)<- {_r1_:vid, _r2_:ORDERS_ORDERKEY,
                                                _r3_:ORDERS_CUSTKEY,
                                                _r4_:ORDERS_ORDERSTATUS,
                                                _r5_:ORDERS_TOTALPRICE,
                                                _r6_:ORDERS_ORDERDATE,
                                                _r7_:ORDERS_ORDERPRIORITY,
                                                _r8_:ORDERS_CLERK,
                                                _r9_:ORDERS_SHIPPRIORITY,
                                                _r10_:ORDERS_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:6, _r3_:-1}
    ))

trigger insert_ORDERS_rcv_push_s6_m_QUERY3_mORDERS3 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int,
_r5_:string, _r6_:real, _r7_:int, _r8_:string, _r9_:string, _r10_:int,
_r11_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:ORDERS_ORDERKEY,
                _r4_:ORDERS_CUSTKEY, _r5_:ORDERS_ORDERSTATUS,
                _r6_:ORDERS_TOTALPRICE, _r7_:ORDERS_ORDERDATE,
                _r8_:ORDERS_ORDERPRIORITY, _r9_:ORDERS_CLERK,
                _r10_:ORDERS_SHIPPRIORITY, _r11_:ORDERS_COMMENT} in (
    log_write_insert_ORDERS
      {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
       _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE, _r6_:ORDERS_ORDERDATE,
       _r7_:ORDERS_ORDERPRIORITY, _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
       _r10_:ORDERS_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mORDERS3_s6_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
          } @ { Set }
        then
          map_QUERY3_mORDERS3_s6_buf.update
            (case ((map_QUERY3_mORDERS3_s6_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mORDERS3_s6_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 6)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 6))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 6))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:6, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 6))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:6, _r3_:0}
        then
          (insert_ORDERS_do_complete_s6, me)<- {_r1_:vid, _r2_:ORDERS_ORDERKEY,
                                                _r3_:ORDERS_CUSTKEY,
                                                _r4_:ORDERS_ORDERSTATUS,
                                                _r5_:ORDERS_TOTALPRICE,
                                                _r6_:ORDERS_ORDERDATE,
                                                _r7_:ORDERS_ORDERPRIORITY,
                                                _r8_:ORDERS_CLERK,
                                                _r9_:ORDERS_SHIPPRIORITY,
                                                _r10_:ORDERS_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:6, _r3_:-1}
    ))

trigger insert_ORDERS_rcv_push_s6_m_QUERY3_mORDERS6 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int,
_r5_:string, _r6_:real, _r7_:int, _r8_:string, _r9_:string, _r10_:int,
_r11_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:ORDERS_ORDERKEY,
                _r4_:ORDERS_CUSTKEY, _r5_:ORDERS_ORDERSTATUS,
                _r6_:ORDERS_TOTALPRICE, _r7_:ORDERS_ORDERDATE,
                _r8_:ORDERS_ORDERPRIORITY, _r9_:ORDERS_CLERK,
                _r10_:ORDERS_SHIPPRIORITY, _r11_:ORDERS_COMMENT} in (
    log_write_insert_ORDERS
      {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
       _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE, _r6_:ORDERS_ORDERDATE,
       _r7_:ORDERS_ORDERPRIORITY, _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
       _r10_:ORDERS_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mORDERS6_s6_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
          } @ { Set }
        then
          map_QUERY3_mORDERS6_s6_buf.update
            (case ((map_QUERY3_mORDERS6_s6_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mORDERS6_s6_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 6)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 6))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 6))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:6, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 6))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:6, _r3_:0}
        then
          (insert_ORDERS_do_complete_s6, me)<- {_r1_:vid, _r2_:ORDERS_ORDERKEY,
                                                _r3_:ORDERS_CUSTKEY,
                                                _r4_:ORDERS_ORDERSTATUS,
                                                _r5_:ORDERS_TOTALPRICE,
                                                _r6_:ORDERS_ORDERDATE,
                                                _r7_:ORDERS_ORDERPRIORITY,
                                                _r8_:ORDERS_CLERK,
                                                _r9_:ORDERS_SHIPPRIORITY,
                                                _r10_:ORDERS_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:6, _r3_:-1}
    ))

trigger insert_ORDERS_rcv_push_s7_m_QUERY3_mORDERS1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int,
_r5_:string, _r6_:real, _r7_:int, _r8_:string, _r9_:string, _r10_:int,
_r11_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:ORDERS_ORDERKEY,
                _r4_:ORDERS_CUSTKEY, _r5_:ORDERS_ORDERSTATUS,
                _r6_:ORDERS_TOTALPRICE, _r7_:ORDERS_ORDERDATE,
                _r8_:ORDERS_ORDERPRIORITY, _r9_:ORDERS_CLERK,
                _r10_:ORDERS_SHIPPRIORITY, _r11_:ORDERS_COMMENT} in (
    log_write_insert_ORDERS
      {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
       _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE, _r6_:ORDERS_ORDERDATE,
       _r7_:ORDERS_ORDERPRIORITY, _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
       _r10_:ORDERS_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mORDERS1_s7_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then
          map_QUERY3_mORDERS1_s7_buf.update
            (case ((map_QUERY3_mORDERS1_s7_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mORDERS1_s7_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 7)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 7))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 7))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:7, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 7))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:7, _r3_:0}
        then
          (insert_ORDERS_do_complete_s7, me)<- {_r1_:vid, _r2_:ORDERS_ORDERKEY,
                                                _r3_:ORDERS_CUSTKEY,
                                                _r4_:ORDERS_ORDERSTATUS,
                                                _r5_:ORDERS_TOTALPRICE,
                                                _r6_:ORDERS_ORDERDATE,
                                                _r7_:ORDERS_ORDERPRIORITY,
                                                _r8_:ORDERS_CLERK,
                                                _r9_:ORDERS_SHIPPRIORITY,
                                                _r10_:ORDERS_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:7, _r3_:-1}
    ))

trigger insert_ORDERS_rcv_push_s9_m_QUERY3_mORDERS3 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int,
_r5_:string, _r6_:real, _r7_:int, _r8_:string, _r9_:string, _r10_:int,
_r11_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:ORDERS_ORDERKEY,
                _r4_:ORDERS_CUSTKEY, _r5_:ORDERS_ORDERSTATUS,
                _r6_:ORDERS_TOTALPRICE, _r7_:ORDERS_ORDERDATE,
                _r8_:ORDERS_ORDERPRIORITY, _r9_:ORDERS_CLERK,
                _r10_:ORDERS_SHIPPRIORITY, _r11_:ORDERS_COMMENT} in (
    log_write_insert_ORDERS
      {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
       _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE, _r6_:ORDERS_ORDERDATE,
       _r7_:ORDERS_ORDERPRIORITY, _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
       _r10_:ORDERS_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mORDERS3_s9_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
          } @ { Set }
        then
          map_QUERY3_mORDERS3_s9_buf.update
            (case ((map_QUERY3_mORDERS3_s9_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mORDERS3_s9_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 9)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 9))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 9))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:9, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 9))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:9, _r3_:0}
        then
          (insert_ORDERS_do_complete_s9, me)<- {_r1_:vid, _r2_:ORDERS_ORDERKEY,
                                                _r3_:ORDERS_CUSTKEY,
                                                _r4_:ORDERS_ORDERSTATUS,
                                                _r5_:ORDERS_TOTALPRICE,
                                                _r6_:ORDERS_ORDERDATE,
                                                _r7_:ORDERS_ORDERPRIORITY,
                                                _r8_:ORDERS_CLERK,
                                                _r9_:ORDERS_SHIPPRIORITY,
                                                _r10_:ORDERS_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:9, _r3_:-1}
    ))

trigger insert_ORDERS_rcv_push_s10_m_QUERY3_mORDERS6 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int,
_r5_:string, _r6_:real, _r7_:int, _r8_:string, _r9_:string, _r10_:int,
_r11_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:ORDERS_ORDERKEY,
                _r4_:ORDERS_CUSTKEY, _r5_:ORDERS_ORDERSTATUS,
                _r6_:ORDERS_TOTALPRICE, _r7_:ORDERS_ORDERDATE,
                _r8_:ORDERS_ORDERPRIORITY, _r9_:ORDERS_CLERK,
                _r10_:ORDERS_SHIPPRIORITY, _r11_:ORDERS_COMMENT} in (
    log_write_insert_ORDERS
      {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
       _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE, _r6_:ORDERS_ORDERDATE,
       _r7_:ORDERS_ORDERPRIORITY, _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
       _r10_:ORDERS_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mORDERS6_s10_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
          } @ { Set }
        then
          map_QUERY3_mORDERS6_s10_buf.update
            (case ((map_QUERY3_mORDERS6_s10_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mORDERS6_s10_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 10)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 10))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 10))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:10, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 10))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:10, _r3_:0}
        then
          (insert_ORDERS_do_complete_s10, me)<- {_r1_:vid,
                                                 _r2_:ORDERS_ORDERKEY,
                                                 _r3_:ORDERS_CUSTKEY,
                                                 _r4_:ORDERS_ORDERSTATUS,
                                                 _r5_:ORDERS_TOTALPRICE,
                                                 _r6_:ORDERS_ORDERDATE,
                                                 _r7_:ORDERS_ORDERPRIORITY,
                                                 _r8_:ORDERS_CLERK,
                                                 _r9_:ORDERS_SHIPPRIORITY,
                                                 _r10_:ORDERS_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:10, _r3_:-1}
    ))

trigger insert_ORDERS_do_complete_s6 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT} in let existing_out_tier = QUERY3 in
    let __prod_ret__11 = ((if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
      let wrapped_lookup_value =
        bind (map_QUERY3_mORDERS1_s6_buf.filter
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                 ORDERS_CUSTKEY))).fold
               ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                 bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                 if vid_lt {key:map_vid, value:vid}
                 then
                   if vid_eq {key:map_vid, value:max_vid}
                   then
                     {key:({| key:int, value:int |
                      {key:__map_0, value:__map_val}|} @ { Set }).combine 
                      acc, value:max_vid}
                   else
                     if vid_gt {key:map_vid, value:max_vid}
                     then
                       {key:{| key:int, value:int |
                        {key:__map_0, value:__map_val}|} @ { Set },
                        value:map_vid}
                     else {key:acc, value:max_vid}
                 else {key:acc, value:max_vid})))
               {key:empty { key:int, value:int } @ { Set },
                value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in __1 in
      if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) *
      (((let wrapped_lookup_value =
           bind (map_QUERY3_mORDERS3_s6_buf.filter
                  ((\_b1_ -> 
                    bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                    ORDERS_ORDERKEY))).fold
                  ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ ->
                  
                    bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                    if vid_lt {key:map_vid, value:vid}
                    then
                      if vid_eq {key:map_vid, value:max_vid}
                      then
                        {key:({| key:int, value:real |
                         {key:__map_0, value:__map_val}|} @ { Set }).combine
                         acc, value:max_vid}
                      else
                        if vid_gt {key:map_vid, value:max_vid}
                        then
                          {key:{| key:int, value:real |
                           {key:__map_0, value:__map_val}|} @ { Set },
                           value:map_vid}
                        else {key:acc, value:max_vid}
                    else {key:acc, value:max_vid})))
                  {key:empty { key:int, value:real } @ { Set },
                   value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
           __1 in
      if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) * -1) +
      let wrapped_lookup_value =
        bind (map_QUERY3_mORDERS6_s6_buf.filter
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                 ORDERS_ORDERKEY))).fold
               ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                 bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                 if vid_lt {key:map_vid, value:vid}
                 then
                   if vid_eq {key:map_vid, value:max_vid}
                   then
                     {key:({| key:int, value:real |
                      {key:__map_0, value:__map_val}|} @ { Set }).combine 
                      acc, value:max_vid}
                   else
                     if vid_gt {key:map_vid, value:max_vid}
                     then
                       {key:{| key:int, value:real |
                        {key:__map_0, value:__map_val}|} @ { Set },
                        value:map_vid}
                     else {key:acc, value:max_vid}
                 else {key:acc, value:max_vid})))
               {key:empty { key:int, value:real } @ { Set },
                value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in __1 in
      if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) in (
      add_delta_to_QUERY3
        {key:vid, value:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
         _r5_:real |
         {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
          _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__11}|} @ { Set }}
      ))

trigger insert_ORDERS_do_complete_s7 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT} in 
    let existing_out_tier = QUERY3_mLINEITEM1 in
    let __prod_ret__12 =
      (let wrapped_lookup_value =
         bind (map_QUERY3_mORDERS1_s7_buf.filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                  ORDERS_CUSTKEY))).fold
                ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                  if vid_lt {key:map_vid, value:vid}
                  then
                    if vid_eq {key:map_vid, value:max_vid}
                    then
                      {key:({| key:int, value:int |
                       {key:__map_0, value:__map_val}|} @ { Set }).combine 
                       acc, value:max_vid}
                    else
                      if vid_gt {key:map_vid, value:max_vid}
                      then
                        {key:{| key:int, value:int |
                         {key:__map_0, value:__map_val}|} @ { Set },
                         value:map_vid}
                      else {key:acc, value:max_vid}
                  else {key:acc, value:max_vid})))
                {key:empty { key:int, value:int } @ { Set },
                 value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in __1 in
      if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) * if ORDERS_ORDERDATE < 19950315 then 1 else 0 in (
      add_delta_to_QUERY3_mLINEITEM1
        {key:vid, value:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
         _r5_:int |
         {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
          _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__12}|} @ { Set }};
      (QUERY3_mLINEITEM1_send_correctives, me)<- {key:vid, value:{|
                                                  _r1_:{
                                                  _r1_:int, _r2_:int, _r3_:int
                                                  }, _r2_:int, _r3_:int,
                                                  _r4_:int, _r5_:int |
                                                  {_r1_:vid,
                                                   _r2_:ORDERS_ORDERKEY,
                                                   _r3_:ORDERS_ORDERDATE,
                                                   _r4_:ORDERS_SHIPPRIORITY,
                                                   _r5_:__prod_ret__12}|} @ { Set }}
      ))

trigger insert_ORDERS_do_complete_s8 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT} in 
    let existing_out_tier = QUERY3_mLINEITEM1_mCUSTOMER2 in
    let __cmp_ret__9 = if ORDERS_ORDERDATE < 19950315 then 1 else 0 in (
      add_delta_to_QUERY3_mLINEITEM1_mCUSTOMER2
        {key:vid, value:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
         _r5_:int, _r6_:int |
         {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
          _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:__cmp_ret__9}|} @ { Set }};
      (QUERY3_mLINEITEM1_mCUSTOMER2_send_correctives, me)<- {key:vid, value:{|
                                                             _r1_:{
                                                             _r1_:int,
                                                             _r2_:int, _r3_:int
                                                             }, _r2_:int,
                                                             _r3_:int,
                                                             _r4_:int,
                                                             _r5_:int, _r6_:int
                                                             |
                                                             {_r1_:vid,
                                                              _r2_:ORDERS_ORDERKEY,
                                                              _r3_:ORDERS_ORDERDATE,
                                                              _r4_:ORDERS_SHIPPRIORITY,
                                                              _r5_:ORDERS_CUSTKEY,
                                                              _r6_:__cmp_ret__9}|} @ { Set }}
      ))

trigger insert_ORDERS_do_complete_s9 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT} in 
    let existing_out_tier = QUERY3_mCUSTOMER2 in
    let __prod_ret__13 = (if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
      let wrapped_lookup_value =
        bind (map_QUERY3_mORDERS3_s9_buf.filter
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                 ORDERS_ORDERKEY))).fold
               ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                 bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                 if vid_lt {key:map_vid, value:vid}
                 then
                   if vid_eq {key:map_vid, value:max_vid}
                   then
                     {key:({| key:int, value:real |
                      {key:__map_0, value:__map_val}|} @ { Set }).combine 
                      acc, value:max_vid}
                   else
                     if vid_gt {key:map_vid, value:max_vid}
                     then
                       {key:{| key:int, value:real |
                        {key:__map_0, value:__map_val}|} @ { Set },
                        value:map_vid}
                     else {key:acc, value:max_vid}
                 else {key:acc, value:max_vid})))
               {key:empty { key:int, value:real } @ { Set },
                value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in __1 in
      if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field in (
      add_delta_to_QUERY3_mCUSTOMER2
        {key:vid, value:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
         _r5_:int, _r6_:real |
         {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
          _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:__prod_ret__13}|} @ { Set }};
      (QUERY3_mCUSTOMER2_send_correctives, me)<- {key:vid, value:{|
                                                  _r1_:{
                                                  _r1_:int, _r2_:int, _r3_:int
                                                  }, _r2_:int, _r3_:int,
                                                  _r4_:int, _r5_:int, _r6_:real
                                                  |
                                                  {_r1_:vid,
                                                   _r2_:ORDERS_ORDERKEY,
                                                   _r3_:ORDERS_ORDERDATE,
                                                   _r4_:ORDERS_SHIPPRIORITY,
                                                   _r5_:ORDERS_CUSTKEY,
                                                   _r6_:__prod_ret__13}|} @ { Set }}
      ))

trigger insert_ORDERS_do_complete_s10 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT} in 
    let existing_out_tier = QUERY3_mCUSTOMER4 in
    let __prod_ret__14 = (if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
      let wrapped_lookup_value =
        bind (map_QUERY3_mORDERS6_s10_buf.filter
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                 ORDERS_ORDERKEY))).fold
               ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                 bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                 if vid_lt {key:map_vid, value:vid}
                 then
                   if vid_eq {key:map_vid, value:max_vid}
                   then
                     {key:({| key:int, value:real |
                      {key:__map_0, value:__map_val}|} @ { Set }).combine 
                      acc, value:max_vid}
                   else
                     if vid_gt {key:map_vid, value:max_vid}
                     then
                       {key:{| key:int, value:real |
                        {key:__map_0, value:__map_val}|} @ { Set },
                        value:map_vid}
                     else {key:acc, value:max_vid}
                 else {key:acc, value:max_vid})))
               {key:empty { key:int, value:real } @ { Set },
                value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in __1 in
      if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field in (
      add_delta_to_QUERY3_mCUSTOMER4
        {key:vid, value:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
         _r5_:int, _r6_:real |
         {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
          _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:__prod_ret__14}|} @ { Set }};
      (QUERY3_mCUSTOMER4_send_correctives, me)<- {key:vid, value:{|
                                                  _r1_:{
                                                  _r1_:int, _r2_:int, _r3_:int
                                                  }, _r2_:int, _r3_:int,
                                                  _r4_:int, _r5_:int, _r6_:real
                                                  |
                                                  {_r1_:vid,
                                                   _r2_:ORDERS_ORDERKEY,
                                                   _r3_:ORDERS_ORDERDATE,
                                                   _r4_:ORDERS_SHIPPRIORITY,
                                                   _r5_:ORDERS_CUSTKEY,
                                                   _r6_:__prod_ret__14}|} @ { Set }}
      ))

trigger insert_ORDERS_rcv_corrective_s6_m_QUERY3_mORDERS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mORDERS1_s6_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 6))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:6, _r3_:0}
        then
          bind log_get_bound_insert_ORDERS compute_vid as {_r1_:vid,
                                                           _r2_:ORDERS_ORDERKEY,
                                                           _r3_:ORDERS_CUSTKEY,
                                                           _r4_:ORDERS_ORDERSTATUS,
                                                           _r5_:ORDERS_TOTALPRICE,
                                                           _r6_:ORDERS_ORDERDATE,
                                                           _r7_:ORDERS_ORDERPRIORITY,
                                                           _r8_:ORDERS_CLERK,
                                                           _r9_:ORDERS_SHIPPRIORITY,
                                                           _r10_:ORDERS_COMMENT} in 
          (insert_ORDERS_do_corrective_s6_m_QUERY3_mORDERS1, me)<- {_r1_:compute_vid,
                                                                    _r2_:ORDERS_ORDERKEY,
                                                                    _r3_:ORDERS_CUSTKEY,
                                                                    _r4_:ORDERS_ORDERSTATUS,
                                                                    _r5_:ORDERS_TOTALPRICE,
                                                                    _r6_:ORDERS_ORDERDATE,
                                                                    _r7_:ORDERS_ORDERPRIORITY,
                                                                    _r8_:ORDERS_CLERK,
                                                                    _r9_:ORDERS_SHIPPRIORITY,
                                                                    _r10_:ORDERS_COMMENT,
                                                                    _r11_:delta_tuples}
        else ()))
    ))

trigger insert_ORDERS_rcv_corrective_s6_m_QUERY3_mORDERS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mORDERS3_s6_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 6))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:6, _r3_:0}
        then
          bind log_get_bound_insert_ORDERS compute_vid as {_r1_:vid,
                                                           _r2_:ORDERS_ORDERKEY,
                                                           _r3_:ORDERS_CUSTKEY,
                                                           _r4_:ORDERS_ORDERSTATUS,
                                                           _r5_:ORDERS_TOTALPRICE,
                                                           _r6_:ORDERS_ORDERDATE,
                                                           _r7_:ORDERS_ORDERPRIORITY,
                                                           _r8_:ORDERS_CLERK,
                                                           _r9_:ORDERS_SHIPPRIORITY,
                                                           _r10_:ORDERS_COMMENT} in 
          (insert_ORDERS_do_corrective_s6_m_QUERY3_mORDERS3, me)<- {_r1_:compute_vid,
                                                                    _r2_:ORDERS_ORDERKEY,
                                                                    _r3_:ORDERS_CUSTKEY,
                                                                    _r4_:ORDERS_ORDERSTATUS,
                                                                    _r5_:ORDERS_TOTALPRICE,
                                                                    _r6_:ORDERS_ORDERDATE,
                                                                    _r7_:ORDERS_ORDERPRIORITY,
                                                                    _r8_:ORDERS_CLERK,
                                                                    _r9_:ORDERS_SHIPPRIORITY,
                                                                    _r10_:ORDERS_COMMENT,
                                                                    _r11_:delta_tuples}
        else ()))
    ))

trigger insert_ORDERS_rcv_corrective_s6_m_QUERY3_mORDERS6 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mORDERS6_s6_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 6))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:6, _r3_:0}
        then
          bind log_get_bound_insert_ORDERS compute_vid as {_r1_:vid,
                                                           _r2_:ORDERS_ORDERKEY,
                                                           _r3_:ORDERS_CUSTKEY,
                                                           _r4_:ORDERS_ORDERSTATUS,
                                                           _r5_:ORDERS_TOTALPRICE,
                                                           _r6_:ORDERS_ORDERDATE,
                                                           _r7_:ORDERS_ORDERPRIORITY,
                                                           _r8_:ORDERS_CLERK,
                                                           _r9_:ORDERS_SHIPPRIORITY,
                                                           _r10_:ORDERS_COMMENT} in 
          (insert_ORDERS_do_corrective_s6_m_QUERY3_mORDERS6, me)<- {_r1_:compute_vid,
                                                                    _r2_:ORDERS_ORDERKEY,
                                                                    _r3_:ORDERS_CUSTKEY,
                                                                    _r4_:ORDERS_ORDERSTATUS,
                                                                    _r5_:ORDERS_TOTALPRICE,
                                                                    _r6_:ORDERS_ORDERDATE,
                                                                    _r7_:ORDERS_ORDERPRIORITY,
                                                                    _r8_:ORDERS_CLERK,
                                                                    _r9_:ORDERS_SHIPPRIORITY,
                                                                    _r10_:ORDERS_COMMENT,
                                                                    _r11_:delta_tuples}
        else ()))
    ))

trigger insert_ORDERS_rcv_corrective_s7_m_QUERY3_mORDERS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mORDERS1_s7_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 7))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:7, _r3_:0}
        then
          bind log_get_bound_insert_ORDERS compute_vid as {_r1_:vid,
                                                           _r2_:ORDERS_ORDERKEY,
                                                           _r3_:ORDERS_CUSTKEY,
                                                           _r4_:ORDERS_ORDERSTATUS,
                                                           _r5_:ORDERS_TOTALPRICE,
                                                           _r6_:ORDERS_ORDERDATE,
                                                           _r7_:ORDERS_ORDERPRIORITY,
                                                           _r8_:ORDERS_CLERK,
                                                           _r9_:ORDERS_SHIPPRIORITY,
                                                           _r10_:ORDERS_COMMENT} in 
          (insert_ORDERS_do_corrective_s7_m_QUERY3_mORDERS1, me)<- {_r1_:compute_vid,
                                                                    _r2_:ORDERS_ORDERKEY,
                                                                    _r3_:ORDERS_CUSTKEY,
                                                                    _r4_:ORDERS_ORDERSTATUS,
                                                                    _r5_:ORDERS_TOTALPRICE,
                                                                    _r6_:ORDERS_ORDERDATE,
                                                                    _r7_:ORDERS_ORDERPRIORITY,
                                                                    _r8_:ORDERS_CLERK,
                                                                    _r9_:ORDERS_SHIPPRIORITY,
                                                                    _r10_:ORDERS_COMMENT,
                                                                    _r11_:delta_tuples}
        else ()))
    ))

trigger insert_ORDERS_rcv_corrective_s9_m_QUERY3_mORDERS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mORDERS3_s9_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 9))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:9, _r3_:0}
        then
          bind log_get_bound_insert_ORDERS compute_vid as {_r1_:vid,
                                                           _r2_:ORDERS_ORDERKEY,
                                                           _r3_:ORDERS_CUSTKEY,
                                                           _r4_:ORDERS_ORDERSTATUS,
                                                           _r5_:ORDERS_TOTALPRICE,
                                                           _r6_:ORDERS_ORDERDATE,
                                                           _r7_:ORDERS_ORDERPRIORITY,
                                                           _r8_:ORDERS_CLERK,
                                                           _r9_:ORDERS_SHIPPRIORITY,
                                                           _r10_:ORDERS_COMMENT} in 
          (insert_ORDERS_do_corrective_s9_m_QUERY3_mORDERS3, me)<- {_r1_:compute_vid,
                                                                    _r2_:ORDERS_ORDERKEY,
                                                                    _r3_:ORDERS_CUSTKEY,
                                                                    _r4_:ORDERS_ORDERSTATUS,
                                                                    _r5_:ORDERS_TOTALPRICE,
                                                                    _r6_:ORDERS_ORDERDATE,
                                                                    _r7_:ORDERS_ORDERPRIORITY,
                                                                    _r8_:ORDERS_CLERK,
                                                                    _r9_:ORDERS_SHIPPRIORITY,
                                                                    _r10_:ORDERS_COMMENT,
                                                                    _r11_:delta_tuples}
        else ()))
    ))

trigger insert_ORDERS_rcv_corrective_s10_m_QUERY3_mORDERS6 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mORDERS6_s10_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 10))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:10, _r3_:0}
        then
          bind log_get_bound_insert_ORDERS compute_vid as {_r1_:vid,
                                                           _r2_:ORDERS_ORDERKEY,
                                                           _r3_:ORDERS_CUSTKEY,
                                                           _r4_:ORDERS_ORDERSTATUS,
                                                           _r5_:ORDERS_TOTALPRICE,
                                                           _r6_:ORDERS_ORDERDATE,
                                                           _r7_:ORDERS_ORDERPRIORITY,
                                                           _r8_:ORDERS_CLERK,
                                                           _r9_:ORDERS_SHIPPRIORITY,
                                                           _r10_:ORDERS_COMMENT} in 
          (insert_ORDERS_do_corrective_s10_m_QUERY3_mORDERS6, me)<- {
            _r1_:compute_vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
            _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
            _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
            _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY, _r10_:ORDERS_COMMENT,
            _r11_:delta_tuples}
        else ()))
    ))

trigger insert_ORDERS_do_corrective_s6_m_QUERY3_mORDERS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string,
_r11_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT, _r11_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mORDERSORDERS_CUSTKEY,
                      _r3_:delta_QUERY3_mORDERS1} in 
        let existing_out_tier = QUERY3 in
        let __prod_ret__76 =
          (((if ORDERS_CUSTKEY == delta_QUERY3_mORDERSORDERS_CUSTKEY
             then 1
             else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
          (((let wrapped_lookup_value =
               bind (map_QUERY3_mORDERS3_s6_buf.filter
                      ((\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == ORDERS_ORDERKEY))).fold
                      ((\_b2_ ->
                      bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {key:map_vid, value:vid}
                        then
                          if vid_eq {key:map_vid, value:max_vid}
                          then
                            {key:({| key:int, value:real |
                             {key:__map_0, value:__map_val}|} @ { Set }).combine
                             acc, value:max_vid}
                          else
                            if vid_gt {key:map_vid, value:max_vid}
                            then
                              {key:{| key:int, value:real |
                               {key:__map_0, value:__map_val}|} @ { Set },
                               value:map_vid}
                            else {key:acc, value:max_vid}
                        else {key:acc, value:max_vid})))
                      {key:empty { key:int, value:real } @ { Set },
                       value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
               __1 in
          if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
          then 0
          else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
            { None -> error () } as {key:_, value:projected_field} in 
            projected_field) * -1) +
          let wrapped_lookup_value =
            bind (map_QUERY3_mORDERS6_s6_buf.filter
                   ((\_b1_ -> 
                     bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                     ORDERS_ORDERKEY))).fold
                   ((\_b2_ ->
                   bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                     bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                     if vid_lt {key:map_vid, value:vid}
                     then
                       if vid_eq {key:map_vid, value:max_vid}
                       then
                         {key:({| key:int, value:real |
                          {key:__map_0, value:__map_val}|} @ { Set }).combine
                          acc, value:max_vid}
                       else
                         if vid_gt {key:map_vid, value:max_vid}
                         then
                           {key:{| key:int, value:real |
                            {key:__map_0, value:__map_val}|} @ { Set },
                            value:map_vid}
                         else {key:acc, value:max_vid}
                     else {key:acc, value:max_vid})))
                   {key:empty { key:int, value:real } @ { Set },
                    value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
            __1 in
          if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
          then 0
          else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
            { None -> error () } as {key:_, value:projected_field} in 
            projected_field)) * delta_QUERY3_mORDERS1 in (
          cond_add_delta_to_QUERY3
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:real |
             {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
              _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__76}|} @ { Set }}
          ))))

trigger insert_ORDERS_do_corrective_s6_m_QUERY3_mORDERS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string,
_r11_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
} @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT, _r11_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mORDERSORDERS_ORDERKEY,
                      _r3_:delta_QUERY3_mORDERS3} in 
        let existing_out_tier = QUERY3 in
        let __prod_ret__88 =
          (((if ORDERS_ORDERKEY == delta_QUERY3_mORDERSORDERS_ORDERKEY
             then 1
             else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
          let wrapped_lookup_value =
            bind (map_QUERY3_mORDERS1_s6_buf.filter
                   ((\_b1_ -> 
                     bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                     ORDERS_CUSTKEY))).fold
                   ((\_b2_ ->
                   bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                     bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                     if vid_lt {key:map_vid, value:vid}
                     then
                       if vid_eq {key:map_vid, value:max_vid}
                       then
                         {key:({| key:int, value:int |
                          {key:__map_0, value:__map_val}|} @ { Set }).combine
                          acc, value:max_vid}
                       else
                         if vid_gt {key:map_vid, value:max_vid}
                         then
                           {key:{| key:int, value:int |
                            {key:__map_0, value:__map_val}|} @ { Set },
                            value:map_vid}
                         else {key:acc, value:max_vid}
                     else {key:acc, value:max_vid})))
                   {key:empty { key:int, value:int } @ { Set },
                    value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
            __1 in
          if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
          then 0
          else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
            { None -> error () } as {key:_, value:projected_field} in 
            projected_field) * -delta_QUERY3_mORDERS3 in (
          cond_add_delta_to_QUERY3
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:real |
             {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
              _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__88}|} @ { Set }}
          ))))

trigger insert_ORDERS_do_corrective_s6_m_QUERY3_mORDERS6 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string,
_r11_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
} @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT, _r11_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mORDERSORDERS_ORDERKEY,
                      _r3_:delta_QUERY3_mORDERS6} in 
        let existing_out_tier = QUERY3 in
        let __prod_ret__99 =
          (((if ORDERS_ORDERKEY == delta_QUERY3_mORDERSORDERS_ORDERKEY
             then 1
             else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
          let wrapped_lookup_value =
            bind (map_QUERY3_mORDERS1_s6_buf.filter
                   ((\_b1_ -> 
                     bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                     ORDERS_CUSTKEY))).fold
                   ((\_b2_ ->
                   bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                     bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                     if vid_lt {key:map_vid, value:vid}
                     then
                       if vid_eq {key:map_vid, value:max_vid}
                       then
                         {key:({| key:int, value:int |
                          {key:__map_0, value:__map_val}|} @ { Set }).combine
                          acc, value:max_vid}
                       else
                         if vid_gt {key:map_vid, value:max_vid}
                         then
                           {key:{| key:int, value:int |
                            {key:__map_0, value:__map_val}|} @ { Set },
                            value:map_vid}
                         else {key:acc, value:max_vid}
                     else {key:acc, value:max_vid})))
                   {key:empty { key:int, value:int } @ { Set },
                    value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
            __1 in
          if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
          then 0
          else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
            { None -> error () } as {key:_, value:projected_field} in 
            projected_field) * delta_QUERY3_mORDERS6 in (
          cond_add_delta_to_QUERY3
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:real |
             {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
              _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__99}|} @ { Set }}
          ))))

trigger insert_ORDERS_do_corrective_s7_m_QUERY3_mORDERS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string,
_r11_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT, _r11_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mORDERSORDERS_CUSTKEY,
                      _r3_:delta_QUERY3_mORDERS1} in 
        let existing_out_tier = QUERY3_mLINEITEM1 in
        let __prod_ret__78 =
          ((if ORDERS_CUSTKEY == delta_QUERY3_mORDERSORDERS_CUSTKEY
            then 1
            else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
          delta_QUERY3_mORDERS1 in (
          cond_add_delta_to_QUERY3_mLINEITEM1
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int |
             {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
              _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__78}|} @ { Set }};
          (QUERY3_mLINEITEM1_send_correctives, me)<- {key:vid, value:{|
                                                      _r1_:{
                                                      _r1_:int, _r2_:int,
                                                      _r3_:int }, _r2_:int,
                                                      _r3_:int, _r4_:int,
                                                      _r5_:int |
                                                      {_r1_:vid,
                                                       _r2_:ORDERS_ORDERKEY,
                                                       _r3_:ORDERS_ORDERDATE,
                                                       _r4_:ORDERS_SHIPPRIORITY,
                                                       _r5_:__prod_ret__78}|} @ { Set }}
          ))))

trigger insert_ORDERS_do_corrective_s9_m_QUERY3_mORDERS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string,
_r11_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
} @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT, _r11_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mORDERSORDERS_ORDERKEY,
                      _r3_:delta_QUERY3_mORDERS3} in 
        let existing_out_tier = QUERY3_mCUSTOMER2 in
        let __prod_ret__90 =
          ((if ORDERS_ORDERKEY == delta_QUERY3_mORDERSORDERS_ORDERKEY
            then 1
            else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
          delta_QUERY3_mORDERS3 in (
          cond_add_delta_to_QUERY3_mCUSTOMER2
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:real |
             {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
              _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
              _r6_:__prod_ret__90}|} @ { Set }};
          (QUERY3_mCUSTOMER2_send_correctives, me)<- {key:vid, value:{|
                                                      _r1_:{
                                                      _r1_:int, _r2_:int,
                                                      _r3_:int }, _r2_:int,
                                                      _r3_:int, _r4_:int,
                                                      _r5_:int, _r6_:real |
                                                      {_r1_:vid,
                                                       _r2_:ORDERS_ORDERKEY,
                                                       _r3_:ORDERS_ORDERDATE,
                                                       _r4_:ORDERS_SHIPPRIORITY,
                                                       _r5_:ORDERS_CUSTKEY,
                                                       _r6_:__prod_ret__90}|} @ { Set }}
          ))))

trigger insert_ORDERS_do_corrective_s10_m_QUERY3_mORDERS6 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string,
_r11_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
} @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT, _r11_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mORDERSORDERS_ORDERKEY,
                      _r3_:delta_QUERY3_mORDERS6} in 
        let existing_out_tier = QUERY3_mCUSTOMER4 in
        let __prod_ret__101 =
          ((if ORDERS_ORDERKEY == delta_QUERY3_mORDERSORDERS_ORDERKEY
            then 1
            else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
          delta_QUERY3_mORDERS6 in (
          cond_add_delta_to_QUERY3_mCUSTOMER4
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:real |
             {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
              _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
              _r6_:__prod_ret__101}|} @ { Set }};
          (QUERY3_mCUSTOMER4_send_correctives, me)<- {key:vid, value:{|
                                                      _r1_:{
                                                      _r1_:int, _r2_:int,
                                                      _r3_:int }, _r2_:int,
                                                      _r3_:int, _r4_:int,
                                                      _r5_:int, _r6_:real |
                                                      {_r1_:vid,
                                                       _r2_:ORDERS_ORDERKEY,
                                                       _r3_:ORDERS_ORDERDATE,
                                                       _r4_:ORDERS_SHIPPRIORITY,
                                                       _r5_:ORDERS_CUSTKEY,
                                                       _r6_:__prod_ret__101}|} @ { Set }}
          ))))

trigger delete_ORDERS : {
_r1_:int, _r2_:int, _r3_:string, _r4_:real, _r5_:int, _r6_:string, _r7_:string,
_r8_:int, _r9_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:ORDERS_ORDERKEY, _r2_:ORDERS_CUSTKEY,
                _r3_:ORDERS_ORDERSTATUS, _r4_:ORDERS_TOTALPRICE,
                _r5_:ORDERS_ORDERDATE, _r6_:ORDERS_ORDERPRIORITY,
                _r7_:ORDERS_CLERK, _r8_:ORDERS_SHIPPRIORITY,
                _r9_:ORDERS_COMMENT} in (
    let vid =
      {_r1_:case (__epoch__.peek ()) of { Some x -> x.i } { None -> error () },
       _r2_:case (__vid_counter__.peek ()) of { Some x -> x.i }
       { None -> error () }, _r3_:hash me} in
    (
      (delete_ORDERS_send_fetch, me)<- {_r1_:vid, _r2_:ORDERS_ORDERKEY,
                                        _r3_:ORDERS_CUSTKEY,
                                        _r4_:ORDERS_ORDERSTATUS,
                                        _r5_:ORDERS_TOTALPRICE,
                                        _r6_:ORDERS_ORDERDATE,
                                        _r7_:ORDERS_ORDERPRIORITY,
                                        _r8_:ORDERS_CLERK,
                                        _r9_:ORDERS_SHIPPRIORITY,
                                        _r10_:ORDERS_COMMENT};
      __vid_counter__.update
        ({i:case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
        ({i:1 + case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
      )
    ))

trigger delete_ORDERS_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                _r10_:ORDERS_COMMENT} in (
    (route_to_QUERY3_mLINEITEM1_mCUSTOMER2
       {_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
        _r3_:Some ORDERS_SHIPPRIORITY, _r4_:Some ORDERS_CUSTKEY}).iterate
      ((\_b1_ -> 
        bind _b1_ as {i:ip} in 
        (delete_ORDERS_do_complete_s13, ip)<- {_r1_:vid, _r2_:ORDERS_ORDERKEY,
                                               _r3_:ORDERS_CUSTKEY,
                                               _r4_:ORDERS_ORDERSTATUS,
                                               _r5_:ORDERS_TOTALPRICE,
                                               _r6_:ORDERS_ORDERDATE,
                                               _r7_:ORDERS_ORDERPRIORITY,
                                               _r8_:ORDERS_CLERK,
                                               _r9_:ORDERS_SHIPPRIORITY,
                                               _r10_:ORDERS_COMMENT}));
    ((((empty {
        _r1_:address, _r2_:int, _r3_:int
        } @ { Collection }).combine
        (let sender_count =
           (route_to_QUERY3_mORDERS3 (Some ORDERS_ORDERKEY)).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mORDERS3_QUERY3_0t0
            {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
                   _r3_:Some ORDERS_SHIPPRIORITY}, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
             } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:11, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mORDERS1 (Some ORDERS_CUSTKEY)).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mORDERS1_QUERY3
            {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
                   _r3_:Some ORDERS_SHIPPRIORITY}, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:11, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mORDERS6 (Some ORDERS_ORDERKEY)).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mORDERS6_QUERY3_0t0
            {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
                   _r3_:Some ORDERS_SHIPPRIORITY}, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
             } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:11, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mORDERS1 (Some ORDERS_CUSTKEY)).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mORDERS1_QUERY3_mLINEITEM1
            {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
                   _r3_:Some ORDERS_SHIPPRIORITY}, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:12, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mORDERS3 (Some ORDERS_ORDERKEY)).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mORDERS3_QUERY3_mCUSTOMER2_0t0
            {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
                   _r3_:Some ORDERS_SHIPPRIORITY, _r4_:Some ORDERS_CUSTKEY},
             _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
             } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:14, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mORDERS6 (Some ORDERS_ORDERKEY)).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        (shuffle_QUERY3_mORDERS6_QUERY3_mCUSTOMER4_0t0
           {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
                  _r3_:Some ORDERS_SHIPPRIORITY, _r4_:Some ORDERS_CUSTKEY},
            _r2_:empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
            } @ { Set }, _r3_:true}).map
          ((\_b1_ -> 
            bind _b1_ as {key:ip, value:tuples} in 
            {_r1_:ip, _r2_:15, _r3_:sender_count}))))))))).groupBy
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in 
          {key:ip, value:stmt_id})) ((\acc -> (\_b3_ -> 
          bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupBy
       ((\_b1_ -> 
         bind _b1_ as {key:_b2_, value:count} in 
         bind _b2_ as {key:ip, value:stmt_id} in ip)) ((\acc -> (\_b3_ -> 
         bind _b3_ as {key:ip_and_stmt_id, value:count} in 
         bind ip_and_stmt_id as {key:ip, value:stmt_id} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:count}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_id_cnt_list} in (
          (delete_ORDERS_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list,
                                         _r3_:vid, _r4_:ORDERS_ORDERKEY,
                                         _r5_:ORDERS_CUSTKEY,
                                         _r6_:ORDERS_ORDERSTATUS,
                                         _r7_:ORDERS_TOTALPRICE,
                                         _r8_:ORDERS_ORDERDATE,
                                         _r9_:ORDERS_ORDERPRIORITY,
                                         _r10_:ORDERS_CLERK,
                                         _r11_:ORDERS_SHIPPRIORITY,
                                         _r12_:ORDERS_COMMENT}
          )));
    ((((route_to_QUERY3_mORDERS6 (Some ORDERS_ORDERKEY)).map
         ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:15, _r2_:6, _r3_:ip}))).combine
       (((route_to_QUERY3_mORDERS3 (Some ORDERS_ORDERKEY)).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:14, _r2_:5, _r3_:ip}))).combine
       (((route_to_QUERY3_mORDERS1 (Some ORDERS_CUSTKEY)).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:12, _r2_:4, _r3_:ip}))).combine
       (((route_to_QUERY3_mORDERS6 (Some ORDERS_ORDERKEY)).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:11, _r2_:6, _r3_:ip}))).combine
       (((route_to_QUERY3_mORDERS3 (Some ORDERS_ORDERKEY)).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:11, _r2_:5, _r3_:ip}))).combine
       (((route_to_QUERY3_mORDERS1 (Some ORDERS_CUSTKEY)).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:11, _r2_:4, _r3_:ip}))).combine
       empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection })))))).groupBy
       ((\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip))
       ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:map_id}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_map_ids} in 
        (delete_ORDERS_rcv_fetch, ip)<- {_r1_:stmt_map_ids, _r2_:vid,
                                         _r3_:ORDERS_ORDERKEY,
                                         _r4_:ORDERS_CUSTKEY,
                                         _r5_:ORDERS_ORDERSTATUS,
                                         _r6_:ORDERS_TOTALPRICE,
                                         _r7_:ORDERS_ORDERDATE,
                                         _r8_:ORDERS_ORDERPRIORITY,
                                         _r9_:ORDERS_CLERK,
                                         _r10_:ORDERS_SHIPPRIORITY,
                                         _r11_:ORDERS_COMMENT}))
    ))

trigger delete_ORDERS_rcv_put : {
_r1_:address, _r2_:collection { key:int, value:int } @ { Set }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int, _r6_:string, _r7_:real,
_r8_:int, _r9_:string, _r10_:string, _r11_:int, _r12_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid,
                _r4_:ORDERS_ORDERKEY, _r5_:ORDERS_CUSTKEY,
                _r6_:ORDERS_ORDERSTATUS, _r7_:ORDERS_TOTALPRICE,
                _r8_:ORDERS_ORDERDATE, _r9_:ORDERS_ORDERPRIORITY,
                _r10_:ORDERS_CLERK, _r11_:ORDERS_SHIPPRIORITY,
                _r12_:ORDERS_COMMENT} in (
    stmt_id_cnt_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:count} in 
        if __stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:_, _r2_:_, _r3_:old_count} in 
          let new_count = old_count + count in (
            __stmt_cntrs__.update
              {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
              {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
            if new_count == 0
            then
              if stmt_id == 15
              then
                (delete_ORDERS_do_complete_s15, me)<- {_r1_:vid,
                                                       _r2_:ORDERS_ORDERKEY,
                                                       _r3_:ORDERS_CUSTKEY,
                                                       _r4_:ORDERS_ORDERSTATUS,
                                                       _r5_:ORDERS_TOTALPRICE,
                                                       _r6_:ORDERS_ORDERDATE,
                                                       _r7_:ORDERS_ORDERPRIORITY,
                                                       _r8_:ORDERS_CLERK,
                                                       _r9_:ORDERS_SHIPPRIORITY,
                                                       _r10_:ORDERS_COMMENT}
              else
                if stmt_id == 14
                then
                  (delete_ORDERS_do_complete_s14, me)<- {_r1_:vid,
                                                         _r2_:ORDERS_ORDERKEY,
                                                         _r3_:ORDERS_CUSTKEY,
                                                         _r4_:ORDERS_ORDERSTATUS,
                                                         _r5_:ORDERS_TOTALPRICE,
                                                         _r6_:ORDERS_ORDERDATE,
                                                         _r7_:ORDERS_ORDERPRIORITY,
                                                         _r8_:ORDERS_CLERK,
                                                         _r9_:ORDERS_SHIPPRIORITY,
                                                         _r10_:ORDERS_COMMENT}
                else
                  if stmt_id == 13
                  then
                    (delete_ORDERS_do_complete_s13, me)<- {_r1_:vid,
                                                           _r2_:ORDERS_ORDERKEY,
                                                           _r3_:ORDERS_CUSTKEY,
                                                           _r4_:ORDERS_ORDERSTATUS,
                                                           _r5_:ORDERS_TOTALPRICE,
                                                           _r6_:ORDERS_ORDERDATE,
                                                           _r7_:ORDERS_ORDERPRIORITY,
                                                           _r8_:ORDERS_CLERK,
                                                           _r9_:ORDERS_SHIPPRIORITY,
                                                           _r10_:ORDERS_COMMENT}
                  else
                    if stmt_id == 12
                    then
                      (delete_ORDERS_do_complete_s12, me)<- {_r1_:vid,
                                                             _r2_:ORDERS_ORDERKEY,
                                                             _r3_:ORDERS_CUSTKEY,
                                                             _r4_:ORDERS_ORDERSTATUS,
                                                             _r5_:ORDERS_TOTALPRICE,
                                                             _r6_:ORDERS_ORDERDATE,
                                                             _r7_:ORDERS_ORDERPRIORITY,
                                                             _r8_:ORDERS_CLERK,
                                                             _r9_:ORDERS_SHIPPRIORITY,
                                                             _r10_:ORDERS_COMMENT}
                    else
                      if stmt_id == 11
                      then
                        (delete_ORDERS_do_complete_s11, me)<- {_r1_:vid,
                                                               _r2_:ORDERS_ORDERKEY,
                                                               _r3_:ORDERS_CUSTKEY,
                                                               _r4_:ORDERS_ORDERSTATUS,
                                                               _r5_:ORDERS_TOTALPRICE,
                                                               _r6_:ORDERS_ORDERDATE,
                                                               _r7_:ORDERS_ORDERPRIORITY,
                                                               _r8_:ORDERS_CLERK,
                                                               _r9_:ORDERS_SHIPPRIORITY,
                                                               _r10_:ORDERS_COMMENT}
                      else ()
            else ()
            )
        else __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count}))
    ))

trigger delete_ORDERS_rcv_fetch : {
_r1_:collection { key:int, value:int } @ { Set }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int, _r5_:string, _r6_:real,
_r7_:int, _r8_:string, _r9_:string, _r10_:int, _r11_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:ORDERS_ORDERKEY,
                _r4_:ORDERS_CUSTKEY, _r5_:ORDERS_ORDERSTATUS,
                _r6_:ORDERS_TOTALPRICE, _r7_:ORDERS_ORDERDATE,
                _r8_:ORDERS_ORDERPRIORITY, _r9_:ORDERS_CLERK,
                _r10_:ORDERS_SHIPPRIORITY, _r11_:ORDERS_COMMENT} in (
    log_write_delete_ORDERS
      {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
       _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE, _r6_:ORDERS_ORDERDATE,
       _r7_:ORDERS_ORDERPRIORITY, _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
       _r10_:ORDERS_COMMENT};
    stmts_and_map_ids.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:map_id} in 
        if stmt_id == 11
        then
          if map_id == 4
          then
            (delete_ORDERS_send_push_s11_m_QUERY3_mORDERS1, me)<- {_r1_:vid,
                                                                   _r2_:ORDERS_ORDERKEY,
                                                                   _r3_:ORDERS_CUSTKEY,
                                                                   _r4_:ORDERS_ORDERSTATUS,
                                                                   _r5_:ORDERS_TOTALPRICE,
                                                                   _r6_:ORDERS_ORDERDATE,
                                                                   _r7_:ORDERS_ORDERPRIORITY,
                                                                   _r8_:ORDERS_CLERK,
                                                                   _r9_:ORDERS_SHIPPRIORITY,
                                                                   _r10_:ORDERS_COMMENT}
          else
            if map_id == 5
            then
              (delete_ORDERS_send_push_s11_m_QUERY3_mORDERS3, me)<- {
                _r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                _r10_:ORDERS_COMMENT}
            else
              if map_id == 6
              then
                (delete_ORDERS_send_push_s11_m_QUERY3_mORDERS6, me)<- {
                  _r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT}
              else ()
        else
          if stmt_id == 12
          then
            if map_id == 4
            then
              (delete_ORDERS_send_push_s12_m_QUERY3_mORDERS1, me)<- {
                _r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                _r10_:ORDERS_COMMENT}
            else ()
          else
            if stmt_id == 14
            then
              if map_id == 5
              then
                (delete_ORDERS_send_push_s14_m_QUERY3_mORDERS3, me)<- {
                  _r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT}
              else ()
            else
              if stmt_id == 15
              then
                if map_id == 6
                then
                  (delete_ORDERS_send_push_s15_m_QUERY3_mORDERS6, me)<- {
                    _r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                    _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                    _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                    _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                    _r10_:ORDERS_COMMENT}
                else ()
              else ()))
    ))

trigger delete_ORDERS_send_push_s11_m_QUERY3_mORDERS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                _r10_:ORDERS_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:3, _r3_:11};
    (shuffle_QUERY3_mORDERS3_QUERY3_0t0
       {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
              _r3_:Some ORDERS_SHIPPRIORITY},
        _r2_:bind (QUERY3_mORDERS3.filter
                    ((\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      ORDERS_ORDERKEY))).fold
                    ((\_b2_ ->
                    bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {key:map_vid, value:vid}
                      then
                        if vid_eq {key:map_vid, value:max_vid}
                        then
                          {key:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:real |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, value:max_vid}
                        else
                          if vid_gt {key:map_vid, value:max_vid}
                          then
                            {key:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:real |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             value:map_vid}
                          else {key:acc, value:max_vid}
                      else {key:acc, value:max_vid})))
                    {key:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                     } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
        key:__1, value:__2} in __1, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_ORDERS_rcv_push_s11_m_QUERY3_mORDERS3, ip)<- {_r1_:tuples,
                                                              _r2_:vid,
                                                              _r3_:ORDERS_ORDERKEY,
                                                              _r4_:ORDERS_CUSTKEY,
                                                              _r5_:ORDERS_ORDERSTATUS,
                                                              _r6_:ORDERS_TOTALPRICE,
                                                              _r7_:ORDERS_ORDERDATE,
                                                              _r8_:ORDERS_ORDERPRIORITY,
                                                              _r9_:ORDERS_CLERK,
                                                              _r10_:ORDERS_SHIPPRIORITY,
                                                              _r11_:ORDERS_COMMENT}))
    ))

trigger delete_ORDERS_send_push_s11_m_QUERY3_mORDERS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                _r10_:ORDERS_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:3, _r3_:11};
    (shuffle_QUERY3_mORDERS1_QUERY3
       {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
              _r3_:Some ORDERS_SHIPPRIORITY},
        _r2_:bind (QUERY3_mORDERS1.filter
                    ((\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      ORDERS_CUSTKEY))).fold
                    ((\_b2_ ->
                    bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {key:map_vid, value:vid}
                      then
                        if vid_eq {key:map_vid, value:max_vid}
                        then
                          {key:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:int |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, value:max_vid}
                        else
                          if vid_gt {key:map_vid, value:max_vid}
                          then
                            {key:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:int |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             value:map_vid}
                          else {key:acc, value:max_vid}
                      else {key:acc, value:max_vid})))
                    {key:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                     } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
        key:__1, value:__2} in __1, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_ORDERS_rcv_push_s11_m_QUERY3_mORDERS1, ip)<- {_r1_:tuples,
                                                              _r2_:vid,
                                                              _r3_:ORDERS_ORDERKEY,
                                                              _r4_:ORDERS_CUSTKEY,
                                                              _r5_:ORDERS_ORDERSTATUS,
                                                              _r6_:ORDERS_TOTALPRICE,
                                                              _r7_:ORDERS_ORDERDATE,
                                                              _r8_:ORDERS_ORDERPRIORITY,
                                                              _r9_:ORDERS_CLERK,
                                                              _r10_:ORDERS_SHIPPRIORITY,
                                                              _r11_:ORDERS_COMMENT}))
    ))

trigger delete_ORDERS_send_push_s11_m_QUERY3_mORDERS6 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                _r10_:ORDERS_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:3, _r3_:11};
    (shuffle_QUERY3_mORDERS6_QUERY3_0t0
       {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
              _r3_:Some ORDERS_SHIPPRIORITY},
        _r2_:bind (QUERY3_mORDERS6.filter
                    ((\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      ORDERS_ORDERKEY))).fold
                    ((\_b2_ ->
                    bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {key:map_vid, value:vid}
                      then
                        if vid_eq {key:map_vid, value:max_vid}
                        then
                          {key:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:real |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, value:max_vid}
                        else
                          if vid_gt {key:map_vid, value:max_vid}
                          then
                            {key:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:real |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             value:map_vid}
                          else {key:acc, value:max_vid}
                      else {key:acc, value:max_vid})))
                    {key:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                     } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
        key:__1, value:__2} in __1, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_ORDERS_rcv_push_s11_m_QUERY3_mORDERS6, ip)<- {_r1_:tuples,
                                                              _r2_:vid,
                                                              _r3_:ORDERS_ORDERKEY,
                                                              _r4_:ORDERS_CUSTKEY,
                                                              _r5_:ORDERS_ORDERSTATUS,
                                                              _r6_:ORDERS_TOTALPRICE,
                                                              _r7_:ORDERS_ORDERDATE,
                                                              _r8_:ORDERS_ORDERPRIORITY,
                                                              _r9_:ORDERS_CLERK,
                                                              _r10_:ORDERS_SHIPPRIORITY,
                                                              _r11_:ORDERS_COMMENT}))
    ))

trigger delete_ORDERS_send_push_s12_m_QUERY3_mORDERS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                _r10_:ORDERS_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:3, _r3_:12};
    (shuffle_QUERY3_mORDERS1_QUERY3_mLINEITEM1
       {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
              _r3_:Some ORDERS_SHIPPRIORITY},
        _r2_:bind (QUERY3_mORDERS1.filter
                    ((\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      ORDERS_CUSTKEY))).fold
                    ((\_b2_ ->
                    bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {key:map_vid, value:vid}
                      then
                        if vid_eq {key:map_vid, value:max_vid}
                        then
                          {key:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:int |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, value:max_vid}
                        else
                          if vid_gt {key:map_vid, value:max_vid}
                          then
                            {key:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:int |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             value:map_vid}
                          else {key:acc, value:max_vid}
                      else {key:acc, value:max_vid})))
                    {key:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                     } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
        key:__1, value:__2} in __1, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_ORDERS_rcv_push_s12_m_QUERY3_mORDERS1, ip)<- {_r1_:tuples,
                                                              _r2_:vid,
                                                              _r3_:ORDERS_ORDERKEY,
                                                              _r4_:ORDERS_CUSTKEY,
                                                              _r5_:ORDERS_ORDERSTATUS,
                                                              _r6_:ORDERS_TOTALPRICE,
                                                              _r7_:ORDERS_ORDERDATE,
                                                              _r8_:ORDERS_ORDERPRIORITY,
                                                              _r9_:ORDERS_CLERK,
                                                              _r10_:ORDERS_SHIPPRIORITY,
                                                              _r11_:ORDERS_COMMENT}))
    ))

trigger delete_ORDERS_send_push_s14_m_QUERY3_mORDERS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                _r10_:ORDERS_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:3, _r3_:14};
    (shuffle_QUERY3_mORDERS3_QUERY3_mCUSTOMER2_0t0
       {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
              _r3_:Some ORDERS_SHIPPRIORITY, _r4_:Some ORDERS_CUSTKEY},
        _r2_:bind (QUERY3_mORDERS3.filter
                    ((\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      ORDERS_ORDERKEY))).fold
                    ((\_b2_ ->
                    bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {key:map_vid, value:vid}
                      then
                        if vid_eq {key:map_vid, value:max_vid}
                        then
                          {key:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:real |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, value:max_vid}
                        else
                          if vid_gt {key:map_vid, value:max_vid}
                          then
                            {key:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:real |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             value:map_vid}
                          else {key:acc, value:max_vid}
                      else {key:acc, value:max_vid})))
                    {key:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                     } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
        key:__1, value:__2} in __1, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_ORDERS_rcv_push_s14_m_QUERY3_mORDERS3, ip)<- {_r1_:tuples,
                                                              _r2_:vid,
                                                              _r3_:ORDERS_ORDERKEY,
                                                              _r4_:ORDERS_CUSTKEY,
                                                              _r5_:ORDERS_ORDERSTATUS,
                                                              _r6_:ORDERS_TOTALPRICE,
                                                              _r7_:ORDERS_ORDERDATE,
                                                              _r8_:ORDERS_ORDERPRIORITY,
                                                              _r9_:ORDERS_CLERK,
                                                              _r10_:ORDERS_SHIPPRIORITY,
                                                              _r11_:ORDERS_COMMENT}))
    ))

trigger delete_ORDERS_send_push_s15_m_QUERY3_mORDERS6 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                _r10_:ORDERS_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:3, _r3_:15};
    (shuffle_QUERY3_mORDERS6_QUERY3_mCUSTOMER4_0t0
       {_r1_:{_r1_:Some ORDERS_ORDERKEY, _r2_:Some ORDERS_ORDERDATE,
              _r3_:Some ORDERS_SHIPPRIORITY, _r4_:Some ORDERS_CUSTKEY},
        _r2_:bind (QUERY3_mORDERS6.filter
                    ((\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      ORDERS_ORDERKEY))).fold
                    ((\_b2_ ->
                    bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {key:map_vid, value:vid}
                      then
                        if vid_eq {key:map_vid, value:max_vid}
                        then
                          {key:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:real |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, value:max_vid}
                        else
                          if vid_gt {key:map_vid, value:max_vid}
                          then
                            {key:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:real |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             value:map_vid}
                          else {key:acc, value:max_vid}
                      else {key:acc, value:max_vid})))
                    {key:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                     } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}} as {
        key:__1, value:__2} in __1, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_ORDERS_rcv_push_s15_m_QUERY3_mORDERS6, ip)<- {_r1_:tuples,
                                                              _r2_:vid,
                                                              _r3_:ORDERS_ORDERKEY,
                                                              _r4_:ORDERS_CUSTKEY,
                                                              _r5_:ORDERS_ORDERSTATUS,
                                                              _r6_:ORDERS_TOTALPRICE,
                                                              _r7_:ORDERS_ORDERDATE,
                                                              _r8_:ORDERS_ORDERPRIORITY,
                                                              _r9_:ORDERS_CLERK,
                                                              _r10_:ORDERS_SHIPPRIORITY,
                                                              _r11_:ORDERS_COMMENT}))
    ))

trigger delete_ORDERS_rcv_push_s11_m_QUERY3_mORDERS1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int,
_r5_:string, _r6_:real, _r7_:int, _r8_:string, _r9_:string, _r10_:int,
_r11_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:ORDERS_ORDERKEY,
                _r4_:ORDERS_CUSTKEY, _r5_:ORDERS_ORDERSTATUS,
                _r6_:ORDERS_TOTALPRICE, _r7_:ORDERS_ORDERDATE,
                _r8_:ORDERS_ORDERPRIORITY, _r9_:ORDERS_CLERK,
                _r10_:ORDERS_SHIPPRIORITY, _r11_:ORDERS_COMMENT} in (
    log_write_delete_ORDERS
      {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
       _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE, _r6_:ORDERS_ORDERDATE,
       _r7_:ORDERS_ORDERPRIORITY, _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
       _r10_:ORDERS_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mORDERS1_s11_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then
          map_QUERY3_mORDERS1_s11_buf.update
            (case ((map_QUERY3_mORDERS1_s11_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mORDERS1_s11_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 11)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 11))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 11))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:11, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 11))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:11, _r3_:0}
        then
          (delete_ORDERS_do_complete_s11, me)<- {_r1_:vid,
                                                 _r2_:ORDERS_ORDERKEY,
                                                 _r3_:ORDERS_CUSTKEY,
                                                 _r4_:ORDERS_ORDERSTATUS,
                                                 _r5_:ORDERS_TOTALPRICE,
                                                 _r6_:ORDERS_ORDERDATE,
                                                 _r7_:ORDERS_ORDERPRIORITY,
                                                 _r8_:ORDERS_CLERK,
                                                 _r9_:ORDERS_SHIPPRIORITY,
                                                 _r10_:ORDERS_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:11, _r3_:-1}
    ))

trigger delete_ORDERS_rcv_push_s11_m_QUERY3_mORDERS3 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int,
_r5_:string, _r6_:real, _r7_:int, _r8_:string, _r9_:string, _r10_:int,
_r11_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:ORDERS_ORDERKEY,
                _r4_:ORDERS_CUSTKEY, _r5_:ORDERS_ORDERSTATUS,
                _r6_:ORDERS_TOTALPRICE, _r7_:ORDERS_ORDERDATE,
                _r8_:ORDERS_ORDERPRIORITY, _r9_:ORDERS_CLERK,
                _r10_:ORDERS_SHIPPRIORITY, _r11_:ORDERS_COMMENT} in (
    log_write_delete_ORDERS
      {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
       _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE, _r6_:ORDERS_ORDERDATE,
       _r7_:ORDERS_ORDERPRIORITY, _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
       _r10_:ORDERS_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mORDERS3_s11_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
          } @ { Set }
        then
          map_QUERY3_mORDERS3_s11_buf.update
            (case ((map_QUERY3_mORDERS3_s11_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mORDERS3_s11_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 11)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 11))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 11))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:11, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 11))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:11, _r3_:0}
        then
          (delete_ORDERS_do_complete_s11, me)<- {_r1_:vid,
                                                 _r2_:ORDERS_ORDERKEY,
                                                 _r3_:ORDERS_CUSTKEY,
                                                 _r4_:ORDERS_ORDERSTATUS,
                                                 _r5_:ORDERS_TOTALPRICE,
                                                 _r6_:ORDERS_ORDERDATE,
                                                 _r7_:ORDERS_ORDERPRIORITY,
                                                 _r8_:ORDERS_CLERK,
                                                 _r9_:ORDERS_SHIPPRIORITY,
                                                 _r10_:ORDERS_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:11, _r3_:-1}
    ))

trigger delete_ORDERS_rcv_push_s11_m_QUERY3_mORDERS6 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int,
_r5_:string, _r6_:real, _r7_:int, _r8_:string, _r9_:string, _r10_:int,
_r11_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:ORDERS_ORDERKEY,
                _r4_:ORDERS_CUSTKEY, _r5_:ORDERS_ORDERSTATUS,
                _r6_:ORDERS_TOTALPRICE, _r7_:ORDERS_ORDERDATE,
                _r8_:ORDERS_ORDERPRIORITY, _r9_:ORDERS_CLERK,
                _r10_:ORDERS_SHIPPRIORITY, _r11_:ORDERS_COMMENT} in (
    log_write_delete_ORDERS
      {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
       _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE, _r6_:ORDERS_ORDERDATE,
       _r7_:ORDERS_ORDERPRIORITY, _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
       _r10_:ORDERS_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mORDERS6_s11_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
          } @ { Set }
        then
          map_QUERY3_mORDERS6_s11_buf.update
            (case ((map_QUERY3_mORDERS6_s11_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mORDERS6_s11_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 11)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 11))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 11))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:11, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 11))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:11, _r3_:0}
        then
          (delete_ORDERS_do_complete_s11, me)<- {_r1_:vid,
                                                 _r2_:ORDERS_ORDERKEY,
                                                 _r3_:ORDERS_CUSTKEY,
                                                 _r4_:ORDERS_ORDERSTATUS,
                                                 _r5_:ORDERS_TOTALPRICE,
                                                 _r6_:ORDERS_ORDERDATE,
                                                 _r7_:ORDERS_ORDERPRIORITY,
                                                 _r8_:ORDERS_CLERK,
                                                 _r9_:ORDERS_SHIPPRIORITY,
                                                 _r10_:ORDERS_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:11, _r3_:-1}
    ))

trigger delete_ORDERS_rcv_push_s12_m_QUERY3_mORDERS1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int,
_r5_:string, _r6_:real, _r7_:int, _r8_:string, _r9_:string, _r10_:int,
_r11_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:ORDERS_ORDERKEY,
                _r4_:ORDERS_CUSTKEY, _r5_:ORDERS_ORDERSTATUS,
                _r6_:ORDERS_TOTALPRICE, _r7_:ORDERS_ORDERDATE,
                _r8_:ORDERS_ORDERPRIORITY, _r9_:ORDERS_CLERK,
                _r10_:ORDERS_SHIPPRIORITY, _r11_:ORDERS_COMMENT} in (
    log_write_delete_ORDERS
      {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
       _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE, _r6_:ORDERS_ORDERDATE,
       _r7_:ORDERS_ORDERPRIORITY, _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
       _r10_:ORDERS_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mORDERS1_s12_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then
          map_QUERY3_mORDERS1_s12_buf.update
            (case ((map_QUERY3_mORDERS1_s12_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mORDERS1_s12_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 12)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 12))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 12))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:12, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 12))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:12, _r3_:0}
        then
          (delete_ORDERS_do_complete_s12, me)<- {_r1_:vid,
                                                 _r2_:ORDERS_ORDERKEY,
                                                 _r3_:ORDERS_CUSTKEY,
                                                 _r4_:ORDERS_ORDERSTATUS,
                                                 _r5_:ORDERS_TOTALPRICE,
                                                 _r6_:ORDERS_ORDERDATE,
                                                 _r7_:ORDERS_ORDERPRIORITY,
                                                 _r8_:ORDERS_CLERK,
                                                 _r9_:ORDERS_SHIPPRIORITY,
                                                 _r10_:ORDERS_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:12, _r3_:-1}
    ))

trigger delete_ORDERS_rcv_push_s14_m_QUERY3_mORDERS3 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int,
_r5_:string, _r6_:real, _r7_:int, _r8_:string, _r9_:string, _r10_:int,
_r11_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:ORDERS_ORDERKEY,
                _r4_:ORDERS_CUSTKEY, _r5_:ORDERS_ORDERSTATUS,
                _r6_:ORDERS_TOTALPRICE, _r7_:ORDERS_ORDERDATE,
                _r8_:ORDERS_ORDERPRIORITY, _r9_:ORDERS_CLERK,
                _r10_:ORDERS_SHIPPRIORITY, _r11_:ORDERS_COMMENT} in (
    log_write_delete_ORDERS
      {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
       _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE, _r6_:ORDERS_ORDERDATE,
       _r7_:ORDERS_ORDERPRIORITY, _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
       _r10_:ORDERS_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mORDERS3_s14_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
          } @ { Set }
        then
          map_QUERY3_mORDERS3_s14_buf.update
            (case ((map_QUERY3_mORDERS3_s14_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mORDERS3_s14_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 14)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 14))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 14))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:14, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 14))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:14, _r3_:0}
        then
          (delete_ORDERS_do_complete_s14, me)<- {_r1_:vid,
                                                 _r2_:ORDERS_ORDERKEY,
                                                 _r3_:ORDERS_CUSTKEY,
                                                 _r4_:ORDERS_ORDERSTATUS,
                                                 _r5_:ORDERS_TOTALPRICE,
                                                 _r6_:ORDERS_ORDERDATE,
                                                 _r7_:ORDERS_ORDERPRIORITY,
                                                 _r8_:ORDERS_CLERK,
                                                 _r9_:ORDERS_SHIPPRIORITY,
                                                 _r10_:ORDERS_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:14, _r3_:-1}
    ))

trigger delete_ORDERS_rcv_push_s15_m_QUERY3_mORDERS6 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int,
_r5_:string, _r6_:real, _r7_:int, _r8_:string, _r9_:string, _r10_:int,
_r11_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:ORDERS_ORDERKEY,
                _r4_:ORDERS_CUSTKEY, _r5_:ORDERS_ORDERSTATUS,
                _r6_:ORDERS_TOTALPRICE, _r7_:ORDERS_ORDERDATE,
                _r8_:ORDERS_ORDERPRIORITY, _r9_:ORDERS_CLERK,
                _r10_:ORDERS_SHIPPRIORITY, _r11_:ORDERS_COMMENT} in (
    log_write_delete_ORDERS
      {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
       _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE, _r6_:ORDERS_ORDERDATE,
       _r7_:ORDERS_ORDERPRIORITY, _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
       _r10_:ORDERS_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mORDERS6_s15_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
          } @ { Set }
        then
          map_QUERY3_mORDERS6_s15_buf.update
            (case ((map_QUERY3_mORDERS6_s15_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mORDERS6_s15_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 15)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 15))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 15))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:15, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 15))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:15, _r3_:0}
        then
          (delete_ORDERS_do_complete_s15, me)<- {_r1_:vid,
                                                 _r2_:ORDERS_ORDERKEY,
                                                 _r3_:ORDERS_CUSTKEY,
                                                 _r4_:ORDERS_ORDERSTATUS,
                                                 _r5_:ORDERS_TOTALPRICE,
                                                 _r6_:ORDERS_ORDERDATE,
                                                 _r7_:ORDERS_ORDERPRIORITY,
                                                 _r8_:ORDERS_CLERK,
                                                 _r9_:ORDERS_SHIPPRIORITY,
                                                 _r10_:ORDERS_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:15, _r3_:-1}
    ))

trigger delete_ORDERS_do_complete_s11 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT} in let existing_out_tier = QUERY3 in
    let __prod_ret__17 = ((if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
      let wrapped_lookup_value =
        bind (map_QUERY3_mORDERS1_s11_buf.filter
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                 ORDERS_CUSTKEY))).fold
               ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                 bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                 if vid_lt {key:map_vid, value:vid}
                 then
                   if vid_eq {key:map_vid, value:max_vid}
                   then
                     {key:({| key:int, value:int |
                      {key:__map_0, value:__map_val}|} @ { Set }).combine 
                      acc, value:max_vid}
                   else
                     if vid_gt {key:map_vid, value:max_vid}
                     then
                       {key:{| key:int, value:int |
                        {key:__map_0, value:__map_val}|} @ { Set },
                        value:map_vid}
                     else {key:acc, value:max_vid}
                 else {key:acc, value:max_vid})))
               {key:empty { key:int, value:int } @ { Set },
                value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in __1 in
      if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) *
      ((let wrapped_lookup_value =
          bind (map_QUERY3_mORDERS3_s11_buf.filter
                 ((\_b1_ -> 
                   bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                   ORDERS_ORDERKEY))).fold
                 ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                   bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                   if vid_lt {key:map_vid, value:vid}
                   then
                     if vid_eq {key:map_vid, value:max_vid}
                     then
                       {key:({| key:int, value:real |
                        {key:__map_0, value:__map_val}|} @ { Set }).combine
                        acc, value:max_vid}
                     else
                       if vid_gt {key:map_vid, value:max_vid}
                       then
                         {key:{| key:int, value:real |
                          {key:__map_0, value:__map_val}|} @ { Set },
                          value:map_vid}
                       else {key:acc, value:max_vid}
                   else {key:acc, value:max_vid})))
                 {key:empty { key:int, value:real } @ { Set },
                  value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
          __1 in
      if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) +
      ((let wrapped_lookup_value =
          bind (map_QUERY3_mORDERS6_s11_buf.filter
                 ((\_b1_ -> 
                   bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                   ORDERS_ORDERKEY))).fold
                 ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                   bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                   if vid_lt {key:map_vid, value:vid}
                   then
                     if vid_eq {key:map_vid, value:max_vid}
                     then
                       {key:({| key:int, value:real |
                        {key:__map_0, value:__map_val}|} @ { Set }).combine
                        acc, value:max_vid}
                     else
                       if vid_gt {key:map_vid, value:max_vid}
                       then
                         {key:{| key:int, value:real |
                          {key:__map_0, value:__map_val}|} @ { Set },
                          value:map_vid}
                       else {key:acc, value:max_vid}
                   else {key:acc, value:max_vid})))
                 {key:empty { key:int, value:real } @ { Set },
                  value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
          __1 in
      if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) * -1)) in (
      add_delta_to_QUERY3
        {key:vid, value:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
         _r5_:real |
         {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
          _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__17}|} @ { Set }}
      ))

trigger delete_ORDERS_do_complete_s12 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT} in 
    let existing_out_tier = QUERY3_mLINEITEM1 in
    let __prod_ret__19 =
      ((let wrapped_lookup_value =
          bind (map_QUERY3_mORDERS1_s12_buf.filter
                 ((\_b1_ -> 
                   bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                   ORDERS_CUSTKEY))).fold
                 ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                   bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                   if vid_lt {key:map_vid, value:vid}
                   then
                     if vid_eq {key:map_vid, value:max_vid}
                     then
                       {key:({| key:int, value:int |
                        {key:__map_0, value:__map_val}|} @ { Set }).combine
                        acc, value:max_vid}
                     else
                       if vid_gt {key:map_vid, value:max_vid}
                       then
                         {key:{| key:int, value:int |
                          {key:__map_0, value:__map_val}|} @ { Set },
                          value:map_vid}
                       else {key:acc, value:max_vid}
                   else {key:acc, value:max_vid})))
                 {key:empty { key:int, value:int } @ { Set },
                  value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
          __1 in
      if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) * -1 in
    (
      add_delta_to_QUERY3_mLINEITEM1
        {key:vid, value:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
         _r5_:int |
         {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
          _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__19}|} @ { Set }};
      (QUERY3_mLINEITEM1_send_correctives, me)<- {key:vid, value:{|
                                                  _r1_:{
                                                  _r1_:int, _r2_:int, _r3_:int
                                                  }, _r2_:int, _r3_:int,
                                                  _r4_:int, _r5_:int |
                                                  {_r1_:vid,
                                                   _r2_:ORDERS_ORDERKEY,
                                                   _r3_:ORDERS_ORDERDATE,
                                                   _r4_:ORDERS_SHIPPRIORITY,
                                                   _r5_:__prod_ret__19}|} @ { Set }}
      ))

trigger delete_ORDERS_do_complete_s13 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT} in 
    let existing_out_tier = QUERY3_mLINEITEM1_mCUSTOMER2 in
    let __prod_ret__20 = (if ORDERS_ORDERDATE < 19950315 then 1 else 0) * -1 in
    (
      add_delta_to_QUERY3_mLINEITEM1_mCUSTOMER2
        {key:vid, value:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
         _r5_:int, _r6_:int |
         {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
          _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:__prod_ret__20}|} @ { Set }};
      (QUERY3_mLINEITEM1_mCUSTOMER2_send_correctives, me)<- {key:vid, value:{|
                                                             _r1_:{
                                                             _r1_:int,
                                                             _r2_:int, _r3_:int
                                                             }, _r2_:int,
                                                             _r3_:int,
                                                             _r4_:int,
                                                             _r5_:int, _r6_:int
                                                             |
                                                             {_r1_:vid,
                                                              _r2_:ORDERS_ORDERKEY,
                                                              _r3_:ORDERS_ORDERDATE,
                                                              _r4_:ORDERS_SHIPPRIORITY,
                                                              _r5_:ORDERS_CUSTKEY,
                                                              _r6_:__prod_ret__20}|} @ { Set }}
      ))

trigger delete_ORDERS_do_complete_s14 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT} in 
    let existing_out_tier = QUERY3_mCUSTOMER2 in
    let __prod_ret__22 = ((if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
      let wrapped_lookup_value =
        bind (map_QUERY3_mORDERS3_s14_buf.filter
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                 ORDERS_ORDERKEY))).fold
               ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                 bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                 if vid_lt {key:map_vid, value:vid}
                 then
                   if vid_eq {key:map_vid, value:max_vid}
                   then
                     {key:({| key:int, value:real |
                      {key:__map_0, value:__map_val}|} @ { Set }).combine 
                      acc, value:max_vid}
                   else
                     if vid_gt {key:map_vid, value:max_vid}
                     then
                       {key:{| key:int, value:real |
                        {key:__map_0, value:__map_val}|} @ { Set },
                        value:map_vid}
                     else {key:acc, value:max_vid}
                 else {key:acc, value:max_vid})))
               {key:empty { key:int, value:real } @ { Set },
                value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in __1 in
      if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) * -1 in (
      add_delta_to_QUERY3_mCUSTOMER2
        {key:vid, value:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
         _r5_:int, _r6_:real |
         {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
          _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:__prod_ret__22}|} @ { Set }};
      (QUERY3_mCUSTOMER2_send_correctives, me)<- {key:vid, value:{|
                                                  _r1_:{
                                                  _r1_:int, _r2_:int, _r3_:int
                                                  }, _r2_:int, _r3_:int,
                                                  _r4_:int, _r5_:int, _r6_:real
                                                  |
                                                  {_r1_:vid,
                                                   _r2_:ORDERS_ORDERKEY,
                                                   _r3_:ORDERS_ORDERDATE,
                                                   _r4_:ORDERS_SHIPPRIORITY,
                                                   _r5_:ORDERS_CUSTKEY,
                                                   _r6_:__prod_ret__22}|} @ { Set }}
      ))

trigger delete_ORDERS_do_complete_s15 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT} in 
    let existing_out_tier = QUERY3_mCUSTOMER4 in
    let __prod_ret__24 = ((if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
      let wrapped_lookup_value =
        bind (map_QUERY3_mORDERS6_s15_buf.filter
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                 ORDERS_ORDERKEY))).fold
               ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                 bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                 if vid_lt {key:map_vid, value:vid}
                 then
                   if vid_eq {key:map_vid, value:max_vid}
                   then
                     {key:({| key:int, value:real |
                      {key:__map_0, value:__map_val}|} @ { Set }).combine 
                      acc, value:max_vid}
                   else
                     if vid_gt {key:map_vid, value:max_vid}
                     then
                       {key:{| key:int, value:real |
                        {key:__map_0, value:__map_val}|} @ { Set },
                        value:map_vid}
                     else {key:acc, value:max_vid}
                 else {key:acc, value:max_vid})))
               {key:empty { key:int, value:real } @ { Set },
                value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in __1 in
      if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {key:_, value:projected_field} in 
        projected_field) * -1 in (
      add_delta_to_QUERY3_mCUSTOMER4
        {key:vid, value:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
         _r5_:int, _r6_:real |
         {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
          _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY, _r6_:__prod_ret__24}|} @ { Set }};
      (QUERY3_mCUSTOMER4_send_correctives, me)<- {key:vid, value:{|
                                                  _r1_:{
                                                  _r1_:int, _r2_:int, _r3_:int
                                                  }, _r2_:int, _r3_:int,
                                                  _r4_:int, _r5_:int, _r6_:real
                                                  |
                                                  {_r1_:vid,
                                                   _r2_:ORDERS_ORDERKEY,
                                                   _r3_:ORDERS_ORDERDATE,
                                                   _r4_:ORDERS_SHIPPRIORITY,
                                                   _r5_:ORDERS_CUSTKEY,
                                                   _r6_:__prod_ret__24}|} @ { Set }}
      ))

trigger delete_ORDERS_rcv_corrective_s11_m_QUERY3_mORDERS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mORDERS1_s11_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 11))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:11, _r3_:0}
        then
          bind log_get_bound_delete_ORDERS compute_vid as {_r1_:vid,
                                                           _r2_:ORDERS_ORDERKEY,
                                                           _r3_:ORDERS_CUSTKEY,
                                                           _r4_:ORDERS_ORDERSTATUS,
                                                           _r5_:ORDERS_TOTALPRICE,
                                                           _r6_:ORDERS_ORDERDATE,
                                                           _r7_:ORDERS_ORDERPRIORITY,
                                                           _r8_:ORDERS_CLERK,
                                                           _r9_:ORDERS_SHIPPRIORITY,
                                                           _r10_:ORDERS_COMMENT} in 
          (delete_ORDERS_do_corrective_s11_m_QUERY3_mORDERS1, me)<- {
            _r1_:compute_vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
            _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
            _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
            _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY, _r10_:ORDERS_COMMENT,
            _r11_:delta_tuples}
        else ()))
    ))

trigger delete_ORDERS_rcv_corrective_s11_m_QUERY3_mORDERS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mORDERS3_s11_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 11))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:11, _r3_:0}
        then
          bind log_get_bound_delete_ORDERS compute_vid as {_r1_:vid,
                                                           _r2_:ORDERS_ORDERKEY,
                                                           _r3_:ORDERS_CUSTKEY,
                                                           _r4_:ORDERS_ORDERSTATUS,
                                                           _r5_:ORDERS_TOTALPRICE,
                                                           _r6_:ORDERS_ORDERDATE,
                                                           _r7_:ORDERS_ORDERPRIORITY,
                                                           _r8_:ORDERS_CLERK,
                                                           _r9_:ORDERS_SHIPPRIORITY,
                                                           _r10_:ORDERS_COMMENT} in 
          (delete_ORDERS_do_corrective_s11_m_QUERY3_mORDERS3, me)<- {
            _r1_:compute_vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
            _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
            _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
            _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY, _r10_:ORDERS_COMMENT,
            _r11_:delta_tuples}
        else ()))
    ))

trigger delete_ORDERS_rcv_corrective_s11_m_QUERY3_mORDERS6 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mORDERS6_s11_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 11))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:11, _r3_:0}
        then
          bind log_get_bound_delete_ORDERS compute_vid as {_r1_:vid,
                                                           _r2_:ORDERS_ORDERKEY,
                                                           _r3_:ORDERS_CUSTKEY,
                                                           _r4_:ORDERS_ORDERSTATUS,
                                                           _r5_:ORDERS_TOTALPRICE,
                                                           _r6_:ORDERS_ORDERDATE,
                                                           _r7_:ORDERS_ORDERPRIORITY,
                                                           _r8_:ORDERS_CLERK,
                                                           _r9_:ORDERS_SHIPPRIORITY,
                                                           _r10_:ORDERS_COMMENT} in 
          (delete_ORDERS_do_corrective_s11_m_QUERY3_mORDERS6, me)<- {
            _r1_:compute_vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
            _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
            _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
            _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY, _r10_:ORDERS_COMMENT,
            _r11_:delta_tuples}
        else ()))
    ))

trigger delete_ORDERS_rcv_corrective_s12_m_QUERY3_mORDERS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mORDERS1_s12_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 12))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:12, _r3_:0}
        then
          bind log_get_bound_delete_ORDERS compute_vid as {_r1_:vid,
                                                           _r2_:ORDERS_ORDERKEY,
                                                           _r3_:ORDERS_CUSTKEY,
                                                           _r4_:ORDERS_ORDERSTATUS,
                                                           _r5_:ORDERS_TOTALPRICE,
                                                           _r6_:ORDERS_ORDERDATE,
                                                           _r7_:ORDERS_ORDERPRIORITY,
                                                           _r8_:ORDERS_CLERK,
                                                           _r9_:ORDERS_SHIPPRIORITY,
                                                           _r10_:ORDERS_COMMENT} in 
          (delete_ORDERS_do_corrective_s12_m_QUERY3_mORDERS1, me)<- {
            _r1_:compute_vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
            _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
            _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
            _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY, _r10_:ORDERS_COMMENT,
            _r11_:delta_tuples}
        else ()))
    ))

trigger delete_ORDERS_rcv_corrective_s14_m_QUERY3_mORDERS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mORDERS3_s14_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 14))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:14, _r3_:0}
        then
          bind log_get_bound_delete_ORDERS compute_vid as {_r1_:vid,
                                                           _r2_:ORDERS_ORDERKEY,
                                                           _r3_:ORDERS_CUSTKEY,
                                                           _r4_:ORDERS_ORDERSTATUS,
                                                           _r5_:ORDERS_TOTALPRICE,
                                                           _r6_:ORDERS_ORDERDATE,
                                                           _r7_:ORDERS_ORDERPRIORITY,
                                                           _r8_:ORDERS_CLERK,
                                                           _r9_:ORDERS_SHIPPRIORITY,
                                                           _r10_:ORDERS_COMMENT} in 
          (delete_ORDERS_do_corrective_s14_m_QUERY3_mORDERS3, me)<- {
            _r1_:compute_vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
            _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
            _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
            _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY, _r10_:ORDERS_COMMENT,
            _r11_:delta_tuples}
        else ()))
    ))

trigger delete_ORDERS_rcv_corrective_s15_m_QUERY3_mORDERS6 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mORDERS6_s15_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 15))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:15, _r3_:0}
        then
          bind log_get_bound_delete_ORDERS compute_vid as {_r1_:vid,
                                                           _r2_:ORDERS_ORDERKEY,
                                                           _r3_:ORDERS_CUSTKEY,
                                                           _r4_:ORDERS_ORDERSTATUS,
                                                           _r5_:ORDERS_TOTALPRICE,
                                                           _r6_:ORDERS_ORDERDATE,
                                                           _r7_:ORDERS_ORDERPRIORITY,
                                                           _r8_:ORDERS_CLERK,
                                                           _r9_:ORDERS_SHIPPRIORITY,
                                                           _r10_:ORDERS_COMMENT} in 
          (delete_ORDERS_do_corrective_s15_m_QUERY3_mORDERS6, me)<- {
            _r1_:compute_vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
            _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
            _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
            _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY, _r10_:ORDERS_COMMENT,
            _r11_:delta_tuples}
        else ()))
    ))

trigger delete_ORDERS_do_corrective_s11_m_QUERY3_mORDERS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string,
_r11_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT, _r11_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mORDERSORDERS_CUSTKEY,
                      _r3_:delta_QUERY3_mORDERS1} in 
        let existing_out_tier = QUERY3 in
        let __prod_ret__110 =
          (((if ORDERS_CUSTKEY == delta_QUERY3_mORDERSORDERS_CUSTKEY
             then 1
             else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
          ((let wrapped_lookup_value =
              bind (map_QUERY3_mORDERS3_s11_buf.filter
                     ((\_b1_ -> 
                       bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                       == ORDERS_ORDERKEY))).fold
                     ((\_b2_ ->
                     bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                       bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                       if vid_lt {key:map_vid, value:vid}
                       then
                         if vid_eq {key:map_vid, value:max_vid}
                         then
                           {key:({| key:int, value:real |
                            {key:__map_0, value:__map_val}|} @ { Set }).combine
                            acc, value:max_vid}
                         else
                           if vid_gt {key:map_vid, value:max_vid}
                           then
                             {key:{| key:int, value:real |
                              {key:__map_0, value:__map_val}|} @ { Set },
                              value:map_vid}
                           else {key:acc, value:max_vid}
                       else {key:acc, value:max_vid})))
                     {key:empty { key:int, value:real } @ { Set },
                      value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
              __1 in
          if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
          then 0
          else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
            { None -> error () } as {key:_, value:projected_field} in 
            projected_field) +
          ((let wrapped_lookup_value =
              bind (map_QUERY3_mORDERS6_s11_buf.filter
                     ((\_b1_ -> 
                       bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                       == ORDERS_ORDERKEY))).fold
                     ((\_b2_ ->
                     bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                       bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                       if vid_lt {key:map_vid, value:vid}
                       then
                         if vid_eq {key:map_vid, value:max_vid}
                         then
                           {key:({| key:int, value:real |
                            {key:__map_0, value:__map_val}|} @ { Set }).combine
                            acc, value:max_vid}
                         else
                           if vid_gt {key:map_vid, value:max_vid}
                           then
                             {key:{| key:int, value:real |
                              {key:__map_0, value:__map_val}|} @ { Set },
                              value:map_vid}
                           else {key:acc, value:max_vid}
                       else {key:acc, value:max_vid})))
                     {key:empty { key:int, value:real } @ { Set },
                      value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
              __1 in
          if wrapped_lookup_value == empty { key:int, value:real } @ { Set }
          then 0
          else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
            { None -> error () } as {key:_, value:projected_field} in 
            projected_field) * -1))) * delta_QUERY3_mORDERS1 in (
          cond_add_delta_to_QUERY3
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:real |
             {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
              _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__110}|} @ { Set }}
          ))))

trigger delete_ORDERS_do_corrective_s11_m_QUERY3_mORDERS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string,
_r11_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
} @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT, _r11_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mORDERSORDERS_ORDERKEY,
                      _r3_:delta_QUERY3_mORDERS3} in 
        let existing_out_tier = QUERY3 in
        let __prod_ret__123 =
          (((if ORDERS_ORDERKEY == delta_QUERY3_mORDERSORDERS_ORDERKEY
             then 1
             else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
          let wrapped_lookup_value =
            bind (map_QUERY3_mORDERS1_s11_buf.filter
                   ((\_b1_ -> 
                     bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                     ORDERS_CUSTKEY))).fold
                   ((\_b2_ ->
                   bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                     bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                     if vid_lt {key:map_vid, value:vid}
                     then
                       if vid_eq {key:map_vid, value:max_vid}
                       then
                         {key:({| key:int, value:int |
                          {key:__map_0, value:__map_val}|} @ { Set }).combine
                          acc, value:max_vid}
                       else
                         if vid_gt {key:map_vid, value:max_vid}
                         then
                           {key:{| key:int, value:int |
                            {key:__map_0, value:__map_val}|} @ { Set },
                            value:map_vid}
                         else {key:acc, value:max_vid}
                     else {key:acc, value:max_vid})))
                   {key:empty { key:int, value:int } @ { Set },
                    value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
            __1 in
          if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
          then 0
          else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
            { None -> error () } as {key:_, value:projected_field} in 
            projected_field) * delta_QUERY3_mORDERS3 in (
          cond_add_delta_to_QUERY3
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:real |
             {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
              _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__123}|} @ { Set }}
          ))))

trigger delete_ORDERS_do_corrective_s11_m_QUERY3_mORDERS6 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string,
_r11_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
} @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT, _r11_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mORDERSORDERS_ORDERKEY,
                      _r3_:delta_QUERY3_mORDERS6} in 
        let existing_out_tier = QUERY3 in
        let __prod_ret__136 =
          (((if ORDERS_ORDERKEY == delta_QUERY3_mORDERSORDERS_ORDERKEY
             then 1
             else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
          let wrapped_lookup_value =
            bind (map_QUERY3_mORDERS1_s11_buf.filter
                   ((\_b1_ -> 
                     bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                     ORDERS_CUSTKEY))).fold
                   ((\_b2_ ->
                   bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                     bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                     if vid_lt {key:map_vid, value:vid}
                     then
                       if vid_eq {key:map_vid, value:max_vid}
                       then
                         {key:({| key:int, value:int |
                          {key:__map_0, value:__map_val}|} @ { Set }).combine
                          acc, value:max_vid}
                       else
                         if vid_gt {key:map_vid, value:max_vid}
                         then
                           {key:{| key:int, value:int |
                            {key:__map_0, value:__map_val}|} @ { Set },
                            value:map_vid}
                         else {key:acc, value:max_vid}
                     else {key:acc, value:max_vid})))
                   {key:empty { key:int, value:int } @ { Set },
                    value:{_r1_:0, _r2_:0, _r3_:0}} as {key:__1, value:__2} in 
            __1 in
          if wrapped_lookup_value == empty { key:int, value:int } @ { Set }
          then 0
          else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
            { None -> error () } as {key:_, value:projected_field} in 
            projected_field) * -delta_QUERY3_mORDERS6 in (
          cond_add_delta_to_QUERY3
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:real |
             {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
              _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__136}|} @ { Set }}
          ))))

trigger delete_ORDERS_do_corrective_s12_m_QUERY3_mORDERS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string,
_r11_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT, _r11_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mORDERSORDERS_CUSTKEY,
                      _r3_:delta_QUERY3_mORDERS1} in 
        let existing_out_tier = QUERY3_mLINEITEM1 in
        let __prod_ret__113 =
          ((if ORDERS_CUSTKEY == delta_QUERY3_mORDERSORDERS_CUSTKEY
            then 1
            else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
          -delta_QUERY3_mORDERS1 in (
          cond_add_delta_to_QUERY3_mLINEITEM1
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int |
             {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
              _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__113}|} @ { Set }};
          (QUERY3_mLINEITEM1_send_correctives, me)<- {key:vid, value:{|
                                                      _r1_:{
                                                      _r1_:int, _r2_:int,
                                                      _r3_:int }, _r2_:int,
                                                      _r3_:int, _r4_:int,
                                                      _r5_:int |
                                                      {_r1_:vid,
                                                       _r2_:ORDERS_ORDERKEY,
                                                       _r3_:ORDERS_ORDERDATE,
                                                       _r4_:ORDERS_SHIPPRIORITY,
                                                       _r5_:__prod_ret__113}|} @ { Set }}
          ))))

trigger delete_ORDERS_do_corrective_s14_m_QUERY3_mORDERS3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string,
_r11_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
} @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT, _r11_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mORDERSORDERS_ORDERKEY,
                      _r3_:delta_QUERY3_mORDERS3} in 
        let existing_out_tier = QUERY3_mCUSTOMER2 in
        let __prod_ret__126 =
          ((if ORDERS_ORDERKEY == delta_QUERY3_mORDERSORDERS_ORDERKEY
            then 1
            else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
          -delta_QUERY3_mORDERS3 in (
          cond_add_delta_to_QUERY3_mCUSTOMER2
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:real |
             {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
              _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
              _r6_:__prod_ret__126}|} @ { Set }};
          (QUERY3_mCUSTOMER2_send_correctives, me)<- {key:vid, value:{|
                                                      _r1_:{
                                                      _r1_:int, _r2_:int,
                                                      _r3_:int }, _r2_:int,
                                                      _r3_:int, _r4_:int,
                                                      _r5_:int, _r6_:real |
                                                      {_r1_:vid,
                                                       _r2_:ORDERS_ORDERKEY,
                                                       _r3_:ORDERS_ORDERDATE,
                                                       _r4_:ORDERS_SHIPPRIORITY,
                                                       _r5_:ORDERS_CUSTKEY,
                                                       _r6_:__prod_ret__126}|} @ { Set }}
          ))))

trigger delete_ORDERS_do_corrective_s15_m_QUERY3_mORDERS6 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:string,
_r5_:real, _r6_:int, _r7_:string, _r8_:string, _r9_:int, _r10_:string,
_r11_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
} @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_CUSTKEY,
                  _r4_:ORDERS_ORDERSTATUS, _r5_:ORDERS_TOTALPRICE,
                  _r6_:ORDERS_ORDERDATE, _r7_:ORDERS_ORDERPRIORITY,
                  _r8_:ORDERS_CLERK, _r9_:ORDERS_SHIPPRIORITY,
                  _r10_:ORDERS_COMMENT, _r11_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mORDERSORDERS_ORDERKEY,
                      _r3_:delta_QUERY3_mORDERS6} in 
        let existing_out_tier = QUERY3_mCUSTOMER4 in
        let __prod_ret__139 =
          ((if ORDERS_ORDERKEY == delta_QUERY3_mORDERSORDERS_ORDERKEY
            then 1
            else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
          -delta_QUERY3_mORDERS6 in (
          cond_add_delta_to_QUERY3_mCUSTOMER4
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:real |
             {_r1_:vid, _r2_:ORDERS_ORDERKEY, _r3_:ORDERS_ORDERDATE,
              _r4_:ORDERS_SHIPPRIORITY, _r5_:ORDERS_CUSTKEY,
              _r6_:__prod_ret__139}|} @ { Set }};
          (QUERY3_mCUSTOMER4_send_correctives, me)<- {key:vid, value:{|
                                                      _r1_:{
                                                      _r1_:int, _r2_:int,
                                                      _r3_:int }, _r2_:int,
                                                      _r3_:int, _r4_:int,
                                                      _r5_:int, _r6_:real |
                                                      {_r1_:vid,
                                                       _r2_:ORDERS_ORDERKEY,
                                                       _r3_:ORDERS_ORDERDATE,
                                                       _r4_:ORDERS_SHIPPRIORITY,
                                                       _r5_:ORDERS_CUSTKEY,
                                                       _r6_:__prod_ret__139}|} @ { Set }}
          ))))

trigger insert_LINEITEM : {
_r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real, _r6_:real, _r7_:real,
_r8_:real, _r9_:string, _r10_:string, _r11_:int, _r12_:int, _r13_:int,
_r14_:string, _r15_:string, _r16_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:LINEITEM_ORDERKEY, _r2_:LINEITEM_PARTKEY,
                _r3_:LINEITEM_SUPPKEY, _r4_:LINEITEM_LINENUMBER,
                _r5_:LINEITEM_QUANTITY, _r6_:LINEITEM_EXTENDEDPRICE,
                _r7_:LINEITEM_DISCOUNT, _r8_:LINEITEM_TAX,
                _r9_:LINEITEM_RETURNFLAG, _r10_:LINEITEM_LINESTATUS,
                _r11_:LINEITEM_SHIPDATE, _r12_:LINEITEM_COMMITDATE,
                _r13_:LINEITEM_RECEIPTDATE, _r14_:LINEITEM_SHIPINSTRUCT,
                _r15_:LINEITEM_SHIPMODE, _r16_:LINEITEM_COMMENT} in (
    let vid =
      {_r1_:case (__epoch__.peek ()) of { Some x -> x.i } { None -> error () },
       _r2_:case (__vid_counter__.peek ()) of { Some x -> x.i }
       { None -> error () }, _r3_:hash me} in
    (
      (insert_LINEITEM_send_fetch, me)<- {_r1_:vid, _r2_:LINEITEM_ORDERKEY,
                                          _r3_:LINEITEM_PARTKEY,
                                          _r4_:LINEITEM_SUPPKEY,
                                          _r5_:LINEITEM_LINENUMBER,
                                          _r6_:LINEITEM_QUANTITY,
                                          _r7_:LINEITEM_EXTENDEDPRICE,
                                          _r8_:LINEITEM_DISCOUNT,
                                          _r9_:LINEITEM_TAX,
                                          _r10_:LINEITEM_RETURNFLAG,
                                          _r11_:LINEITEM_LINESTATUS,
                                          _r12_:LINEITEM_SHIPDATE,
                                          _r13_:LINEITEM_COMMITDATE,
                                          _r14_:LINEITEM_RECEIPTDATE,
                                          _r15_:LINEITEM_SHIPINSTRUCT,
                                          _r16_:LINEITEM_SHIPMODE,
                                          _r17_:LINEITEM_COMMENT};
      __vid_counter__.update
        ({i:case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
        ({i:1 + case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
      )
    ))

trigger insert_LINEITEM_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in (
    (route_to_QUERY3_mORDERS3 (Some LINEITEM_ORDERKEY)).iterate
      ((\_b1_ -> 
        bind _b1_ as {i:ip} in 
        (insert_LINEITEM_do_complete_s17, ip)<- {_r1_:vid,
                                                 _r2_:LINEITEM_ORDERKEY,
                                                 _r3_:LINEITEM_PARTKEY,
                                                 _r4_:LINEITEM_SUPPKEY,
                                                 _r5_:LINEITEM_LINENUMBER,
                                                 _r6_:LINEITEM_QUANTITY,
                                                 _r7_:LINEITEM_EXTENDEDPRICE,
                                                 _r8_:LINEITEM_DISCOUNT,
                                                 _r9_:LINEITEM_TAX,
                                                 _r10_:LINEITEM_RETURNFLAG,
                                                 _r11_:LINEITEM_LINESTATUS,
                                                 _r12_:LINEITEM_SHIPDATE,
                                                 _r13_:LINEITEM_COMMITDATE,
                                                 _r14_:LINEITEM_RECEIPTDATE,
                                                 _r15_:LINEITEM_SHIPINSTRUCT,
                                                 _r16_:LINEITEM_SHIPMODE,
                                                 _r17_:LINEITEM_COMMENT}));
    (route_to_QUERY3_mORDERS6 (Some LINEITEM_ORDERKEY)).iterate
      ((\_b1_ -> 
        bind _b1_ as {i:ip} in 
        (insert_LINEITEM_do_complete_s18, ip)<- {_r1_:vid,
                                                 _r2_:LINEITEM_ORDERKEY,
                                                 _r3_:LINEITEM_PARTKEY,
                                                 _r4_:LINEITEM_SUPPKEY,
                                                 _r5_:LINEITEM_LINENUMBER,
                                                 _r6_:LINEITEM_QUANTITY,
                                                 _r7_:LINEITEM_EXTENDEDPRICE,
                                                 _r8_:LINEITEM_DISCOUNT,
                                                 _r9_:LINEITEM_TAX,
                                                 _r10_:LINEITEM_RETURNFLAG,
                                                 _r11_:LINEITEM_LINESTATUS,
                                                 _r12_:LINEITEM_SHIPDATE,
                                                 _r13_:LINEITEM_COMMITDATE,
                                                 _r14_:LINEITEM_RECEIPTDATE,
                                                 _r15_:LINEITEM_SHIPINSTRUCT,
                                                 _r16_:LINEITEM_SHIPMODE,
                                                 _r17_:LINEITEM_COMMENT}));
    ((((empty {
        _r1_:address, _r2_:int, _r3_:int
        } @ { Collection }).combine
        (let sender_count =
           (route_to_QUERY3_mLINEITEM1
              {_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mLINEITEM1_QUERY3_0t0_1t1_2t2
            {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut,
                   _r3_:None immut}, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:16, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mLINEITEM1_mCUSTOMER2
              {_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut,
               _r4_:None immut}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mCUSTOMER2_0t0_1t1_2t2_3t3
            {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut,
                   _r3_:None immut, _r4_:None immut}, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:int } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:19, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mLINEITEM1_mCUSTOMER2
              {_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut,
               _r4_:None immut}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mCUSTOMER4_0t0_1t1_2t2_3t3
           {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut,
                  _r3_:None immut, _r4_:None immut}, _r2_:empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
            _r4_:int, _r5_:int, _r6_:int } @ { Set }, _r3_:true}).map
          ((\_b1_ -> 
            bind _b1_ as {key:ip, value:tuples} in 
            {_r1_:ip, _r2_:20, _r3_:sender_count})))))).groupBy
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in 
          {key:ip, value:stmt_id})) ((\acc -> (\_b3_ -> 
          bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupBy
       ((\_b1_ -> 
         bind _b1_ as {key:_b2_, value:count} in 
         bind _b2_ as {key:ip, value:stmt_id} in ip)) ((\acc -> (\_b3_ -> 
         bind _b3_ as {key:ip_and_stmt_id, value:count} in 
         bind ip_and_stmt_id as {key:ip, value:stmt_id} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:count}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_id_cnt_list} in (
          (insert_LINEITEM_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list,
                                           _r3_:vid, _r4_:LINEITEM_ORDERKEY,
                                           _r5_:LINEITEM_PARTKEY,
                                           _r6_:LINEITEM_SUPPKEY,
                                           _r7_:LINEITEM_LINENUMBER,
                                           _r8_:LINEITEM_QUANTITY,
                                           _r9_:LINEITEM_EXTENDEDPRICE,
                                           _r10_:LINEITEM_DISCOUNT,
                                           _r11_:LINEITEM_TAX,
                                           _r12_:LINEITEM_RETURNFLAG,
                                           _r13_:LINEITEM_LINESTATUS,
                                           _r14_:LINEITEM_SHIPDATE,
                                           _r15_:LINEITEM_COMMITDATE,
                                           _r16_:LINEITEM_RECEIPTDATE,
                                           _r17_:LINEITEM_SHIPINSTRUCT,
                                           _r18_:LINEITEM_SHIPMODE,
                                           _r19_:LINEITEM_COMMENT}
          )));
    ((((route_to_QUERY3_mLINEITEM1_mCUSTOMER2
          {_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut,
           _r4_:None immut}).map
         ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:20, _r2_:3, _r3_:ip}))).combine
       (((route_to_QUERY3_mLINEITEM1_mCUSTOMER2
            {_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut,
             _r4_:None immut}).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:19, _r2_:3, _r3_:ip}))).combine
       (((route_to_QUERY3_mLINEITEM1
            {_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut}).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:16, _r2_:2, _r3_:ip}))).combine
       empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection }))).groupBy
       ((\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip))
       ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:map_id}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_map_ids} in 
        (insert_LINEITEM_rcv_fetch, ip)<- {_r1_:stmt_map_ids, _r2_:vid,
                                           _r3_:LINEITEM_ORDERKEY,
                                           _r4_:LINEITEM_PARTKEY,
                                           _r5_:LINEITEM_SUPPKEY,
                                           _r6_:LINEITEM_LINENUMBER,
                                           _r7_:LINEITEM_QUANTITY,
                                           _r8_:LINEITEM_EXTENDEDPRICE,
                                           _r9_:LINEITEM_DISCOUNT,
                                           _r10_:LINEITEM_TAX,
                                           _r11_:LINEITEM_RETURNFLAG,
                                           _r12_:LINEITEM_LINESTATUS,
                                           _r13_:LINEITEM_SHIPDATE,
                                           _r14_:LINEITEM_COMMITDATE,
                                           _r15_:LINEITEM_RECEIPTDATE,
                                           _r16_:LINEITEM_SHIPINSTRUCT,
                                           _r17_:LINEITEM_SHIPMODE,
                                           _r18_:LINEITEM_COMMENT}))
    ))

trigger insert_LINEITEM_rcv_put : {
_r1_:address, _r2_:collection { key:int, value:int } @ { Set }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int, _r6_:int, _r7_:int,
_r8_:real, _r9_:real, _r10_:real, _r11_:real, _r12_:string, _r13_:string,
_r14_:int, _r15_:int, _r16_:int, _r17_:string, _r18_:string, _r19_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid,
                _r4_:LINEITEM_ORDERKEY, _r5_:LINEITEM_PARTKEY,
                _r6_:LINEITEM_SUPPKEY, _r7_:LINEITEM_LINENUMBER,
                _r8_:LINEITEM_QUANTITY, _r9_:LINEITEM_EXTENDEDPRICE,
                _r10_:LINEITEM_DISCOUNT, _r11_:LINEITEM_TAX,
                _r12_:LINEITEM_RETURNFLAG, _r13_:LINEITEM_LINESTATUS,
                _r14_:LINEITEM_SHIPDATE, _r15_:LINEITEM_COMMITDATE,
                _r16_:LINEITEM_RECEIPTDATE, _r17_:LINEITEM_SHIPINSTRUCT,
                _r18_:LINEITEM_SHIPMODE, _r19_:LINEITEM_COMMENT} in (
    stmt_id_cnt_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:count} in 
        if __stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:_, _r2_:_, _r3_:old_count} in 
          let new_count = old_count + count in (
            __stmt_cntrs__.update
              {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
              {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
            if new_count == 0
            then
              if stmt_id == 20
              then
                (insert_LINEITEM_do_complete_s20, me)<- {_r1_:vid,
                                                         _r2_:LINEITEM_ORDERKEY,
                                                         _r3_:LINEITEM_PARTKEY,
                                                         _r4_:LINEITEM_SUPPKEY,
                                                         _r5_:LINEITEM_LINENUMBER,
                                                         _r6_:LINEITEM_QUANTITY,
                                                         _r7_:LINEITEM_EXTENDEDPRICE,
                                                         _r8_:LINEITEM_DISCOUNT,
                                                         _r9_:LINEITEM_TAX,
                                                         _r10_:LINEITEM_RETURNFLAG,
                                                         _r11_:LINEITEM_LINESTATUS,
                                                         _r12_:LINEITEM_SHIPDATE,
                                                         _r13_:LINEITEM_COMMITDATE,
                                                         _r14_:LINEITEM_RECEIPTDATE,
                                                         _r15_:LINEITEM_SHIPINSTRUCT,
                                                         _r16_:LINEITEM_SHIPMODE,
                                                         _r17_:LINEITEM_COMMENT}
              else
                if stmt_id == 19
                then
                  (insert_LINEITEM_do_complete_s19, me)<- {_r1_:vid,
                                                           _r2_:LINEITEM_ORDERKEY,
                                                           _r3_:LINEITEM_PARTKEY,
                                                           _r4_:LINEITEM_SUPPKEY,
                                                           _r5_:LINEITEM_LINENUMBER,
                                                           _r6_:LINEITEM_QUANTITY,
                                                           _r7_:LINEITEM_EXTENDEDPRICE,
                                                           _r8_:LINEITEM_DISCOUNT,
                                                           _r9_:LINEITEM_TAX,
                                                           _r10_:LINEITEM_RETURNFLAG,
                                                           _r11_:LINEITEM_LINESTATUS,
                                                           _r12_:LINEITEM_SHIPDATE,
                                                           _r13_:LINEITEM_COMMITDATE,
                                                           _r14_:LINEITEM_RECEIPTDATE,
                                                           _r15_:LINEITEM_SHIPINSTRUCT,
                                                           _r16_:LINEITEM_SHIPMODE,
                                                           _r17_:LINEITEM_COMMENT}
                else
                  if stmt_id == 18
                  then
                    (insert_LINEITEM_do_complete_s18, me)<- {_r1_:vid,
                                                             _r2_:LINEITEM_ORDERKEY,
                                                             _r3_:LINEITEM_PARTKEY,
                                                             _r4_:LINEITEM_SUPPKEY,
                                                             _r5_:LINEITEM_LINENUMBER,
                                                             _r6_:LINEITEM_QUANTITY,
                                                             _r7_:LINEITEM_EXTENDEDPRICE,
                                                             _r8_:LINEITEM_DISCOUNT,
                                                             _r9_:LINEITEM_TAX,
                                                             _r10_:LINEITEM_RETURNFLAG,
                                                             _r11_:LINEITEM_LINESTATUS,
                                                             _r12_:LINEITEM_SHIPDATE,
                                                             _r13_:LINEITEM_COMMITDATE,
                                                             _r14_:LINEITEM_RECEIPTDATE,
                                                             _r15_:LINEITEM_SHIPINSTRUCT,
                                                             _r16_:LINEITEM_SHIPMODE,
                                                             _r17_:LINEITEM_COMMENT}
                  else
                    if stmt_id == 17
                    then
                      (insert_LINEITEM_do_complete_s17, me)<- {_r1_:vid,
                                                               _r2_:LINEITEM_ORDERKEY,
                                                               _r3_:LINEITEM_PARTKEY,
                                                               _r4_:LINEITEM_SUPPKEY,
                                                               _r5_:LINEITEM_LINENUMBER,
                                                               _r6_:LINEITEM_QUANTITY,
                                                               _r7_:LINEITEM_EXTENDEDPRICE,
                                                               _r8_:LINEITEM_DISCOUNT,
                                                               _r9_:LINEITEM_TAX,
                                                               _r10_:LINEITEM_RETURNFLAG,
                                                               _r11_:LINEITEM_LINESTATUS,
                                                               _r12_:LINEITEM_SHIPDATE,
                                                               _r13_:LINEITEM_COMMITDATE,
                                                               _r14_:LINEITEM_RECEIPTDATE,
                                                               _r15_:LINEITEM_SHIPINSTRUCT,
                                                               _r16_:LINEITEM_SHIPMODE,
                                                               _r17_:LINEITEM_COMMENT}
                    else
                      if stmt_id == 16
                      then
                        (insert_LINEITEM_do_complete_s16, me)<- {_r1_:vid,
                                                                 _r2_:LINEITEM_ORDERKEY,
                                                                 _r3_:LINEITEM_PARTKEY,
                                                                 _r4_:LINEITEM_SUPPKEY,
                                                                 _r5_:LINEITEM_LINENUMBER,
                                                                 _r6_:LINEITEM_QUANTITY,
                                                                 _r7_:LINEITEM_EXTENDEDPRICE,
                                                                 _r8_:LINEITEM_DISCOUNT,
                                                                 _r9_:LINEITEM_TAX,
                                                                 _r10_:LINEITEM_RETURNFLAG,
                                                                 _r11_:LINEITEM_LINESTATUS,
                                                                 _r12_:LINEITEM_SHIPDATE,
                                                                 _r13_:LINEITEM_COMMITDATE,
                                                                 _r14_:LINEITEM_RECEIPTDATE,
                                                                 _r15_:LINEITEM_SHIPINSTRUCT,
                                                                 _r16_:LINEITEM_SHIPMODE,
                                                                 _r17_:LINEITEM_COMMENT}
                      else ()
            else ()
            )
        else __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count}))
    ))

trigger insert_LINEITEM_rcv_fetch : {
_r1_:collection { key:int, value:int } @ { Set }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int, _r5_:int, _r6_:int,
_r7_:real, _r8_:real, _r9_:real, _r10_:real, _r11_:string, _r12_:string,
_r13_:int, _r14_:int, _r15_:int, _r16_:string, _r17_:string, _r18_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:LINEITEM_ORDERKEY,
                _r4_:LINEITEM_PARTKEY, _r5_:LINEITEM_SUPPKEY,
                _r6_:LINEITEM_LINENUMBER, _r7_:LINEITEM_QUANTITY,
                _r8_:LINEITEM_EXTENDEDPRICE, _r9_:LINEITEM_DISCOUNT,
                _r10_:LINEITEM_TAX, _r11_:LINEITEM_RETURNFLAG,
                _r12_:LINEITEM_LINESTATUS, _r13_:LINEITEM_SHIPDATE,
                _r14_:LINEITEM_COMMITDATE, _r15_:LINEITEM_RECEIPTDATE,
                _r16_:LINEITEM_SHIPINSTRUCT, _r17_:LINEITEM_SHIPMODE,
                _r18_:LINEITEM_COMMENT} in (
    log_write_insert_LINEITEM
      {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
       _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER, _r6_:LINEITEM_QUANTITY,
       _r7_:LINEITEM_EXTENDEDPRICE, _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
       _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
       _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
       _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
       _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT};
    stmts_and_map_ids.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:map_id} in 
        if stmt_id == 16
        then
          if map_id == 2
          then
            (insert_LINEITEM_send_push_s16_m_QUERY3_mLINEITEM1, me)<- {
              _r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
              _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
              _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
              _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
              _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
              _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
              _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
              _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT}
          else ()
        else
          if stmt_id == 19
          then
            if map_id == 3
            then
              (insert_LINEITEM_send_push_s19_m_QUERY3_mLINEITEM1_mCUSTOMER2,
                me)<- {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                       _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                       _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                       _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                       _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                       _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                       _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                       _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT}
            else ()
          else
            if stmt_id == 20
            then
              if map_id == 3
              then
                (insert_LINEITEM_send_push_s20_m_QUERY3_mLINEITEM1_mCUSTOMER2,
                  me)<- {_r1_:vid, _r2_:LINEITEM_ORDERKEY,
                         _r3_:LINEITEM_PARTKEY, _r4_:LINEITEM_SUPPKEY,
                         _r5_:LINEITEM_LINENUMBER, _r6_:LINEITEM_QUANTITY,
                         _r7_:LINEITEM_EXTENDEDPRICE, _r8_:LINEITEM_DISCOUNT,
                         _r9_:LINEITEM_TAX, _r10_:LINEITEM_RETURNFLAG,
                         _r11_:LINEITEM_LINESTATUS, _r12_:LINEITEM_SHIPDATE,
                         _r13_:LINEITEM_COMMITDATE, _r14_:LINEITEM_RECEIPTDATE,
                         _r15_:LINEITEM_SHIPINSTRUCT, _r16_:LINEITEM_SHIPMODE,
                         _r17_:LINEITEM_COMMENT}
              else ()
            else ()))
    ))

trigger insert_LINEITEM_send_push_s16_m_QUERY3_mLINEITEM1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:4, _r3_:16};
    (shuffle_QUERY3_mLINEITEM1_QUERY3_0t0_1t1_2t2
       {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut},
        _r2_:((QUERY3_mLINEITEM1.filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                                _r5_:_r5_} in _r2_ == LINEITEM_ORDERKEY))).groupBy
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_val} in 
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2})) ((\_b2_ ->
                bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_val} in 
                  if vid_lt {key:map_vid, value:vid}
                  then
                    if vid_eq {key:map_vid, value:max_vid}
                    then
                      {key:({|
                       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                       _r3_:int, _r4_:int, _r5_:int |
                       {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                        _r5_:__map_val}|} @ { Set }).combine acc, value:max_vid}
                    else
                      if vid_gt {key:map_vid, value:max_vid}
                      then
                        {key:{|
                         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                         _r3_:int, _r4_:int, _r5_:int |
                         {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                          _r4_:__map_2, _r5_:__map_val}|} @ { Set },
                         value:map_vid}
                      else {key:acc, value:max_vid}
                  else {key:acc, value:max_vid})))
                {key:empty {
                 _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                 _r4_:int, _r5_:int } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}}).ext
               ((\_b1_ -> 
                 bind _b1_ as {key:_, value:_b2_} in 
                 bind _b2_ as {key:project, value:_} in project)) empty {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
               _r4_:int, _r5_:int } @ { Collection }, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_LINEITEM_rcv_push_s16_m_QUERY3_mLINEITEM1, ip)<- {_r1_:tuples,
                                                                  _r2_:vid,
                                                                  _r3_:LINEITEM_ORDERKEY,
                                                                  _r4_:LINEITEM_PARTKEY,
                                                                  _r5_:LINEITEM_SUPPKEY,
                                                                  _r6_:LINEITEM_LINENUMBER,
                                                                  _r7_:LINEITEM_QUANTITY,
                                                                  _r8_:LINEITEM_EXTENDEDPRICE,
                                                                  _r9_:LINEITEM_DISCOUNT,
                                                                  _r10_:LINEITEM_TAX,
                                                                  _r11_:LINEITEM_RETURNFLAG,
                                                                  _r12_:LINEITEM_LINESTATUS,
                                                                  _r13_:LINEITEM_SHIPDATE,
                                                                  _r14_:LINEITEM_COMMITDATE,
                                                                  _r15_:LINEITEM_RECEIPTDATE,
                                                                  _r16_:LINEITEM_SHIPINSTRUCT,
                                                                  _r17_:LINEITEM_SHIPMODE,
                                                                  _r18_:LINEITEM_COMMENT}))
    ))

trigger insert_LINEITEM_send_push_s19_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:4, _r3_:19};
    (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mCUSTOMER2_0t0_1t1_2t2_3t3
       {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut,
              _r4_:None immut},
        _r2_:((QUERY3_mLINEITEM1_mCUSTOMER2.filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                                _r5_:_r5_, _r6_:_r6_} in _r2_ ==
                  LINEITEM_ORDERKEY))).groupBy
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
                ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  if vid_lt {key:map_vid, value:vid}
                  then
                    if vid_eq {key:map_vid, value:max_vid}
                    then
                      {key:({|
                       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                       _r3_:int, _r4_:int, _r5_:int, _r6_:int |
                       {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                        _r5_:__map_3, _r6_:__map_val}|} @ { Set }).combine 
                       acc, value:max_vid}
                    else
                      if vid_gt {key:map_vid, value:max_vid}
                      then
                        {key:{|
                         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                         _r3_:int, _r4_:int, _r5_:int, _r6_:int |
                         {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                          _r4_:__map_2, _r5_:__map_3, _r6_:__map_val}|} @ { Set },
                         value:map_vid}
                      else {key:acc, value:max_vid}
                  else {key:acc, value:max_vid})))
                {key:empty {
                 _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                 _r4_:int, _r5_:int, _r6_:int } @ { Set },
                 value:{_r1_:0, _r2_:0, _r3_:0}}).ext
               ((\_b1_ -> 
                 bind _b1_ as {key:_, value:_b2_} in 
                 bind _b2_ as {key:project, value:_} in project)) empty {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
               _r4_:int, _r5_:int, _r6_:int } @ { Collection }, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_LINEITEM_rcv_push_s19_m_QUERY3_mLINEITEM1_mCUSTOMER2, ip)<- {
          _r1_:tuples, _r2_:vid, _r3_:LINEITEM_ORDERKEY, _r4_:LINEITEM_PARTKEY,
          _r5_:LINEITEM_SUPPKEY, _r6_:LINEITEM_LINENUMBER,
          _r7_:LINEITEM_QUANTITY, _r8_:LINEITEM_EXTENDEDPRICE,
          _r9_:LINEITEM_DISCOUNT, _r10_:LINEITEM_TAX,
          _r11_:LINEITEM_RETURNFLAG, _r12_:LINEITEM_LINESTATUS,
          _r13_:LINEITEM_SHIPDATE, _r14_:LINEITEM_COMMITDATE,
          _r15_:LINEITEM_RECEIPTDATE, _r16_:LINEITEM_SHIPINSTRUCT,
          _r17_:LINEITEM_SHIPMODE, _r18_:LINEITEM_COMMENT}))
    ))

trigger insert_LINEITEM_send_push_s20_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:4, _r3_:20};
    (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mCUSTOMER4_0t0_1t1_2t2_3t3
       {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut,
              _r4_:None immut},
        _r2_:((QUERY3_mLINEITEM1_mCUSTOMER2.filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                                _r5_:_r5_, _r6_:_r6_} in _r2_ ==
                  LINEITEM_ORDERKEY))).groupBy
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
                ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  if vid_lt {key:map_vid, value:vid}
                  then
                    if vid_eq {key:map_vid, value:max_vid}
                    then
                      {key:({|
                       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                       _r3_:int, _r4_:int, _r5_:int, _r6_:int |
                       {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                        _r5_:__map_3, _r6_:__map_val}|} @ { Set }).combine 
                       acc, value:max_vid}
                    else
                      if vid_gt {key:map_vid, value:max_vid}
                      then
                        {key:{|
                         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                         _r3_:int, _r4_:int, _r5_:int, _r6_:int |
                         {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                          _r4_:__map_2, _r5_:__map_3, _r6_:__map_val}|} @ { Set },
                         value:map_vid}
                      else {key:acc, value:max_vid}
                  else {key:acc, value:max_vid})))
                {key:empty {
                 _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                 _r4_:int, _r5_:int, _r6_:int } @ { Set },
                 value:{_r1_:0, _r2_:0, _r3_:0}}).ext
               ((\_b1_ -> 
                 bind _b1_ as {key:_, value:_b2_} in 
                 bind _b2_ as {key:project, value:_} in project)) empty {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
               _r4_:int, _r5_:int, _r6_:int } @ { Collection }, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (insert_LINEITEM_rcv_push_s20_m_QUERY3_mLINEITEM1_mCUSTOMER2, ip)<- {
          _r1_:tuples, _r2_:vid, _r3_:LINEITEM_ORDERKEY, _r4_:LINEITEM_PARTKEY,
          _r5_:LINEITEM_SUPPKEY, _r6_:LINEITEM_LINENUMBER,
          _r7_:LINEITEM_QUANTITY, _r8_:LINEITEM_EXTENDEDPRICE,
          _r9_:LINEITEM_DISCOUNT, _r10_:LINEITEM_TAX,
          _r11_:LINEITEM_RETURNFLAG, _r12_:LINEITEM_LINESTATUS,
          _r13_:LINEITEM_SHIPDATE, _r14_:LINEITEM_COMMITDATE,
          _r15_:LINEITEM_RECEIPTDATE, _r16_:LINEITEM_SHIPINSTRUCT,
          _r17_:LINEITEM_SHIPMODE, _r18_:LINEITEM_COMMENT}))
    ))

trigger insert_LINEITEM_rcv_push_s16_m_QUERY3_mLINEITEM1 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int,
_r5_:int, _r6_:int, _r7_:real, _r8_:real, _r9_:real, _r10_:real, _r11_:string,
_r12_:string, _r13_:int, _r14_:int, _r15_:int, _r16_:string, _r17_:string,
_r18_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:LINEITEM_ORDERKEY,
                _r4_:LINEITEM_PARTKEY, _r5_:LINEITEM_SUPPKEY,
                _r6_:LINEITEM_LINENUMBER, _r7_:LINEITEM_QUANTITY,
                _r8_:LINEITEM_EXTENDEDPRICE, _r9_:LINEITEM_DISCOUNT,
                _r10_:LINEITEM_TAX, _r11_:LINEITEM_RETURNFLAG,
                _r12_:LINEITEM_LINESTATUS, _r13_:LINEITEM_SHIPDATE,
                _r14_:LINEITEM_COMMITDATE, _r15_:LINEITEM_RECEIPTDATE,
                _r16_:LINEITEM_SHIPINSTRUCT, _r17_:LINEITEM_SHIPMODE,
                _r18_:LINEITEM_COMMENT} in (
    log_write_insert_LINEITEM
      {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
       _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER, _r6_:LINEITEM_QUANTITY,
       _r7_:LINEITEM_EXTENDEDPRICE, _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
       _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
       _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
       _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
       _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mLINEITEM1_s16_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_, _r5_:_r5_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                           _r4_:__temp_3, _r5_:__temp_4} in ((_r1_ == __temp_0
            and _r4_ == __temp_3) and _r3_ == __temp_2) and _r2_ == __temp_1))
          != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
          _r5_:int } @ { Set }
        then
          map_QUERY3_mLINEITEM1_s16_buf.update
            (case ((map_QUERY3_mLINEITEM1_s16_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                             _r4_:__temp_3, _r5_:__temp_4} in ((_r1_ ==
              __temp_0 and _r4_ == __temp_3) and _r3_ == __temp_2) and _r2_ ==
              __temp_1))).peek ()) of { Some x -> x } { None -> error () })
            tuple
        else map_QUERY3_mLINEITEM1_s16_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 16)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 16))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 16))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:16, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 16))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:16, _r3_:0}
        then
          (insert_LINEITEM_do_complete_s16, me)<- {_r1_:vid,
                                                   _r2_:LINEITEM_ORDERKEY,
                                                   _r3_:LINEITEM_PARTKEY,
                                                   _r4_:LINEITEM_SUPPKEY,
                                                   _r5_:LINEITEM_LINENUMBER,
                                                   _r6_:LINEITEM_QUANTITY,
                                                   _r7_:LINEITEM_EXTENDEDPRICE,
                                                   _r8_:LINEITEM_DISCOUNT,
                                                   _r9_:LINEITEM_TAX,
                                                   _r10_:LINEITEM_RETURNFLAG,
                                                   _r11_:LINEITEM_LINESTATUS,
                                                   _r12_:LINEITEM_SHIPDATE,
                                                   _r13_:LINEITEM_COMMITDATE,
                                                   _r14_:LINEITEM_RECEIPTDATE,
                                                   _r15_:LINEITEM_SHIPINSTRUCT,
                                                   _r16_:LINEITEM_SHIPMODE,
                                                   _r17_:LINEITEM_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:16, _r3_:-1}
    ))

trigger insert_LINEITEM_rcv_push_s19_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int,
_r4_:int, _r5_:int, _r6_:int, _r7_:real, _r8_:real, _r9_:real, _r10_:real,
_r11_:string, _r12_:string, _r13_:int, _r14_:int, _r15_:int, _r16_:string,
_r17_:string, _r18_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:LINEITEM_ORDERKEY,
                _r4_:LINEITEM_PARTKEY, _r5_:LINEITEM_SUPPKEY,
                _r6_:LINEITEM_LINENUMBER, _r7_:LINEITEM_QUANTITY,
                _r8_:LINEITEM_EXTENDEDPRICE, _r9_:LINEITEM_DISCOUNT,
                _r10_:LINEITEM_TAX, _r11_:LINEITEM_RETURNFLAG,
                _r12_:LINEITEM_LINESTATUS, _r13_:LINEITEM_SHIPDATE,
                _r14_:LINEITEM_COMMITDATE, _r15_:LINEITEM_RECEIPTDATE,
                _r16_:LINEITEM_SHIPINSTRUCT, _r17_:LINEITEM_SHIPMODE,
                _r18_:LINEITEM_COMMENT} in (
    log_write_insert_LINEITEM
      {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
       _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER, _r6_:LINEITEM_QUANTITY,
       _r7_:LINEITEM_EXTENDEDPRICE, _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
       _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
       _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
       _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
       _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                          _r5_:_r5_, _r6_:_r6_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                           _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
            (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3) and
            _r3_ == __temp_2) and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
          _r5_:int, _r6_:int } @ { Set }
        then
          map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf.update
            (case ((map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_, _r6_:_r6_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                             _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
              (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3)
              and _r3_ == __temp_2) and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 19)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 19))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 19))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:19, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 19))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:19, _r3_:0}
        then
          (insert_LINEITEM_do_complete_s19, me)<- {_r1_:vid,
                                                   _r2_:LINEITEM_ORDERKEY,
                                                   _r3_:LINEITEM_PARTKEY,
                                                   _r4_:LINEITEM_SUPPKEY,
                                                   _r5_:LINEITEM_LINENUMBER,
                                                   _r6_:LINEITEM_QUANTITY,
                                                   _r7_:LINEITEM_EXTENDEDPRICE,
                                                   _r8_:LINEITEM_DISCOUNT,
                                                   _r9_:LINEITEM_TAX,
                                                   _r10_:LINEITEM_RETURNFLAG,
                                                   _r11_:LINEITEM_LINESTATUS,
                                                   _r12_:LINEITEM_SHIPDATE,
                                                   _r13_:LINEITEM_COMMITDATE,
                                                   _r14_:LINEITEM_RECEIPTDATE,
                                                   _r15_:LINEITEM_SHIPINSTRUCT,
                                                   _r16_:LINEITEM_SHIPMODE,
                                                   _r17_:LINEITEM_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:19, _r3_:-1}
    ))

trigger insert_LINEITEM_rcv_push_s20_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int,
_r4_:int, _r5_:int, _r6_:int, _r7_:real, _r8_:real, _r9_:real, _r10_:real,
_r11_:string, _r12_:string, _r13_:int, _r14_:int, _r15_:int, _r16_:string,
_r17_:string, _r18_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:LINEITEM_ORDERKEY,
                _r4_:LINEITEM_PARTKEY, _r5_:LINEITEM_SUPPKEY,
                _r6_:LINEITEM_LINENUMBER, _r7_:LINEITEM_QUANTITY,
                _r8_:LINEITEM_EXTENDEDPRICE, _r9_:LINEITEM_DISCOUNT,
                _r10_:LINEITEM_TAX, _r11_:LINEITEM_RETURNFLAG,
                _r12_:LINEITEM_LINESTATUS, _r13_:LINEITEM_SHIPDATE,
                _r14_:LINEITEM_COMMITDATE, _r15_:LINEITEM_RECEIPTDATE,
                _r16_:LINEITEM_SHIPINSTRUCT, _r17_:LINEITEM_SHIPMODE,
                _r18_:LINEITEM_COMMENT} in (
    log_write_insert_LINEITEM
      {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
       _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER, _r6_:LINEITEM_QUANTITY,
       _r7_:LINEITEM_EXTENDEDPRICE, _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
       _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
       _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
       _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
       _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                          _r5_:_r5_, _r6_:_r6_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                           _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
            (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3) and
            _r3_ == __temp_2) and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
          _r5_:int, _r6_:int } @ { Set }
        then
          map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf.update
            (case ((map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_, _r6_:_r6_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                             _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
              (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3)
              and _r3_ == __temp_2) and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 20)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 20))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 20))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:20, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 20))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:20, _r3_:0}
        then
          (insert_LINEITEM_do_complete_s20, me)<- {_r1_:vid,
                                                   _r2_:LINEITEM_ORDERKEY,
                                                   _r3_:LINEITEM_PARTKEY,
                                                   _r4_:LINEITEM_SUPPKEY,
                                                   _r5_:LINEITEM_LINENUMBER,
                                                   _r6_:LINEITEM_QUANTITY,
                                                   _r7_:LINEITEM_EXTENDEDPRICE,
                                                   _r8_:LINEITEM_DISCOUNT,
                                                   _r9_:LINEITEM_TAX,
                                                   _r10_:LINEITEM_RETURNFLAG,
                                                   _r11_:LINEITEM_LINESTATUS,
                                                   _r12_:LINEITEM_SHIPDATE,
                                                   _r13_:LINEITEM_COMMITDATE,
                                                   _r14_:LINEITEM_RECEIPTDATE,
                                                   _r15_:LINEITEM_SHIPINSTRUCT,
                                                   _r16_:LINEITEM_SHIPMODE,
                                                   _r17_:LINEITEM_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:20, _r3_:-1}
    ))

trigger insert_LINEITEM_do_complete_s16 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in 
    let existing_out_tier = QUERY3 in
    let __delta_values__ =
      (((((map_QUERY3_mLINEITEM1_s16_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_} in _r2_ == LINEITEM_ORDERKEY))).groupBy
            ((\_b1_ -> 
              bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                            _r4_:__map_2, _r5_:__map_val} in 
              {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2})) ((\_b2_ ->
            bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
              bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                            _r4_:__map_2, _r5_:__map_val} in 
              if vid_lt {key:map_vid, value:vid}
              then
                if vid_eq {key:map_vid, value:max_vid}
                then
                  {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:int |
                   {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_val}|} @ { Set }).combine
                   acc, value:max_vid}
                else
                  if vid_gt {key:map_vid, value:max_vid}
                  then
                    {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:int |
                     {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_val}|} @ { Set },
                     value:map_vid}
                  else {key:acc, value:max_vid}
              else {key:acc, value:max_vid})))
            {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:int } @ { Set },
             value:{_r1_:0, _r2_:0, _r3_:0}}).ext
           ((\_b1_ -> 
             bind _b1_ as {key:_, value:_b2_} in 
             bind _b2_ as {key:project, value:_} in project)) empty {
           _r1_:int, _r2_:int, _r3_:int, _r4_:int } @ { Collection }).map
          ((\_b1_ -> 
            bind _b1_ as {_r1_:LINEITEM_ORDERKEY, _r2_:ORDERS_ORDERDATE,
                          _r3_:ORDERS_SHIPPRIORITY, _r4_:__map_ret__19} in 
            {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
             _r3_:__map_ret__19}))).map
         ((\_b1_ -> 
           bind _b1_ as {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
                         _r3_:__map_ret__19} in 
           {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY, _r3_:__map_ret__19
            * (-LINEITEM_DISCOUNT + 1)}))).map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
                        _r3_:__prod_ret__26} in 
          {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY, _r3_:__prod_ret__26
           * LINEITEM_EXTENDEDPRICE})) in
    let __delta_with_vid__ =
      __delta_values__.map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
                        _r3_:__prod_ret__27} in 
          {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:ORDERS_ORDERDATE,
           _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__27})) in (
      add_delta_to_QUERY3 {key:vid, value:__delta_with_vid__} ))

trigger insert_LINEITEM_do_complete_s17 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in 
    let existing_out_tier = QUERY3_mORDERS3 in
    let __prod_ret__28 = LINEITEM_DISCOUNT * LINEITEM_EXTENDEDPRICE in (
      add_delta_to_QUERY3_mORDERS3
        {key:vid, value:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real |
         {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__prod_ret__28}|} @ { Set }};
      (QUERY3_mORDERS3_send_correctives, me)<- {key:vid, value:{|
                                                _r1_:{
                                                _r1_:int, _r2_:int, _r3_:int },
                                                _r2_:int, _r3_:real |
                                                {_r1_:vid,
                                                 _r2_:LINEITEM_ORDERKEY,
                                                 _r3_:__prod_ret__28}|} @ { Set }}
      ))

trigger insert_LINEITEM_do_complete_s18 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in 
    let existing_out_tier = QUERY3_mORDERS6 in
    let __val_ret__17 = LINEITEM_EXTENDEDPRICE in (
      add_delta_to_QUERY3_mORDERS6
        {key:vid, value:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real |
         {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__val_ret__17}|} @ { Set }};
      (QUERY3_mORDERS6_send_correctives, me)<- {key:vid, value:{|
                                                _r1_:{
                                                _r1_:int, _r2_:int, _r3_:int },
                                                _r2_:int, _r3_:real |
                                                {_r1_:vid,
                                                 _r2_:LINEITEM_ORDERKEY,
                                                 _r3_:__val_ret__17}|} @ { Set }}
      ))

trigger insert_LINEITEM_do_complete_s19 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in 
    let existing_out_tier = QUERY3_mCUSTOMER2 in
    let __delta_values__ =
      (((((map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_, _r6_:_r6_} in _r2_ == LINEITEM_ORDERKEY))).groupBy
            ((\_b1_ -> 
              bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                            _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
              {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
            ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
              bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                            _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
              if vid_lt {key:map_vid, value:vid}
              then
                if vid_eq {key:map_vid, value:max_vid}
                then
                  {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                   {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                    _r5_:__map_val}|} @ { Set }).combine acc, value:max_vid}
                else
                  if vid_gt {key:map_vid, value:max_vid}
                  then
                    {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                     {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                      _r5_:__map_val}|} @ { Set }, value:map_vid}
                  else {key:acc, value:max_vid}
              else {key:acc, value:max_vid})))
            {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
             } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}}).ext
           ((\_b1_ -> 
             bind _b1_ as {key:_, value:_b2_} in 
             bind _b2_ as {key:project, value:_} in project)) empty {
           _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int } @ { Collection }).map
          ((\_b1_ -> 
            bind _b1_ as {_r1_:LINEITEM_ORDERKEY, _r2_:ORDERS_ORDERDATE,
                          _r3_:ORDERS_SHIPPRIORITY,
                          _r4_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
                          _r5_:__map_ret__20} in 
            {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
             _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, _r4_:__map_ret__20}))).map
         ((\_b1_ -> 
           bind _b1_ as {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
                         _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
                         _r4_:__map_ret__20} in 
           {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
            _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, _r4_:__map_ret__20 *
            LINEITEM_DISCOUNT}))).map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
                        _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
                        _r4_:__prod_ret__29} in 
          {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
           _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, _r4_:__prod_ret__29 *
           LINEITEM_EXTENDEDPRICE})) in
    let __delta_with_vid__ =
      __delta_values__.map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
                        _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
                        _r4_:__prod_ret__30} in 
          {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:ORDERS_ORDERDATE,
           _r4_:ORDERS_SHIPPRIORITY, _r5_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
           _r6_:__prod_ret__30})) in (
      add_delta_to_QUERY3_mCUSTOMER2 {key:vid, value:__delta_with_vid__};
      (QUERY3_mCUSTOMER2_send_correctives, me)<- {key:vid,
                                                  value:__delta_with_vid__}
      ))

trigger insert_LINEITEM_do_complete_s20 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in 
    let existing_out_tier = QUERY3_mCUSTOMER4 in
    let __delta_values__ =
      ((((map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf.filter
           ((\_b1_ -> 
             bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                           _r5_:_r5_, _r6_:_r6_} in _r2_ == LINEITEM_ORDERKEY))).groupBy
           ((\_b1_ -> 
             bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                           _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
           ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
             bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                           _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
             if vid_lt {key:map_vid, value:vid}
             then
               if vid_eq {key:map_vid, value:max_vid}
               then
                 {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                   _r5_:__map_val}|} @ { Set }).combine acc, value:max_vid}
               else
                 if vid_gt {key:map_vid, value:max_vid}
                 then
                   {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                    {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                     _r5_:__map_val}|} @ { Set }, value:map_vid}
                 else {key:acc, value:max_vid}
             else {key:acc, value:max_vid})))
           {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
            } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}}).ext
          ((\_b1_ -> 
            bind _b1_ as {key:_, value:_b2_} in 
            bind _b2_ as {key:project, value:_} in project)) empty {
          _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int } @ { Collection }).map
         ((\_b1_ -> 
           bind _b1_ as {_r1_:LINEITEM_ORDERKEY, _r2_:ORDERS_ORDERDATE,
                         _r3_:ORDERS_SHIPPRIORITY,
                         _r4_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
                         _r5_:__map_ret__21} in 
           {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
            _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, _r4_:__map_ret__21}))).map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
                        _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
                        _r4_:__map_ret__21} in 
          {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
           _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, _r4_:__map_ret__21 *
           LINEITEM_EXTENDEDPRICE})) in
    let __delta_with_vid__ =
      __delta_values__.map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
                        _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
                        _r4_:__prod_ret__31} in 
          {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:ORDERS_ORDERDATE,
           _r4_:ORDERS_SHIPPRIORITY, _r5_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
           _r6_:__prod_ret__31})) in (
      add_delta_to_QUERY3_mCUSTOMER4 {key:vid, value:__delta_with_vid__};
      (QUERY3_mCUSTOMER4_send_correctives, me)<- {key:vid,
                                                  value:__delta_with_vid__}
      ))

trigger insert_LINEITEM_rcv_corrective_s16_m_QUERY3_mLINEITEM1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int
} @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mLINEITEM1_s16_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 16))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:16, _r3_:0}
        then
          bind log_get_bound_insert_LINEITEM compute_vid as {_r1_:vid,
                                                             _r2_:LINEITEM_ORDERKEY,
                                                             _r3_:LINEITEM_PARTKEY,
                                                             _r4_:LINEITEM_SUPPKEY,
                                                             _r5_:LINEITEM_LINENUMBER,
                                                             _r6_:LINEITEM_QUANTITY,
                                                             _r7_:LINEITEM_EXTENDEDPRICE,
                                                             _r8_:LINEITEM_DISCOUNT,
                                                             _r9_:LINEITEM_TAX,
                                                             _r10_:LINEITEM_RETURNFLAG,
                                                             _r11_:LINEITEM_LINESTATUS,
                                                             _r12_:LINEITEM_SHIPDATE,
                                                             _r13_:LINEITEM_COMMITDATE,
                                                             _r14_:LINEITEM_RECEIPTDATE,
                                                             _r15_:LINEITEM_SHIPINSTRUCT,
                                                             _r16_:LINEITEM_SHIPMODE,
                                                             _r17_:LINEITEM_COMMENT} in 
          (insert_LINEITEM_do_corrective_s16_m_QUERY3_mLINEITEM1, me)<- {
            _r1_:compute_vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
            _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
            _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
            _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
            _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
            _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
            _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
            _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT, _r18_:delta_tuples}
        else ()))
    ))

trigger insert_LINEITEM_rcv_corrective_s19_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf
      {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 19))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:19, _r3_:0}
        then
          bind log_get_bound_insert_LINEITEM compute_vid as {_r1_:vid,
                                                             _r2_:LINEITEM_ORDERKEY,
                                                             _r3_:LINEITEM_PARTKEY,
                                                             _r4_:LINEITEM_SUPPKEY,
                                                             _r5_:LINEITEM_LINENUMBER,
                                                             _r6_:LINEITEM_QUANTITY,
                                                             _r7_:LINEITEM_EXTENDEDPRICE,
                                                             _r8_:LINEITEM_DISCOUNT,
                                                             _r9_:LINEITEM_TAX,
                                                             _r10_:LINEITEM_RETURNFLAG,
                                                             _r11_:LINEITEM_LINESTATUS,
                                                             _r12_:LINEITEM_SHIPDATE,
                                                             _r13_:LINEITEM_COMMITDATE,
                                                             _r14_:LINEITEM_RECEIPTDATE,
                                                             _r15_:LINEITEM_SHIPINSTRUCT,
                                                             _r16_:LINEITEM_SHIPMODE,
                                                             _r17_:LINEITEM_COMMENT} in 
          (insert_LINEITEM_do_corrective_s19_m_QUERY3_mLINEITEM1_mCUSTOMER2,
            me)<- {_r1_:compute_vid, _r2_:LINEITEM_ORDERKEY,
                   _r3_:LINEITEM_PARTKEY, _r4_:LINEITEM_SUPPKEY,
                   _r5_:LINEITEM_LINENUMBER, _r6_:LINEITEM_QUANTITY,
                   _r7_:LINEITEM_EXTENDEDPRICE, _r8_:LINEITEM_DISCOUNT,
                   _r9_:LINEITEM_TAX, _r10_:LINEITEM_RETURNFLAG,
                   _r11_:LINEITEM_LINESTATUS, _r12_:LINEITEM_SHIPDATE,
                   _r13_:LINEITEM_COMMITDATE, _r14_:LINEITEM_RECEIPTDATE,
                   _r15_:LINEITEM_SHIPINSTRUCT, _r16_:LINEITEM_SHIPMODE,
                   _r17_:LINEITEM_COMMENT, _r18_:delta_tuples}
        else ()))
    ))

trigger insert_LINEITEM_rcv_corrective_s20_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf
      {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 20))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:20, _r3_:0}
        then
          bind log_get_bound_insert_LINEITEM compute_vid as {_r1_:vid,
                                                             _r2_:LINEITEM_ORDERKEY,
                                                             _r3_:LINEITEM_PARTKEY,
                                                             _r4_:LINEITEM_SUPPKEY,
                                                             _r5_:LINEITEM_LINENUMBER,
                                                             _r6_:LINEITEM_QUANTITY,
                                                             _r7_:LINEITEM_EXTENDEDPRICE,
                                                             _r8_:LINEITEM_DISCOUNT,
                                                             _r9_:LINEITEM_TAX,
                                                             _r10_:LINEITEM_RETURNFLAG,
                                                             _r11_:LINEITEM_LINESTATUS,
                                                             _r12_:LINEITEM_SHIPDATE,
                                                             _r13_:LINEITEM_COMMITDATE,
                                                             _r14_:LINEITEM_RECEIPTDATE,
                                                             _r15_:LINEITEM_SHIPINSTRUCT,
                                                             _r16_:LINEITEM_SHIPMODE,
                                                             _r17_:LINEITEM_COMMENT} in 
          (insert_LINEITEM_do_corrective_s20_m_QUERY3_mLINEITEM1_mCUSTOMER2,
            me)<- {_r1_:compute_vid, _r2_:LINEITEM_ORDERKEY,
                   _r3_:LINEITEM_PARTKEY, _r4_:LINEITEM_SUPPKEY,
                   _r5_:LINEITEM_LINENUMBER, _r6_:LINEITEM_QUANTITY,
                   _r7_:LINEITEM_EXTENDEDPRICE, _r8_:LINEITEM_DISCOUNT,
                   _r9_:LINEITEM_TAX, _r10_:LINEITEM_RETURNFLAG,
                   _r11_:LINEITEM_LINESTATUS, _r12_:LINEITEM_SHIPDATE,
                   _r13_:LINEITEM_COMMITDATE, _r14_:LINEITEM_RECEIPTDATE,
                   _r15_:LINEITEM_SHIPINSTRUCT, _r16_:LINEITEM_SHIPMODE,
                   _r17_:LINEITEM_COMMENT, _r18_:delta_tuples}
        else ()))
    ))

trigger insert_LINEITEM_do_corrective_s16_m_QUERY3_mLINEITEM1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string,
_r18_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int
} @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT,
                  _r18_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                      _r3_:delta_ORDERS_ORDERDATE,
                      _r4_:delta_ORDERS_SHIPPRIORITY,
                      _r5_:delta_QUERY3_mLINEITEM1} in 
        let existing_out_tier = QUERY3 in
        let __prod_ret__45 =
          (((if LINEITEM_ORDERKEY == delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY
             then 1
             else 0) * (-LINEITEM_DISCOUNT + 1)) * delta_QUERY3_mLINEITEM1) *
          LINEITEM_EXTENDEDPRICE in (
          cond_add_delta_to_QUERY3
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:real |
             {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:delta_ORDERS_ORDERDATE,
              _r4_:delta_ORDERS_SHIPPRIORITY, _r5_:__prod_ret__45}|} @ { Set }}
          ))))

trigger insert_LINEITEM_do_corrective_s19_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string,
_r18_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT,
                  _r18_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                      _r3_:delta_ORDERS_ORDERDATE,
                      _r4_:delta_ORDERS_SHIPPRIORITY,
                      _r5_:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
                      _r6_:delta_QUERY3_mLINEITEM1_mCUSTOMER2} in 
        let existing_out_tier = QUERY3_mCUSTOMER2 in
        let __prod_ret__48 =
          (((if LINEITEM_ORDERKEY == delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY
             then 1
             else 0) * delta_QUERY3_mLINEITEM1_mCUSTOMER2) * LINEITEM_DISCOUNT)
          * LINEITEM_EXTENDEDPRICE in (
          cond_add_delta_to_QUERY3_mCUSTOMER2
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:real |
             {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:delta_ORDERS_ORDERDATE,
              _r4_:delta_ORDERS_SHIPPRIORITY,
              _r5_:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
              _r6_:__prod_ret__48}|} @ { Set }};
          (QUERY3_mCUSTOMER2_send_correctives, me)<- {key:vid, value:{|
                                                      _r1_:{
                                                      _r1_:int, _r2_:int,
                                                      _r3_:int }, _r2_:int,
                                                      _r3_:int, _r4_:int,
                                                      _r5_:int, _r6_:real |
                                                      {_r1_:vid,
                                                       _r2_:LINEITEM_ORDERKEY,
                                                       _r3_:delta_ORDERS_ORDERDATE,
                                                       _r4_:delta_ORDERS_SHIPPRIORITY,
                                                       _r5_:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
                                                       _r6_:__prod_ret__48}|} @ { Set }}
          ))))

trigger insert_LINEITEM_do_corrective_s20_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string,
_r18_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT,
                  _r18_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                      _r3_:delta_ORDERS_ORDERDATE,
                      _r4_:delta_ORDERS_SHIPPRIORITY,
                      _r5_:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
                      _r6_:delta_QUERY3_mLINEITEM1_mCUSTOMER2} in 
        let existing_out_tier = QUERY3_mCUSTOMER4 in
        let __prod_ret__50 =
          ((if LINEITEM_ORDERKEY == delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY
            then 1
            else 0) * delta_QUERY3_mLINEITEM1_mCUSTOMER2) *
          LINEITEM_EXTENDEDPRICE in (
          cond_add_delta_to_QUERY3_mCUSTOMER4
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:real |
             {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:delta_ORDERS_ORDERDATE,
              _r4_:delta_ORDERS_SHIPPRIORITY,
              _r5_:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
              _r6_:__prod_ret__50}|} @ { Set }};
          (QUERY3_mCUSTOMER4_send_correctives, me)<- {key:vid, value:{|
                                                      _r1_:{
                                                      _r1_:int, _r2_:int,
                                                      _r3_:int }, _r2_:int,
                                                      _r3_:int, _r4_:int,
                                                      _r5_:int, _r6_:real |
                                                      {_r1_:vid,
                                                       _r2_:LINEITEM_ORDERKEY,
                                                       _r3_:delta_ORDERS_ORDERDATE,
                                                       _r4_:delta_ORDERS_SHIPPRIORITY,
                                                       _r5_:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
                                                       _r6_:__prod_ret__50}|} @ { Set }}
          ))))

trigger delete_LINEITEM : {
_r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real, _r6_:real, _r7_:real,
_r8_:real, _r9_:string, _r10_:string, _r11_:int, _r12_:int, _r13_:int,
_r14_:string, _r15_:string, _r16_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:LINEITEM_ORDERKEY, _r2_:LINEITEM_PARTKEY,
                _r3_:LINEITEM_SUPPKEY, _r4_:LINEITEM_LINENUMBER,
                _r5_:LINEITEM_QUANTITY, _r6_:LINEITEM_EXTENDEDPRICE,
                _r7_:LINEITEM_DISCOUNT, _r8_:LINEITEM_TAX,
                _r9_:LINEITEM_RETURNFLAG, _r10_:LINEITEM_LINESTATUS,
                _r11_:LINEITEM_SHIPDATE, _r12_:LINEITEM_COMMITDATE,
                _r13_:LINEITEM_RECEIPTDATE, _r14_:LINEITEM_SHIPINSTRUCT,
                _r15_:LINEITEM_SHIPMODE, _r16_:LINEITEM_COMMENT} in (
    let vid =
      {_r1_:case (__epoch__.peek ()) of { Some x -> x.i } { None -> error () },
       _r2_:case (__vid_counter__.peek ()) of { Some x -> x.i }
       { None -> error () }, _r3_:hash me} in
    (
      (delete_LINEITEM_send_fetch, me)<- {_r1_:vid, _r2_:LINEITEM_ORDERKEY,
                                          _r3_:LINEITEM_PARTKEY,
                                          _r4_:LINEITEM_SUPPKEY,
                                          _r5_:LINEITEM_LINENUMBER,
                                          _r6_:LINEITEM_QUANTITY,
                                          _r7_:LINEITEM_EXTENDEDPRICE,
                                          _r8_:LINEITEM_DISCOUNT,
                                          _r9_:LINEITEM_TAX,
                                          _r10_:LINEITEM_RETURNFLAG,
                                          _r11_:LINEITEM_LINESTATUS,
                                          _r12_:LINEITEM_SHIPDATE,
                                          _r13_:LINEITEM_COMMITDATE,
                                          _r14_:LINEITEM_RECEIPTDATE,
                                          _r15_:LINEITEM_SHIPINSTRUCT,
                                          _r16_:LINEITEM_SHIPMODE,
                                          _r17_:LINEITEM_COMMENT};
      __vid_counter__.update
        ({i:case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
        ({i:1 + case (__vid_counter__.peek ()) of { Some x -> x.i }
          { None -> error () }})
      )
    ))

trigger delete_LINEITEM_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in (
    (route_to_QUERY3_mORDERS3 (Some LINEITEM_ORDERKEY)).iterate
      ((\_b1_ -> 
        bind _b1_ as {i:ip} in 
        (delete_LINEITEM_do_complete_s22, ip)<- {_r1_:vid,
                                                 _r2_:LINEITEM_ORDERKEY,
                                                 _r3_:LINEITEM_PARTKEY,
                                                 _r4_:LINEITEM_SUPPKEY,
                                                 _r5_:LINEITEM_LINENUMBER,
                                                 _r6_:LINEITEM_QUANTITY,
                                                 _r7_:LINEITEM_EXTENDEDPRICE,
                                                 _r8_:LINEITEM_DISCOUNT,
                                                 _r9_:LINEITEM_TAX,
                                                 _r10_:LINEITEM_RETURNFLAG,
                                                 _r11_:LINEITEM_LINESTATUS,
                                                 _r12_:LINEITEM_SHIPDATE,
                                                 _r13_:LINEITEM_COMMITDATE,
                                                 _r14_:LINEITEM_RECEIPTDATE,
                                                 _r15_:LINEITEM_SHIPINSTRUCT,
                                                 _r16_:LINEITEM_SHIPMODE,
                                                 _r17_:LINEITEM_COMMENT}));
    (route_to_QUERY3_mORDERS6 (Some LINEITEM_ORDERKEY)).iterate
      ((\_b1_ -> 
        bind _b1_ as {i:ip} in 
        (delete_LINEITEM_do_complete_s23, ip)<- {_r1_:vid,
                                                 _r2_:LINEITEM_ORDERKEY,
                                                 _r3_:LINEITEM_PARTKEY,
                                                 _r4_:LINEITEM_SUPPKEY,
                                                 _r5_:LINEITEM_LINENUMBER,
                                                 _r6_:LINEITEM_QUANTITY,
                                                 _r7_:LINEITEM_EXTENDEDPRICE,
                                                 _r8_:LINEITEM_DISCOUNT,
                                                 _r9_:LINEITEM_TAX,
                                                 _r10_:LINEITEM_RETURNFLAG,
                                                 _r11_:LINEITEM_LINESTATUS,
                                                 _r12_:LINEITEM_SHIPDATE,
                                                 _r13_:LINEITEM_COMMITDATE,
                                                 _r14_:LINEITEM_RECEIPTDATE,
                                                 _r15_:LINEITEM_SHIPINSTRUCT,
                                                 _r16_:LINEITEM_SHIPMODE,
                                                 _r17_:LINEITEM_COMMENT}));
    ((((empty {
        _r1_:address, _r2_:int, _r3_:int
        } @ { Collection }).combine
        (let sender_count =
           (route_to_QUERY3_mLINEITEM1
              {_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mLINEITEM1_QUERY3_0t0_1t1_2t2
            {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut,
                   _r3_:None immut}, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:21, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mLINEITEM1_mCUSTOMER2
              {_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut,
               _r4_:None immut}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mCUSTOMER2_0t0_1t1_2t2_3t3
            {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut,
                   _r3_:None immut, _r4_:None immut}, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:int } @ { Set }, _r3_:true}).map
           ((\_b1_ -> 
             bind _b1_ as {key:ip, value:tuples} in 
             {_r1_:ip, _r2_:24, _r3_:sender_count}))).combine
        (let sender_count =
           (route_to_QUERY3_mLINEITEM1_mCUSTOMER2
              {_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut,
               _r4_:None immut}).fold
             ((\count -> (\_b3_ ->  bind _b3_ as {i:ip} in count + 1))) 0 in
        (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mCUSTOMER4_0t0_1t1_2t2_3t3
           {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut,
                  _r3_:None immut, _r4_:None immut}, _r2_:empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
            _r4_:int, _r5_:int, _r6_:int } @ { Set }, _r3_:true}).map
          ((\_b1_ -> 
            bind _b1_ as {key:ip, value:tuples} in 
            {_r1_:ip, _r2_:25, _r3_:sender_count})))))).groupBy
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in 
          {key:ip, value:stmt_id})) ((\acc -> (\_b3_ -> 
          bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupBy
       ((\_b1_ -> 
         bind _b1_ as {key:_b2_, value:count} in 
         bind _b2_ as {key:ip, value:stmt_id} in ip)) ((\acc -> (\_b3_ -> 
         bind _b3_ as {key:ip_and_stmt_id, value:count} in 
         bind ip_and_stmt_id as {key:ip, value:stmt_id} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:count}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_id_cnt_list} in (
          (delete_LINEITEM_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list,
                                           _r3_:vid, _r4_:LINEITEM_ORDERKEY,
                                           _r5_:LINEITEM_PARTKEY,
                                           _r6_:LINEITEM_SUPPKEY,
                                           _r7_:LINEITEM_LINENUMBER,
                                           _r8_:LINEITEM_QUANTITY,
                                           _r9_:LINEITEM_EXTENDEDPRICE,
                                           _r10_:LINEITEM_DISCOUNT,
                                           _r11_:LINEITEM_TAX,
                                           _r12_:LINEITEM_RETURNFLAG,
                                           _r13_:LINEITEM_LINESTATUS,
                                           _r14_:LINEITEM_SHIPDATE,
                                           _r15_:LINEITEM_COMMITDATE,
                                           _r16_:LINEITEM_RECEIPTDATE,
                                           _r17_:LINEITEM_SHIPINSTRUCT,
                                           _r18_:LINEITEM_SHIPMODE,
                                           _r19_:LINEITEM_COMMENT}
          )));
    ((((route_to_QUERY3_mLINEITEM1_mCUSTOMER2
          {_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut,
           _r4_:None immut}).map
         ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:25, _r2_:3, _r3_:ip}))).combine
       (((route_to_QUERY3_mLINEITEM1_mCUSTOMER2
            {_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut,
             _r4_:None immut}).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:24, _r2_:3, _r3_:ip}))).combine
       (((route_to_QUERY3_mLINEITEM1
            {_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut}).map
           ((\_b1_ ->  bind _b1_ as {i:ip} in {_r1_:21, _r2_:2, _r3_:ip}))).combine
       empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection }))).groupBy
       ((\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip))
       ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
         ({| key:int, value:int |
         {key:stmt_id, value:map_id}|} @ { Collection })))) empty {
       key:int, value:int } @ { Collection }).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:stmt_map_ids} in 
        (delete_LINEITEM_rcv_fetch, ip)<- {_r1_:stmt_map_ids, _r2_:vid,
                                           _r3_:LINEITEM_ORDERKEY,
                                           _r4_:LINEITEM_PARTKEY,
                                           _r5_:LINEITEM_SUPPKEY,
                                           _r6_:LINEITEM_LINENUMBER,
                                           _r7_:LINEITEM_QUANTITY,
                                           _r8_:LINEITEM_EXTENDEDPRICE,
                                           _r9_:LINEITEM_DISCOUNT,
                                           _r10_:LINEITEM_TAX,
                                           _r11_:LINEITEM_RETURNFLAG,
                                           _r12_:LINEITEM_LINESTATUS,
                                           _r13_:LINEITEM_SHIPDATE,
                                           _r14_:LINEITEM_COMMITDATE,
                                           _r15_:LINEITEM_RECEIPTDATE,
                                           _r16_:LINEITEM_SHIPINSTRUCT,
                                           _r17_:LINEITEM_SHIPMODE,
                                           _r18_:LINEITEM_COMMENT}))
    ))

trigger delete_LINEITEM_rcv_put : {
_r1_:address, _r2_:collection { key:int, value:int } @ { Set }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int, _r6_:int, _r7_:int,
_r8_:real, _r9_:real, _r10_:real, _r11_:real, _r12_:string, _r13_:string,
_r14_:int, _r15_:int, _r16_:int, _r17_:string, _r18_:string, _r19_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid,
                _r4_:LINEITEM_ORDERKEY, _r5_:LINEITEM_PARTKEY,
                _r6_:LINEITEM_SUPPKEY, _r7_:LINEITEM_LINENUMBER,
                _r8_:LINEITEM_QUANTITY, _r9_:LINEITEM_EXTENDEDPRICE,
                _r10_:LINEITEM_DISCOUNT, _r11_:LINEITEM_TAX,
                _r12_:LINEITEM_RETURNFLAG, _r13_:LINEITEM_LINESTATUS,
                _r14_:LINEITEM_SHIPDATE, _r15_:LINEITEM_COMMITDATE,
                _r16_:LINEITEM_RECEIPTDATE, _r17_:LINEITEM_SHIPINSTRUCT,
                _r18_:LINEITEM_SHIPMODE, _r19_:LINEITEM_COMMENT} in (
    stmt_id_cnt_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:count} in 
        if __stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:_, _r2_:_, _r3_:old_count} in 
          let new_count = old_count + count in (
            __stmt_cntrs__.update
              {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
              {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
            if new_count == 0
            then
              if stmt_id == 25
              then
                (delete_LINEITEM_do_complete_s25, me)<- {_r1_:vid,
                                                         _r2_:LINEITEM_ORDERKEY,
                                                         _r3_:LINEITEM_PARTKEY,
                                                         _r4_:LINEITEM_SUPPKEY,
                                                         _r5_:LINEITEM_LINENUMBER,
                                                         _r6_:LINEITEM_QUANTITY,
                                                         _r7_:LINEITEM_EXTENDEDPRICE,
                                                         _r8_:LINEITEM_DISCOUNT,
                                                         _r9_:LINEITEM_TAX,
                                                         _r10_:LINEITEM_RETURNFLAG,
                                                         _r11_:LINEITEM_LINESTATUS,
                                                         _r12_:LINEITEM_SHIPDATE,
                                                         _r13_:LINEITEM_COMMITDATE,
                                                         _r14_:LINEITEM_RECEIPTDATE,
                                                         _r15_:LINEITEM_SHIPINSTRUCT,
                                                         _r16_:LINEITEM_SHIPMODE,
                                                         _r17_:LINEITEM_COMMENT}
              else
                if stmt_id == 24
                then
                  (delete_LINEITEM_do_complete_s24, me)<- {_r1_:vid,
                                                           _r2_:LINEITEM_ORDERKEY,
                                                           _r3_:LINEITEM_PARTKEY,
                                                           _r4_:LINEITEM_SUPPKEY,
                                                           _r5_:LINEITEM_LINENUMBER,
                                                           _r6_:LINEITEM_QUANTITY,
                                                           _r7_:LINEITEM_EXTENDEDPRICE,
                                                           _r8_:LINEITEM_DISCOUNT,
                                                           _r9_:LINEITEM_TAX,
                                                           _r10_:LINEITEM_RETURNFLAG,
                                                           _r11_:LINEITEM_LINESTATUS,
                                                           _r12_:LINEITEM_SHIPDATE,
                                                           _r13_:LINEITEM_COMMITDATE,
                                                           _r14_:LINEITEM_RECEIPTDATE,
                                                           _r15_:LINEITEM_SHIPINSTRUCT,
                                                           _r16_:LINEITEM_SHIPMODE,
                                                           _r17_:LINEITEM_COMMENT}
                else
                  if stmt_id == 23
                  then
                    (delete_LINEITEM_do_complete_s23, me)<- {_r1_:vid,
                                                             _r2_:LINEITEM_ORDERKEY,
                                                             _r3_:LINEITEM_PARTKEY,
                                                             _r4_:LINEITEM_SUPPKEY,
                                                             _r5_:LINEITEM_LINENUMBER,
                                                             _r6_:LINEITEM_QUANTITY,
                                                             _r7_:LINEITEM_EXTENDEDPRICE,
                                                             _r8_:LINEITEM_DISCOUNT,
                                                             _r9_:LINEITEM_TAX,
                                                             _r10_:LINEITEM_RETURNFLAG,
                                                             _r11_:LINEITEM_LINESTATUS,
                                                             _r12_:LINEITEM_SHIPDATE,
                                                             _r13_:LINEITEM_COMMITDATE,
                                                             _r14_:LINEITEM_RECEIPTDATE,
                                                             _r15_:LINEITEM_SHIPINSTRUCT,
                                                             _r16_:LINEITEM_SHIPMODE,
                                                             _r17_:LINEITEM_COMMENT}
                  else
                    if stmt_id == 22
                    then
                      (delete_LINEITEM_do_complete_s22, me)<- {_r1_:vid,
                                                               _r2_:LINEITEM_ORDERKEY,
                                                               _r3_:LINEITEM_PARTKEY,
                                                               _r4_:LINEITEM_SUPPKEY,
                                                               _r5_:LINEITEM_LINENUMBER,
                                                               _r6_:LINEITEM_QUANTITY,
                                                               _r7_:LINEITEM_EXTENDEDPRICE,
                                                               _r8_:LINEITEM_DISCOUNT,
                                                               _r9_:LINEITEM_TAX,
                                                               _r10_:LINEITEM_RETURNFLAG,
                                                               _r11_:LINEITEM_LINESTATUS,
                                                               _r12_:LINEITEM_SHIPDATE,
                                                               _r13_:LINEITEM_COMMITDATE,
                                                               _r14_:LINEITEM_RECEIPTDATE,
                                                               _r15_:LINEITEM_SHIPINSTRUCT,
                                                               _r16_:LINEITEM_SHIPMODE,
                                                               _r17_:LINEITEM_COMMENT}
                    else
                      if stmt_id == 21
                      then
                        (delete_LINEITEM_do_complete_s21, me)<- {_r1_:vid,
                                                                 _r2_:LINEITEM_ORDERKEY,
                                                                 _r3_:LINEITEM_PARTKEY,
                                                                 _r4_:LINEITEM_SUPPKEY,
                                                                 _r5_:LINEITEM_LINENUMBER,
                                                                 _r6_:LINEITEM_QUANTITY,
                                                                 _r7_:LINEITEM_EXTENDEDPRICE,
                                                                 _r8_:LINEITEM_DISCOUNT,
                                                                 _r9_:LINEITEM_TAX,
                                                                 _r10_:LINEITEM_RETURNFLAG,
                                                                 _r11_:LINEITEM_LINESTATUS,
                                                                 _r12_:LINEITEM_SHIPDATE,
                                                                 _r13_:LINEITEM_COMMITDATE,
                                                                 _r14_:LINEITEM_RECEIPTDATE,
                                                                 _r15_:LINEITEM_SHIPINSTRUCT,
                                                                 _r16_:LINEITEM_SHIPMODE,
                                                                 _r17_:LINEITEM_COMMENT}
                      else ()
            else ()
            )
        else __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count}))
    ))

trigger delete_LINEITEM_rcv_fetch : {
_r1_:collection { key:int, value:int } @ { Set }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int, _r5_:int, _r6_:int,
_r7_:real, _r8_:real, _r9_:real, _r10_:real, _r11_:string, _r12_:string,
_r13_:int, _r14_:int, _r15_:int, _r16_:string, _r17_:string, _r18_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:LINEITEM_ORDERKEY,
                _r4_:LINEITEM_PARTKEY, _r5_:LINEITEM_SUPPKEY,
                _r6_:LINEITEM_LINENUMBER, _r7_:LINEITEM_QUANTITY,
                _r8_:LINEITEM_EXTENDEDPRICE, _r9_:LINEITEM_DISCOUNT,
                _r10_:LINEITEM_TAX, _r11_:LINEITEM_RETURNFLAG,
                _r12_:LINEITEM_LINESTATUS, _r13_:LINEITEM_SHIPDATE,
                _r14_:LINEITEM_COMMITDATE, _r15_:LINEITEM_RECEIPTDATE,
                _r16_:LINEITEM_SHIPINSTRUCT, _r17_:LINEITEM_SHIPMODE,
                _r18_:LINEITEM_COMMENT} in (
    log_write_delete_LINEITEM
      {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
       _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER, _r6_:LINEITEM_QUANTITY,
       _r7_:LINEITEM_EXTENDEDPRICE, _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
       _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
       _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
       _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
       _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT};
    stmts_and_map_ids.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:map_id} in 
        if stmt_id == 21
        then
          if map_id == 2
          then
            (delete_LINEITEM_send_push_s21_m_QUERY3_mLINEITEM1, me)<- {
              _r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
              _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
              _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
              _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
              _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
              _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
              _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
              _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT}
          else ()
        else
          if stmt_id == 24
          then
            if map_id == 3
            then
              (delete_LINEITEM_send_push_s24_m_QUERY3_mLINEITEM1_mCUSTOMER2,
                me)<- {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                       _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                       _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                       _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                       _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                       _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                       _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                       _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT}
            else ()
          else
            if stmt_id == 25
            then
              if map_id == 3
              then
                (delete_LINEITEM_send_push_s25_m_QUERY3_mLINEITEM1_mCUSTOMER2,
                  me)<- {_r1_:vid, _r2_:LINEITEM_ORDERKEY,
                         _r3_:LINEITEM_PARTKEY, _r4_:LINEITEM_SUPPKEY,
                         _r5_:LINEITEM_LINENUMBER, _r6_:LINEITEM_QUANTITY,
                         _r7_:LINEITEM_EXTENDEDPRICE, _r8_:LINEITEM_DISCOUNT,
                         _r9_:LINEITEM_TAX, _r10_:LINEITEM_RETURNFLAG,
                         _r11_:LINEITEM_LINESTATUS, _r12_:LINEITEM_SHIPDATE,
                         _r13_:LINEITEM_COMMITDATE, _r14_:LINEITEM_RECEIPTDATE,
                         _r15_:LINEITEM_SHIPINSTRUCT, _r16_:LINEITEM_SHIPMODE,
                         _r17_:LINEITEM_COMMENT}
              else ()
            else ()))
    ))

trigger delete_LINEITEM_send_push_s21_m_QUERY3_mLINEITEM1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:5, _r3_:21};
    (shuffle_QUERY3_mLINEITEM1_QUERY3_0t0_1t1_2t2
       {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut},
        _r2_:((QUERY3_mLINEITEM1.filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                                _r5_:_r5_} in _r2_ == LINEITEM_ORDERKEY))).groupBy
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_val} in 
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2})) ((\_b2_ ->
                bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_val} in 
                  if vid_lt {key:map_vid, value:vid}
                  then
                    if vid_eq {key:map_vid, value:max_vid}
                    then
                      {key:({|
                       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                       _r3_:int, _r4_:int, _r5_:int |
                       {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                        _r5_:__map_val}|} @ { Set }).combine acc, value:max_vid}
                    else
                      if vid_gt {key:map_vid, value:max_vid}
                      then
                        {key:{|
                         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                         _r3_:int, _r4_:int, _r5_:int |
                         {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                          _r4_:__map_2, _r5_:__map_val}|} @ { Set },
                         value:map_vid}
                      else {key:acc, value:max_vid}
                  else {key:acc, value:max_vid})))
                {key:empty {
                 _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                 _r4_:int, _r5_:int } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}}).ext
               ((\_b1_ -> 
                 bind _b1_ as {key:_, value:_b2_} in 
                 bind _b2_ as {key:project, value:_} in project)) empty {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
               _r4_:int, _r5_:int } @ { Collection }, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_LINEITEM_rcv_push_s21_m_QUERY3_mLINEITEM1, ip)<- {_r1_:tuples,
                                                                  _r2_:vid,
                                                                  _r3_:LINEITEM_ORDERKEY,
                                                                  _r4_:LINEITEM_PARTKEY,
                                                                  _r5_:LINEITEM_SUPPKEY,
                                                                  _r6_:LINEITEM_LINENUMBER,
                                                                  _r7_:LINEITEM_QUANTITY,
                                                                  _r8_:LINEITEM_EXTENDEDPRICE,
                                                                  _r9_:LINEITEM_DISCOUNT,
                                                                  _r10_:LINEITEM_TAX,
                                                                  _r11_:LINEITEM_RETURNFLAG,
                                                                  _r12_:LINEITEM_LINESTATUS,
                                                                  _r13_:LINEITEM_SHIPDATE,
                                                                  _r14_:LINEITEM_COMMITDATE,
                                                                  _r15_:LINEITEM_RECEIPTDATE,
                                                                  _r16_:LINEITEM_SHIPINSTRUCT,
                                                                  _r17_:LINEITEM_SHIPMODE,
                                                                  _r18_:LINEITEM_COMMENT}))
    ))

trigger delete_LINEITEM_send_push_s24_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:5, _r3_:24};
    (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mCUSTOMER2_0t0_1t1_2t2_3t3
       {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut,
              _r4_:None immut},
        _r2_:((QUERY3_mLINEITEM1_mCUSTOMER2.filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                                _r5_:_r5_, _r6_:_r6_} in _r2_ ==
                  LINEITEM_ORDERKEY))).groupBy
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
                ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  if vid_lt {key:map_vid, value:vid}
                  then
                    if vid_eq {key:map_vid, value:max_vid}
                    then
                      {key:({|
                       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                       _r3_:int, _r4_:int, _r5_:int, _r6_:int |
                       {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                        _r5_:__map_3, _r6_:__map_val}|} @ { Set }).combine 
                       acc, value:max_vid}
                    else
                      if vid_gt {key:map_vid, value:max_vid}
                      then
                        {key:{|
                         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                         _r3_:int, _r4_:int, _r5_:int, _r6_:int |
                         {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                          _r4_:__map_2, _r5_:__map_3, _r6_:__map_val}|} @ { Set },
                         value:map_vid}
                      else {key:acc, value:max_vid}
                  else {key:acc, value:max_vid})))
                {key:empty {
                 _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                 _r4_:int, _r5_:int, _r6_:int } @ { Set },
                 value:{_r1_:0, _r2_:0, _r3_:0}}).ext
               ((\_b1_ -> 
                 bind _b1_ as {key:_, value:_b2_} in 
                 bind _b2_ as {key:project, value:_} in project)) empty {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
               _r4_:int, _r5_:int, _r6_:int } @ { Collection }, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_LINEITEM_rcv_push_s24_m_QUERY3_mLINEITEM1_mCUSTOMER2, ip)<- {
          _r1_:tuples, _r2_:vid, _r3_:LINEITEM_ORDERKEY, _r4_:LINEITEM_PARTKEY,
          _r5_:LINEITEM_SUPPKEY, _r6_:LINEITEM_LINENUMBER,
          _r7_:LINEITEM_QUANTITY, _r8_:LINEITEM_EXTENDEDPRICE,
          _r9_:LINEITEM_DISCOUNT, _r10_:LINEITEM_TAX,
          _r11_:LINEITEM_RETURNFLAG, _r12_:LINEITEM_LINESTATUS,
          _r13_:LINEITEM_SHIPDATE, _r14_:LINEITEM_COMMITDATE,
          _r15_:LINEITEM_RECEIPTDATE, _r16_:LINEITEM_SHIPINSTRUCT,
          _r17_:LINEITEM_SHIPMODE, _r18_:LINEITEM_COMMENT}))
    ))

trigger delete_LINEITEM_send_push_s25_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in (
    log_master_write {_r1_:vid, _r2_:5, _r3_:25};
    (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mCUSTOMER4_0t0_1t1_2t2_3t3
       {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut, _r3_:None immut,
              _r4_:None immut},
        _r2_:((QUERY3_mLINEITEM1_mCUSTOMER2.filter
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                                _r5_:_r5_, _r6_:_r6_} in _r2_ ==
                  LINEITEM_ORDERKEY))).groupBy
                ((\_b1_ -> 
                  bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
                ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
                  if vid_lt {key:map_vid, value:vid}
                  then
                    if vid_eq {key:map_vid, value:max_vid}
                    then
                      {key:({|
                       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                       _r3_:int, _r4_:int, _r5_:int, _r6_:int |
                       {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_2,
                        _r5_:__map_3, _r6_:__map_val}|} @ { Set }).combine 
                       acc, value:max_vid}
                    else
                      if vid_gt {key:map_vid, value:max_vid}
                      then
                        {key:{|
                         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                         _r3_:int, _r4_:int, _r5_:int, _r6_:int |
                         {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                          _r4_:__map_2, _r5_:__map_3, _r6_:__map_val}|} @ { Set },
                         value:map_vid}
                      else {key:acc, value:max_vid}
                  else {key:acc, value:max_vid})))
                {key:empty {
                 _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                 _r4_:int, _r5_:int, _r6_:int } @ { Set },
                 value:{_r1_:0, _r2_:0, _r3_:0}}).ext
               ((\_b1_ -> 
                 bind _b1_ as {key:_, value:_b2_} in 
                 bind _b2_ as {key:project, value:_} in project)) empty {
               _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
               _r4_:int, _r5_:int, _r6_:int } @ { Collection }, _r3_:true}).iterate
      ((\_b1_ -> 
        bind _b1_ as {key:ip, value:tuples} in 
        (delete_LINEITEM_rcv_push_s25_m_QUERY3_mLINEITEM1_mCUSTOMER2, ip)<- {
          _r1_:tuples, _r2_:vid, _r3_:LINEITEM_ORDERKEY, _r4_:LINEITEM_PARTKEY,
          _r5_:LINEITEM_SUPPKEY, _r6_:LINEITEM_LINENUMBER,
          _r7_:LINEITEM_QUANTITY, _r8_:LINEITEM_EXTENDEDPRICE,
          _r9_:LINEITEM_DISCOUNT, _r10_:LINEITEM_TAX,
          _r11_:LINEITEM_RETURNFLAG, _r12_:LINEITEM_LINESTATUS,
          _r13_:LINEITEM_SHIPDATE, _r14_:LINEITEM_COMMITDATE,
          _r15_:LINEITEM_RECEIPTDATE, _r16_:LINEITEM_SHIPINSTRUCT,
          _r17_:LINEITEM_SHIPMODE, _r18_:LINEITEM_COMMENT}))
    ))

trigger delete_LINEITEM_rcv_push_s21_m_QUERY3_mLINEITEM1 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int,
_r5_:int, _r6_:int, _r7_:real, _r8_:real, _r9_:real, _r10_:real, _r11_:string,
_r12_:string, _r13_:int, _r14_:int, _r15_:int, _r16_:string, _r17_:string,
_r18_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:LINEITEM_ORDERKEY,
                _r4_:LINEITEM_PARTKEY, _r5_:LINEITEM_SUPPKEY,
                _r6_:LINEITEM_LINENUMBER, _r7_:LINEITEM_QUANTITY,
                _r8_:LINEITEM_EXTENDEDPRICE, _r9_:LINEITEM_DISCOUNT,
                _r10_:LINEITEM_TAX, _r11_:LINEITEM_RETURNFLAG,
                _r12_:LINEITEM_LINESTATUS, _r13_:LINEITEM_SHIPDATE,
                _r14_:LINEITEM_COMMITDATE, _r15_:LINEITEM_RECEIPTDATE,
                _r16_:LINEITEM_SHIPINSTRUCT, _r17_:LINEITEM_SHIPMODE,
                _r18_:LINEITEM_COMMENT} in (
    log_write_delete_LINEITEM
      {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
       _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER, _r6_:LINEITEM_QUANTITY,
       _r7_:LINEITEM_EXTENDEDPRICE, _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
       _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
       _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
       _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
       _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mLINEITEM1_s21_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_, _r5_:_r5_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                           _r4_:__temp_3, _r5_:__temp_4} in ((_r1_ == __temp_0
            and _r4_ == __temp_3) and _r3_ == __temp_2) and _r2_ == __temp_1))
          != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
          _r5_:int } @ { Set }
        then
          map_QUERY3_mLINEITEM1_s21_buf.update
            (case ((map_QUERY3_mLINEITEM1_s21_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                             _r4_:__temp_3, _r5_:__temp_4} in ((_r1_ ==
              __temp_0 and _r4_ == __temp_3) and _r3_ == __temp_2) and _r2_ ==
              __temp_1))).peek ()) of { Some x -> x } { None -> error () })
            tuple
        else map_QUERY3_mLINEITEM1_s21_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 21)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 21))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 21))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:21, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 21))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:21, _r3_:0}
        then
          (delete_LINEITEM_do_complete_s21, me)<- {_r1_:vid,
                                                   _r2_:LINEITEM_ORDERKEY,
                                                   _r3_:LINEITEM_PARTKEY,
                                                   _r4_:LINEITEM_SUPPKEY,
                                                   _r5_:LINEITEM_LINENUMBER,
                                                   _r6_:LINEITEM_QUANTITY,
                                                   _r7_:LINEITEM_EXTENDEDPRICE,
                                                   _r8_:LINEITEM_DISCOUNT,
                                                   _r9_:LINEITEM_TAX,
                                                   _r10_:LINEITEM_RETURNFLAG,
                                                   _r11_:LINEITEM_LINESTATUS,
                                                   _r12_:LINEITEM_SHIPDATE,
                                                   _r13_:LINEITEM_COMMITDATE,
                                                   _r14_:LINEITEM_RECEIPTDATE,
                                                   _r15_:LINEITEM_SHIPINSTRUCT,
                                                   _r16_:LINEITEM_SHIPMODE,
                                                   _r17_:LINEITEM_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:21, _r3_:-1}
    ))

trigger delete_LINEITEM_rcv_push_s24_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int,
_r4_:int, _r5_:int, _r6_:int, _r7_:real, _r8_:real, _r9_:real, _r10_:real,
_r11_:string, _r12_:string, _r13_:int, _r14_:int, _r15_:int, _r16_:string,
_r17_:string, _r18_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:LINEITEM_ORDERKEY,
                _r4_:LINEITEM_PARTKEY, _r5_:LINEITEM_SUPPKEY,
                _r6_:LINEITEM_LINENUMBER, _r7_:LINEITEM_QUANTITY,
                _r8_:LINEITEM_EXTENDEDPRICE, _r9_:LINEITEM_DISCOUNT,
                _r10_:LINEITEM_TAX, _r11_:LINEITEM_RETURNFLAG,
                _r12_:LINEITEM_LINESTATUS, _r13_:LINEITEM_SHIPDATE,
                _r14_:LINEITEM_COMMITDATE, _r15_:LINEITEM_RECEIPTDATE,
                _r16_:LINEITEM_SHIPINSTRUCT, _r17_:LINEITEM_SHIPMODE,
                _r18_:LINEITEM_COMMENT} in (
    log_write_delete_LINEITEM
      {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
       _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER, _r6_:LINEITEM_QUANTITY,
       _r7_:LINEITEM_EXTENDEDPRICE, _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
       _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
       _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
       _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
       _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                          _r5_:_r5_, _r6_:_r6_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                           _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
            (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3) and
            _r3_ == __temp_2) and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
          _r5_:int, _r6_:int } @ { Set }
        then
          map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf.update
            (case ((map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_, _r6_:_r6_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                             _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
              (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3)
              and _r3_ == __temp_2) and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 24)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 24))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 24))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:24, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 24))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:24, _r3_:0}
        then
          (delete_LINEITEM_do_complete_s24, me)<- {_r1_:vid,
                                                   _r2_:LINEITEM_ORDERKEY,
                                                   _r3_:LINEITEM_PARTKEY,
                                                   _r4_:LINEITEM_SUPPKEY,
                                                   _r5_:LINEITEM_LINENUMBER,
                                                   _r6_:LINEITEM_QUANTITY,
                                                   _r7_:LINEITEM_EXTENDEDPRICE,
                                                   _r8_:LINEITEM_DISCOUNT,
                                                   _r9_:LINEITEM_TAX,
                                                   _r10_:LINEITEM_RETURNFLAG,
                                                   _r11_:LINEITEM_LINESTATUS,
                                                   _r12_:LINEITEM_SHIPDATE,
                                                   _r13_:LINEITEM_COMMITDATE,
                                                   _r14_:LINEITEM_RECEIPTDATE,
                                                   _r15_:LINEITEM_SHIPINSTRUCT,
                                                   _r16_:LINEITEM_SHIPMODE,
                                                   _r17_:LINEITEM_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:24, _r3_:-1}
    ))

trigger delete_LINEITEM_rcv_push_s25_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int,
_r4_:int, _r5_:int, _r6_:int, _r7_:real, _r8_:real, _r9_:real, _r10_:real,
_r11_:string, _r12_:string, _r13_:int, _r14_:int, _r15_:int, _r16_:string,
_r17_:string, _r18_:string
}
= (\_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:LINEITEM_ORDERKEY,
                _r4_:LINEITEM_PARTKEY, _r5_:LINEITEM_SUPPKEY,
                _r6_:LINEITEM_LINENUMBER, _r7_:LINEITEM_QUANTITY,
                _r8_:LINEITEM_EXTENDEDPRICE, _r9_:LINEITEM_DISCOUNT,
                _r10_:LINEITEM_TAX, _r11_:LINEITEM_RETURNFLAG,
                _r12_:LINEITEM_LINESTATUS, _r13_:LINEITEM_SHIPDATE,
                _r14_:LINEITEM_COMMITDATE, _r15_:LINEITEM_RECEIPTDATE,
                _r16_:LINEITEM_SHIPINSTRUCT, _r17_:LINEITEM_SHIPMODE,
                _r18_:LINEITEM_COMMENT} in (
    log_write_delete_LINEITEM
      {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
       _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER, _r6_:LINEITEM_QUANTITY,
       _r7_:LINEITEM_EXTENDEDPRICE, _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
       _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
       _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
       _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
       _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT};
    tuples.iterate
      ((\tuple -> 
        if map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                          _r5_:_r5_, _r6_:_r6_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                           _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
            (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3) and
            _r3_ == __temp_2) and _r2_ == __temp_1)) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int,
          _r5_:int, _r6_:int } @ { Set }
        then
          map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf.update
            (case ((map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_, _r6_:_r6_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                             _r4_:__temp_3, _r5_:__temp_4, _r6_:__temp_5} in 
              (((_r1_ == __temp_0 and _r5_ == __temp_4) and _r4_ == __temp_3)
              and _r3_ == __temp_2) and _r2_ == __temp_1))).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf.insert tuple));
    if __stmt_cntrs__.filter
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 25)) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 25))).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 25))).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:25, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 25))).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:25, _r3_:0}
        then
          (delete_LINEITEM_do_complete_s25, me)<- {_r1_:vid,
                                                   _r2_:LINEITEM_ORDERKEY,
                                                   _r3_:LINEITEM_PARTKEY,
                                                   _r4_:LINEITEM_SUPPKEY,
                                                   _r5_:LINEITEM_LINENUMBER,
                                                   _r6_:LINEITEM_QUANTITY,
                                                   _r7_:LINEITEM_EXTENDEDPRICE,
                                                   _r8_:LINEITEM_DISCOUNT,
                                                   _r9_:LINEITEM_TAX,
                                                   _r10_:LINEITEM_RETURNFLAG,
                                                   _r11_:LINEITEM_LINESTATUS,
                                                   _r12_:LINEITEM_SHIPDATE,
                                                   _r13_:LINEITEM_COMMITDATE,
                                                   _r14_:LINEITEM_RECEIPTDATE,
                                                   _r15_:LINEITEM_SHIPINSTRUCT,
                                                   _r16_:LINEITEM_SHIPMODE,
                                                   _r17_:LINEITEM_COMMENT}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:25, _r3_:-1}
    ))

trigger delete_LINEITEM_do_complete_s21 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in 
    let existing_out_tier = QUERY3 in
    let __delta_values__ =
      (((((map_QUERY3_mLINEITEM1_s21_buf.filter
            ((\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                            _r5_:_r5_} in _r2_ == LINEITEM_ORDERKEY))).groupBy
            ((\_b1_ -> 
              bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                            _r4_:__map_2, _r5_:__map_val} in 
              {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2})) ((\_b2_ ->
            bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
              bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                            _r4_:__map_2, _r5_:__map_val} in 
              if vid_lt {key:map_vid, value:vid}
              then
                if vid_eq {key:map_vid, value:max_vid}
                then
                  {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:int |
                   {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_val}|} @ { Set }).combine
                   acc, value:max_vid}
                else
                  if vid_gt {key:map_vid, value:max_vid}
                  then
                    {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:int |
                     {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_val}|} @ { Set },
                     value:map_vid}
                  else {key:acc, value:max_vid}
              else {key:acc, value:max_vid})))
            {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:int } @ { Set },
             value:{_r1_:0, _r2_:0, _r3_:0}}).ext
           ((\_b1_ -> 
             bind _b1_ as {key:_, value:_b2_} in 
             bind _b2_ as {key:project, value:_} in project)) empty {
           _r1_:int, _r2_:int, _r3_:int, _r4_:int } @ { Collection }).map
          ((\_b1_ -> 
            bind _b1_ as {_r1_:LINEITEM_ORDERKEY, _r2_:ORDERS_ORDERDATE,
                          _r3_:ORDERS_SHIPPRIORITY, _r4_:__map_ret__22} in 
            {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
             _r3_:__map_ret__22}))).map
         ((\_b1_ -> 
           bind _b1_ as {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
                         _r3_:__map_ret__22} in 
           {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY, _r3_:__map_ret__22
            * LINEITEM_EXTENDEDPRICE}))).map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
                        _r3_:__prod_ret__32} in 
          {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY, _r3_:__prod_ret__32
           * (-1 + LINEITEM_DISCOUNT)})) in
    let __delta_with_vid__ =
      __delta_values__.map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
                        _r3_:__prod_ret__33} in 
          {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:ORDERS_ORDERDATE,
           _r4_:ORDERS_SHIPPRIORITY, _r5_:__prod_ret__33})) in (
      add_delta_to_QUERY3 {key:vid, value:__delta_with_vid__} ))

trigger delete_LINEITEM_do_complete_s22 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in 
    let existing_out_tier = QUERY3_mORDERS3 in
    let __prod_ret__35 = -LINEITEM_DISCOUNT * LINEITEM_EXTENDEDPRICE in (
      add_delta_to_QUERY3_mORDERS3
        {key:vid, value:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real |
         {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__prod_ret__35}|} @ { Set }};
      (QUERY3_mORDERS3_send_correctives, me)<- {key:vid, value:{|
                                                _r1_:{
                                                _r1_:int, _r2_:int, _r3_:int },
                                                _r2_:int, _r3_:real |
                                                {_r1_:vid,
                                                 _r2_:LINEITEM_ORDERKEY,
                                                 _r3_:__prod_ret__35}|} @ { Set }}
      ))

trigger delete_LINEITEM_do_complete_s23 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in 
    let existing_out_tier = QUERY3_mORDERS6 in
    let __prod_ret__36 = -LINEITEM_EXTENDEDPRICE in (
      add_delta_to_QUERY3_mORDERS6
        {key:vid, value:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real |
         {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:__prod_ret__36}|} @ { Set }};
      (QUERY3_mORDERS6_send_correctives, me)<- {key:vid, value:{|
                                                _r1_:{
                                                _r1_:int, _r2_:int, _r3_:int },
                                                _r2_:int, _r3_:real |
                                                {_r1_:vid,
                                                 _r2_:LINEITEM_ORDERKEY,
                                                 _r3_:__prod_ret__36}|} @ { Set }}
      ))

trigger delete_LINEITEM_do_complete_s24 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in 
    let existing_out_tier = QUERY3_mCUSTOMER2 in
    let __delta_values__ =
      ((((map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf.filter
           ((\_b1_ -> 
             bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                           _r5_:_r5_, _r6_:_r6_} in _r2_ == LINEITEM_ORDERKEY))).groupBy
           ((\_b1_ -> 
             bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                           _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
           ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
             bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                           _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
             if vid_lt {key:map_vid, value:vid}
             then
               if vid_eq {key:map_vid, value:max_vid}
               then
                 {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                   _r5_:__map_val}|} @ { Set }).combine acc, value:max_vid}
               else
                 if vid_gt {key:map_vid, value:max_vid}
                 then
                   {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                    {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                     _r5_:__map_val}|} @ { Set }, value:map_vid}
                 else {key:acc, value:max_vid}
             else {key:acc, value:max_vid})))
           {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
            } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}}).ext
          ((\_b1_ -> 
            bind _b1_ as {key:_, value:_b2_} in 
            bind _b2_ as {key:project, value:_} in project)) empty {
          _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int } @ { Collection }).map
         ((\_b1_ -> 
           bind _b1_ as {_r1_:LINEITEM_ORDERKEY, _r2_:ORDERS_ORDERDATE,
                         _r3_:ORDERS_SHIPPRIORITY,
                         _r4_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
                         _r5_:__map_ret__23} in 
           {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
            _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, _r4_:__map_ret__23}))).map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
                        _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
                        _r4_:__map_ret__23} in 
          {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
           _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, _r4_:__map_ret__23 *
           (-LINEITEM_DISCOUNT * LINEITEM_EXTENDEDPRICE)})) in
    let __delta_with_vid__ =
      __delta_values__.map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
                        _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
                        _r4_:__prod_ret__39} in 
          {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:ORDERS_ORDERDATE,
           _r4_:ORDERS_SHIPPRIORITY, _r5_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
           _r6_:__prod_ret__39})) in (
      add_delta_to_QUERY3_mCUSTOMER2 {key:vid, value:__delta_with_vid__};
      (QUERY3_mCUSTOMER2_send_correctives, me)<- {key:vid,
                                                  value:__delta_with_vid__}
      ))

trigger delete_LINEITEM_do_complete_s25 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT} in 
    let existing_out_tier = QUERY3_mCUSTOMER4 in
    let __delta_values__ =
      ((((map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf.filter
           ((\_b1_ -> 
             bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_,
                           _r5_:_r5_, _r6_:_r6_} in _r2_ == LINEITEM_ORDERKEY))).groupBy
           ((\_b1_ -> 
             bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                           _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3}))
           ((\_b2_ -> bind _b2_ as {key:acc, value:max_vid} in (\_b5_ -> 
             bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                           _r4_:__map_2, _r5_:__map_3, _r6_:__map_val} in 
             if vid_lt {key:map_vid, value:vid}
             then
               if vid_eq {key:map_vid, value:max_vid}
               then
                 {key:({| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                   _r5_:__map_val}|} @ { Set }).combine acc, value:max_vid}
               else
                 if vid_gt {key:map_vid, value:max_vid}
                 then
                   {key:{| _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int |
                    {_r1_:__map_0, _r2_:__map_1, _r3_:__map_2, _r4_:__map_3,
                     _r5_:__map_val}|} @ { Set }, value:map_vid}
                 else {key:acc, value:max_vid}
             else {key:acc, value:max_vid})))
           {key:empty { _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int
            } @ { Set }, value:{_r1_:0, _r2_:0, _r3_:0}}).ext
          ((\_b1_ -> 
            bind _b1_ as {key:_, value:_b2_} in 
            bind _b2_ as {key:project, value:_} in project)) empty {
          _r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:int } @ { Collection }).map
         ((\_b1_ -> 
           bind _b1_ as {_r1_:LINEITEM_ORDERKEY, _r2_:ORDERS_ORDERDATE,
                         _r3_:ORDERS_SHIPPRIORITY,
                         _r4_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
                         _r5_:__map_ret__24} in 
           {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
            _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, _r4_:__map_ret__24}))).map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
                        _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
                        _r4_:__map_ret__24} in 
          {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
           _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, _r4_:__map_ret__24 *
           -LINEITEM_EXTENDEDPRICE})) in
    let __delta_with_vid__ =
      __delta_values__.map
        ((\_b1_ -> 
          bind _b1_ as {_r1_:ORDERS_ORDERDATE, _r2_:ORDERS_SHIPPRIORITY,
                        _r3_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
                        _r4_:__prod_ret__41} in 
          {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:ORDERS_ORDERDATE,
           _r4_:ORDERS_SHIPPRIORITY, _r5_:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
           _r6_:__prod_ret__41})) in (
      add_delta_to_QUERY3_mCUSTOMER4 {key:vid, value:__delta_with_vid__};
      (QUERY3_mCUSTOMER4_send_correctives, me)<- {key:vid,
                                                  value:__delta_with_vid__}
      ))

trigger delete_LINEITEM_rcv_corrective_s21_m_QUERY3_mLINEITEM1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int
} @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mLINEITEM1_s21_buf {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 21))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:21, _r3_:0}
        then
          bind log_get_bound_delete_LINEITEM compute_vid as {_r1_:vid,
                                                             _r2_:LINEITEM_ORDERKEY,
                                                             _r3_:LINEITEM_PARTKEY,
                                                             _r4_:LINEITEM_SUPPKEY,
                                                             _r5_:LINEITEM_LINENUMBER,
                                                             _r6_:LINEITEM_QUANTITY,
                                                             _r7_:LINEITEM_EXTENDEDPRICE,
                                                             _r8_:LINEITEM_DISCOUNT,
                                                             _r9_:LINEITEM_TAX,
                                                             _r10_:LINEITEM_RETURNFLAG,
                                                             _r11_:LINEITEM_LINESTATUS,
                                                             _r12_:LINEITEM_SHIPDATE,
                                                             _r13_:LINEITEM_COMMITDATE,
                                                             _r14_:LINEITEM_RECEIPTDATE,
                                                             _r15_:LINEITEM_SHIPINSTRUCT,
                                                             _r16_:LINEITEM_SHIPMODE,
                                                             _r17_:LINEITEM_COMMENT} in 
          (delete_LINEITEM_do_corrective_s21_m_QUERY3_mLINEITEM1, me)<- {
            _r1_:compute_vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
            _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
            _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
            _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
            _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
            _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
            _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
            _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT, _r18_:delta_tuples}
        else ()))
    ))

trigger delete_LINEITEM_rcv_corrective_s24_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf
      {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 24))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:24, _r3_:0}
        then
          bind log_get_bound_delete_LINEITEM compute_vid as {_r1_:vid,
                                                             _r2_:LINEITEM_ORDERKEY,
                                                             _r3_:LINEITEM_PARTKEY,
                                                             _r4_:LINEITEM_SUPPKEY,
                                                             _r5_:LINEITEM_LINENUMBER,
                                                             _r6_:LINEITEM_QUANTITY,
                                                             _r7_:LINEITEM_EXTENDEDPRICE,
                                                             _r8_:LINEITEM_DISCOUNT,
                                                             _r9_:LINEITEM_TAX,
                                                             _r10_:LINEITEM_RETURNFLAG,
                                                             _r11_:LINEITEM_LINESTATUS,
                                                             _r12_:LINEITEM_SHIPDATE,
                                                             _r13_:LINEITEM_COMMITDATE,
                                                             _r14_:LINEITEM_RECEIPTDATE,
                                                             _r15_:LINEITEM_SHIPINSTRUCT,
                                                             _r16_:LINEITEM_SHIPMODE,
                                                             _r17_:LINEITEM_COMMENT} in 
          (delete_LINEITEM_do_corrective_s24_m_QUERY3_mLINEITEM1_mCUSTOMER2,
            me)<- {_r1_:compute_vid, _r2_:LINEITEM_ORDERKEY,
                   _r3_:LINEITEM_PARTKEY, _r4_:LINEITEM_SUPPKEY,
                   _r5_:LINEITEM_LINENUMBER, _r6_:LINEITEM_QUANTITY,
                   _r7_:LINEITEM_EXTENDEDPRICE, _r8_:LINEITEM_DISCOUNT,
                   _r9_:LINEITEM_TAX, _r10_:LINEITEM_RETURNFLAG,
                   _r11_:LINEITEM_LINESTATUS, _r12_:LINEITEM_SHIPDATE,
                   _r13_:LINEITEM_COMMITDATE, _r14_:LINEITEM_RECEIPTDATE,
                   _r15_:LINEITEM_SHIPINSTRUCT, _r16_:LINEITEM_SHIPMODE,
                   _r17_:LINEITEM_COMMENT, _r18_:delta_tuples}
        else ()))
    ))

trigger delete_LINEITEM_rcv_corrective_s25_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }
}
= (\_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf
      {key:vid, value:delta_tuples};
    compute_vids.iterate
      ((\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          ((\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 25))).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:25, _r3_:0}
        then
          bind log_get_bound_delete_LINEITEM compute_vid as {_r1_:vid,
                                                             _r2_:LINEITEM_ORDERKEY,
                                                             _r3_:LINEITEM_PARTKEY,
                                                             _r4_:LINEITEM_SUPPKEY,
                                                             _r5_:LINEITEM_LINENUMBER,
                                                             _r6_:LINEITEM_QUANTITY,
                                                             _r7_:LINEITEM_EXTENDEDPRICE,
                                                             _r8_:LINEITEM_DISCOUNT,
                                                             _r9_:LINEITEM_TAX,
                                                             _r10_:LINEITEM_RETURNFLAG,
                                                             _r11_:LINEITEM_LINESTATUS,
                                                             _r12_:LINEITEM_SHIPDATE,
                                                             _r13_:LINEITEM_COMMITDATE,
                                                             _r14_:LINEITEM_RECEIPTDATE,
                                                             _r15_:LINEITEM_SHIPINSTRUCT,
                                                             _r16_:LINEITEM_SHIPMODE,
                                                             _r17_:LINEITEM_COMMENT} in 
          (delete_LINEITEM_do_corrective_s25_m_QUERY3_mLINEITEM1_mCUSTOMER2,
            me)<- {_r1_:compute_vid, _r2_:LINEITEM_ORDERKEY,
                   _r3_:LINEITEM_PARTKEY, _r4_:LINEITEM_SUPPKEY,
                   _r5_:LINEITEM_LINENUMBER, _r6_:LINEITEM_QUANTITY,
                   _r7_:LINEITEM_EXTENDEDPRICE, _r8_:LINEITEM_DISCOUNT,
                   _r9_:LINEITEM_TAX, _r10_:LINEITEM_RETURNFLAG,
                   _r11_:LINEITEM_LINESTATUS, _r12_:LINEITEM_SHIPDATE,
                   _r13_:LINEITEM_COMMITDATE, _r14_:LINEITEM_RECEIPTDATE,
                   _r15_:LINEITEM_SHIPINSTRUCT, _r16_:LINEITEM_SHIPMODE,
                   _r17_:LINEITEM_COMMENT, _r18_:delta_tuples}
        else ()))
    ))

trigger delete_LINEITEM_do_corrective_s21_m_QUERY3_mLINEITEM1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string,
_r18_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int
} @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT,
                  _r18_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                      _r3_:delta_ORDERS_ORDERDATE,
                      _r4_:delta_ORDERS_SHIPPRIORITY,
                      _r5_:delta_QUERY3_mLINEITEM1} in 
        let existing_out_tier = QUERY3 in
        let __prod_ret__58 =
          (((if LINEITEM_ORDERKEY == delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY
             then 1
             else 0) * delta_QUERY3_mLINEITEM1) * LINEITEM_EXTENDEDPRICE) * (-1
          + LINEITEM_DISCOUNT) in (
          cond_add_delta_to_QUERY3
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:real |
             {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:delta_ORDERS_ORDERDATE,
              _r4_:delta_ORDERS_SHIPPRIORITY, _r5_:__prod_ret__58}|} @ { Set }}
          ))))

trigger delete_LINEITEM_do_corrective_s24_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string,
_r18_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT,
                  _r18_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                      _r3_:delta_ORDERS_ORDERDATE,
                      _r4_:delta_ORDERS_SHIPPRIORITY,
                      _r5_:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
                      _r6_:delta_QUERY3_mLINEITEM1_mCUSTOMER2} in 
        let existing_out_tier = QUERY3_mCUSTOMER2 in
        let __prod_ret__62 =
          (if LINEITEM_ORDERKEY == delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY
           then 1
           else 0) * ((-delta_QUERY3_mLINEITEM1_mCUSTOMER2 * LINEITEM_DISCOUNT)
          * LINEITEM_EXTENDEDPRICE) in (
          cond_add_delta_to_QUERY3_mCUSTOMER2
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:real |
             {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:delta_ORDERS_ORDERDATE,
              _r4_:delta_ORDERS_SHIPPRIORITY,
              _r5_:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
              _r6_:__prod_ret__62}|} @ { Set }};
          (QUERY3_mCUSTOMER2_send_correctives, me)<- {key:vid, value:{|
                                                      _r1_:{
                                                      _r1_:int, _r2_:int,
                                                      _r3_:int }, _r2_:int,
                                                      _r3_:int, _r4_:int,
                                                      _r5_:int, _r6_:real |
                                                      {_r1_:vid,
                                                       _r2_:LINEITEM_ORDERKEY,
                                                       _r3_:delta_ORDERS_ORDERDATE,
                                                       _r4_:delta_ORDERS_SHIPPRIORITY,
                                                       _r5_:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
                                                       _r6_:__prod_ret__62}|} @ { Set }}
          ))))

trigger delete_LINEITEM_do_corrective_s25_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real, _r7_:real, _r8_:real, _r9_:real, _r10_:string, _r11_:string,
_r12_:int, _r13_:int, _r14_:int, _r15_:string, _r16_:string, _r17_:string,
_r18_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:LINEITEM_PARTKEY,
                  _r4_:LINEITEM_SUPPKEY, _r5_:LINEITEM_LINENUMBER,
                  _r6_:LINEITEM_QUANTITY, _r7_:LINEITEM_EXTENDEDPRICE,
                  _r8_:LINEITEM_DISCOUNT, _r9_:LINEITEM_TAX,
                  _r10_:LINEITEM_RETURNFLAG, _r11_:LINEITEM_LINESTATUS,
                  _r12_:LINEITEM_SHIPDATE, _r13_:LINEITEM_COMMITDATE,
                  _r14_:LINEITEM_RECEIPTDATE, _r15_:LINEITEM_SHIPINSTRUCT,
                  _r16_:LINEITEM_SHIPMODE, _r17_:LINEITEM_COMMENT,
                  _r18_:delta_tuples} in 
    delta_tuples.iterate
      ((\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY,
                      _r3_:delta_ORDERS_ORDERDATE,
                      _r4_:delta_ORDERS_SHIPPRIORITY,
                      _r5_:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
                      _r6_:delta_QUERY3_mLINEITEM1_mCUSTOMER2} in 
        let existing_out_tier = QUERY3_mCUSTOMER4 in
        let __prod_ret__65 =
          (if LINEITEM_ORDERKEY == delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY
           then 1
           else 0) * (-delta_QUERY3_mLINEITEM1_mCUSTOMER2 *
          LINEITEM_EXTENDEDPRICE) in (
          cond_add_delta_to_QUERY3_mCUSTOMER4
            {key:vid, value:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int, _r5_:int, _r6_:real |
             {_r1_:vid, _r2_:LINEITEM_ORDERKEY, _r3_:delta_ORDERS_ORDERDATE,
              _r4_:delta_ORDERS_SHIPPRIORITY,
              _r5_:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
              _r6_:__prod_ret__65}|} @ { Set }};
          (QUERY3_mCUSTOMER4_send_correctives, me)<- {key:vid, value:{|
                                                      _r1_:{
                                                      _r1_:int, _r2_:int,
                                                      _r3_:int }, _r2_:int,
                                                      _r3_:int, _r4_:int,
                                                      _r5_:int, _r6_:real |
                                                      {_r1_:vid,
                                                       _r2_:LINEITEM_ORDERKEY,
                                                       _r3_:delta_ORDERS_ORDERDATE,
                                                       _r4_:delta_ORDERS_SHIPPRIORITY,
                                                       _r5_:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
                                                       _r6_:__prod_ret__65}|} @ { Set }}
          ))))

trigger QUERY3_mLINEITEM1_send_correctives : {
key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int
} @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {key:corrective_vid, value:delta_tuples} in 
    let corrective_list =
      filter_corrective_list
        {key:corrective_vid, value:{| key:int, value:int | {key:5, value:21},
         {key:4, value:16}|} @ { Set }} in
    corrective_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:vid_list} in 
        if stmt_id == 21
        then
          ((vid_list.ext
              ((\vid -> 
                bind log_get_bound_delete_LINEITEM vid as {_r1_:vid,
                                                           _r2_:LINEITEM_ORDERKEY,
                                                           _r3_:LINEITEM_PARTKEY,
                                                           _r4_:LINEITEM_SUPPKEY,
                                                           _r5_:LINEITEM_LINENUMBER,
                                                           _r6_:LINEITEM_QUANTITY,
                                                           _r7_:LINEITEM_EXTENDEDPRICE,
                                                           _r8_:LINEITEM_DISCOUNT,
                                                           _r9_:LINEITEM_TAX,
                                                           _r10_:LINEITEM_RETURNFLAG,
                                                           _r11_:LINEITEM_LINESTATUS,
                                                           _r12_:LINEITEM_SHIPDATE,
                                                           _r13_:LINEITEM_COMMITDATE,
                                                           _r14_:LINEITEM_RECEIPTDATE,
                                                           _r15_:LINEITEM_SHIPINSTRUCT,
                                                           _r16_:LINEITEM_SHIPMODE,
                                                           _r17_:LINEITEM_COMMENT} in 
                (shuffle_QUERY3_mLINEITEM1_QUERY3_0t0_1t1_2t2
                   {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut,
                          _r3_:None immut}, _r2_:delta_tuples, _r3_:false}).map
                  ((\_b1_ -> 
                    bind _b1_ as {key:ip, value:tuples} in 
                    {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
              _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
              _r3_:collection {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
              _r4_:int, _r5_:int } @ { Set } } @ { Collection }).groupBy
             ((\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
             ((\_b2_ ->
             bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
               bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
               {key:acc_vid.combine
                ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                value:acc_tuples.combine tuples})))
             {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
              value:empty {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
              _r4_:int, _r5_:int } @ { Set }}).iterate
            ((\_b1_ -> 
              bind _b1_ as {key:ip, value:_b3_} in 
              bind _b3_ as {key:vid_send_list, value:tuple} in 
              (delete_LINEITEM_rcv_corrective_s21_m_QUERY3_mLINEITEM1, ip)<- {
                _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
        else
          if stmt_id == 16
          then
            ((vid_list.ext
                ((\vid -> 
                  bind log_get_bound_insert_LINEITEM vid as {_r1_:vid,
                                                             _r2_:LINEITEM_ORDERKEY,
                                                             _r3_:LINEITEM_PARTKEY,
                                                             _r4_:LINEITEM_SUPPKEY,
                                                             _r5_:LINEITEM_LINENUMBER,
                                                             _r6_:LINEITEM_QUANTITY,
                                                             _r7_:LINEITEM_EXTENDEDPRICE,
                                                             _r8_:LINEITEM_DISCOUNT,
                                                             _r9_:LINEITEM_TAX,
                                                             _r10_:LINEITEM_RETURNFLAG,
                                                             _r11_:LINEITEM_LINESTATUS,
                                                             _r12_:LINEITEM_SHIPDATE,
                                                             _r13_:LINEITEM_COMMITDATE,
                                                             _r14_:LINEITEM_RECEIPTDATE,
                                                             _r15_:LINEITEM_SHIPINSTRUCT,
                                                             _r16_:LINEITEM_SHIPMODE,
                                                             _r17_:LINEITEM_COMMENT} in 
                  (shuffle_QUERY3_mLINEITEM1_QUERY3_0t0_1t1_2t2
                     {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut,
                            _r3_:None immut}, _r2_:delta_tuples, _r3_:false}).map
                    ((\_b1_ -> 
                      bind _b1_ as {key:ip, value:tuples} in 
                      {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
                _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                _r3_:collection {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                _r4_:int, _r5_:int } @ { Set } } @ { Collection }).groupBy
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
               ((\_b2_ ->
               bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                 bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                 {key:acc_vid.combine
                  ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                  value:acc_tuples.combine tuples})))
               {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                value:empty {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                _r4_:int, _r5_:int } @ { Set }}).iterate
              ((\_b1_ -> 
                bind _b1_ as {key:ip, value:_b3_} in 
                bind _b3_ as {key:vid_send_list, value:tuple} in 
                (insert_LINEITEM_rcv_corrective_s16_m_QUERY3_mLINEITEM1, ip)<- {
                  _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
          else ())))

trigger QUERY3_mCUSTOMER4_send_correctives : {
key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real } @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {key:corrective_vid, value:delta_tuples} in 
    let corrective_list =
      filter_corrective_list
        {key:corrective_vid, value:{| key:int, value:int | {key:1, value:3},
         {key:0, value:0}|} @ { Set }} in
    corrective_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:vid_list} in 
        if stmt_id == 3
        then
          ((vid_list.ext
              ((\vid -> 
                bind log_get_bound_delete_CUSTOMER vid as {_r1_:vid,
                                                           _r2_:CUSTOMER_CUSTKEY,
                                                           _r3_:CUSTOMER_NAME,
                                                           _r4_:CUSTOMER_ADDRESS,
                                                           _r5_:CUSTOMER_NATIONKEY,
                                                           _r6_:CUSTOMER_PHONE,
                                                           _r7_:CUSTOMER_ACCTBAL,
                                                           _r8_:CUSTOMER_MKTSEGMENT,
                                                           _r9_:CUSTOMER_COMMENT} in 
                (shuffle_QUERY3_mCUSTOMER4_QUERY3_0t0_1t1_2t2
                   {_r1_:{_r1_:None immut, _r2_:None immut, _r3_:None immut},
                    _r2_:delta_tuples, _r3_:false}).map
                  ((\_b1_ -> 
                    bind _b1_ as {key:ip, value:tuples} in 
                    {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
              _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
              _r3_:collection {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
              _r4_:int, _r5_:int, _r6_:real } @ { Set } } @ { Collection }).groupBy
             ((\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
             ((\_b2_ ->
             bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
               bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
               {key:acc_vid.combine
                ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                value:acc_tuples.combine tuples})))
             {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
              value:empty {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
              _r4_:int, _r5_:int, _r6_:real } @ { Set }}).iterate
            ((\_b1_ -> 
              bind _b1_ as {key:ip, value:_b3_} in 
              bind _b3_ as {key:vid_send_list, value:tuple} in 
              (delete_CUSTOMER_rcv_corrective_s3_m_QUERY3_mCUSTOMER4, ip)<- {
                _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
        else
          if stmt_id == 0
          then
            ((vid_list.ext
                ((\vid -> 
                  bind log_get_bound_insert_CUSTOMER vid as {_r1_:vid,
                                                             _r2_:CUSTOMER_CUSTKEY,
                                                             _r3_:CUSTOMER_NAME,
                                                             _r4_:CUSTOMER_ADDRESS,
                                                             _r5_:CUSTOMER_NATIONKEY,
                                                             _r6_:CUSTOMER_PHONE,
                                                             _r7_:CUSTOMER_ACCTBAL,
                                                             _r8_:CUSTOMER_MKTSEGMENT,
                                                             _r9_:CUSTOMER_COMMENT} in 
                  (shuffle_QUERY3_mCUSTOMER4_QUERY3_0t0_1t1_2t2
                     {_r1_:{_r1_:None immut, _r2_:None immut, _r3_:None immut},
                      _r2_:delta_tuples, _r3_:false}).map
                    ((\_b1_ -> 
                      bind _b1_ as {key:ip, value:tuples} in 
                      {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
                _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                _r3_:collection {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                _r4_:int, _r5_:int, _r6_:real } @ { Set } } @ { Collection }).groupBy
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
               ((\_b2_ ->
               bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                 bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                 {key:acc_vid.combine
                  ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                  value:acc_tuples.combine tuples})))
               {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                value:empty {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                _r4_:int, _r5_:int, _r6_:real } @ { Set }}).iterate
              ((\_b1_ -> 
                bind _b1_ as {key:ip, value:_b3_} in 
                bind _b3_ as {key:vid_send_list, value:tuple} in 
                (insert_CUSTOMER_rcv_corrective_s0_m_QUERY3_mCUSTOMER4, ip)<- {
                  _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
          else ())))

trigger QUERY3_mCUSTOMER2_send_correctives : {
key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:real } @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {key:corrective_vid, value:delta_tuples} in 
    let corrective_list =
      filter_corrective_list
        {key:corrective_vid, value:{| key:int, value:int | {key:1, value:3},
         {key:0, value:0}|} @ { Set }} in
    corrective_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:vid_list} in 
        if stmt_id == 3
        then
          ((vid_list.ext
              ((\vid -> 
                bind log_get_bound_delete_CUSTOMER vid as {_r1_:vid,
                                                           _r2_:CUSTOMER_CUSTKEY,
                                                           _r3_:CUSTOMER_NAME,
                                                           _r4_:CUSTOMER_ADDRESS,
                                                           _r5_:CUSTOMER_NATIONKEY,
                                                           _r6_:CUSTOMER_PHONE,
                                                           _r7_:CUSTOMER_ACCTBAL,
                                                           _r8_:CUSTOMER_MKTSEGMENT,
                                                           _r9_:CUSTOMER_COMMENT} in 
                (shuffle_QUERY3_mCUSTOMER2_QUERY3_0t0_1t1_2t2
                   {_r1_:{_r1_:None immut, _r2_:None immut, _r3_:None immut},
                    _r2_:delta_tuples, _r3_:false}).map
                  ((\_b1_ -> 
                    bind _b1_ as {key:ip, value:tuples} in 
                    {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
              _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
              _r3_:collection {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
              _r4_:int, _r5_:int, _r6_:real } @ { Set } } @ { Collection }).groupBy
             ((\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
             ((\_b2_ ->
             bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
               bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
               {key:acc_vid.combine
                ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                value:acc_tuples.combine tuples})))
             {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
              value:empty {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
              _r4_:int, _r5_:int, _r6_:real } @ { Set }}).iterate
            ((\_b1_ -> 
              bind _b1_ as {key:ip, value:_b3_} in 
              bind _b3_ as {key:vid_send_list, value:tuple} in 
              (delete_CUSTOMER_rcv_corrective_s3_m_QUERY3_mCUSTOMER2, ip)<- {
                _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
        else
          if stmt_id == 0
          then
            ((vid_list.ext
                ((\vid -> 
                  bind log_get_bound_insert_CUSTOMER vid as {_r1_:vid,
                                                             _r2_:CUSTOMER_CUSTKEY,
                                                             _r3_:CUSTOMER_NAME,
                                                             _r4_:CUSTOMER_ADDRESS,
                                                             _r5_:CUSTOMER_NATIONKEY,
                                                             _r6_:CUSTOMER_PHONE,
                                                             _r7_:CUSTOMER_ACCTBAL,
                                                             _r8_:CUSTOMER_MKTSEGMENT,
                                                             _r9_:CUSTOMER_COMMENT} in 
                  (shuffle_QUERY3_mCUSTOMER2_QUERY3_0t0_1t1_2t2
                     {_r1_:{_r1_:None immut, _r2_:None immut, _r3_:None immut},
                      _r2_:delta_tuples, _r3_:false}).map
                    ((\_b1_ -> 
                      bind _b1_ as {key:ip, value:tuples} in 
                      {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
                _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                _r3_:collection {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                _r4_:int, _r5_:int, _r6_:real } @ { Set } } @ { Collection }).groupBy
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
               ((\_b2_ ->
               bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                 bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                 {key:acc_vid.combine
                  ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                  value:acc_tuples.combine tuples})))
               {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                value:empty {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                _r4_:int, _r5_:int, _r6_:real } @ { Set }}).iterate
              ((\_b1_ -> 
                bind _b1_ as {key:ip, value:_b3_} in 
                bind _b3_ as {key:vid_send_list, value:tuple} in 
                (insert_CUSTOMER_rcv_corrective_s0_m_QUERY3_mCUSTOMER2, ip)<- {
                  _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
          else ())))

trigger QUERY3_mORDERS6_send_correctives : {
key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {key:corrective_vid, value:delta_tuples} in 
    let corrective_list =
      filter_corrective_list
        {key:corrective_vid, value:{| key:int, value:int | {key:3, value:15},
         {key:3, value:11}, {key:2, value:10}, {key:2, value:6}|} @ { Set }} in
    corrective_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:vid_list} in 
        if stmt_id == 15
        then
          ((vid_list.ext
              ((\vid -> 
                bind log_get_bound_delete_ORDERS vid as {_r1_:vid,
                                                         _r2_:ORDERS_ORDERKEY,
                                                         _r3_:ORDERS_CUSTKEY,
                                                         _r4_:ORDERS_ORDERSTATUS,
                                                         _r5_:ORDERS_TOTALPRICE,
                                                         _r6_:ORDERS_ORDERDATE,
                                                         _r7_:ORDERS_ORDERPRIORITY,
                                                         _r8_:ORDERS_CLERK,
                                                         _r9_:ORDERS_SHIPPRIORITY,
                                                         _r10_:ORDERS_COMMENT} in 
                (shuffle_QUERY3_mORDERS6_QUERY3_mCUSTOMER4_0t0
                   {_r1_:{_r1_:Some ORDERS_ORDERKEY,
                          _r2_:Some ORDERS_ORDERDATE,
                          _r3_:Some ORDERS_SHIPPRIORITY,
                          _r4_:Some ORDERS_CUSTKEY}, _r2_:delta_tuples,
                    _r3_:false}).map
                  ((\_b1_ -> 
                    bind _b1_ as {key:ip, value:tuples} in 
                    {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
              _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
              _r3_:collection {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
              } @ { Set } } @ { Collection }).groupBy
             ((\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
             ((\_b2_ ->
             bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
               bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
               {key:acc_vid.combine
                ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                value:acc_tuples.combine tuples})))
             {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
              value:empty {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
              } @ { Set }}).iterate
            ((\_b1_ -> 
              bind _b1_ as {key:ip, value:_b3_} in 
              bind _b3_ as {key:vid_send_list, value:tuple} in 
              (delete_ORDERS_rcv_corrective_s15_m_QUERY3_mORDERS6, ip)<- {
                _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
        else
          if stmt_id == 11
          then
            ((vid_list.ext
                ((\vid -> 
                  bind log_get_bound_delete_ORDERS vid as {_r1_:vid,
                                                           _r2_:ORDERS_ORDERKEY,
                                                           _r3_:ORDERS_CUSTKEY,
                                                           _r4_:ORDERS_ORDERSTATUS,
                                                           _r5_:ORDERS_TOTALPRICE,
                                                           _r6_:ORDERS_ORDERDATE,
                                                           _r7_:ORDERS_ORDERPRIORITY,
                                                           _r8_:ORDERS_CLERK,
                                                           _r9_:ORDERS_SHIPPRIORITY,
                                                           _r10_:ORDERS_COMMENT} in 
                  (shuffle_QUERY3_mORDERS6_QUERY3_0t0
                     {_r1_:{_r1_:Some ORDERS_ORDERKEY,
                            _r2_:Some ORDERS_ORDERDATE,
                            _r3_:Some ORDERS_SHIPPRIORITY}, _r2_:delta_tuples,
                      _r3_:false}).map
                    ((\_b1_ -> 
                      bind _b1_ as {key:ip, value:tuples} in 
                      {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
                _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                _r3_:collection {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                } @ { Set } } @ { Collection }).groupBy
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
               ((\_b2_ ->
               bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                 bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                 {key:acc_vid.combine
                  ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                  value:acc_tuples.combine tuples})))
               {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                value:empty {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                } @ { Set }}).iterate
              ((\_b1_ -> 
                bind _b1_ as {key:ip, value:_b3_} in 
                bind _b3_ as {key:vid_send_list, value:tuple} in 
                (delete_ORDERS_rcv_corrective_s11_m_QUERY3_mORDERS6, ip)<- {
                  _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
          else
            if stmt_id == 10
            then
              ((vid_list.ext
                  ((\vid -> 
                    bind log_get_bound_insert_ORDERS vid as {_r1_:vid,
                                                             _r2_:ORDERS_ORDERKEY,
                                                             _r3_:ORDERS_CUSTKEY,
                                                             _r4_:ORDERS_ORDERSTATUS,
                                                             _r5_:ORDERS_TOTALPRICE,
                                                             _r6_:ORDERS_ORDERDATE,
                                                             _r7_:ORDERS_ORDERPRIORITY,
                                                             _r8_:ORDERS_CLERK,
                                                             _r9_:ORDERS_SHIPPRIORITY,
                                                             _r10_:ORDERS_COMMENT} in 
                    (shuffle_QUERY3_mORDERS6_QUERY3_mCUSTOMER4_0t0
                       {_r1_:{_r1_:Some ORDERS_ORDERKEY,
                              _r2_:Some ORDERS_ORDERDATE,
                              _r3_:Some ORDERS_SHIPPRIORITY,
                              _r4_:Some ORDERS_CUSTKEY}, _r2_:delta_tuples,
                        _r3_:false}).map
                      ((\_b1_ -> 
                        bind _b1_ as {key:ip, value:tuples} in 
                        {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
                  _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                  _r3_:collection {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                  } @ { Set } } @ { Collection }).groupBy
                 ((\_b1_ -> 
                   bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
                 ((\_b2_ ->
                 bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                   bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                   {key:acc_vid.combine
                    ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                    value:acc_tuples.combine tuples})))
                 {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                  value:empty {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                  } @ { Set }}).iterate
                ((\_b1_ -> 
                  bind _b1_ as {key:ip, value:_b3_} in 
                  bind _b3_ as {key:vid_send_list, value:tuple} in 
                  (insert_ORDERS_rcv_corrective_s10_m_QUERY3_mORDERS6, ip)<- {
                    _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
            else
              if stmt_id == 6
              then
                ((vid_list.ext
                    ((\vid -> 
                      bind log_get_bound_insert_ORDERS vid as {_r1_:vid,
                                                               _r2_:ORDERS_ORDERKEY,
                                                               _r3_:ORDERS_CUSTKEY,
                                                               _r4_:ORDERS_ORDERSTATUS,
                                                               _r5_:ORDERS_TOTALPRICE,
                                                               _r6_:ORDERS_ORDERDATE,
                                                               _r7_:ORDERS_ORDERPRIORITY,
                                                               _r8_:ORDERS_CLERK,
                                                               _r9_:ORDERS_SHIPPRIORITY,
                                                               _r10_:ORDERS_COMMENT} in 
                      (shuffle_QUERY3_mORDERS6_QUERY3_0t0
                         {_r1_:{_r1_:Some ORDERS_ORDERKEY,
                                _r2_:Some ORDERS_ORDERDATE,
                                _r3_:Some ORDERS_SHIPPRIORITY},
                          _r2_:delta_tuples, _r3_:false}).map
                        ((\_b1_ -> 
                          bind _b1_ as {key:ip, value:tuples} in 
                          {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
                    _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                    _r3_:collection {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                    } @ { Set } } @ { Collection }).groupBy
                   ((\_b1_ -> 
                     bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
                   ((\_b2_ ->
                   bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                     bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                     {key:acc_vid.combine
                      ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                      value:acc_tuples.combine tuples})))
                   {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                    value:empty {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                    } @ { Set }}).iterate
                  ((\_b1_ -> 
                    bind _b1_ as {key:ip, value:_b3_} in 
                    bind _b3_ as {key:vid_send_list, value:tuple} in 
                    (insert_ORDERS_rcv_corrective_s6_m_QUERY3_mORDERS6, ip)<- {
                      _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
              else ())))

trigger QUERY3_mLINEITEM1_mCUSTOMER2_send_correctives : {
key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int, _r5_:int,
_r6_:int } @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {key:corrective_vid, value:delta_tuples} in 
    let corrective_list =
      filter_corrective_list
        {key:corrective_vid, value:{| key:int, value:int | {key:5, value:25},
         {key:5, value:24}, {key:4, value:20}, {key:4, value:19},
         {key:1, value:4}, {key:0, value:1}|} @ { Set }} in
    corrective_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:vid_list} in 
        if stmt_id == 25
        then
          ((vid_list.ext
              ((\vid -> 
                bind log_get_bound_delete_LINEITEM vid as {_r1_:vid,
                                                           _r2_:LINEITEM_ORDERKEY,
                                                           _r3_:LINEITEM_PARTKEY,
                                                           _r4_:LINEITEM_SUPPKEY,
                                                           _r5_:LINEITEM_LINENUMBER,
                                                           _r6_:LINEITEM_QUANTITY,
                                                           _r7_:LINEITEM_EXTENDEDPRICE,
                                                           _r8_:LINEITEM_DISCOUNT,
                                                           _r9_:LINEITEM_TAX,
                                                           _r10_:LINEITEM_RETURNFLAG,
                                                           _r11_:LINEITEM_LINESTATUS,
                                                           _r12_:LINEITEM_SHIPDATE,
                                                           _r13_:LINEITEM_COMMITDATE,
                                                           _r14_:LINEITEM_RECEIPTDATE,
                                                           _r15_:LINEITEM_SHIPINSTRUCT,
                                                           _r16_:LINEITEM_SHIPMODE,
                                                           _r17_:LINEITEM_COMMENT} in 
                (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mCUSTOMER4_0t0_1t1_2t2_3t3
                   {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut,
                          _r3_:None immut, _r4_:None immut}, _r2_:delta_tuples,
                    _r3_:false}).map
                  ((\_b1_ -> 
                    bind _b1_ as {key:ip, value:tuples} in 
                    {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
              _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
              _r3_:collection {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
              _r4_:int, _r5_:int, _r6_:int } @ { Set } } @ { Collection }).groupBy
             ((\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
             ((\_b2_ ->
             bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
               bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
               {key:acc_vid.combine
                ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                value:acc_tuples.combine tuples})))
             {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
              value:empty {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
              _r4_:int, _r5_:int, _r6_:int } @ { Set }}).iterate
            ((\_b1_ -> 
              bind _b1_ as {key:ip, value:_b3_} in 
              bind _b3_ as {key:vid_send_list, value:tuple} in 
              (delete_LINEITEM_rcv_corrective_s25_m_QUERY3_mLINEITEM1_mCUSTOMER2,
                ip)<- {_r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
        else
          if stmt_id == 24
          then
            ((vid_list.ext
                ((\vid -> 
                  bind log_get_bound_delete_LINEITEM vid as {_r1_:vid,
                                                             _r2_:LINEITEM_ORDERKEY,
                                                             _r3_:LINEITEM_PARTKEY,
                                                             _r4_:LINEITEM_SUPPKEY,
                                                             _r5_:LINEITEM_LINENUMBER,
                                                             _r6_:LINEITEM_QUANTITY,
                                                             _r7_:LINEITEM_EXTENDEDPRICE,
                                                             _r8_:LINEITEM_DISCOUNT,
                                                             _r9_:LINEITEM_TAX,
                                                             _r10_:LINEITEM_RETURNFLAG,
                                                             _r11_:LINEITEM_LINESTATUS,
                                                             _r12_:LINEITEM_SHIPDATE,
                                                             _r13_:LINEITEM_COMMITDATE,
                                                             _r14_:LINEITEM_RECEIPTDATE,
                                                             _r15_:LINEITEM_SHIPINSTRUCT,
                                                             _r16_:LINEITEM_SHIPMODE,
                                                             _r17_:LINEITEM_COMMENT} in 
                  (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mCUSTOMER2_0t0_1t1_2t2_3t3
                     {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut,
                            _r3_:None immut, _r4_:None immut},
                      _r2_:delta_tuples, _r3_:false}).map
                    ((\_b1_ -> 
                      bind _b1_ as {key:ip, value:tuples} in 
                      {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
                _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                _r3_:collection {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                _r4_:int, _r5_:int, _r6_:int } @ { Set } } @ { Collection }).groupBy
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
               ((\_b2_ ->
               bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                 bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                 {key:acc_vid.combine
                  ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                  value:acc_tuples.combine tuples})))
               {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                value:empty {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                _r4_:int, _r5_:int, _r6_:int } @ { Set }}).iterate
              ((\_b1_ -> 
                bind _b1_ as {key:ip, value:_b3_} in 
                bind _b3_ as {key:vid_send_list, value:tuple} in 
                (delete_LINEITEM_rcv_corrective_s24_m_QUERY3_mLINEITEM1_mCUSTOMER2,
                  ip)<- {_r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
          else
            if stmt_id == 20
            then
              ((vid_list.ext
                  ((\vid -> 
                    bind log_get_bound_insert_LINEITEM vid as {_r1_:vid,
                                                               _r2_:LINEITEM_ORDERKEY,
                                                               _r3_:LINEITEM_PARTKEY,
                                                               _r4_:LINEITEM_SUPPKEY,
                                                               _r5_:LINEITEM_LINENUMBER,
                                                               _r6_:LINEITEM_QUANTITY,
                                                               _r7_:LINEITEM_EXTENDEDPRICE,
                                                               _r8_:LINEITEM_DISCOUNT,
                                                               _r9_:LINEITEM_TAX,
                                                               _r10_:LINEITEM_RETURNFLAG,
                                                               _r11_:LINEITEM_LINESTATUS,
                                                               _r12_:LINEITEM_SHIPDATE,
                                                               _r13_:LINEITEM_COMMITDATE,
                                                               _r14_:LINEITEM_RECEIPTDATE,
                                                               _r15_:LINEITEM_SHIPINSTRUCT,
                                                               _r16_:LINEITEM_SHIPMODE,
                                                               _r17_:LINEITEM_COMMENT} in 
                    (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mCUSTOMER4_0t0_1t1_2t2_3t3
                       {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut,
                              _r3_:None immut, _r4_:None immut},
                        _r2_:delta_tuples, _r3_:false}).map
                      ((\_b1_ -> 
                        bind _b1_ as {key:ip, value:tuples} in 
                        {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
                  _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                  _r3_:collection {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                  _r4_:int, _r5_:int, _r6_:int } @ { Set } } @ { Collection }).groupBy
                 ((\_b1_ -> 
                   bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
                 ((\_b2_ ->
                 bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                   bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                   {key:acc_vid.combine
                    ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                    value:acc_tuples.combine tuples})))
                 {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                  value:empty {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                  _r4_:int, _r5_:int, _r6_:int } @ { Set }}).iterate
                ((\_b1_ -> 
                  bind _b1_ as {key:ip, value:_b3_} in 
                  bind _b3_ as {key:vid_send_list, value:tuple} in 
                  (insert_LINEITEM_rcv_corrective_s20_m_QUERY3_mLINEITEM1_mCUSTOMER2,
                    ip)<- {_r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
            else
              if stmt_id == 19
              then
                ((vid_list.ext
                    ((\vid -> 
                      bind log_get_bound_insert_LINEITEM vid as {_r1_:vid,
                                                                 _r2_:LINEITEM_ORDERKEY,
                                                                 _r3_:LINEITEM_PARTKEY,
                                                                 _r4_:LINEITEM_SUPPKEY,
                                                                 _r5_:LINEITEM_LINENUMBER,
                                                                 _r6_:LINEITEM_QUANTITY,
                                                                 _r7_:LINEITEM_EXTENDEDPRICE,
                                                                 _r8_:LINEITEM_DISCOUNT,
                                                                 _r9_:LINEITEM_TAX,
                                                                 _r10_:LINEITEM_RETURNFLAG,
                                                                 _r11_:LINEITEM_LINESTATUS,
                                                                 _r12_:LINEITEM_SHIPDATE,
                                                                 _r13_:LINEITEM_COMMITDATE,
                                                                 _r14_:LINEITEM_RECEIPTDATE,
                                                                 _r15_:LINEITEM_SHIPINSTRUCT,
                                                                 _r16_:LINEITEM_SHIPMODE,
                                                                 _r17_:LINEITEM_COMMENT} in 
                      (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mCUSTOMER2_0t0_1t1_2t2_3t3
                         {_r1_:{_r1_:Some LINEITEM_ORDERKEY, _r2_:None immut,
                                _r3_:None immut, _r4_:None immut},
                          _r2_:delta_tuples, _r3_:false}).map
                        ((\_b1_ -> 
                          bind _b1_ as {key:ip, value:tuples} in 
                          {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
                    _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                    _r3_:collection {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                    _r4_:int, _r5_:int, _r6_:int } @ { Set } } @ { Collection }).groupBy
                   ((\_b1_ -> 
                     bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
                   ((\_b2_ ->
                   bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                     bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                     {key:acc_vid.combine
                      ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                      value:acc_tuples.combine tuples})))
                   {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                    value:empty {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                    _r4_:int, _r5_:int, _r6_:int } @ { Set }}).iterate
                  ((\_b1_ -> 
                    bind _b1_ as {key:ip, value:_b3_} in 
                    bind _b3_ as {key:vid_send_list, value:tuple} in 
                    (insert_LINEITEM_rcv_corrective_s19_m_QUERY3_mLINEITEM1_mCUSTOMER2,
                      ip)<- {_r1_:corrective_vid, _r2_:vid_send_list,
                             _r3_:tuple}))
              else
                if stmt_id == 4
                then
                  ((vid_list.ext
                      ((\vid -> 
                        bind log_get_bound_delete_CUSTOMER vid as {_r1_:vid,
                                                                   _r2_:CUSTOMER_CUSTKEY,
                                                                   _r3_:CUSTOMER_NAME,
                                                                   _r4_:CUSTOMER_ADDRESS,
                                                                   _r5_:CUSTOMER_NATIONKEY,
                                                                   _r6_:CUSTOMER_PHONE,
                                                                   _r7_:CUSTOMER_ACCTBAL,
                                                                   _r8_:CUSTOMER_MKTSEGMENT,
                                                                   _r9_:CUSTOMER_COMMENT} in 
                        (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mLINEITEM1_0t0_1t1_2t2
                           {_r1_:{_r1_:None immut, _r2_:None immut,
                                  _r3_:None immut}, _r2_:delta_tuples,
                            _r3_:false}).map
                          ((\_b1_ -> 
                            bind _b1_ as {key:ip, value:tuples} in 
                            {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
                      _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                      _r3_:collection {
                      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                      _r3_:int, _r4_:int, _r5_:int, _r6_:int } @ { Set }
                      } @ { Collection }).groupBy
                     ((\_b1_ -> 
                       bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
                     ((\_b2_ ->
                     bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                       bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                       {key:acc_vid.combine
                        ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                        value:acc_tuples.combine tuples})))
                     {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                      value:empty {
                      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                      _r3_:int, _r4_:int, _r5_:int, _r6_:int } @ { Set }}).iterate
                    ((\_b1_ -> 
                      bind _b1_ as {key:ip, value:_b3_} in 
                      bind _b3_ as {key:vid_send_list, value:tuple} in 
                      (delete_CUSTOMER_rcv_corrective_s4_m_QUERY3_mLINEITEM1_mCUSTOMER2,
                        ip)<- {_r1_:corrective_vid, _r2_:vid_send_list,
                               _r3_:tuple}))
                else
                  if stmt_id == 1
                  then
                    ((vid_list.ext
                        ((\vid -> 
                          bind log_get_bound_insert_CUSTOMER vid as {
                          _r1_:vid, _r2_:CUSTOMER_CUSTKEY, _r3_:CUSTOMER_NAME,
                          _r4_:CUSTOMER_ADDRESS, _r5_:CUSTOMER_NATIONKEY,
                          _r6_:CUSTOMER_PHONE, _r7_:CUSTOMER_ACCTBAL,
                          _r8_:CUSTOMER_MKTSEGMENT, _r9_:CUSTOMER_COMMENT} in 
                          (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_QUERY3_mLINEITEM1_0t0_1t1_2t2
                             {_r1_:{_r1_:None immut, _r2_:None immut,
                                    _r3_:None immut}, _r2_:delta_tuples,
                              _r3_:false}).map
                            ((\_b1_ -> 
                              bind _b1_ as {key:ip, value:tuples} in 
                              {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
                        _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                        _r3_:collection {
                        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                        _r3_:int, _r4_:int, _r5_:int, _r6_:int } @ { Set }
                        } @ { Collection }).groupBy
                       ((\_b1_ -> 
                         bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
                       ((\_b2_ ->
                       bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ ->
                       
                         bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                         {key:acc_vid.combine
                          ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                          value:acc_tuples.combine tuples})))
                       {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                        value:empty {
                        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                        _r3_:int, _r4_:int, _r5_:int, _r6_:int } @ { Set }}).iterate
                      ((\_b1_ -> 
                        bind _b1_ as {key:ip, value:_b3_} in 
                        bind _b3_ as {key:vid_send_list, value:tuple} in 
                        (insert_CUSTOMER_rcv_corrective_s1_m_QUERY3_mLINEITEM1_mCUSTOMER2,
                          ip)<- {_r1_:corrective_vid, _r2_:vid_send_list,
                                 _r3_:tuple}))
                  else ())))

trigger QUERY3_mORDERS3_send_correctives : {
key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real } @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {key:corrective_vid, value:delta_tuples} in 
    let corrective_list =
      filter_corrective_list
        {key:corrective_vid, value:{| key:int, value:int | {key:3, value:14},
         {key:3, value:11}, {key:2, value:9}, {key:2, value:6}|} @ { Set }} in
    corrective_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:vid_list} in 
        if stmt_id == 14
        then
          ((vid_list.ext
              ((\vid -> 
                bind log_get_bound_delete_ORDERS vid as {_r1_:vid,
                                                         _r2_:ORDERS_ORDERKEY,
                                                         _r3_:ORDERS_CUSTKEY,
                                                         _r4_:ORDERS_ORDERSTATUS,
                                                         _r5_:ORDERS_TOTALPRICE,
                                                         _r6_:ORDERS_ORDERDATE,
                                                         _r7_:ORDERS_ORDERPRIORITY,
                                                         _r8_:ORDERS_CLERK,
                                                         _r9_:ORDERS_SHIPPRIORITY,
                                                         _r10_:ORDERS_COMMENT} in 
                (shuffle_QUERY3_mORDERS3_QUERY3_mCUSTOMER2_0t0
                   {_r1_:{_r1_:Some ORDERS_ORDERKEY,
                          _r2_:Some ORDERS_ORDERDATE,
                          _r3_:Some ORDERS_SHIPPRIORITY,
                          _r4_:Some ORDERS_CUSTKEY}, _r2_:delta_tuples,
                    _r3_:false}).map
                  ((\_b1_ -> 
                    bind _b1_ as {key:ip, value:tuples} in 
                    {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
              _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
              _r3_:collection {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
              } @ { Set } } @ { Collection }).groupBy
             ((\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
             ((\_b2_ ->
             bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
               bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
               {key:acc_vid.combine
                ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                value:acc_tuples.combine tuples})))
             {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
              value:empty {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
              } @ { Set }}).iterate
            ((\_b1_ -> 
              bind _b1_ as {key:ip, value:_b3_} in 
              bind _b3_ as {key:vid_send_list, value:tuple} in 
              (delete_ORDERS_rcv_corrective_s14_m_QUERY3_mORDERS3, ip)<- {
                _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
        else
          if stmt_id == 11
          then
            ((vid_list.ext
                ((\vid -> 
                  bind log_get_bound_delete_ORDERS vid as {_r1_:vid,
                                                           _r2_:ORDERS_ORDERKEY,
                                                           _r3_:ORDERS_CUSTKEY,
                                                           _r4_:ORDERS_ORDERSTATUS,
                                                           _r5_:ORDERS_TOTALPRICE,
                                                           _r6_:ORDERS_ORDERDATE,
                                                           _r7_:ORDERS_ORDERPRIORITY,
                                                           _r8_:ORDERS_CLERK,
                                                           _r9_:ORDERS_SHIPPRIORITY,
                                                           _r10_:ORDERS_COMMENT} in 
                  (shuffle_QUERY3_mORDERS3_QUERY3_0t0
                     {_r1_:{_r1_:Some ORDERS_ORDERKEY,
                            _r2_:Some ORDERS_ORDERDATE,
                            _r3_:Some ORDERS_SHIPPRIORITY}, _r2_:delta_tuples,
                      _r3_:false}).map
                    ((\_b1_ -> 
                      bind _b1_ as {key:ip, value:tuples} in 
                      {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
                _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                _r3_:collection {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                } @ { Set } } @ { Collection }).groupBy
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
               ((\_b2_ ->
               bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                 bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                 {key:acc_vid.combine
                  ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                  value:acc_tuples.combine tuples})))
               {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                value:empty {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                } @ { Set }}).iterate
              ((\_b1_ -> 
                bind _b1_ as {key:ip, value:_b3_} in 
                bind _b3_ as {key:vid_send_list, value:tuple} in 
                (delete_ORDERS_rcv_corrective_s11_m_QUERY3_mORDERS3, ip)<- {
                  _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
          else
            if stmt_id == 9
            then
              ((vid_list.ext
                  ((\vid -> 
                    bind log_get_bound_insert_ORDERS vid as {_r1_:vid,
                                                             _r2_:ORDERS_ORDERKEY,
                                                             _r3_:ORDERS_CUSTKEY,
                                                             _r4_:ORDERS_ORDERSTATUS,
                                                             _r5_:ORDERS_TOTALPRICE,
                                                             _r6_:ORDERS_ORDERDATE,
                                                             _r7_:ORDERS_ORDERPRIORITY,
                                                             _r8_:ORDERS_CLERK,
                                                             _r9_:ORDERS_SHIPPRIORITY,
                                                             _r10_:ORDERS_COMMENT} in 
                    (shuffle_QUERY3_mORDERS3_QUERY3_mCUSTOMER2_0t0
                       {_r1_:{_r1_:Some ORDERS_ORDERKEY,
                              _r2_:Some ORDERS_ORDERDATE,
                              _r3_:Some ORDERS_SHIPPRIORITY,
                              _r4_:Some ORDERS_CUSTKEY}, _r2_:delta_tuples,
                        _r3_:false}).map
                      ((\_b1_ -> 
                        bind _b1_ as {key:ip, value:tuples} in 
                        {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
                  _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                  _r3_:collection {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                  } @ { Set } } @ { Collection }).groupBy
                 ((\_b1_ -> 
                   bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
                 ((\_b2_ ->
                 bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                   bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                   {key:acc_vid.combine
                    ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                    value:acc_tuples.combine tuples})))
                 {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                  value:empty {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                  } @ { Set }}).iterate
                ((\_b1_ -> 
                  bind _b1_ as {key:ip, value:_b3_} in 
                  bind _b3_ as {key:vid_send_list, value:tuple} in 
                  (insert_ORDERS_rcv_corrective_s9_m_QUERY3_mORDERS3, ip)<- {
                    _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
            else
              if stmt_id == 6
              then
                ((vid_list.ext
                    ((\vid -> 
                      bind log_get_bound_insert_ORDERS vid as {_r1_:vid,
                                                               _r2_:ORDERS_ORDERKEY,
                                                               _r3_:ORDERS_CUSTKEY,
                                                               _r4_:ORDERS_ORDERSTATUS,
                                                               _r5_:ORDERS_TOTALPRICE,
                                                               _r6_:ORDERS_ORDERDATE,
                                                               _r7_:ORDERS_ORDERPRIORITY,
                                                               _r8_:ORDERS_CLERK,
                                                               _r9_:ORDERS_SHIPPRIORITY,
                                                               _r10_:ORDERS_COMMENT} in 
                      (shuffle_QUERY3_mORDERS3_QUERY3_0t0
                         {_r1_:{_r1_:Some ORDERS_ORDERKEY,
                                _r2_:Some ORDERS_ORDERDATE,
                                _r3_:Some ORDERS_SHIPPRIORITY},
                          _r2_:delta_tuples, _r3_:false}).map
                        ((\_b1_ -> 
                          bind _b1_ as {key:ip, value:tuples} in 
                          {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
                    _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                    _r3_:collection {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                    } @ { Set } } @ { Collection }).groupBy
                   ((\_b1_ -> 
                     bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
                   ((\_b2_ ->
                   bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                     bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                     {key:acc_vid.combine
                      ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                      value:acc_tuples.combine tuples})))
                   {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                    value:empty {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:real
                    } @ { Set }}).iterate
                  ((\_b1_ -> 
                    bind _b1_ as {key:ip, value:_b3_} in 
                    bind _b3_ as {key:vid_send_list, value:tuple} in 
                    (insert_ORDERS_rcv_corrective_s6_m_QUERY3_mORDERS3, ip)<- {
                      _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
              else ())))

trigger QUERY3_mORDERS1_send_correctives : {
key:{ _r1_:int, _r2_:int, _r3_:int }, value:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
=
  (\_b1_ -> 
    bind _b1_ as {key:corrective_vid, value:delta_tuples} in 
    let corrective_list =
      filter_corrective_list
        {key:corrective_vid, value:{| key:int, value:int | {key:3, value:12},
         {key:3, value:11}, {key:2, value:7}, {key:2, value:6}|} @ { Set }} in
    corrective_list.iterate
      ((\_b1_ -> 
        bind _b1_ as {key:stmt_id, value:vid_list} in 
        if stmt_id == 12
        then
          ((vid_list.ext
              ((\vid -> 
                bind log_get_bound_delete_ORDERS vid as {_r1_:vid,
                                                         _r2_:ORDERS_ORDERKEY,
                                                         _r3_:ORDERS_CUSTKEY,
                                                         _r4_:ORDERS_ORDERSTATUS,
                                                         _r5_:ORDERS_TOTALPRICE,
                                                         _r6_:ORDERS_ORDERDATE,
                                                         _r7_:ORDERS_ORDERPRIORITY,
                                                         _r8_:ORDERS_CLERK,
                                                         _r9_:ORDERS_SHIPPRIORITY,
                                                         _r10_:ORDERS_COMMENT} in 
                (shuffle_QUERY3_mORDERS1_QUERY3_mLINEITEM1
                   {_r1_:{_r1_:Some ORDERS_ORDERKEY,
                          _r2_:Some ORDERS_ORDERDATE,
                          _r3_:Some ORDERS_SHIPPRIORITY}, _r2_:delta_tuples,
                    _r3_:false}).map
                  ((\_b1_ -> 
                    bind _b1_ as {key:ip, value:tuples} in 
                    {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
              _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
              _r3_:collection {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
              } @ { Set } } @ { Collection }).groupBy
             ((\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
             ((\_b2_ ->
             bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
               bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
               {key:acc_vid.combine
                ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                value:acc_tuples.combine tuples})))
             {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
              value:empty {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
              } @ { Set }}).iterate
            ((\_b1_ -> 
              bind _b1_ as {key:ip, value:_b3_} in 
              bind _b3_ as {key:vid_send_list, value:tuple} in 
              (delete_ORDERS_rcv_corrective_s12_m_QUERY3_mORDERS1, ip)<- {
                _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
        else
          if stmt_id == 11
          then
            ((vid_list.ext
                ((\vid -> 
                  bind log_get_bound_delete_ORDERS vid as {_r1_:vid,
                                                           _r2_:ORDERS_ORDERKEY,
                                                           _r3_:ORDERS_CUSTKEY,
                                                           _r4_:ORDERS_ORDERSTATUS,
                                                           _r5_:ORDERS_TOTALPRICE,
                                                           _r6_:ORDERS_ORDERDATE,
                                                           _r7_:ORDERS_ORDERPRIORITY,
                                                           _r8_:ORDERS_CLERK,
                                                           _r9_:ORDERS_SHIPPRIORITY,
                                                           _r10_:ORDERS_COMMENT} in 
                  (shuffle_QUERY3_mORDERS1_QUERY3
                     {_r1_:{_r1_:Some ORDERS_ORDERKEY,
                            _r2_:Some ORDERS_ORDERDATE,
                            _r3_:Some ORDERS_SHIPPRIORITY}, _r2_:delta_tuples,
                      _r3_:false}).map
                    ((\_b1_ -> 
                      bind _b1_ as {key:ip, value:tuples} in 
                      {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
                _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                _r3_:collection {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                } @ { Set } } @ { Collection }).groupBy
               ((\_b1_ -> 
                 bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
               ((\_b2_ ->
               bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                 bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                 {key:acc_vid.combine
                  ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                  value:acc_tuples.combine tuples})))
               {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                value:empty {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                } @ { Set }}).iterate
              ((\_b1_ -> 
                bind _b1_ as {key:ip, value:_b3_} in 
                bind _b3_ as {key:vid_send_list, value:tuple} in 
                (delete_ORDERS_rcv_corrective_s11_m_QUERY3_mORDERS1, ip)<- {
                  _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
          else
            if stmt_id == 7
            then
              ((vid_list.ext
                  ((\vid -> 
                    bind log_get_bound_insert_ORDERS vid as {_r1_:vid,
                                                             _r2_:ORDERS_ORDERKEY,
                                                             _r3_:ORDERS_CUSTKEY,
                                                             _r4_:ORDERS_ORDERSTATUS,
                                                             _r5_:ORDERS_TOTALPRICE,
                                                             _r6_:ORDERS_ORDERDATE,
                                                             _r7_:ORDERS_ORDERPRIORITY,
                                                             _r8_:ORDERS_CLERK,
                                                             _r9_:ORDERS_SHIPPRIORITY,
                                                             _r10_:ORDERS_COMMENT} in 
                    (shuffle_QUERY3_mORDERS1_QUERY3_mLINEITEM1
                       {_r1_:{_r1_:Some ORDERS_ORDERKEY,
                              _r2_:Some ORDERS_ORDERDATE,
                              _r3_:Some ORDERS_SHIPPRIORITY},
                        _r2_:delta_tuples, _r3_:false}).map
                      ((\_b1_ -> 
                        bind _b1_ as {key:ip, value:tuples} in 
                        {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
                  _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                  _r3_:collection {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                  } @ { Set } } @ { Collection }).groupBy
                 ((\_b1_ -> 
                   bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
                 ((\_b2_ ->
                 bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                   bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                   {key:acc_vid.combine
                    ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                    value:acc_tuples.combine tuples})))
                 {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                  value:empty {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                  } @ { Set }}).iterate
                ((\_b1_ -> 
                  bind _b1_ as {key:ip, value:_b3_} in 
                  bind _b3_ as {key:vid_send_list, value:tuple} in 
                  (insert_ORDERS_rcv_corrective_s7_m_QUERY3_mORDERS1, ip)<- {
                    _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
            else
              if stmt_id == 6
              then
                ((vid_list.ext
                    ((\vid -> 
                      bind log_get_bound_insert_ORDERS vid as {_r1_:vid,
                                                               _r2_:ORDERS_ORDERKEY,
                                                               _r3_:ORDERS_CUSTKEY,
                                                               _r4_:ORDERS_ORDERSTATUS,
                                                               _r5_:ORDERS_TOTALPRICE,
                                                               _r6_:ORDERS_ORDERDATE,
                                                               _r7_:ORDERS_ORDERPRIORITY,
                                                               _r8_:ORDERS_CLERK,
                                                               _r9_:ORDERS_SHIPPRIORITY,
                                                               _r10_:ORDERS_COMMENT} in 
                      (shuffle_QUERY3_mORDERS1_QUERY3
                         {_r1_:{_r1_:Some ORDERS_ORDERKEY,
                                _r2_:Some ORDERS_ORDERDATE,
                                _r3_:Some ORDERS_SHIPPRIORITY},
                          _r2_:delta_tuples, _r3_:false}).map
                        ((\_b1_ -> 
                          bind _b1_ as {key:ip, value:tuples} in 
                          {_r1_:ip, _r2_:vid, _r3_:tuples})))) empty {
                    _r1_:address, _r2_:{ _r1_:int, _r2_:int, _r3_:int },
                    _r3_:collection {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                    } @ { Set } } @ { Collection }).groupBy
                   ((\_b1_ -> 
                     bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip))
                   ((\_b2_ ->
                   bind _b2_ as {key:acc_vid, value:acc_tuples} in (\_b5_ -> 
                     bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                     {key:acc_vid.combine
                      ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                      value:acc_tuples.combine tuples})))
                   {key:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                    value:empty {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                    } @ { Set }}).iterate
                  ((\_b1_ -> 
                    bind _b1_ as {key:ip, value:_b3_} in 
                    bind _b3_ as {key:vid_send_list, value:tuple} in 
                    (insert_ORDERS_rcv_corrective_s6_m_QUERY3_mORDERS1, ip)<- {
                      _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple}))
              else ())))

trigger node_dummy : int
=
  (\x ->  ())

trigger switch_main : {
_r1_:string, _r2_:option {
_r1_:int, _r2_:string, _r3_:string, _r4_:int, _r5_:string, _r6_:real,
_r7_:string, _r8_:string }, _r3_:option {
_r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real, _r6_:real, _r7_:real,
_r8_:real, _r9_:string, _r10_:string, _r11_:string, _r12_:string, _r13_:string,
_r14_:string, _r15_:string, _r16_:string }, _r4_:option {
_r1_:int, _r2_:int, _r3_:string, _r4_:real, _r5_:string, _r6_:string,
_r7_:string, _r8_:int, _r9_:string }
}
=
  (\_b1_ -> 
    bind _b1_ as {_r1_:trigger_id, _r2_:insert_CUSTOMER_args,
                  _r3_:insert_LINEITEM_args, _r4_:insert_ORDERS_args} in 
    if trigger_id == "insert_CUSTOMER"
    then
      (insert_CUSTOMER, me)<- let insert_CUSTOMER_args_unwrap = case insert_CUSTOMER_args of
        { Some x -> x }
        { None -> error () } in
        insert_CUSTOMER_args_unwrap
    else
      if trigger_id == "insert_LINEITEM"
      then
        (insert_LINEITEM, me)<- let insert_LINEITEM_args_unwrap = case insert_LINEITEM_args of
          { Some x -> x }
          { None -> error () } in
          bind insert_LINEITEM_args_unwrap as {_r1_:_a1, _r2_:_a2, _r3_:_a3,
                                               _r4_:_a4, _r5_:_a5, _r6_:_a6,
                                               _r7_:_a7, _r8_:_a8, _r9_:_a9,
                                               _r10_:_a10, _r11_:_a11,
                                               _r12_:_a12, _r13_:_a13,
                                               _r14_:_a14, _r15_:_a15,
                                               _r16_:_a16} in 
          {_r1_:_a1, _r2_:_a2, _r3_:_a3, _r4_:_a4, _r5_:_a5, _r6_:_a6,
           _r7_:_a7, _r8_:_a8, _r9_:_a9, _r10_:_a10, _r11_:parse_sql_date _a11,
           _r12_:parse_sql_date _a12, _r13_:parse_sql_date _a13, _r14_:_a14,
           _r15_:_a15, _r16_:_a16}
      else
        if trigger_id == "insert_ORDERS"
        then
          (insert_ORDERS, me)<- let insert_ORDERS_args_unwrap = case insert_ORDERS_args of
            { Some x -> x }
            { None -> error () } in
            bind insert_ORDERS_args_unwrap as {_r1_:_a1, _r2_:_a2, _r3_:_a3,
                                               _r4_:_a4, _r5_:_a5, _r6_:_a6,
                                               _r7_:_a7, _r8_:_a8, _r9_:_a9} in 
            {_r1_:_a1, _r2_:_a2, _r3_:_a3, _r4_:_a4, _r5_:parse_sql_date _a5,
             _r6_:_a6, _r7_:_a7, _r8_:_a8, _r9_:_a9}
        else ())

source s1 : {
_r1_:string, _r2_:option {
_r1_:int, _r2_:string, _r3_:string, _r4_:int, _r5_:string, _r6_:real,
_r7_:string, _r8_:string }, _r3_:option {
_r1_:int, _r2_:int, _r3_:int, _r4_:int, _r5_:real, _r6_:real, _r7_:real,
_r8_:real, _r9_:string, _r10_:string, _r11_:string, _r12_:string, _r13_:string,
_r14_:string, _r15_:string, _r16_:string }, _r4_:option {
_r1_:int, _r2_:int, _r3_:string, _r4_:real, _r5_:string, _r6_:string,
_r7_:string, _r8_:int, _r9_:string }
} = file "tpch3.csv" k3
feed s1 |> switch_main

