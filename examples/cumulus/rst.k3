declare __map_ids__ : collection { _r1_:int, _r2_:string, _r3_:int
  } @ { Set } = {| _r1_:int, _r2_:string, _r3_:int |
  {_r1_:1, _r2_:"ATIMESD", _r3_:1}, {_r1_:2, _r2_:"ATIMESD_mT1", _r3_:2},
  {_r1_:3, _r2_:"ATIMESD_mT1_mR1", _r3_:3},
  {_r1_:4, _r2_:"ATIMESD_mS1", _r3_:2}, {_r1_:5, _r2_:"ATIMESD_mS2", _r3_:2},
  {_r1_:6, _r2_:"ATIMESD_mR1", _r3_:2}|} @ { Set }

declare __vid_counter__ : collection {elem:mut int} @ { Set } = {|elem:int|
  1|} @ { Set }

declare __epoch__ : collection {elem:mut int} @ { Set } = {|elem:int|
  0|} @ { Set }

declare __init_vid__ : { _r1_:int, _r2_:int, _r3_:int } =
  {_r1_:0, _r2_:0, _r3_:hash me}

declare ATIMESD : collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int
  } @ { Set } = {| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int |
  {_r1_:__init_vid__, _r2_:0}|} @ { Set }

declare ATIMESD_mT1 : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare ATIMESD_mT1_mR1 : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Set }

declare ATIMESD_mS1 : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare ATIMESD_mS2 : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare ATIMESD_mR1 : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mT1_s0_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mT1_mR1_s2_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Set }

declare map_ATIMESD_mT1_s3_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mT1_mR1_s5_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Set }

declare map_ATIMESD_mS1_s6_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mS2_s6_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mS1_s7_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mS2_s9_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mS1_s10_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mS2_s10_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mS1_s11_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mS2_s13_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mR1_s14_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mT1_mR1_s15_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Set }

declare map_ATIMESD_mR1_s17_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mT1_mR1_s18_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Set }

declare map_ATIMESD_mS2_s24_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mS2_s26_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mS1_s28_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mS1_s30_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mS2_s32_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mS2_s34_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mS1_s36_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare map_ATIMESD_mS1_s38_buf : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare __stmt_cntrs__ : collection {
  _r1_:{ _r1_:mut int, _r2_:mut int, _r3_:mut int }, _r2_:mut int, _r3_:mut int
  } @ { Set }

declare log__master : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare log_insert_T : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare log_delete_T : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare log_insert_S : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare log_delete_S : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare log_insert_R : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare log_delete_R : collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }

declare vid_eq : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = \_b1_ -> 
    bind _b1_ as {_r1_:_b2_, _r2_:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in l0 == r0 and (l1 == r1 and l2
    == r2)

declare vid_neq : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = \_b1_ -> 
    bind _b1_ as {_r1_:_b2_, _r2_:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in not (l0 == r0 and (l1 == r1 and
    l2 == r2))

declare vid_lt : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = \_b1_ -> 
    bind _b1_ as {_r1_:_b2_, _r2_:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in l0 < r0 or (l0 == r0 and (l1 <
    r1 or (l1 == r1 and l2 < r2)))

declare vid_gt : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = \_b1_ -> 
    bind _b1_ as {_r1_:_b2_, _r2_:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in l0 > r0 or (l0 == r0 and (l1 >
    r1 or (l1 == r1 and l2 > r2)))

declare vid_leq : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = \_b1_ -> 
    bind _b1_ as {_r1_:_b2_, _r2_:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in not (l0 > r0 or (l0 == r0 and
    (l1 > r1 or (l1 == r1 and l2 > r2))))

declare vid_geq : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }
  } -> bool = \_b1_ -> 
    bind _b1_ as {_r1_:_b2_, _r2_:_b6_} in 
    bind _b2_ as {_r1_:l0, _r2_:l1, _r3_:l2} in 
    bind _b6_ as {_r1_:r0, _r2_:r1, _r3_:r2} in not (l0 < r0 or (l0 == r0 and
    (l1 < r1 or (l1 == r1 and l2 < r2))))

declare log_read_geq : { _r1_:int, _r2_:int, _r3_:int } -> collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set } =
  \vid -> 
    (log__master.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:vid2, _r2_:trig, _r3_:stmt} in 
        vid_geq {_r1_:vid2, _r2_:vid})).map
      (\_b1_ -> 
        bind _b1_ as {_r1_:vid2, _r2_:trig, _r3_:stmt} in 
        {_r1_:vid2, _r2_:trig, _r3_:stmt})

declare add_delta_to_ATIMESD : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int } @ { Set } } -> () =
  \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = ATIMESD in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:__prod_ret__1} in 
          let update_value =
            case ((bind existing_out_tier.fold
                          ((\_b2_ ->
                          bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                            bind _b5_ as {_r1_:map_vid, _r2_:__map_val} in 
                            if vid_lt {_r1_:map_vid, _r2_:vid}
                            then
                              if vid_eq {_r1_:map_vid, _r2_:max_vid}
                              then
                                {_r1_:({|elem:int|
                                 __map_val|} @ { Set }).combine acc,
                                 _r2_:max_vid}
                              else
                                if vid_gt {_r1_:map_vid, _r2_:max_vid}
                                then
                                  {_r1_:{|elem:int| __map_val|} @ { Set },
                                   _r2_:map_vid}
                                else {_r1_:acc, _r2_:max_vid}
                            else {_r1_:acc, _r2_:max_vid})))
                          {_r1_:empty {elem:int} @ { Set },
                           _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1,
                                                              _r2_:__2} in 
            __1).peek ()) of { Some x -> x } { None -> error () } +
            __prod_ret__1 in ( ATIMESD.insert {_r1_:vid, _r2_:update_value} ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_val} in 
          ((().filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_val} in vid > min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1} in 
               {_r1_:__id_0, _r2_:__id_1})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_val} in 
              ATIMESD.update
                {_r1_:vid, _r2_:__map_val}
                {_r1_:vid, _r2_:__map_val + __arg_val}))
      )

declare add_delta_to_ATIMESD_mT1 : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = ATIMESD_mT1 in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:S_C, _r3_:__map_ret__7} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == S_C)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __map_ret__7 in (
            ATIMESD_mT1.insert {_r1_:vid, _r2_:S_C, _r3_:update_value} ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((ATIMESD_mT1.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              ATIMESD_mT1.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_ATIMESD_mT1_mR1 : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Set } } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = ATIMESD_mT1_mR1 in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:__val_ret__10} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_} in _r2_ == S_B and _r3_ == S_C)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int, _r3_:int |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int, _r3_:int |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int, _r3_:int
              } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:projected_field} in 
              projected_field) + __val_ret__10 in (
            ATIMESD_mT1_mR1.insert
              {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1,
                        _r4_:__arg_val} in 
          (((ATIMESD_mT1_mR1.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
               _r2_ == __arg_0 and _r3_ == __arg_1)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_val} in vid > min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                            _r4_:__map_val} in 
              ATIMESD_mT1_mR1.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_val +
                 __arg_val}))
      )

declare add_delta_to_ATIMESD_mS1 : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = ATIMESD_mS1 in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:R_B, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == R_B)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__17 in (
            ATIMESD_mS1.insert {_r1_:vid, _r2_:R_B, _r3_:update_value} ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((ATIMESD_mS1.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              ATIMESD_mS1.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_ATIMESD_mS2 : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = ATIMESD_mS2 in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:__val_ret__2} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == T_C)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__2 in (
            ATIMESD_mS2.insert {_r1_:vid, _r2_:T_C, _r3_:update_value} ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((ATIMESD_mS2.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              ATIMESD_mS2.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_ATIMESD_mR1 : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = ATIMESD_mR1 in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ATIMESD_mRR_B, _r3_:__prod_ret__2} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == ATIMESD_mRR_B)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __prod_ret__2 in (
            ATIMESD_mR1.insert
              {_r1_:vid, _r2_:ATIMESD_mRR_B, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((ATIMESD_mR1.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              ATIMESD_mR1.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare cond_add_delta_to_ATIMESD : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int } @ { Set } } -> () =
  \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = ATIMESD in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:__prod_ret__1} in 
          let lhs_slice = ATIMESD.filter
            (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == vid) in
          if lhs_slice != empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int } @ { Set }
          then
            ATIMESD.update
              (case (lhs_slice.peek ()) of { Some x -> x }
              { None -> error () }) (bind case (lhs_slice.peek ()) of
              { Some x -> x }
              { None -> error () } as {_r1_:lhs0, _r2_:lhs1} in 
              {_r1_:lhs0, _r2_:lhs1 + __prod_ret__1})
          else
            let update_value =
              case ((bind existing_out_tier.fold
                            ((\_b2_ ->
                            bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                              bind _b5_ as {_r1_:map_vid, _r2_:__map_val} in 
                              if vid_lt {_r1_:map_vid, _r2_:vid}
                              then
                                if vid_eq {_r1_:map_vid, _r2_:max_vid}
                                then
                                  {_r1_:({|elem:int|
                                   __map_val|} @ { Set }).combine acc,
                                   _r2_:max_vid}
                                else
                                  if vid_gt {_r1_:map_vid, _r2_:max_vid}
                                  then
                                    {_r1_:{|elem:int| __map_val|} @ { Set },
                                     _r2_:map_vid}
                                  else {_r1_:acc, _r2_:max_vid}
                              else {_r1_:acc, _r2_:max_vid})))
                            {_r1_:empty {elem:int} @ { Set },
                             _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1,
                                                                _r2_:__2} in 
              __1).peek ()) of { Some x -> x } { None -> error () } +
              __prod_ret__1 in ( ATIMESD.insert {_r1_:vid, _r2_:update_value} ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_val} in 
          ((().filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_val} in vid > min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1} in 
               {_r1_:__id_0, _r2_:__id_1})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_val} in 
              ATIMESD.update
                {_r1_:vid, _r2_:__map_val}
                {_r1_:vid, _r2_:__map_val + __arg_val}))
      )

declare cond_add_delta_to_ATIMESD_mT1 : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = ATIMESD_mT1 in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:S_C, _r3_:__map_ret__7} in 
          let lhs_slice = ATIMESD_mT1.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
              _r2_ == S_C) in
          if lhs_slice != empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Set }
          then
            ATIMESD_mT1.update
              (case (lhs_slice.peek ()) of { Some x -> x }
              { None -> error () }) (bind case (lhs_slice.peek ()) of
              { Some x -> x }
              { None -> error () } as {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2} in 
              {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2 + __map_ret__7})
          else
            let update_value =
              (let wrapped_lookup_value =
                 bind (existing_out_tier.filter
                        (\_b1_ -> 
                          bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
                          _r2_ == S_C)).fold
                        ((\_b2_ ->
                        bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                          bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                        _r3_:__map_val} in 
                          if vid_lt {_r1_:map_vid, _r2_:vid}
                          then
                            if vid_eq {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:({| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                               acc, _r2_:max_vid}
                            else
                              if vid_gt {_r1_:map_vid, _r2_:max_vid}
                              then
                                {_r1_:{| _r1_:int, _r2_:int |
                                 {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                                 _r2_:map_vid}
                              else {_r1_:acc, _r2_:max_vid}
                          else {_r1_:acc, _r2_:max_vid})))
                        {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                         _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
                 __1 in
              if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
              then 0
              else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
                { None -> error () } as {_r1_:_, _r2_:projected_field} in 
                projected_field) + __map_ret__7 in (
              ATIMESD_mT1.insert {_r1_:vid, _r2_:S_C, _r3_:update_value} ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((ATIMESD_mT1.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              ATIMESD_mT1.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare cond_add_delta_to_ATIMESD_mT1_mR1 : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Set } } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = ATIMESD_mT1_mR1 in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:__val_ret__10} in 
          let lhs_slice = ATIMESD_mT1_mR1.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
              (_r1_ == vid and _r3_ == S_C) * _r2_ == S_B) in
          if lhs_slice != empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
            } @ { Set }
          then
            ATIMESD_mT1_mR1.update
              (case (lhs_slice.peek ()) of { Some x -> x }
              { None -> error () }) (bind case (lhs_slice.peek ()) of
              { Some x -> x }
              { None -> error () } as {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2,
                                       _r4_:lhs3} in 
              {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2, _r4_:lhs3 + __val_ret__10})
          else
            let update_value =
              (let wrapped_lookup_value =
                 bind (existing_out_tier.filter
                        (\_b1_ -> 
                          bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                        _r4_:_r4_} in _r2_ == S_B and _r3_ ==
                          S_C)).fold
                        ((\_b2_ ->
                        bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                          bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                        _r3_:__map_1, _r4_:__map_val} in 
                          if vid_lt {_r1_:map_vid, _r2_:vid}
                          then
                            if vid_eq {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:({| _r1_:int, _r2_:int, _r3_:int |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set }).combine
                               acc, _r2_:max_vid}
                            else
                              if vid_gt {_r1_:map_vid, _r2_:max_vid}
                              then
                                {_r1_:{| _r1_:int, _r2_:int, _r3_:int |
                                 {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set },
                                 _r2_:map_vid}
                              else {_r1_:acc, _r2_:max_vid}
                          else {_r1_:acc, _r2_:max_vid})))
                        {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Set },
                         _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
                 __1 in
              if wrapped_lookup_value == empty { _r1_:int, _r2_:int, _r3_:int
                } @ { Set }
              then 0
              else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
                { None -> error () } as {_r1_:_, _r2_:_, _r3_:projected_field} in 
                projected_field) + __val_ret__10 in (
              ATIMESD_mT1_mR1.insert
                {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:update_value}
              ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1,
                        _r4_:__arg_val} in 
          (((ATIMESD_mT1_mR1.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
               _r2_ == __arg_0 and _r3_ == __arg_1)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_val} in vid > min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                            _r4_:__map_val} in 
              ATIMESD_mT1_mR1.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_val +
                 __arg_val}))
      )

declare cond_add_delta_to_ATIMESD_mS1 : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = ATIMESD_mS1 in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:R_B, _r3_:__val_ret__17} in 
          let lhs_slice = ATIMESD_mS1.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
              _r2_ == R_B) in
          if lhs_slice != empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Set }
          then
            ATIMESD_mS1.update
              (case (lhs_slice.peek ()) of { Some x -> x }
              { None -> error () }) (bind case (lhs_slice.peek ()) of
              { Some x -> x }
              { None -> error () } as {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2} in 
              {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2 + __val_ret__17})
          else
            let update_value =
              (let wrapped_lookup_value =
                 bind (existing_out_tier.filter
                        (\_b1_ -> 
                          bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
                          _r2_ == R_B)).fold
                        ((\_b2_ ->
                        bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                          bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                        _r3_:__map_val} in 
                          if vid_lt {_r1_:map_vid, _r2_:vid}
                          then
                            if vid_eq {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:({| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                               acc, _r2_:max_vid}
                            else
                              if vid_gt {_r1_:map_vid, _r2_:max_vid}
                              then
                                {_r1_:{| _r1_:int, _r2_:int |
                                 {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                                 _r2_:map_vid}
                              else {_r1_:acc, _r2_:max_vid}
                          else {_r1_:acc, _r2_:max_vid})))
                        {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                         _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
                 __1 in
              if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
              then 0
              else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
                { None -> error () } as {_r1_:_, _r2_:projected_field} in 
                projected_field) + __val_ret__17 in (
              ATIMESD_mS1.insert {_r1_:vid, _r2_:R_B, _r3_:update_value} ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((ATIMESD_mS1.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              ATIMESD_mS1.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare cond_add_delta_to_ATIMESD_mS2 : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = ATIMESD_mS2 in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:__val_ret__2} in 
          let lhs_slice = ATIMESD_mS2.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
              _r2_ == T_C) in
          if lhs_slice != empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Set }
          then
            ATIMESD_mS2.update
              (case (lhs_slice.peek ()) of { Some x -> x }
              { None -> error () }) (bind case (lhs_slice.peek ()) of
              { Some x -> x }
              { None -> error () } as {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2} in 
              {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2 + __val_ret__2})
          else
            let update_value =
              (let wrapped_lookup_value =
                 bind (existing_out_tier.filter
                        (\_b1_ -> 
                          bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
                          _r2_ == T_C)).fold
                        ((\_b2_ ->
                        bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                          bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                        _r3_:__map_val} in 
                          if vid_lt {_r1_:map_vid, _r2_:vid}
                          then
                            if vid_eq {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:({| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                               acc, _r2_:max_vid}
                            else
                              if vid_gt {_r1_:map_vid, _r2_:max_vid}
                              then
                                {_r1_:{| _r1_:int, _r2_:int |
                                 {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                                 _r2_:map_vid}
                              else {_r1_:acc, _r2_:max_vid}
                          else {_r1_:acc, _r2_:max_vid})))
                        {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                         _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
                 __1 in
              if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
              then 0
              else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
                { None -> error () } as {_r1_:_, _r2_:projected_field} in 
                projected_field) + __val_ret__2 in (
              ATIMESD_mS2.insert {_r1_:vid, _r2_:T_C, _r3_:update_value} ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((ATIMESD_mS2.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              ATIMESD_mS2.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare cond_add_delta_to_ATIMESD_mR1 : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = ATIMESD_mR1 in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ATIMESD_mRR_B, _r3_:__prod_ret__2} in 
          let lhs_slice = ATIMESD_mR1.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
              _r2_ == ATIMESD_mRR_B) in
          if lhs_slice != empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Set }
          then
            ATIMESD_mR1.update
              (case (lhs_slice.peek ()) of { Some x -> x }
              { None -> error () }) (bind case (lhs_slice.peek ()) of
              { Some x -> x }
              { None -> error () } as {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2} in 
              {_r1_:lhs0, _r2_:lhs1, _r3_:lhs2 + __prod_ret__2})
          else
            let update_value =
              (let wrapped_lookup_value =
                 bind (existing_out_tier.filter
                        (\_b1_ -> 
                          bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
                          _r2_ == ATIMESD_mRR_B)).fold
                        ((\_b2_ ->
                        bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                          bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                        _r3_:__map_val} in 
                          if vid_lt {_r1_:map_vid, _r2_:vid}
                          then
                            if vid_eq {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:({| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                               acc, _r2_:max_vid}
                            else
                              if vid_gt {_r1_:map_vid, _r2_:max_vid}
                              then
                                {_r1_:{| _r1_:int, _r2_:int |
                                 {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                                 _r2_:map_vid}
                              else {_r1_:acc, _r2_:max_vid}
                          else {_r1_:acc, _r2_:max_vid})))
                        {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                         _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
                 __1 in
              if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
              then 0
              else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
                { None -> error () } as {_r1_:_, _r2_:projected_field} in 
                projected_field) + __prod_ret__2 in (
              ATIMESD_mR1.insert
                {_r1_:vid, _r2_:ATIMESD_mRR_B, _r3_:update_value}
              ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((ATIMESD_mR1.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              ATIMESD_mR1.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mT1_s0_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mT1_s0_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:S_C, _r3_:__map_ret__7} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == S_C)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __map_ret__7 in (
            map_ATIMESD_mT1_s0_buf.insert
              {_r1_:vid, _r2_:S_C, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mT1_s0_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mT1_s0_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mT1_mR1_s2_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Set } } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mT1_mR1_s2_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:__val_ret__10} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_} in _r2_ == S_B and _r3_ == S_C)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int, _r3_:int |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int, _r3_:int |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int, _r3_:int
              } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:projected_field} in 
              projected_field) + __val_ret__10 in (
            map_ATIMESD_mT1_mR1_s2_buf.insert
              {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1,
                        _r4_:__arg_val} in 
          (((map_ATIMESD_mT1_mR1_s2_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
               _r2_ == __arg_0 and _r3_ == __arg_1)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_val} in vid > min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                            _r4_:__map_val} in 
              map_ATIMESD_mT1_mR1_s2_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_val +
                 __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mT1_s3_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mT1_s3_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:S_C, _r3_:__map_ret__7} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == S_C)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __map_ret__7 in (
            map_ATIMESD_mT1_s3_buf.insert
              {_r1_:vid, _r2_:S_C, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mT1_s3_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mT1_s3_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mT1_mR1_s5_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Set } } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mT1_mR1_s5_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:__val_ret__10} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_} in _r2_ == S_B and _r3_ == S_C)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int, _r3_:int |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int, _r3_:int |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int, _r3_:int
              } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:projected_field} in 
              projected_field) + __val_ret__10 in (
            map_ATIMESD_mT1_mR1_s5_buf.insert
              {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1,
                        _r4_:__arg_val} in 
          (((map_ATIMESD_mT1_mR1_s5_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
               _r2_ == __arg_0 and _r3_ == __arg_1)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_val} in vid > min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                            _r4_:__map_val} in 
              map_ATIMESD_mT1_mR1_s5_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_val +
                 __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mS1_s6_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mS1_s6_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:R_B, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == R_B)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__17 in (
            map_ATIMESD_mS1_s6_buf.insert
              {_r1_:vid, _r2_:R_B, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mS1_s6_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mS1_s6_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mS2_s6_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mS2_s6_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:__val_ret__2} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == T_C)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__2 in (
            map_ATIMESD_mS2_s6_buf.insert
              {_r1_:vid, _r2_:T_C, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mS2_s6_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mS2_s6_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mS1_s7_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mS1_s7_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:R_B, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == R_B)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__17 in (
            map_ATIMESD_mS1_s7_buf.insert
              {_r1_:vid, _r2_:R_B, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mS1_s7_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mS1_s7_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mS2_s9_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mS2_s9_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:__val_ret__2} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == T_C)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__2 in (
            map_ATIMESD_mS2_s9_buf.insert
              {_r1_:vid, _r2_:T_C, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mS2_s9_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mS2_s9_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mS1_s10_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mS1_s10_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:R_B, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == R_B)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__17 in (
            map_ATIMESD_mS1_s10_buf.insert
              {_r1_:vid, _r2_:R_B, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mS1_s10_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mS1_s10_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mS2_s10_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mS2_s10_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:__val_ret__2} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == T_C)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__2 in (
            map_ATIMESD_mS2_s10_buf.insert
              {_r1_:vid, _r2_:T_C, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mS2_s10_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mS2_s10_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mS1_s11_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mS1_s11_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:R_B, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == R_B)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__17 in (
            map_ATIMESD_mS1_s11_buf.insert
              {_r1_:vid, _r2_:R_B, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mS1_s11_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mS1_s11_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mS2_s13_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mS2_s13_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:__val_ret__2} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == T_C)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__2 in (
            map_ATIMESD_mS2_s13_buf.insert
              {_r1_:vid, _r2_:T_C, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mS2_s13_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mS2_s13_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mR1_s14_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mR1_s14_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ATIMESD_mRR_B, _r3_:__prod_ret__2} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == ATIMESD_mRR_B)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __prod_ret__2 in (
            map_ATIMESD_mR1_s14_buf.insert
              {_r1_:vid, _r2_:ATIMESD_mRR_B, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mR1_s14_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mR1_s14_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mT1_mR1_s15_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Set } } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mT1_mR1_s15_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:__val_ret__10} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_} in _r2_ == S_B and _r3_ == S_C)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int, _r3_:int |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int, _r3_:int |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int, _r3_:int
              } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:projected_field} in 
              projected_field) + __val_ret__10 in (
            map_ATIMESD_mT1_mR1_s15_buf.insert
              {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1,
                        _r4_:__arg_val} in 
          (((map_ATIMESD_mT1_mR1_s15_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
               _r2_ == __arg_0 and _r3_ == __arg_1)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_val} in vid > min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                            _r4_:__map_val} in 
              map_ATIMESD_mT1_mR1_s15_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_val +
                 __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mR1_s17_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mR1_s17_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:ATIMESD_mRR_B, _r3_:__prod_ret__2} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == ATIMESD_mRR_B)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __prod_ret__2 in (
            map_ATIMESD_mR1_s17_buf.insert
              {_r1_:vid, _r2_:ATIMESD_mRR_B, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mR1_s17_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mR1_s17_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mT1_mR1_s18_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Set } } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mT1_mR1_s18_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:__val_ret__10} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_,
                                      _r4_:_r4_} in _r2_ == S_B and _r3_ == S_C)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                      _r4_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int, _r3_:int |
                             {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int, _r3_:int |
                               {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int, _r3_:int
              } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:_, _r3_:projected_field} in 
              projected_field) + __val_ret__10 in (
            map_ATIMESD_mT1_mR1_s18_buf.insert
              {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_1,
                        _r4_:__arg_val} in 
          (((map_ATIMESD_mT1_mR1_s18_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
               _r2_ == __arg_0 and _r3_ == __arg_1)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                             _r4_:__map_val} in vid > min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_1,
                            _r4_:__map_val} in 
              map_ATIMESD_mT1_mR1_s18_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_1, _r4_:__map_val +
                 __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mS2_s24_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mS2_s24_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:__val_ret__2} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == T_C)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__2 in (
            map_ATIMESD_mS2_s24_buf.insert
              {_r1_:vid, _r2_:T_C, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mS2_s24_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mS2_s24_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mS2_s26_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mS2_s26_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:__val_ret__2} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == T_C)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__2 in (
            map_ATIMESD_mS2_s26_buf.insert
              {_r1_:vid, _r2_:T_C, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mS2_s26_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mS2_s26_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mS1_s28_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mS1_s28_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:R_B, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == R_B)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__17 in (
            map_ATIMESD_mS1_s28_buf.insert
              {_r1_:vid, _r2_:R_B, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mS1_s28_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mS1_s28_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mS1_s30_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mS1_s30_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:R_B, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == R_B)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__17 in (
            map_ATIMESD_mS1_s30_buf.insert
              {_r1_:vid, _r2_:R_B, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mS1_s30_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mS1_s30_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mS2_s32_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mS2_s32_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:__val_ret__2} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == T_C)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__2 in (
            map_ATIMESD_mS2_s32_buf.insert
              {_r1_:vid, _r2_:T_C, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mS2_s32_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mS2_s32_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mS2_s34_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mS2_s34_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:__val_ret__2} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == T_C)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__2 in (
            map_ATIMESD_mS2_s34_buf.insert
              {_r1_:vid, _r2_:T_C, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mS2_s34_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mS2_s34_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mS1_s36_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mS1_s36_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:R_B, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == R_B)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__17 in (
            map_ATIMESD_mS1_s36_buf.insert
              {_r1_:vid, _r2_:R_B, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mS1_s36_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mS1_s36_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare add_delta_to_map_ATIMESD_mS1_s38_buf : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:min_vid, _r2_:delta_tuples} in (
      let existing_out_tier = map_ATIMESD_mS1_s38_buf in
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:R_B, _r3_:__val_ret__17} in 
          let update_value =
            (let wrapped_lookup_value =
               bind (existing_out_tier.filter
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_
                        == R_B)).fold
                      ((\_b2_ ->
                      bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                        bind _b5_ as {_r1_:map_vid, _r2_:__map_0,
                                      _r3_:__map_val} in 
                        if vid_lt {_r1_:map_vid, _r2_:vid}
                        then
                          if vid_eq {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:({| _r1_:int, _r2_:int |
                             {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                             acc, _r2_:max_vid}
                          else
                            if vid_gt {_r1_:map_vid, _r2_:max_vid}
                            then
                              {_r1_:{| _r1_:int, _r2_:int |
                               {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                               _r2_:map_vid}
                            else {_r1_:acc, _r2_:max_vid}
                        else {_r1_:acc, _r2_:max_vid})))
                      {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                       _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
               __1 in
            if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
            then 0
            else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
              { None -> error () } as {_r1_:_, _r2_:projected_field} in 
              projected_field) + __val_ret__17 in (
            map_ATIMESD_mS1_s38_buf.insert
              {_r1_:vid, _r2_:R_B, _r3_:update_value}
            ));
      delta_tuples.iterate
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid_arg, _r2_:__arg_0, _r3_:__arg_val} in 
          (((map_ATIMESD_mS1_s38_buf.filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
               __arg_0)).filter
             (\_b1_ -> 
               bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in vid >
               min_vid)).map
             (\_b1_ -> 
               bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2} in 
               {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2})).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:vid, _r2_:__map_0, _r3_:__map_val} in 
              map_ATIMESD_mS1_s38_buf.update
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val}
                {_r1_:vid, _r2_:__map_0, _r3_:__map_val + __arg_val}))
      )

declare log_master_write : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:trig_id, _r3_:stmt_id} in 
    log__master.insert {_r1_:vid, _r2_:trig_id, _r3_:stmt_id}

declare log_write_insert_T : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in 
    log_insert_T.insert {_r1_:vid, _r2_:T_C, _r3_:T_D}

declare log_write_delete_T : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in 
    log_delete_T.insert {_r1_:vid, _r2_:T_C, _r3_:T_D}

declare log_write_insert_S : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in 
    log_insert_S.insert {_r1_:vid, _r2_:S_B, _r3_:S_C}

declare log_write_delete_S : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in 
    log_delete_S.insert {_r1_:vid, _r2_:S_B, _r3_:S_C}

declare log_write_insert_R : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in 
    log_insert_R.insert {_r1_:vid, _r2_:R_A, _r3_:R_B}

declare log_write_delete_R : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in 
    log_delete_R.insert {_r1_:vid, _r2_:R_A, _r3_:R_B}

declare log_get_bound_insert_T : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } = \vid -> 
    case ((log_insert_T.filter
    (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid)).peek
    ()) of { Some x -> x } { None -> error () }

declare log_get_bound_delete_T : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } = \vid -> 
    case ((log_delete_T.filter
    (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid)).peek
    ()) of { Some x -> x } { None -> error () }

declare log_get_bound_insert_S : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } = \vid -> 
    case ((log_insert_S.filter
    (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid)).peek
    ()) of { Some x -> x } { None -> error () }

declare log_get_bound_delete_S : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } = \vid -> 
    case ((log_delete_S.filter
    (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid)).peek
    ()) of { Some x -> x } { None -> error () }

declare log_get_bound_insert_R : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } = \vid -> 
    case ((log_insert_R.filter
    (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid)).peek
    ()) of { Some x -> x } { None -> error () }

declare log_get_bound_delete_R : { _r1_:int, _r2_:int, _r3_:int } -> {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } = \vid -> 
    case ((log_delete_R.filter
    (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid)).peek
    ()) of { Some x -> x } { None -> error () }

declare node_ring : mut collection {
  _r1_:address, _r2_:string, _r3_:string, _r4_:int } @ { Seq }

declare replicas : mut collection {elem:int} @ { Set } = {|elem:int|
  8|} @ { Set }

declare set_replicas : int -> () = \n -> 
    replicas.update
      (case (replicas.peek ()) of { Some x -> x } { None -> error () }) n

declare add_node : { _r1_:address, _r2_:string, _r3_:string } -> () = \_b1_ -> 
    bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name} in 
    let rng =
      range 1 1 (case (().peek ()) of { Some x -> x } { None -> error () }) in
    let new_elems =
      rng.map
        (\i ->  {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash (i + hash addr)}) in
    (
      new_elems.iterate (\x ->  node_ring.insert x);
      let temp_ring = node_ring.sort
        (\_b1_ -> 
          bind _b1_ as {_r1_:_b2_, _r2_:_b7_} in 
          bind _b2_ as {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash1} in 
          bind _b7_ as {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash2} in hash1
          > hash2) in
      (
        node_ring.iterate (\node ->  node_ring.delete node);
        temp_ring.iterate (\node ->  node_ring.insert node)
        )
      )

declare remove_node : { _r1_:address, _r2_:string, _r3_:string } -> () =
  \_b1_ -> 
    bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name} in 
    let nodes_to_delete = node_ring.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in (_r1_ ==
        addr and _r3_ == name) * _r2_ == _role_) in
    nodes_to_delete.iterate (\x ->  node_ring.delete x)

declare get_ring_node : { _r1_:int, _r2_:int } -> address = \_b1_ -> 
    bind _b1_ as {_r1_:data, _r2_:max_val} in 
    let scaled =
      int_of_real
        (real_of_int (get_max_int ()) * (real_of_int data /
        real_of_int max_val)) in
    let results =
      (node_ring.filter
        (\_b1_ -> 
          bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash} in hash
          >= scaled)).map
        (\_b1_ -> 
          bind _b1_ as {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3} in 
          {_r1_:__id_0, _r2_:__id_1, _r3_:__id_2, _r4_:__id_3}) in
    bind if results == empty { _r1_:address, _r2_:string, _r3_:string, _r4_:int
           } @ { Seq }
         then case (node_ring.peek ()) of { Some x -> x } { None -> error () }
         else case (results.peek ()) of { Some x -> x } { None -> error () } as {
    _r1_:addr, _r2_:_, _r3_:_, _r4_:_} in addr

declare get_all_uniq_nodes : () -> collection {elem:address} @ { Seq } = \_ -> 
    (node_ring.groupby
       (\_b1_ -> 
         bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name, _r4_:hash} in addr)
       ((\_ -> (\_ ->  ()))) empty {elem:address} @ { Seq }).map
      (\_b1_ ->  bind _b1_ as {_r1_:__1, _r2_:__2} in __1)

declare pmap_data : collection {
  _r1_:int, _r2_:collection { _r1_:int, _r2_:int } @ { Seq } } @ { Seq } =
  pmap_input.map
    (\_b1_ -> 
      bind _b1_ as {_r1_:map_name, _r2_:map_types} in 
      {_r1_:bind case ((__map_ids__.filter
       (\_b1_ -> 
         bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == map_name)).peek
       ()) of { Some x -> x }
       { None -> error () } as {_r1_:__1, _r2_:__2, _r3_:__3} in __1,
       _r2_:map_types})

declare calc_dim_bounds : collection { _r1_:int, _r2_:int } @ { Seq } -> {
  _r1_:collection { _r1_:int, _r2_:int } @ { Seq }, _r2_:int } = \pmap -> 
    pmap.fold
      ((\_b2_ -> bind _b2_ as {_r1_:xs, _r2_:acc_size} in (\_b5_ -> 
        bind _b5_ as {_r1_:pos, _r2_:bin_size} in 
        {_r1_:xs.combine
         ({| _r1_:int, _r2_:int | {_r1_:pos, _r2_:acc_size}|} @ { Seq }),
         _r2_:bin_size * acc_size})))
      {_r1_:empty { _r1_:int, _r2_:int } @ { Seq }, _r2_:1}

declare route_to_ATIMESD : () -> collection {elem:address} @ { Collection } =
  \_ ->  {|elem:address| get_ring_node {_r1_:1, _r2_:1}|} @ { Collection }

declare route_to_ATIMESD_mT1 :
  option int -> collection {elem:address} @ { Collection } = \key -> 
    let pmap = bind case ((pmap_data.filter
      (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 2)).peek 
      ()) of { Some x -> x } { None -> error () } as {_r1_:__1, _r2_:__2} in 
      __2 in
    if pmap == empty { _r1_:int, _r2_:int } @ { Seq }
    then get_all_uniq_nodes ()
    else bind calc_dim_bounds pmap as {_r1_:dim_bounds, _r2_:max_val} in 
      let key_id_0 = key in
      let bound_bucket =
        (if key_id_0 == None immut
         then 0
         else
           let pmap_slice = pmap.filter
             (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 0) in
           if pmap_slice == empty { _r1_:int, _r2_:int } @ { Seq }
           then 0
           else let key_id_0_unwrap = case key_id_0 of { Some x -> x }
             { None -> error () } in
             let value = hash key_id_0_unwrap % bind case (pmap_slice.peek
               ()) of { Some x -> x }
               { None -> error () } as {_r1_:__1, _r2_:__2} in __2 in value *
             bind case ((dim_bounds.filter
             (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 0)).peek
             ()) of { Some x -> x }
             { None -> error () } as {_r1_:__1, _r2_:__2} in __2) + 0 in
      let free_dims =
        (if key_id_0 != None immut
         then empty { _r1_:int, _r2_:int } @ { Seq }
         else pmap.filter
           (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 0)).combine
        empty { _r1_:int, _r2_:int } @ { Seq } in
      let free_domains =
        free_dims.map
          (\_b1_ -> 
            bind _b1_ as {_r1_:i, _r2_:b_i} in {_r1_:i, _r2_:range 0 1 b_i}) in
      let free_cart_prod =
        free_domains.fold
          ((\prev_cart_prod -> (\_b3_ -> 
            bind _b3_ as {_r1_:i, _r2_:domain} in 
            domain.ext
              (\domain_element -> 
                if prev_cart_prod == empty {elem:collection {
                  _r1_:int, _r2_:int } @ { Seq }} @ { Seq }
                then {|elem:collection { _r1_:int, _r2_:int } @ { Seq }| {|
                  _r1_:int, _r2_:int |
                  {_r1_:i, _r2_:domain_element}|} @ { Seq }|} @ { Seq }
                else
                  prev_cart_prod.map
                    (\rest_tup -> 
                      rest_tup.combine
                      ({| _r1_:int, _r2_:int |
                      {_r1_:i, _r2_:domain_element}|} @ { Seq }))))))
          empty {elem:collection { _r1_:int, _r2_:int } @ { Seq }} @ { Seq } in
      let sorted_ip_list =
        (free_cart_prod.map
           (\free_bucket -> 
             get_ring_node
               {_r1_:free_bucket.fold
                       ((\acc -> (\_b3_ -> 
                         bind _b3_ as {_r1_:i, _r2_:val} in acc + (val *
                         bind case ((dim_bounds.filter
                         (\_b1_ -> 
                           bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == i)).peek
                         ()) of { Some x -> x }
                         { None -> error () } as {_r1_:__1, _r2_:__2} in __2))))
                       bound_bucket, _r2_:max_val})).groupby
          (\ip ->  ip) ((\_ -> (\_ ->  ()))) empty {elem:address} @ { Seq } in
      if sorted_ip_list == empty { _r1_:address, _r2_:() } @ { Seq }
      then {|elem:address|
        get_ring_node {_r1_:bound_bucket, _r2_:max_val}|} @ { Seq }
      else
        sorted_ip_list.map (\_b1_ ->  bind _b1_ as {_r1_:__1, _r2_:__2} in __1)

declare route_to_ATIMESD_mT1_mR1 : { _r1_:option int, _r2_:option int
  } -> collection {elem:address} @ { Collection } = \key -> 
    let pmap = bind case ((pmap_data.filter
      (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 3)).peek 
      ()) of { Some x -> x } { None -> error () } as {_r1_:__1, _r2_:__2} in 
      __2 in
    if pmap == empty { _r1_:int, _r2_:int } @ { Seq }
    then get_all_uniq_nodes ()
    else bind calc_dim_bounds pmap as {_r1_:dim_bounds, _r2_:max_val} in 
      bind key as {_r1_:key_id_0, _r2_:key_id_1} in 
      let bound_bucket =
        (if key_id_1 == None immut
         then 0
         else
           let pmap_slice = pmap.filter
             (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 1) in
           if pmap_slice == empty { _r1_:int, _r2_:int } @ { Seq }
           then 0
           else let key_id_1_unwrap = case key_id_1 of { Some x -> x }
             { None -> error () } in
             let value = hash key_id_1_unwrap % bind case (pmap_slice.peek
               ()) of { Some x -> x }
               { None -> error () } as {_r1_:__1, _r2_:__2} in __2 in value *
             bind case ((dim_bounds.filter
             (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 1)).peek
             ()) of { Some x -> x }
             { None -> error () } as {_r1_:__1, _r2_:__2} in __2) +
        ((if key_id_0 == None immut
          then 0
          else
            let pmap_slice = pmap.filter
              (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 0) in
            if pmap_slice == empty { _r1_:int, _r2_:int } @ { Seq }
            then 0
            else let key_id_0_unwrap = case key_id_0 of { Some x -> x }
              { None -> error () } in
              let value = hash key_id_0_unwrap % bind case (pmap_slice.peek
                ()) of { Some x -> x }
                { None -> error () } as {_r1_:__1, _r2_:__2} in __2 in value *
              bind case ((dim_bounds.filter
              (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 0)).peek
              ()) of { Some x -> x }
              { None -> error () } as {_r1_:__1, _r2_:__2} in __2) + 0) in
      let free_dims =
        (if key_id_1 != None immut
         then empty { _r1_:int, _r2_:int } @ { Seq }
         else pmap.filter
           (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 1)).combine
        ((if key_id_0 != None immut
          then empty { _r1_:int, _r2_:int } @ { Seq }
          else pmap.filter
            (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 0)).combine
        empty { _r1_:int, _r2_:int } @ { Seq }) in
      let free_domains =
        free_dims.map
          (\_b1_ -> 
            bind _b1_ as {_r1_:i, _r2_:b_i} in {_r1_:i, _r2_:range 0 1 b_i}) in
      let free_cart_prod =
        free_domains.fold
          ((\prev_cart_prod -> (\_b3_ -> 
            bind _b3_ as {_r1_:i, _r2_:domain} in 
            domain.ext
              (\domain_element -> 
                if prev_cart_prod == empty {elem:collection {
                  _r1_:int, _r2_:int } @ { Seq }} @ { Seq }
                then {|elem:collection { _r1_:int, _r2_:int } @ { Seq }| {|
                  _r1_:int, _r2_:int |
                  {_r1_:i, _r2_:domain_element}|} @ { Seq }|} @ { Seq }
                else
                  prev_cart_prod.map
                    (\rest_tup -> 
                      rest_tup.combine
                      ({| _r1_:int, _r2_:int |
                      {_r1_:i, _r2_:domain_element}|} @ { Seq }))))))
          empty {elem:collection { _r1_:int, _r2_:int } @ { Seq }} @ { Seq } in
      let sorted_ip_list =
        (free_cart_prod.map
           (\free_bucket -> 
             get_ring_node
               {_r1_:free_bucket.fold
                       ((\acc -> (\_b3_ -> 
                         bind _b3_ as {_r1_:i, _r2_:val} in acc + (val *
                         bind case ((dim_bounds.filter
                         (\_b1_ -> 
                           bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == i)).peek
                         ()) of { Some x -> x }
                         { None -> error () } as {_r1_:__1, _r2_:__2} in __2))))
                       bound_bucket, _r2_:max_val})).groupby
          (\ip ->  ip) ((\_ -> (\_ ->  ()))) empty {elem:address} @ { Seq } in
      if sorted_ip_list == empty { _r1_:address, _r2_:() } @ { Seq }
      then {|elem:address|
        get_ring_node {_r1_:bound_bucket, _r2_:max_val}|} @ { Seq }
      else
        sorted_ip_list.map (\_b1_ ->  bind _b1_ as {_r1_:__1, _r2_:__2} in __1)

declare route_to_ATIMESD_mS1 :
  option int -> collection {elem:address} @ { Collection } = \key -> 
    let pmap = bind case ((pmap_data.filter
      (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 4)).peek 
      ()) of { Some x -> x } { None -> error () } as {_r1_:__1, _r2_:__2} in 
      __2 in
    if pmap == empty { _r1_:int, _r2_:int } @ { Seq }
    then get_all_uniq_nodes ()
    else bind calc_dim_bounds pmap as {_r1_:dim_bounds, _r2_:max_val} in 
      let key_id_0 = key in
      let bound_bucket =
        (if key_id_0 == None immut
         then 0
         else
           let pmap_slice = pmap.filter
             (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 0) in
           if pmap_slice == empty { _r1_:int, _r2_:int } @ { Seq }
           then 0
           else let key_id_0_unwrap = case key_id_0 of { Some x -> x }
             { None -> error () } in
             let value = hash key_id_0_unwrap % bind case (pmap_slice.peek
               ()) of { Some x -> x }
               { None -> error () } as {_r1_:__1, _r2_:__2} in __2 in value *
             bind case ((dim_bounds.filter
             (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 0)).peek
             ()) of { Some x -> x }
             { None -> error () } as {_r1_:__1, _r2_:__2} in __2) + 0 in
      let free_dims =
        (if key_id_0 != None immut
         then empty { _r1_:int, _r2_:int } @ { Seq }
         else pmap.filter
           (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 0)).combine
        empty { _r1_:int, _r2_:int } @ { Seq } in
      let free_domains =
        free_dims.map
          (\_b1_ -> 
            bind _b1_ as {_r1_:i, _r2_:b_i} in {_r1_:i, _r2_:range 0 1 b_i}) in
      let free_cart_prod =
        free_domains.fold
          ((\prev_cart_prod -> (\_b3_ -> 
            bind _b3_ as {_r1_:i, _r2_:domain} in 
            domain.ext
              (\domain_element -> 
                if prev_cart_prod == empty {elem:collection {
                  _r1_:int, _r2_:int } @ { Seq }} @ { Seq }
                then {|elem:collection { _r1_:int, _r2_:int } @ { Seq }| {|
                  _r1_:int, _r2_:int |
                  {_r1_:i, _r2_:domain_element}|} @ { Seq }|} @ { Seq }
                else
                  prev_cart_prod.map
                    (\rest_tup -> 
                      rest_tup.combine
                      ({| _r1_:int, _r2_:int |
                      {_r1_:i, _r2_:domain_element}|} @ { Seq }))))))
          empty {elem:collection { _r1_:int, _r2_:int } @ { Seq }} @ { Seq } in
      let sorted_ip_list =
        (free_cart_prod.map
           (\free_bucket -> 
             get_ring_node
               {_r1_:free_bucket.fold
                       ((\acc -> (\_b3_ -> 
                         bind _b3_ as {_r1_:i, _r2_:val} in acc + (val *
                         bind case ((dim_bounds.filter
                         (\_b1_ -> 
                           bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == i)).peek
                         ()) of { Some x -> x }
                         { None -> error () } as {_r1_:__1, _r2_:__2} in __2))))
                       bound_bucket, _r2_:max_val})).groupby
          (\ip ->  ip) ((\_ -> (\_ ->  ()))) empty {elem:address} @ { Seq } in
      if sorted_ip_list == empty { _r1_:address, _r2_:() } @ { Seq }
      then {|elem:address|
        get_ring_node {_r1_:bound_bucket, _r2_:max_val}|} @ { Seq }
      else
        sorted_ip_list.map (\_b1_ ->  bind _b1_ as {_r1_:__1, _r2_:__2} in __1)

declare route_to_ATIMESD_mS2 :
  option int -> collection {elem:address} @ { Collection } = \key -> 
    let pmap = bind case ((pmap_data.filter
      (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 5)).peek 
      ()) of { Some x -> x } { None -> error () } as {_r1_:__1, _r2_:__2} in 
      __2 in
    if pmap == empty { _r1_:int, _r2_:int } @ { Seq }
    then get_all_uniq_nodes ()
    else bind calc_dim_bounds pmap as {_r1_:dim_bounds, _r2_:max_val} in 
      let key_id_0 = key in
      let bound_bucket =
        (if key_id_0 == None immut
         then 0
         else
           let pmap_slice = pmap.filter
             (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 0) in
           if pmap_slice == empty { _r1_:int, _r2_:int } @ { Seq }
           then 0
           else let key_id_0_unwrap = case key_id_0 of { Some x -> x }
             { None -> error () } in
             let value = hash key_id_0_unwrap % bind case (pmap_slice.peek
               ()) of { Some x -> x }
               { None -> error () } as {_r1_:__1, _r2_:__2} in __2 in value *
             bind case ((dim_bounds.filter
             (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 0)).peek
             ()) of { Some x -> x }
             { None -> error () } as {_r1_:__1, _r2_:__2} in __2) + 0 in
      let free_dims =
        (if key_id_0 != None immut
         then empty { _r1_:int, _r2_:int } @ { Seq }
         else pmap.filter
           (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 0)).combine
        empty { _r1_:int, _r2_:int } @ { Seq } in
      let free_domains =
        free_dims.map
          (\_b1_ -> 
            bind _b1_ as {_r1_:i, _r2_:b_i} in {_r1_:i, _r2_:range 0 1 b_i}) in
      let free_cart_prod =
        free_domains.fold
          ((\prev_cart_prod -> (\_b3_ -> 
            bind _b3_ as {_r1_:i, _r2_:domain} in 
            domain.ext
              (\domain_element -> 
                if prev_cart_prod == empty {elem:collection {
                  _r1_:int, _r2_:int } @ { Seq }} @ { Seq }
                then {|elem:collection { _r1_:int, _r2_:int } @ { Seq }| {|
                  _r1_:int, _r2_:int |
                  {_r1_:i, _r2_:domain_element}|} @ { Seq }|} @ { Seq }
                else
                  prev_cart_prod.map
                    (\rest_tup -> 
                      rest_tup.combine
                      ({| _r1_:int, _r2_:int |
                      {_r1_:i, _r2_:domain_element}|} @ { Seq }))))))
          empty {elem:collection { _r1_:int, _r2_:int } @ { Seq }} @ { Seq } in
      let sorted_ip_list =
        (free_cart_prod.map
           (\free_bucket -> 
             get_ring_node
               {_r1_:free_bucket.fold
                       ((\acc -> (\_b3_ -> 
                         bind _b3_ as {_r1_:i, _r2_:val} in acc + (val *
                         bind case ((dim_bounds.filter
                         (\_b1_ -> 
                           bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == i)).peek
                         ()) of { Some x -> x }
                         { None -> error () } as {_r1_:__1, _r2_:__2} in __2))))
                       bound_bucket, _r2_:max_val})).groupby
          (\ip ->  ip) ((\_ -> (\_ ->  ()))) empty {elem:address} @ { Seq } in
      if sorted_ip_list == empty { _r1_:address, _r2_:() } @ { Seq }
      then {|elem:address|
        get_ring_node {_r1_:bound_bucket, _r2_:max_val}|} @ { Seq }
      else
        sorted_ip_list.map (\_b1_ ->  bind _b1_ as {_r1_:__1, _r2_:__2} in __1)

declare route_to_ATIMESD_mR1 :
  option int -> collection {elem:address} @ { Collection } = \key -> 
    let pmap = bind case ((pmap_data.filter
      (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 6)).peek 
      ()) of { Some x -> x } { None -> error () } as {_r1_:__1, _r2_:__2} in 
      __2 in
    if pmap == empty { _r1_:int, _r2_:int } @ { Seq }
    then get_all_uniq_nodes ()
    else bind calc_dim_bounds pmap as {_r1_:dim_bounds, _r2_:max_val} in 
      let key_id_0 = key in
      let bound_bucket =
        (if key_id_0 == None immut
         then 0
         else
           let pmap_slice = pmap.filter
             (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 0) in
           if pmap_slice == empty { _r1_:int, _r2_:int } @ { Seq }
           then 0
           else let key_id_0_unwrap = case key_id_0 of { Some x -> x }
             { None -> error () } in
             let value = hash key_id_0_unwrap % bind case (pmap_slice.peek
               ()) of { Some x -> x }
               { None -> error () } as {_r1_:__1, _r2_:__2} in __2 in value *
             bind case ((dim_bounds.filter
             (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 0)).peek
             ()) of { Some x -> x }
             { None -> error () } as {_r1_:__1, _r2_:__2} in __2) + 0 in
      let free_dims =
        (if key_id_0 != None immut
         then empty { _r1_:int, _r2_:int } @ { Seq }
         else pmap.filter
           (\_b1_ ->  bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == 0)).combine
        empty { _r1_:int, _r2_:int } @ { Seq } in
      let free_domains =
        free_dims.map
          (\_b1_ -> 
            bind _b1_ as {_r1_:i, _r2_:b_i} in {_r1_:i, _r2_:range 0 1 b_i}) in
      let free_cart_prod =
        free_domains.fold
          ((\prev_cart_prod -> (\_b3_ -> 
            bind _b3_ as {_r1_:i, _r2_:domain} in 
            domain.ext
              (\domain_element -> 
                if prev_cart_prod == empty {elem:collection {
                  _r1_:int, _r2_:int } @ { Seq }} @ { Seq }
                then {|elem:collection { _r1_:int, _r2_:int } @ { Seq }| {|
                  _r1_:int, _r2_:int |
                  {_r1_:i, _r2_:domain_element}|} @ { Seq }|} @ { Seq }
                else
                  prev_cart_prod.map
                    (\rest_tup -> 
                      rest_tup.combine
                      ({| _r1_:int, _r2_:int |
                      {_r1_:i, _r2_:domain_element}|} @ { Seq }))))))
          empty {elem:collection { _r1_:int, _r2_:int } @ { Seq }} @ { Seq } in
      let sorted_ip_list =
        (free_cart_prod.map
           (\free_bucket -> 
             get_ring_node
               {_r1_:free_bucket.fold
                       ((\acc -> (\_b3_ -> 
                         bind _b3_ as {_r1_:i, _r2_:val} in acc + (val *
                         bind case ((dim_bounds.filter
                         (\_b1_ -> 
                           bind _b1_ as {_r1_:_r1_, _r2_:_r2_} in _r1_ == i)).peek
                         ()) of { Some x -> x }
                         { None -> error () } as {_r1_:__1, _r2_:__2} in __2))))
                       bound_bucket, _r2_:max_val})).groupby
          (\ip ->  ip) ((\_ -> (\_ ->  ()))) empty {elem:address} @ { Seq } in
      if sorted_ip_list == empty { _r1_:address, _r2_:() } @ { Seq }
      then {|elem:address|
        get_ring_node {_r1_:bound_bucket, _r2_:max_val}|} @ { Seq }
      else
        sorted_ip_list.map (\_b1_ ->  bind _b1_ as {_r1_:__1, _r2_:__2} in __1)

declare shuffle_ATIMESD_mT1_ATIMESD : {
  _r1_:(), _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set },
  _r3_:bool } -> collection {
  _r1_:address, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } @ { Collection } = \_b1_ -> 
    bind _b1_ as {_r1_:_, _r2_:tuples, _r3_:shuffle_on_empty} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_ATIMESD ()).map
          (\ip -> 
            {_r1_:ip, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }})
      else empty {
        _r1_:address, _r2_:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         (\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2} in 
           (route_to_ATIMESD ()).map
             (\ip -> 
               {_r1_:ip, _r2_:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
                r_tuple|} @ { Set }})))).groupby
      (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:tuple} in ip) ((\acc -> 
      (\_b3_ ->  bind _b3_ as {_r1_:ip, _r2_:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Set }

declare shuffle_ATIMESD_mT1_mR1_ATIMESD_mR1_0t0 : {
  _r1_:option int, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Set }, _r3_:bool } -> collection {
  _r1_:address, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Set } } @ { Collection } = \_b1_ -> 
    bind _b1_ as {_r1_:l_key, _r2_:tuples, _r3_:shuffle_on_empty} in 
    let __id_l0 = l_key in
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_ATIMESD_mR1 l_key).map
          (\ip -> 
            {_r1_:ip, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int } @ { Set }})
      else empty {
        _r1_:address, _r2_:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
        } @ { Set } } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         (\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2,
                            _r4_:__id_r3} in let full_lkey = Some __id_r1 in
           (route_to_ATIMESD_mR1 full_lkey).map
             (\ip -> 
               {_r1_:ip, _r2_:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                _r4_:int | r_tuple|} @ { Set }})))).groupby
      (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:tuple} in ip) ((\acc -> 
      (\_b3_ ->  bind _b3_ as {_r1_:ip, _r2_:tuple} in tuple.combine acc)))
      empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
      } @ { Set }

declare shuffle_ATIMESD_mS2_ATIMESD : {
  _r1_:(), _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set },
  _r3_:bool } -> collection {
  _r1_:address, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } @ { Collection } = \_b1_ -> 
    bind _b1_ as {_r1_:_, _r2_:tuples, _r3_:shuffle_on_empty} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_ATIMESD ()).map
          (\ip -> 
            {_r1_:ip, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }})
      else empty {
        _r1_:address, _r2_:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         (\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2} in 
           (route_to_ATIMESD ()).map
             (\ip -> 
               {_r1_:ip, _r2_:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
                r_tuple|} @ { Set }})))).groupby
      (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:tuple} in ip) ((\acc -> 
      (\_b3_ ->  bind _b3_ as {_r1_:ip, _r2_:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Set }

declare shuffle_ATIMESD_mS1_ATIMESD : {
  _r1_:(), _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set },
  _r3_:bool } -> collection {
  _r1_:address, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } @ { Collection } = \_b1_ -> 
    bind _b1_ as {_r1_:_, _r2_:tuples, _r3_:shuffle_on_empty} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_ATIMESD ()).map
          (\ip -> 
            {_r1_:ip, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }})
      else empty {
        _r1_:address, _r2_:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         (\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2} in 
           (route_to_ATIMESD ()).map
             (\ip -> 
               {_r1_:ip, _r2_:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
                r_tuple|} @ { Set }})))).groupby
      (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:tuple} in ip) ((\acc -> 
      (\_b3_ ->  bind _b3_ as {_r1_:ip, _r2_:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Set }

declare shuffle_ATIMESD_mS1_ATIMESD_mT1 : {
  _r1_:option int, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set },
  _r3_:bool } -> collection {
  _r1_:address, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } @ { Collection } = \_b1_ -> 
    bind _b1_ as {_r1_:l_key, _r2_:tuples, _r3_:shuffle_on_empty} in 
    let __id_l0 = l_key in
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_ATIMESD_mT1 l_key).map
          (\ip -> 
            {_r1_:ip, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }})
      else empty {
        _r1_:address, _r2_:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         (\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2} in 
           let full_lkey = __id_l0 in
           (route_to_ATIMESD_mT1 full_lkey).map
             (\ip -> 
               {_r1_:ip, _r2_:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
                r_tuple|} @ { Set }})))).groupby
      (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:tuple} in ip) ((\acc -> 
      (\_b3_ ->  bind _b3_ as {_r1_:ip, _r2_:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Set }

declare shuffle_ATIMESD_mS2_ATIMESD_mR1 : {
  _r1_:option int, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set },
  _r3_:bool } -> collection {
  _r1_:address, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } @ { Collection } = \_b1_ -> 
    bind _b1_ as {_r1_:l_key, _r2_:tuples, _r3_:shuffle_on_empty} in 
    let __id_l0 = l_key in
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_ATIMESD_mR1 l_key).map
          (\ip -> 
            {_r1_:ip, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }})
      else empty {
        _r1_:address, _r2_:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         (\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2} in 
           let full_lkey = __id_l0 in
           (route_to_ATIMESD_mR1 full_lkey).map
             (\ip -> 
               {_r1_:ip, _r2_:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
                r_tuple|} @ { Set }})))).groupby
      (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:tuple} in ip) ((\acc -> 
      (\_b3_ ->  bind _b3_ as {_r1_:ip, _r2_:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Set }

declare shuffle_ATIMESD_mR1_ATIMESD : {
  _r1_:(), _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set },
  _r3_:bool } -> collection {
  _r1_:address, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
  } @ { Collection } = \_b1_ -> 
    bind _b1_ as {_r1_:_, _r2_:tuples, _r3_:shuffle_on_empty} in 
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_ATIMESD ()).map
          (\ip -> 
            {_r1_:ip, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }})
      else empty {
        _r1_:address, _r2_:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         (\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2} in 
           (route_to_ATIMESD ()).map
             (\ip -> 
               {_r1_:ip, _r2_:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
                r_tuple|} @ { Set }})))).groupby
      (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:tuple} in ip) ((\acc -> 
      (\_b3_ ->  bind _b3_ as {_r1_:ip, _r2_:tuple} in tuple.combine acc)))
      empty { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
      } @ { Set }

declare shuffle_ATIMESD_mT1_mR1_ATIMESD_mT1_0t1 : {
  _r1_:option int, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Set }, _r3_:bool } -> collection {
  _r1_:address, _r2_:collection {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
  } @ { Set } } @ { Collection } = \_b1_ -> 
    bind _b1_ as {_r1_:l_key, _r2_:tuples, _r3_:shuffle_on_empty} in 
    let __id_l0 = l_key in
    let all_targets =
      if shuffle_on_empty == true
      then
        (route_to_ATIMESD_mT1 l_key).map
          (\ip -> 
            {_r1_:ip, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
             _r4_:int } @ { Set }})
      else empty {
        _r1_:address, _r2_:collection {
        _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
        } @ { Set } } @ { Collection } in
    (all_targets.combine
      (tuples.ext
         (\r_tuple -> 
           bind r_tuple as {_r1_:__id_r0, _r2_:__id_r1, _r3_:__id_r2,
                            _r4_:__id_r3} in let full_lkey = Some __id_r2 in
           (route_to_ATIMESD_mT1 full_lkey).map
             (\ip -> 
               {_r1_:ip, _r2_:{|
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                _r4_:int | r_tuple|} @ { Set }})))).groupby
      (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:tuple} in ip) ((\acc -> 
      (\_b3_ ->  bind _b3_ as {_r1_:ip, _r2_:tuple} in tuple.combine acc)))
      empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
      } @ { Set }

declare init : () = (
    my_peers.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:addr, _r2_:_role_, _r3_:name} in 
        if _role_ != "switch"
        then add_node {_r1_:addr, _r2_:_role_, _r3_:name}
        else ())
    )

declare filter_corrective_list : {
  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection { _r1_:int, _r2_:int
  } @ { Seq } } -> collection {
  _r1_:int, _r2_:collection { _r1_:int, _r2_:int, _r3_:int } @ { Seq }
  } @ { Seq } = \_b1_ -> 
    bind _b1_ as {_r1_:request_vid, _r2_:trig_stmt_list} in 
    (((log_read_geq request_vid).map
        (\_b1_ -> 
          bind _b1_ as {_r1_:vid, _r2_:trig_id, _r3_:stmt_id} in 
          {_r1_:vid, _r2_:stmt_id})).sort
      (\_b1_ -> 
        bind _b1_ as {_r1_:_b2_, _r2_:_b5_} in 
        bind _b2_ as {_r1_:vid1, _r2_:stmt1} in 
        bind _b5_ as {_r1_:vid2, _r2_:stmt2} in vid_lt {_r1_:vid1, _r2_:vid2})).groupby
      (\_b1_ ->  bind _b1_ as {_r1_:_, _r2_:stmt_id} in stmt_id) ((\vid_list ->
      (\_b3_ -> 
        bind _b3_ as {_r1_:vid, _r2_:_} in vid_list.combine
        ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq })))) empty {
      _r1_:int, _r2_:int, _r3_:int } @ { Seq }

trigger insert_T : {
_r1_:int, _r2_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:T_C, _r2_:T_D} in (
    let vid =
      {_r1_:case (__epoch__.peek ()) of { Some x -> x } { None -> error () },
       _r2_:case (__vid_counter__.peek ()) of { Some x -> x }
       { None -> error () }, _r3_:hash me} in
    (
      (insert_T_send_fetch, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D};
      __vid_counter__.update
        (case (__vid_counter__.peek ()) of { Some x -> x }
        { None -> error () }) (1 + case (__vid_counter__.peek ()) of
        { Some x -> x } { None -> error () })
      )
    )

trigger insert_T_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in (
    (route_to_ATIMESD_mS2 (Some T_C)).iterate
      (\ip ->  (insert_T_do_complete_s1, ip)<- {_r1_:vid, _r2_:T_C, _r3_:T_D});
    ((((empty {
        _r1_:address, _r2_:int, _r3_:int
        } @ { Collection }).combine
        (let sender_count =
           (route_to_ATIMESD_mT1 (Some T_C)).fold
             ((\count -> (\ip ->  count + 1))) 0 in
        ((shuffle_ATIMESD_mT1_ATIMESD
            {_r1_:(), _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }, _r3_:true}).map
           (\_b1_ -> 
             bind _b1_ as {_r1_:ip, _r2_:tuples} in 
             {_r1_:ip, _r2_:0, _r3_:sender_count})).combine
        (let sender_count =
           (route_to_ATIMESD_mT1_mR1 {_r1_:None immut, _r2_:Some T_C}).fold
             ((\count -> (\ip ->  count + 1))) 0 in
        (shuffle_ATIMESD_mT1_mR1_ATIMESD_mR1_0t0
           {_r1_:None immut, _r2_:empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
            } @ { Set }, _r3_:true}).map
          (\_b1_ -> 
            bind _b1_ as {_r1_:ip, _r2_:tuples} in 
            {_r1_:ip, _r2_:2, _r3_:sender_count})))).groupby
        (\_b1_ -> 
          bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in 
          {_r1_:ip, _r2_:stmt_id}) ((\acc -> (\_b3_ -> 
          bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupby
       (\_b1_ -> 
         bind _b1_ as {_r1_:_b2_, _r2_:count} in 
         bind _b2_ as {_r1_:ip, _r2_:stmt_id} in ip) ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:ip_and_stmt_id, _r2_:count} in 
         bind ip_and_stmt_id as {_r1_:ip, _r2_:stmt_id} in acc.combine
         ({| _r1_:int, _r2_:int |
         {_r1_:stmt_id, _r2_:count}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int } @ { Collection }).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_id_cnt_list} in (
          (insert_T_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list, _r3_:vid,
                                    _r4_:T_C, _r5_:T_D}
          ));
    ((((route_to_ATIMESD_mT1_mR1 {_r1_:None immut, _r2_:Some T_C}).map
         (\ip ->  {_r1_:2, _r2_:3, _r3_:ip})).combine
       (((route_to_ATIMESD_mT1 (Some T_C)).map
           (\ip ->  {_r1_:0, _r2_:2, _r3_:ip})).combine
       empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection })).groupby
       (\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip)
       ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
         ({| _r1_:int, _r2_:int |
         {_r1_:stmt_id, _r2_:map_id}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int } @ { Collection }).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_map_ids} in 
        (insert_T_rcv_fetch, ip)<- {_r1_:stmt_map_ids, _r2_:vid, _r3_:T_C,
                                    _r4_:T_D})
    )

trigger insert_T_rcv_put : {
_r1_:address, _r2_:collection { _r1_:int, _r2_:int } @ { Set }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid, _r4_:T_C,
                _r5_:T_D} in (
    stmt_id_cnt_list.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:stmt_id, _r2_:count} in 
        if __stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:_, _r2_:_, _r3_:old_count} in 
          let new_count = old_count + count in (
            __stmt_cntrs__.update
              {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
              {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
            if new_count == 0
            then
              if stmt_id == 2
              then
                (insert_T_do_complete_s2, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
              else
                if stmt_id == 1
                then
                  (insert_T_do_complete_s1, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
                else
                  if stmt_id == 0
                  then
                    (insert_T_do_complete_s0, me)<- {_r1_:vid, _r2_:T_C,
                                                     _r3_:T_D}
                  else ()
            else ()
            )
        else __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count})
    )

trigger insert_T_rcv_fetch : {
_r1_:collection { _r1_:int, _r2_:int } @ { Set }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:T_C, _r4_:T_D} in (
    log_write_insert_T {_r1_:vid, _r2_:T_C, _r3_:T_D};
    stmts_and_map_ids.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:stmt_id, _r2_:map_id} in 
        if stmt_id == 0
        then
          if map_id == 2
          then
            (insert_T_send_push_s0_m_ATIMESD_mT1, me)<- {_r1_:vid, _r2_:T_C,
                                                         _r3_:T_D}
          else ()
        else
          if stmt_id == 2
          then
            if map_id == 3
            then
              (insert_T_send_push_s2_m_ATIMESD_mT1_mR1, me)<- {_r1_:vid,
                                                               _r2_:T_C,
                                                               _r3_:T_D}
            else ()
          else ())
    )

trigger insert_T_send_push_s0_m_ATIMESD_mT1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in (
    log_master_write {_r1_:vid, _r2_:0, _r3_:0};
    (shuffle_ATIMESD_mT1_ATIMESD
       {_r1_:(),
        _r2_:bind (ATIMESD_mT1.filter
                    (\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      T_C)).fold
                    ((\_b2_ ->
                    bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {_r1_:map_vid, _r2_:vid}
                      then
                        if vid_eq {_r1_:map_vid, _r2_:max_vid}
                        then
                          {_r1_:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:int |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, _r2_:max_vid}
                        else
                          if vid_gt {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:int |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             _r2_:map_vid}
                          else {_r1_:acc, _r2_:max_vid}
                      else {_r1_:acc, _r2_:max_vid})))
                    {_r1_:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                     } @ { Set }, _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {
        _r1_:__1, _r2_:__2} in __1, _r3_:true}).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
        (insert_T_rcv_push_s0_m_ATIMESD_mT1, ip)<- {_r1_:tuples, _r2_:vid,
                                                    _r3_:T_C, _r4_:T_D})
    )

trigger insert_T_send_push_s2_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in (
    log_master_write {_r1_:vid, _r2_:0, _r3_:2};
    (shuffle_ATIMESD_mT1_mR1_ATIMESD_mR1_0t0
       {_r1_:None immut,
        _r2_:((ATIMESD_mT1_mR1.filter
                (\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
                  _r3_ == T_C)).groupby
                (\_b1_ -> 
                  bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_val} in {_r1_:__map_0, _r2_:__map_1})
                ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_val} in 
                  if vid_lt {_r1_:map_vid, _r2_:vid}
                  then
                    if vid_eq {_r1_:map_vid, _r2_:max_vid}
                    then
                      {_r1_:({|
                       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                       _r3_:int, _r4_:int |
                       {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                        _r4_:__map_val}|} @ { Set }).combine acc, _r2_:max_vid}
                    else
                      if vid_gt {_r1_:map_vid, _r2_:max_vid}
                      then
                        {_r1_:{|
                         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                         _r3_:int, _r4_:int |
                         {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                          _r4_:__map_val}|} @ { Set }, _r2_:map_vid}
                      else {_r1_:acc, _r2_:max_vid}
                  else {_r1_:acc, _r2_:max_vid})))
                {_r1_:empty {
                 _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                 _r4_:int } @ { Set }, _r2_:{_r1_:0, _r2_:0, _r3_:0}}).ext
               (\_b1_ -> 
                 bind _b1_ as {_r1_:_, _r2_:_b2_} in 
                 bind _b2_ as {_r1_:project, _r2_:_} in project), _r3_:true}).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
        (insert_T_rcv_push_s2_m_ATIMESD_mT1_mR1, ip)<- {_r1_:tuples, _r2_:vid,
                                                        _r3_:T_C, _r4_:T_D})
    )

trigger insert_T_rcv_push_s0_m_ATIMESD_mT1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:T_C, _r4_:T_D} in (
    log_write_insert_T {_r1_:vid, _r2_:T_C, _r3_:T_D};
    tuples.iterate
      (\tuple -> 
        if map_ATIMESD_mT1_s0_buf.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then
          map_ATIMESD_mT1_s0_buf.update
            (case ((map_ATIMESD_mT1_s0_buf.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1)).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_ATIMESD_mT1_s0_buf.insert tuple);
    if __stmt_cntrs__.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 0) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 0)).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 0)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:0, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 0)).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:0, _r3_:0}
        then (insert_T_do_complete_s0, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:0, _r3_:-1}
    )

trigger insert_T_rcv_push_s2_m_ATIMESD_mT1_mR1 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:T_C, _r4_:T_D} in (
    log_write_insert_T {_r1_:vid, _r2_:T_C, _r3_:T_D};
    tuples.iterate
      (\tuple -> 
        if map_ATIMESD_mT1_mR1_s2_buf.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                           _r4_:__temp_3} in (_r1_ == __temp_0 and _r3_ ==
            __temp_2) * _r2_ == __temp_1) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
          } @ { Set }
        then
          map_ATIMESD_mT1_mR1_s2_buf.update
            (case ((map_ATIMESD_mT1_mR1_s2_buf.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                             _r4_:__temp_3} in (_r1_ == __temp_0 and _r3_ ==
              __temp_2) * _r2_ == __temp_1)).peek ()) of { Some x -> x }
            { None -> error () }) tuple
        else map_ATIMESD_mT1_mR1_s2_buf.insert tuple);
    if __stmt_cntrs__.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 2) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 2)).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 2)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:2, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 2)).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:2, _r3_:0}
        then (insert_T_do_complete_s2, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:2, _r3_:-1}
    )

trigger insert_T_do_complete_s0 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in 
    let existing_out_tier = ATIMESD in
    let __prod_ret__1 =
      (let wrapped_lookup_value =
         bind (map_ATIMESD_mT1_s0_buf.filter
                (\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == T_C)).fold
                ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                  if vid_lt {_r1_:map_vid, _r2_:vid}
                  then
                    if vid_eq {_r1_:map_vid, _r2_:max_vid}
                    then
                      {_r1_:({| _r1_:int, _r2_:int |
                       {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine 
                       acc, _r2_:max_vid}
                    else
                      if vid_gt {_r1_:map_vid, _r2_:max_vid}
                      then
                        {_r1_:{| _r1_:int, _r2_:int |
                         {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                         _r2_:map_vid}
                      else {_r1_:acc, _r2_:max_vid}
                  else {_r1_:acc, _r2_:max_vid})))
                {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                 _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in __1 in
      if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {_r1_:_, _r2_:projected_field} in 
        projected_field) * T_D in (
      add_delta_to_ATIMESD
        {_r1_:vid, _r2_:{| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int |
         {_r1_:vid, _r2_:__prod_ret__1}|} @ { Set }}
      )

trigger insert_T_do_complete_s1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in 
    let existing_out_tier = ATIMESD_mS2 in let __val_ret__2 = T_D in (
      add_delta_to_ATIMESD_mS2
        {_r1_:vid, _r2_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:T_C, _r3_:__val_ret__2}|} @ { Set }};
      (ATIMESD_mS2_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                            _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                            }, _r2_:int, _r3_:int |
                                            {_r1_:vid, _r2_:T_C,
                                             _r3_:__val_ret__2}|} @ { Set }}
      )

trigger insert_T_do_complete_s2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in 
    let existing_out_tier = ATIMESD_mR1 in
    let __delta_values__ =
      ((((map_ATIMESD_mT1_mR1_s2_buf.filter
           (\_b1_ -> 
             bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in _r3_
             == T_C)).groupby
           (\_b1_ -> 
             bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                           _r4_:__map_val} in {_r1_:__map_0, _r2_:__map_1})
           ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
             bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                           _r4_:__map_val} in 
             if vid_lt {_r1_:map_vid, _r2_:vid}
             then
               if vid_eq {_r1_:map_vid, _r2_:max_vid}
               then
                 {_r1_:({| _r1_:int, _r2_:int, _r3_:int |
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set }).combine
                  acc, _r2_:max_vid}
               else
                 if vid_gt {_r1_:map_vid, _r2_:max_vid}
                 then
                   {_r1_:{| _r1_:int, _r2_:int, _r3_:int |
                    {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set },
                    _r2_:map_vid}
                 else {_r1_:acc, _r2_:max_vid}
             else {_r1_:acc, _r2_:max_vid})))
           {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Set },
            _r2_:{_r1_:0, _r2_:0, _r3_:0}}).ext
          (\_b1_ -> 
            bind _b1_ as {_r1_:_, _r2_:_b2_} in 
            bind _b2_ as {_r1_:project, _r2_:_} in project)).map
         (\_b1_ -> 
           bind _b1_ as {_r1_:ATIMESD_mRR_B, _r2_:T_C, _r3_:__map_ret__2} in 
           {_r1_:ATIMESD_mRR_B, _r2_:__map_ret__2})).map
        (\_b1_ -> 
          bind _b1_ as {_r1_:ATIMESD_mRR_B, _r2_:__map_ret__2} in 
          {_r1_:ATIMESD_mRR_B, _r2_:__map_ret__2 * T_D}) in
    let __delta_with_vid__ =
      __delta_values__.map
        (\_b1_ -> 
          bind _b1_ as {_r1_:ATIMESD_mRR_B, _r2_:__prod_ret__2} in 
          {_r1_:vid, _r2_:ATIMESD_mRR_B, _r3_:__prod_ret__2}) in (
      add_delta_to_ATIMESD_mR1 {_r1_:vid, _r2_:__delta_with_vid__};
      (ATIMESD_mR1_send_correctives, me)<- {_r1_:vid, _r2_:__delta_with_vid__}
      )

trigger insert_T_rcv_corrective_s0_m_ATIMESD_mT1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_ATIMESD_mT1_s0_buf {_r1_:vid, _r2_:delta_tuples};
    compute_vids.iterate
      (\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 0)).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:0, _r3_:0}
        then
          bind log_get_bound_insert_T compute_vid as {_r1_:vid, _r2_:T_C,
                                                      _r3_:T_D} in 
          (insert_T_do_corrective_s0_m_ATIMESD_mT1, me)<- {_r1_:compute_vid,
                                                           _r2_:T_C, _r3_:T_D,
                                                           _r4_:delta_tuples}
        else ())
    )

trigger insert_T_rcv_corrective_s2_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int } @ { Set }
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_ATIMESD_mT1_mR1_s2_buf {_r1_:vid, _r2_:delta_tuples};
    compute_vids.iterate
      (\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 2)).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:2, _r3_:0}
        then
          bind log_get_bound_insert_T compute_vid as {_r1_:vid, _r2_:T_C,
                                                      _r3_:T_D} in 
          (insert_T_do_corrective_s2_m_ATIMESD_mT1_mR1, me)<- {_r1_:compute_vid,
                                                               _r2_:T_C,
                                                               _r3_:T_D,
                                                               _r4_:delta_tuples}
        else ())
    )

trigger insert_T_do_corrective_s0_m_ATIMESD_mT1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D, _r4_:delta_tuples} in 
    delta_tuples.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ATIMESD_mTT_C, _r3_:delta_ATIMESD_mT1} in 
        let existing_out_tier = ATIMESD in
        let __prod_ret__63 = ((if T_C == delta_ATIMESD_mTT_C then 1 else 0) *
          delta_ATIMESD_mT1) * T_D in (
          cond_add_delta_to_ATIMESD
            {_r1_:vid, _r2_:{| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int
             | {_r1_:vid, _r2_:__prod_ret__63}|} @ { Set }}
          ))

trigger insert_T_do_corrective_s2_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D, _r4_:delta_tuples} in 
    delta_tuples.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ATIMESD_mT1_mRR_B,
                      _r3_:delta_ATIMESD_mTT_C, _r4_:delta_ATIMESD_mT1_mR1} in 
        let existing_out_tier = ATIMESD_mR1 in
        let __prod_ret__65 = ((if T_C == delta_ATIMESD_mTT_C then 1 else 0) *
          delta_ATIMESD_mT1_mR1) * T_D in (
          cond_add_delta_to_ATIMESD_mR1
            {_r1_:vid, _r2_:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
             {_r1_:vid, _r2_:delta_ATIMESD_mT1_mRR_B, _r3_:__prod_ret__65}|} @ { Set }};
          (ATIMESD_mR1_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                                _r1_:{
                                                _r1_:int, _r2_:int, _r3_:int },
                                                _r2_:int, _r3_:int |
                                                {_r1_:vid,
                                                 _r2_:delta_ATIMESD_mT1_mRR_B,
                                                 _r3_:__prod_ret__65}|} @ { Set }}
          ))

trigger delete_T : {
_r1_:int, _r2_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:T_C, _r2_:T_D} in (
    let vid =
      {_r1_:case (__epoch__.peek ()) of { Some x -> x } { None -> error () },
       _r2_:case (__vid_counter__.peek ()) of { Some x -> x }
       { None -> error () }, _r3_:hash me} in
    (
      (delete_T_send_fetch, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D};
      __vid_counter__.update
        (case (__vid_counter__.peek ()) of { Some x -> x }
        { None -> error () }) (1 + case (__vid_counter__.peek ()) of
        { Some x -> x } { None -> error () })
      )
    )

trigger delete_T_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in (
    (route_to_ATIMESD_mS2 (Some T_C)).iterate
      (\ip ->  (delete_T_do_complete_s4, ip)<- {_r1_:vid, _r2_:T_C, _r3_:T_D});
    ((((empty {
        _r1_:address, _r2_:int, _r3_:int
        } @ { Collection }).combine
        (let sender_count =
           (route_to_ATIMESD_mT1 (Some T_C)).fold
             ((\count -> (\ip ->  count + 1))) 0 in
        ((shuffle_ATIMESD_mT1_ATIMESD
            {_r1_:(), _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }, _r3_:true}).map
           (\_b1_ -> 
             bind _b1_ as {_r1_:ip, _r2_:tuples} in 
             {_r1_:ip, _r2_:3, _r3_:sender_count})).combine
        (let sender_count =
           (route_to_ATIMESD_mT1_mR1 {_r1_:None immut, _r2_:Some T_C}).fold
             ((\count -> (\ip ->  count + 1))) 0 in
        (shuffle_ATIMESD_mT1_mR1_ATIMESD_mR1_0t0
           {_r1_:None immut, _r2_:empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
            } @ { Set }, _r3_:true}).map
          (\_b1_ -> 
            bind _b1_ as {_r1_:ip, _r2_:tuples} in 
            {_r1_:ip, _r2_:5, _r3_:sender_count})))).groupby
        (\_b1_ -> 
          bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in 
          {_r1_:ip, _r2_:stmt_id}) ((\acc -> (\_b3_ -> 
          bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupby
       (\_b1_ -> 
         bind _b1_ as {_r1_:_b2_, _r2_:count} in 
         bind _b2_ as {_r1_:ip, _r2_:stmt_id} in ip) ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:ip_and_stmt_id, _r2_:count} in 
         bind ip_and_stmt_id as {_r1_:ip, _r2_:stmt_id} in acc.combine
         ({| _r1_:int, _r2_:int |
         {_r1_:stmt_id, _r2_:count}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int } @ { Collection }).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_id_cnt_list} in (
          (delete_T_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list, _r3_:vid,
                                    _r4_:T_C, _r5_:T_D}
          ));
    ((((route_to_ATIMESD_mT1_mR1 {_r1_:None immut, _r2_:Some T_C}).map
         (\ip ->  {_r1_:5, _r2_:3, _r3_:ip})).combine
       (((route_to_ATIMESD_mT1 (Some T_C)).map
           (\ip ->  {_r1_:3, _r2_:2, _r3_:ip})).combine
       empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection })).groupby
       (\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip)
       ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
         ({| _r1_:int, _r2_:int |
         {_r1_:stmt_id, _r2_:map_id}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int } @ { Collection }).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_map_ids} in 
        (delete_T_rcv_fetch, ip)<- {_r1_:stmt_map_ids, _r2_:vid, _r3_:T_C,
                                    _r4_:T_D})
    )

trigger delete_T_rcv_put : {
_r1_:address, _r2_:collection { _r1_:int, _r2_:int } @ { Set }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid, _r4_:T_C,
                _r5_:T_D} in (
    stmt_id_cnt_list.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:stmt_id, _r2_:count} in 
        if __stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:_, _r2_:_, _r3_:old_count} in 
          let new_count = old_count + count in (
            __stmt_cntrs__.update
              {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
              {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
            if new_count == 0
            then
              if stmt_id == 5
              then
                (delete_T_do_complete_s5, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
              else
                if stmt_id == 4
                then
                  (delete_T_do_complete_s4, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
                else
                  if stmt_id == 3
                  then
                    (delete_T_do_complete_s3, me)<- {_r1_:vid, _r2_:T_C,
                                                     _r3_:T_D}
                  else ()
            else ()
            )
        else __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count})
    )

trigger delete_T_rcv_fetch : {
_r1_:collection { _r1_:int, _r2_:int } @ { Set }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:T_C, _r4_:T_D} in (
    log_write_delete_T {_r1_:vid, _r2_:T_C, _r3_:T_D};
    stmts_and_map_ids.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:stmt_id, _r2_:map_id} in 
        if stmt_id == 3
        then
          if map_id == 2
          then
            (delete_T_send_push_s3_m_ATIMESD_mT1, me)<- {_r1_:vid, _r2_:T_C,
                                                         _r3_:T_D}
          else ()
        else
          if stmt_id == 5
          then
            if map_id == 3
            then
              (delete_T_send_push_s5_m_ATIMESD_mT1_mR1, me)<- {_r1_:vid,
                                                               _r2_:T_C,
                                                               _r3_:T_D}
            else ()
          else ())
    )

trigger delete_T_send_push_s3_m_ATIMESD_mT1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in (
    log_master_write {_r1_:vid, _r2_:1, _r3_:3};
    (shuffle_ATIMESD_mT1_ATIMESD
       {_r1_:(),
        _r2_:bind (ATIMESD_mT1.filter
                    (\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      T_C)).fold
                    ((\_b2_ ->
                    bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {_r1_:map_vid, _r2_:vid}
                      then
                        if vid_eq {_r1_:map_vid, _r2_:max_vid}
                        then
                          {_r1_:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:int |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, _r2_:max_vid}
                        else
                          if vid_gt {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:int |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             _r2_:map_vid}
                          else {_r1_:acc, _r2_:max_vid}
                      else {_r1_:acc, _r2_:max_vid})))
                    {_r1_:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                     } @ { Set }, _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {
        _r1_:__1, _r2_:__2} in __1, _r3_:true}).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
        (delete_T_rcv_push_s3_m_ATIMESD_mT1, ip)<- {_r1_:tuples, _r2_:vid,
                                                    _r3_:T_C, _r4_:T_D})
    )

trigger delete_T_send_push_s5_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in (
    log_master_write {_r1_:vid, _r2_:1, _r3_:5};
    (shuffle_ATIMESD_mT1_mR1_ATIMESD_mR1_0t0
       {_r1_:None immut,
        _r2_:((ATIMESD_mT1_mR1.filter
                (\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
                  _r3_ == T_C)).groupby
                (\_b1_ -> 
                  bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_val} in {_r1_:__map_0, _r2_:__map_1})
                ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_val} in 
                  if vid_lt {_r1_:map_vid, _r2_:vid}
                  then
                    if vid_eq {_r1_:map_vid, _r2_:max_vid}
                    then
                      {_r1_:({|
                       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                       _r3_:int, _r4_:int |
                       {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                        _r4_:__map_val}|} @ { Set }).combine acc, _r2_:max_vid}
                    else
                      if vid_gt {_r1_:map_vid, _r2_:max_vid}
                      then
                        {_r1_:{|
                         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                         _r3_:int, _r4_:int |
                         {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                          _r4_:__map_val}|} @ { Set }, _r2_:map_vid}
                      else {_r1_:acc, _r2_:max_vid}
                  else {_r1_:acc, _r2_:max_vid})))
                {_r1_:empty {
                 _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                 _r4_:int } @ { Set }, _r2_:{_r1_:0, _r2_:0, _r3_:0}}).ext
               (\_b1_ -> 
                 bind _b1_ as {_r1_:_, _r2_:_b2_} in 
                 bind _b2_ as {_r1_:project, _r2_:_} in project), _r3_:true}).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
        (delete_T_rcv_push_s5_m_ATIMESD_mT1_mR1, ip)<- {_r1_:tuples, _r2_:vid,
                                                        _r3_:T_C, _r4_:T_D})
    )

trigger delete_T_rcv_push_s3_m_ATIMESD_mT1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:T_C, _r4_:T_D} in (
    log_write_delete_T {_r1_:vid, _r2_:T_C, _r3_:T_D};
    tuples.iterate
      (\tuple -> 
        if map_ATIMESD_mT1_s3_buf.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then
          map_ATIMESD_mT1_s3_buf.update
            (case ((map_ATIMESD_mT1_s3_buf.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1)).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_ATIMESD_mT1_s3_buf.insert tuple);
    if __stmt_cntrs__.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 3) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 3)).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 3)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:3, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 3)).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:3, _r3_:0}
        then (delete_T_do_complete_s3, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:3, _r3_:-1}
    )

trigger delete_T_rcv_push_s5_m_ATIMESD_mT1_mR1 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:T_C, _r4_:T_D} in (
    log_write_delete_T {_r1_:vid, _r2_:T_C, _r3_:T_D};
    tuples.iterate
      (\tuple -> 
        if map_ATIMESD_mT1_mR1_s5_buf.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                           _r4_:__temp_3} in (_r1_ == __temp_0 and _r3_ ==
            __temp_2) * _r2_ == __temp_1) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
          } @ { Set }
        then
          map_ATIMESD_mT1_mR1_s5_buf.update
            (case ((map_ATIMESD_mT1_mR1_s5_buf.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                             _r4_:__temp_3} in (_r1_ == __temp_0 and _r3_ ==
              __temp_2) * _r2_ == __temp_1)).peek ()) of { Some x -> x }
            { None -> error () }) tuple
        else map_ATIMESD_mT1_mR1_s5_buf.insert tuple);
    if __stmt_cntrs__.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 5) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 5)).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 5)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:5, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 5)).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:5, _r3_:0}
        then (delete_T_do_complete_s5, me)<- {_r1_:vid, _r2_:T_C, _r3_:T_D}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:5, _r3_:-1}
    )

trigger delete_T_do_complete_s3 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in 
    let existing_out_tier = ATIMESD in
    let __prod_ret__4 =
      (let wrapped_lookup_value =
         bind (map_ATIMESD_mT1_s3_buf.filter
                (\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == T_C)).fold
                ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                  if vid_lt {_r1_:map_vid, _r2_:vid}
                  then
                    if vid_eq {_r1_:map_vid, _r2_:max_vid}
                    then
                      {_r1_:({| _r1_:int, _r2_:int |
                       {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine 
                       acc, _r2_:max_vid}
                    else
                      if vid_gt {_r1_:map_vid, _r2_:max_vid}
                      then
                        {_r1_:{| _r1_:int, _r2_:int |
                         {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                         _r2_:map_vid}
                      else {_r1_:acc, _r2_:max_vid}
                  else {_r1_:acc, _r2_:max_vid})))
                {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                 _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in __1 in
      if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {_r1_:_, _r2_:projected_field} in 
        projected_field) * -T_D in (
      add_delta_to_ATIMESD
        {_r1_:vid, _r2_:{| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int |
         {_r1_:vid, _r2_:__prod_ret__4}|} @ { Set }}
      )

trigger delete_T_do_complete_s4 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in 
    let existing_out_tier = ATIMESD_mS2 in let __prod_ret__5 = -T_D in (
      add_delta_to_ATIMESD_mS2
        {_r1_:vid, _r2_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:T_C, _r3_:__prod_ret__5}|} @ { Set }};
      (ATIMESD_mS2_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                            _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                            }, _r2_:int, _r3_:int |
                                            {_r1_:vid, _r2_:T_C,
                                             _r3_:__prod_ret__5}|} @ { Set }}
      )

trigger delete_T_do_complete_s5 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D} in 
    let existing_out_tier = ATIMESD_mR1 in
    let __delta_values__ =
      ((((map_ATIMESD_mT1_mR1_s5_buf.filter
           (\_b1_ -> 
             bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in _r3_
             == T_C)).groupby
           (\_b1_ -> 
             bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                           _r4_:__map_val} in {_r1_:__map_0, _r2_:__map_1})
           ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
             bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                           _r4_:__map_val} in 
             if vid_lt {_r1_:map_vid, _r2_:vid}
             then
               if vid_eq {_r1_:map_vid, _r2_:max_vid}
               then
                 {_r1_:({| _r1_:int, _r2_:int, _r3_:int |
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set }).combine
                  acc, _r2_:max_vid}
               else
                 if vid_gt {_r1_:map_vid, _r2_:max_vid}
                 then
                   {_r1_:{| _r1_:int, _r2_:int, _r3_:int |
                    {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set },
                    _r2_:map_vid}
                 else {_r1_:acc, _r2_:max_vid}
             else {_r1_:acc, _r2_:max_vid})))
           {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Set },
            _r2_:{_r1_:0, _r2_:0, _r3_:0}}).ext
          (\_b1_ -> 
            bind _b1_ as {_r1_:_, _r2_:_b2_} in 
            bind _b2_ as {_r1_:project, _r2_:_} in project)).map
         (\_b1_ -> 
           bind _b1_ as {_r1_:ATIMESD_mRR_B, _r2_:T_C, _r3_:__map_ret__4} in 
           {_r1_:ATIMESD_mRR_B, _r2_:__map_ret__4})).map
        (\_b1_ -> 
          bind _b1_ as {_r1_:ATIMESD_mRR_B, _r2_:__map_ret__4} in 
          {_r1_:ATIMESD_mRR_B, _r2_:__map_ret__4 * -T_D}) in
    let __delta_with_vid__ =
      __delta_values__.map
        (\_b1_ -> 
          bind _b1_ as {_r1_:ATIMESD_mRR_B, _r2_:__prod_ret__7} in 
          {_r1_:vid, _r2_:ATIMESD_mRR_B, _r3_:__prod_ret__7}) in (
      add_delta_to_ATIMESD_mR1 {_r1_:vid, _r2_:__delta_with_vid__};
      (ATIMESD_mR1_send_correctives, me)<- {_r1_:vid, _r2_:__delta_with_vid__}
      )

trigger delete_T_rcv_corrective_s3_m_ATIMESD_mT1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_ATIMESD_mT1_s3_buf {_r1_:vid, _r2_:delta_tuples};
    compute_vids.iterate
      (\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 3)).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:3, _r3_:0}
        then
          bind log_get_bound_delete_T compute_vid as {_r1_:vid, _r2_:T_C,
                                                      _r3_:T_D} in 
          (delete_T_do_corrective_s3_m_ATIMESD_mT1, me)<- {_r1_:compute_vid,
                                                           _r2_:T_C, _r3_:T_D,
                                                           _r4_:delta_tuples}
        else ())
    )

trigger delete_T_rcv_corrective_s5_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int } @ { Set }
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_ATIMESD_mT1_mR1_s5_buf {_r1_:vid, _r2_:delta_tuples};
    compute_vids.iterate
      (\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 5)).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:5, _r3_:0}
        then
          bind log_get_bound_delete_T compute_vid as {_r1_:vid, _r2_:T_C,
                                                      _r3_:T_D} in 
          (delete_T_do_corrective_s5_m_ATIMESD_mT1_mR1, me)<- {_r1_:compute_vid,
                                                               _r2_:T_C,
                                                               _r3_:T_D,
                                                               _r4_:delta_tuples}
        else ())
    )

trigger delete_T_do_corrective_s3_m_ATIMESD_mT1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D, _r4_:delta_tuples} in 
    delta_tuples.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ATIMESD_mTT_C, _r3_:delta_ATIMESD_mT1} in 
        let existing_out_tier = ATIMESD in
        let __prod_ret__68 = (if T_C == delta_ATIMESD_mTT_C then 1 else 0) *
          (-delta_ATIMESD_mT1 * T_D) in (
          cond_add_delta_to_ATIMESD
            {_r1_:vid, _r2_:{| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int
             | {_r1_:vid, _r2_:__prod_ret__68}|} @ { Set }}
          ))

trigger delete_T_do_corrective_s5_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:T_C, _r3_:T_D, _r4_:delta_tuples} in 
    delta_tuples.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ATIMESD_mT1_mRR_B,
                      _r3_:delta_ATIMESD_mTT_C, _r4_:delta_ATIMESD_mT1_mR1} in 
        let existing_out_tier = ATIMESD_mR1 in
        let __prod_ret__71 = (if T_C == delta_ATIMESD_mTT_C then 1 else 0) *
          (-delta_ATIMESD_mT1_mR1 * T_D) in (
          cond_add_delta_to_ATIMESD_mR1
            {_r1_:vid, _r2_:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
             {_r1_:vid, _r2_:delta_ATIMESD_mT1_mRR_B, _r3_:__prod_ret__71}|} @ { Set }};
          (ATIMESD_mR1_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                                _r1_:{
                                                _r1_:int, _r2_:int, _r3_:int },
                                                _r2_:int, _r3_:int |
                                                {_r1_:vid,
                                                 _r2_:delta_ATIMESD_mT1_mRR_B,
                                                 _r3_:__prod_ret__71}|} @ { Set }}
          ))

trigger insert_S : {
_r1_:int, _r2_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:S_B, _r2_:S_C} in (
    let vid =
      {_r1_:case (__epoch__.peek ()) of { Some x -> x } { None -> error () },
       _r2_:case (__vid_counter__.peek ()) of { Some x -> x }
       { None -> error () }, _r3_:hash me} in
    (
      (insert_S_send_fetch, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C};
      __vid_counter__.update
        (case (__vid_counter__.peek ()) of { Some x -> x }
        { None -> error () }) (1 + case (__vid_counter__.peek ()) of
        { Some x -> x } { None -> error () })
      )
    )

trigger insert_S_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    (route_to_ATIMESD_mT1_mR1 {_r1_:Some S_B, _r2_:Some S_C}).iterate
      (\ip ->  (insert_S_do_complete_s8, ip)<- {_r1_:vid, _r2_:S_B, _r3_:S_C});
    ((((empty {
        _r1_:address, _r2_:int, _r3_:int
        } @ { Collection }).combine
        (let sender_count =
           (route_to_ATIMESD_mS2 (Some S_C)).fold
             ((\count -> (\ip ->  count + 1))) 0 in
        ((shuffle_ATIMESD_mS2_ATIMESD
            {_r1_:(), _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }, _r3_:true}).map
           (\_b1_ -> 
             bind _b1_ as {_r1_:ip, _r2_:tuples} in 
             {_r1_:ip, _r2_:6, _r3_:sender_count})).combine
        (let sender_count =
           (route_to_ATIMESD_mS1 (Some S_B)).fold
             ((\count -> (\ip ->  count + 1))) 0 in
        ((shuffle_ATIMESD_mS1_ATIMESD
            {_r1_:(), _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }, _r3_:true}).map
           (\_b1_ -> 
             bind _b1_ as {_r1_:ip, _r2_:tuples} in 
             {_r1_:ip, _r2_:6, _r3_:sender_count})).combine
        (let sender_count =
           (route_to_ATIMESD_mS1 (Some S_B)).fold
             ((\count -> (\ip ->  count + 1))) 0 in
        ((shuffle_ATIMESD_mS1_ATIMESD_mT1
            {_r1_:Some S_C, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }, _r3_:true}).map
           (\_b1_ -> 
             bind _b1_ as {_r1_:ip, _r2_:tuples} in 
             {_r1_:ip, _r2_:7, _r3_:sender_count})).combine
        (let sender_count =
           (route_to_ATIMESD_mS2 (Some S_C)).fold
             ((\count -> (\ip ->  count + 1))) 0 in
        (shuffle_ATIMESD_mS2_ATIMESD_mR1
           {_r1_:Some S_B, _r2_:empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Set }, _r3_:true}).map
          (\_b1_ -> 
            bind _b1_ as {_r1_:ip, _r2_:tuples} in 
            {_r1_:ip, _r2_:9, _r3_:sender_count})))))).groupby
        (\_b1_ -> 
          bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in 
          {_r1_:ip, _r2_:stmt_id}) ((\acc -> (\_b3_ -> 
          bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupby
       (\_b1_ -> 
         bind _b1_ as {_r1_:_b2_, _r2_:count} in 
         bind _b2_ as {_r1_:ip, _r2_:stmt_id} in ip) ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:ip_and_stmt_id, _r2_:count} in 
         bind ip_and_stmt_id as {_r1_:ip, _r2_:stmt_id} in acc.combine
         ({| _r1_:int, _r2_:int |
         {_r1_:stmt_id, _r2_:count}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int } @ { Collection }).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_id_cnt_list} in (
          (insert_S_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list, _r3_:vid,
                                    _r4_:S_B, _r5_:S_C}
          ));
    ((((route_to_ATIMESD_mS2 (Some S_C)).map
         (\ip ->  {_r1_:9, _r2_:5, _r3_:ip})).combine
       (((route_to_ATIMESD_mS1 (Some S_B)).map
           (\ip ->  {_r1_:7, _r2_:4, _r3_:ip})).combine
       (((route_to_ATIMESD_mS2 (Some S_C)).map
           (\ip ->  {_r1_:6, _r2_:5, _r3_:ip})).combine
       (((route_to_ATIMESD_mS1 (Some S_B)).map
           (\ip ->  {_r1_:6, _r2_:4, _r3_:ip})).combine
       empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection })))).groupby
       (\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip)
       ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
         ({| _r1_:int, _r2_:int |
         {_r1_:stmt_id, _r2_:map_id}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int } @ { Collection }).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_map_ids} in 
        (insert_S_rcv_fetch, ip)<- {_r1_:stmt_map_ids, _r2_:vid, _r3_:S_B,
                                    _r4_:S_C})
    )

trigger insert_S_rcv_put : {
_r1_:address, _r2_:collection { _r1_:int, _r2_:int } @ { Set }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid, _r4_:S_B,
                _r5_:S_C} in (
    stmt_id_cnt_list.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:stmt_id, _r2_:count} in 
        if __stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:_, _r2_:_, _r3_:old_count} in 
          let new_count = old_count + count in (
            __stmt_cntrs__.update
              {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
              {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
            if new_count == 0
            then
              if stmt_id == 9
              then
                (insert_S_do_complete_s9, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
              else
                if stmt_id == 8
                then
                  (insert_S_do_complete_s8, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
                else
                  if stmt_id == 7
                  then
                    (insert_S_do_complete_s7, me)<- {_r1_:vid, _r2_:S_B,
                                                     _r3_:S_C}
                  else
                    if stmt_id == 6
                    then
                      (insert_S_do_complete_s6, me)<- {_r1_:vid, _r2_:S_B,
                                                       _r3_:S_C}
                    else ()
            else ()
            )
        else __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count})
    )

trigger insert_S_rcv_fetch : {
_r1_:collection { _r1_:int, _r2_:int } @ { Set }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_insert_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    stmts_and_map_ids.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:stmt_id, _r2_:map_id} in 
        if stmt_id == 6
        then
          if map_id == 4
          then
            (insert_S_send_push_s6_m_ATIMESD_mS1, me)<- {_r1_:vid, _r2_:S_B,
                                                         _r3_:S_C}
          else
            if map_id == 5
            then
              (insert_S_send_push_s6_m_ATIMESD_mS2, me)<- {_r1_:vid, _r2_:S_B,
                                                           _r3_:S_C}
            else ()
        else
          if stmt_id == 7
          then
            if map_id == 4
            then
              (insert_S_send_push_s7_m_ATIMESD_mS1, me)<- {_r1_:vid, _r2_:S_B,
                                                           _r3_:S_C}
            else ()
          else
            if stmt_id == 9
            then
              if map_id == 5
              then
                (insert_S_send_push_s9_m_ATIMESD_mS2, me)<- {_r1_:vid,
                                                             _r2_:S_B, _r3_:S_C}
              else ()
            else ())
    )

trigger insert_S_send_push_s6_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    log_master_write {_r1_:vid, _r2_:2, _r3_:6};
    (shuffle_ATIMESD_mS2_ATIMESD
       {_r1_:(),
        _r2_:bind (ATIMESD_mS2.filter
                    (\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      S_C)).fold
                    ((\_b2_ ->
                    bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {_r1_:map_vid, _r2_:vid}
                      then
                        if vid_eq {_r1_:map_vid, _r2_:max_vid}
                        then
                          {_r1_:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:int |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, _r2_:max_vid}
                        else
                          if vid_gt {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:int |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             _r2_:map_vid}
                          else {_r1_:acc, _r2_:max_vid}
                      else {_r1_:acc, _r2_:max_vid})))
                    {_r1_:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                     } @ { Set }, _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {
        _r1_:__1, _r2_:__2} in __1, _r3_:true}).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
        (insert_S_rcv_push_s6_m_ATIMESD_mS2, ip)<- {_r1_:tuples, _r2_:vid,
                                                    _r3_:S_B, _r4_:S_C})
    )

trigger insert_S_send_push_s6_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    log_master_write {_r1_:vid, _r2_:2, _r3_:6};
    (shuffle_ATIMESD_mS1_ATIMESD
       {_r1_:(),
        _r2_:bind (ATIMESD_mS1.filter
                    (\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      S_B)).fold
                    ((\_b2_ ->
                    bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {_r1_:map_vid, _r2_:vid}
                      then
                        if vid_eq {_r1_:map_vid, _r2_:max_vid}
                        then
                          {_r1_:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:int |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, _r2_:max_vid}
                        else
                          if vid_gt {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:int |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             _r2_:map_vid}
                          else {_r1_:acc, _r2_:max_vid}
                      else {_r1_:acc, _r2_:max_vid})))
                    {_r1_:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                     } @ { Set }, _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {
        _r1_:__1, _r2_:__2} in __1, _r3_:true}).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
        (insert_S_rcv_push_s6_m_ATIMESD_mS1, ip)<- {_r1_:tuples, _r2_:vid,
                                                    _r3_:S_B, _r4_:S_C})
    )

trigger insert_S_send_push_s7_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    log_master_write {_r1_:vid, _r2_:2, _r3_:7};
    (shuffle_ATIMESD_mS1_ATIMESD_mT1
       {_r1_:Some S_C,
        _r2_:bind (ATIMESD_mS1.filter
                    (\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      S_B)).fold
                    ((\_b2_ ->
                    bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {_r1_:map_vid, _r2_:vid}
                      then
                        if vid_eq {_r1_:map_vid, _r2_:max_vid}
                        then
                          {_r1_:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:int |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, _r2_:max_vid}
                        else
                          if vid_gt {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:int |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             _r2_:map_vid}
                          else {_r1_:acc, _r2_:max_vid}
                      else {_r1_:acc, _r2_:max_vid})))
                    {_r1_:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                     } @ { Set }, _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {
        _r1_:__1, _r2_:__2} in __1, _r3_:true}).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
        (insert_S_rcv_push_s7_m_ATIMESD_mS1, ip)<- {_r1_:tuples, _r2_:vid,
                                                    _r3_:S_B, _r4_:S_C})
    )

trigger insert_S_send_push_s9_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    log_master_write {_r1_:vid, _r2_:2, _r3_:9};
    (shuffle_ATIMESD_mS2_ATIMESD_mR1
       {_r1_:Some S_B,
        _r2_:bind (ATIMESD_mS2.filter
                    (\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      S_C)).fold
                    ((\_b2_ ->
                    bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {_r1_:map_vid, _r2_:vid}
                      then
                        if vid_eq {_r1_:map_vid, _r2_:max_vid}
                        then
                          {_r1_:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:int |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, _r2_:max_vid}
                        else
                          if vid_gt {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:int |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             _r2_:map_vid}
                          else {_r1_:acc, _r2_:max_vid}
                      else {_r1_:acc, _r2_:max_vid})))
                    {_r1_:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                     } @ { Set }, _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {
        _r1_:__1, _r2_:__2} in __1, _r3_:true}).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
        (insert_S_rcv_push_s9_m_ATIMESD_mS2, ip)<- {_r1_:tuples, _r2_:vid,
                                                    _r3_:S_B, _r4_:S_C})
    )

trigger insert_S_rcv_push_s6_m_ATIMESD_mS1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_insert_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    tuples.iterate
      (\tuple -> 
        if map_ATIMESD_mS1_s6_buf.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then
          map_ATIMESD_mS1_s6_buf.update
            (case ((map_ATIMESD_mS1_s6_buf.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1)).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_ATIMESD_mS1_s6_buf.insert tuple);
    if __stmt_cntrs__.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 6) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 6)).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 6)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:6, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 6)).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:6, _r3_:0}
        then (insert_S_do_complete_s6, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:6, _r3_:-1}
    )

trigger insert_S_rcv_push_s6_m_ATIMESD_mS2 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_insert_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    tuples.iterate
      (\tuple -> 
        if map_ATIMESD_mS2_s6_buf.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then
          map_ATIMESD_mS2_s6_buf.update
            (case ((map_ATIMESD_mS2_s6_buf.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1)).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_ATIMESD_mS2_s6_buf.insert tuple);
    if __stmt_cntrs__.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 6) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 6)).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 6)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:6, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 6)).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:6, _r3_:0}
        then (insert_S_do_complete_s6, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:6, _r3_:-1}
    )

trigger insert_S_rcv_push_s7_m_ATIMESD_mS1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_insert_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    tuples.iterate
      (\tuple -> 
        if map_ATIMESD_mS1_s7_buf.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then
          map_ATIMESD_mS1_s7_buf.update
            (case ((map_ATIMESD_mS1_s7_buf.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1)).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_ATIMESD_mS1_s7_buf.insert tuple);
    if __stmt_cntrs__.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 7) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 7)).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 7)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:7, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 7)).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:7, _r3_:0}
        then (insert_S_do_complete_s7, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:7, _r3_:-1}
    )

trigger insert_S_rcv_push_s9_m_ATIMESD_mS2 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_insert_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    tuples.iterate
      (\tuple -> 
        if map_ATIMESD_mS2_s9_buf.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then
          map_ATIMESD_mS2_s9_buf.update
            (case ((map_ATIMESD_mS2_s9_buf.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1)).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_ATIMESD_mS2_s9_buf.insert tuple);
    if __stmt_cntrs__.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 9) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 9)).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 9)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:9, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 9)).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:9, _r3_:0}
        then (insert_S_do_complete_s9, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:9, _r3_:-1}
    )

trigger insert_S_do_complete_s6 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in 
    let existing_out_tier = ATIMESD in
    let __prod_ret__8 =
      (let wrapped_lookup_value =
         bind (map_ATIMESD_mS1_s6_buf.filter
                (\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B)).fold
                ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                  if vid_lt {_r1_:map_vid, _r2_:vid}
                  then
                    if vid_eq {_r1_:map_vid, _r2_:max_vid}
                    then
                      {_r1_:({| _r1_:int, _r2_:int |
                       {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine 
                       acc, _r2_:max_vid}
                    else
                      if vid_gt {_r1_:map_vid, _r2_:max_vid}
                      then
                        {_r1_:{| _r1_:int, _r2_:int |
                         {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                         _r2_:map_vid}
                      else {_r1_:acc, _r2_:max_vid}
                  else {_r1_:acc, _r2_:max_vid})))
                {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                 _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in __1 in
      if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {_r1_:_, _r2_:projected_field} in 
        projected_field) *
      let wrapped_lookup_value =
        bind (map_ATIMESD_mS2_s6_buf.filter
               (\_b1_ -> 
                 bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_C)).fold
               ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                 bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                 if vid_lt {_r1_:map_vid, _r2_:vid}
                 then
                   if vid_eq {_r1_:map_vid, _r2_:max_vid}
                   then
                     {_r1_:({| _r1_:int, _r2_:int |
                      {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine 
                      acc, _r2_:max_vid}
                   else
                     if vid_gt {_r1_:map_vid, _r2_:max_vid}
                     then
                       {_r1_:{| _r1_:int, _r2_:int |
                        {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                        _r2_:map_vid}
                     else {_r1_:acc, _r2_:max_vid}
                 else {_r1_:acc, _r2_:max_vid})))
               {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in __1 in
      if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {_r1_:_, _r2_:projected_field} in 
        projected_field in (
      add_delta_to_ATIMESD
        {_r1_:vid, _r2_:{| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int |
         {_r1_:vid, _r2_:__prod_ret__8}|} @ { Set }}
      )

trigger insert_S_do_complete_s7 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in 
    let existing_out_tier = ATIMESD_mT1 in
    let __map_ret__7 =
      let wrapped_lookup_value =
        bind (map_ATIMESD_mS1_s7_buf.filter
               (\_b1_ -> 
                 bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B)).fold
               ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                 bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                 if vid_lt {_r1_:map_vid, _r2_:vid}
                 then
                   if vid_eq {_r1_:map_vid, _r2_:max_vid}
                   then
                     {_r1_:({| _r1_:int, _r2_:int |
                      {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine 
                      acc, _r2_:max_vid}
                   else
                     if vid_gt {_r1_:map_vid, _r2_:max_vid}
                     then
                       {_r1_:{| _r1_:int, _r2_:int |
                        {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                        _r2_:map_vid}
                     else {_r1_:acc, _r2_:max_vid}
                 else {_r1_:acc, _r2_:max_vid})))
               {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in __1 in
      if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {_r1_:_, _r2_:projected_field} in 
        projected_field in (
      add_delta_to_ATIMESD_mT1
        {_r1_:vid, _r2_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:S_C, _r3_:__map_ret__7}|} @ { Set }};
      (ATIMESD_mT1_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                            _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                            }, _r2_:int, _r3_:int |
                                            {_r1_:vid, _r2_:S_C,
                                             _r3_:__map_ret__7}|} @ { Set }}
      )

trigger insert_S_do_complete_s8 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in 
    let existing_out_tier = ATIMESD_mT1_mR1 in let __val_ret__10 = 1 in (
      add_delta_to_ATIMESD_mT1_mR1
        {_r1_:vid, _r2_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int |
         {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:__val_ret__10}|} @ { Set }};
      (ATIMESD_mT1_mR1_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                                _r1_:{
                                                _r1_:int, _r2_:int, _r3_:int },
                                                _r2_:int, _r3_:int, _r4_:int |
                                                {_r1_:vid, _r2_:S_B, _r3_:S_C,
                                                 _r4_:__val_ret__10}|} @ { Set }}
      )

trigger insert_S_do_complete_s9 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in 
    let existing_out_tier = ATIMESD_mR1 in
    let __map_ret__8 =
      let wrapped_lookup_value =
        bind (map_ATIMESD_mS2_s9_buf.filter
               (\_b1_ -> 
                 bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_C)).fold
               ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                 bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                 if vid_lt {_r1_:map_vid, _r2_:vid}
                 then
                   if vid_eq {_r1_:map_vid, _r2_:max_vid}
                   then
                     {_r1_:({| _r1_:int, _r2_:int |
                      {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine 
                      acc, _r2_:max_vid}
                   else
                     if vid_gt {_r1_:map_vid, _r2_:max_vid}
                     then
                       {_r1_:{| _r1_:int, _r2_:int |
                        {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                        _r2_:map_vid}
                     else {_r1_:acc, _r2_:max_vid}
                 else {_r1_:acc, _r2_:max_vid})))
               {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in __1 in
      if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {_r1_:_, _r2_:projected_field} in 
        projected_field in (
      add_delta_to_ATIMESD_mR1
        {_r1_:vid, _r2_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:S_B, _r3_:__map_ret__8}|} @ { Set }};
      (ATIMESD_mR1_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                            _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                            }, _r2_:int, _r3_:int |
                                            {_r1_:vid, _r2_:S_B,
                                             _r3_:__map_ret__8}|} @ { Set }}
      )

trigger insert_S_rcv_corrective_s6_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_ATIMESD_mS1_s6_buf {_r1_:vid, _r2_:delta_tuples};
    compute_vids.iterate
      (\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 6)).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:6, _r3_:0}
        then
          bind log_get_bound_insert_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C} in 
          (insert_S_do_corrective_s6_m_ATIMESD_mS1, me)<- {_r1_:compute_vid,
                                                           _r2_:S_B, _r3_:S_C,
                                                           _r4_:delta_tuples}
        else ())
    )

trigger insert_S_rcv_corrective_s6_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_ATIMESD_mS2_s6_buf {_r1_:vid, _r2_:delta_tuples};
    compute_vids.iterate
      (\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 6)).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:6, _r3_:0}
        then
          bind log_get_bound_insert_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C} in 
          (insert_S_do_corrective_s6_m_ATIMESD_mS2, me)<- {_r1_:compute_vid,
                                                           _r2_:S_B, _r3_:S_C,
                                                           _r4_:delta_tuples}
        else ())
    )

trigger insert_S_rcv_corrective_s7_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_ATIMESD_mS1_s7_buf {_r1_:vid, _r2_:delta_tuples};
    compute_vids.iterate
      (\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 7)).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:7, _r3_:0}
        then
          bind log_get_bound_insert_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C} in 
          (insert_S_do_corrective_s7_m_ATIMESD_mS1, me)<- {_r1_:compute_vid,
                                                           _r2_:S_B, _r3_:S_C,
                                                           _r4_:delta_tuples}
        else ())
    )

trigger insert_S_rcv_corrective_s9_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_ATIMESD_mS2_s9_buf {_r1_:vid, _r2_:delta_tuples};
    compute_vids.iterate
      (\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 9)).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:9, _r3_:0}
        then
          bind log_get_bound_insert_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C} in 
          (insert_S_do_corrective_s9_m_ATIMESD_mS2, me)<- {_r1_:compute_vid,
                                                           _r2_:S_B, _r3_:S_C,
                                                           _r4_:delta_tuples}
        else ())
    )

trigger insert_S_do_corrective_s6_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
    delta_tuples.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ATIMESD_mSS_B, _r3_:delta_ATIMESD_mS1} in 
        let existing_out_tier = ATIMESD in
        let __prod_ret__31 = ((if S_B == delta_ATIMESD_mSS_B then 1 else 0) *
          let wrapped_lookup_value =
            bind (map_ATIMESD_mS2_s6_buf.filter
                   (\_b1_ -> 
                     bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                     S_C)).fold
                   ((\_b2_ ->
                   bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                     bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                     if vid_lt {_r1_:map_vid, _r2_:vid}
                     then
                       if vid_eq {_r1_:map_vid, _r2_:max_vid}
                       then
                         {_r1_:({| _r1_:int, _r2_:int |
                          {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                          acc, _r2_:max_vid}
                       else
                         if vid_gt {_r1_:map_vid, _r2_:max_vid}
                         then
                           {_r1_:{| _r1_:int, _r2_:int |
                            {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                            _r2_:map_vid}
                         else {_r1_:acc, _r2_:max_vid}
                     else {_r1_:acc, _r2_:max_vid})))
                   {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                    _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
            __1 in
          if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
          then 0
          else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
            { None -> error () } as {_r1_:_, _r2_:projected_field} in 
            projected_field) * delta_ATIMESD_mS1 in (
          cond_add_delta_to_ATIMESD
            {_r1_:vid, _r2_:{| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int
             | {_r1_:vid, _r2_:__prod_ret__31}|} @ { Set }}
          ))

trigger insert_S_do_corrective_s6_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
    delta_tuples.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ATIMESD_mSS_C, _r3_:delta_ATIMESD_mS2} in 
        let existing_out_tier = ATIMESD in
        let __prod_ret__37 = ((if S_C == delta_ATIMESD_mSS_C then 1 else 0) *
          let wrapped_lookup_value =
            bind (map_ATIMESD_mS1_s6_buf.filter
                   (\_b1_ -> 
                     bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                     S_B)).fold
                   ((\_b2_ ->
                   bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                     bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                     if vid_lt {_r1_:map_vid, _r2_:vid}
                     then
                       if vid_eq {_r1_:map_vid, _r2_:max_vid}
                       then
                         {_r1_:({| _r1_:int, _r2_:int |
                          {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                          acc, _r2_:max_vid}
                       else
                         if vid_gt {_r1_:map_vid, _r2_:max_vid}
                         then
                           {_r1_:{| _r1_:int, _r2_:int |
                            {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                            _r2_:map_vid}
                         else {_r1_:acc, _r2_:max_vid}
                     else {_r1_:acc, _r2_:max_vid})))
                   {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                    _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
            __1 in
          if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
          then 0
          else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
            { None -> error () } as {_r1_:_, _r2_:projected_field} in 
            projected_field) * delta_ATIMESD_mS2 in (
          cond_add_delta_to_ATIMESD
            {_r1_:vid, _r2_:{| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int
             | {_r1_:vid, _r2_:__prod_ret__37}|} @ { Set }}
          ))

trigger insert_S_do_corrective_s7_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
    delta_tuples.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ATIMESD_mSS_B, _r3_:delta_ATIMESD_mS1} in 
        let existing_out_tier = ATIMESD_mT1 in
        let __prod_ret__32 = (if S_B == delta_ATIMESD_mSS_B then 1 else 0) *
          delta_ATIMESD_mS1 in (
          cond_add_delta_to_ATIMESD_mT1
            {_r1_:vid, _r2_:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
             {_r1_:vid, _r2_:S_C, _r3_:__prod_ret__32}|} @ { Set }};
          (ATIMESD_mT1_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                                _r1_:{
                                                _r1_:int, _r2_:int, _r3_:int },
                                                _r2_:int, _r3_:int |
                                                {_r1_:vid, _r2_:S_C,
                                                 _r3_:__prod_ret__32}|} @ { Set }}
          ))

trigger insert_S_do_corrective_s9_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
    delta_tuples.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ATIMESD_mSS_C, _r3_:delta_ATIMESD_mS2} in 
        let existing_out_tier = ATIMESD_mR1 in
        let __prod_ret__38 = (if S_C == delta_ATIMESD_mSS_C then 1 else 0) *
          delta_ATIMESD_mS2 in (
          cond_add_delta_to_ATIMESD_mR1
            {_r1_:vid, _r2_:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
             {_r1_:vid, _r2_:S_B, _r3_:__prod_ret__38}|} @ { Set }};
          (ATIMESD_mR1_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                                _r1_:{
                                                _r1_:int, _r2_:int, _r3_:int },
                                                _r2_:int, _r3_:int |
                                                {_r1_:vid, _r2_:S_B,
                                                 _r3_:__prod_ret__38}|} @ { Set }}
          ))

trigger delete_S : {
_r1_:int, _r2_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:S_B, _r2_:S_C} in (
    let vid =
      {_r1_:case (__epoch__.peek ()) of { Some x -> x } { None -> error () },
       _r2_:case (__vid_counter__.peek ()) of { Some x -> x }
       { None -> error () }, _r3_:hash me} in
    (
      (delete_S_send_fetch, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C};
      __vid_counter__.update
        (case (__vid_counter__.peek ()) of { Some x -> x }
        { None -> error () }) (1 + case (__vid_counter__.peek ()) of
        { Some x -> x } { None -> error () })
      )
    )

trigger delete_S_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    (route_to_ATIMESD_mT1_mR1 {_r1_:Some S_B, _r2_:Some S_C}).iterate
      (\ip ->  (delete_S_do_complete_s12, ip)<- {_r1_:vid, _r2_:S_B, _r3_:S_C});
    ((((empty {
        _r1_:address, _r2_:int, _r3_:int
        } @ { Collection }).combine
        (let sender_count =
           (route_to_ATIMESD_mS2 (Some S_C)).fold
             ((\count -> (\ip ->  count + 1))) 0 in
        ((shuffle_ATIMESD_mS2_ATIMESD
            {_r1_:(), _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }, _r3_:true}).map
           (\_b1_ -> 
             bind _b1_ as {_r1_:ip, _r2_:tuples} in 
             {_r1_:ip, _r2_:10, _r3_:sender_count})).combine
        (let sender_count =
           (route_to_ATIMESD_mS1 (Some S_B)).fold
             ((\count -> (\ip ->  count + 1))) 0 in
        ((shuffle_ATIMESD_mS1_ATIMESD
            {_r1_:(), _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }, _r3_:true}).map
           (\_b1_ -> 
             bind _b1_ as {_r1_:ip, _r2_:tuples} in 
             {_r1_:ip, _r2_:10, _r3_:sender_count})).combine
        (let sender_count =
           (route_to_ATIMESD_mS1 (Some S_B)).fold
             ((\count -> (\ip ->  count + 1))) 0 in
        ((shuffle_ATIMESD_mS1_ATIMESD_mT1
            {_r1_:Some S_C, _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }, _r3_:true}).map
           (\_b1_ -> 
             bind _b1_ as {_r1_:ip, _r2_:tuples} in 
             {_r1_:ip, _r2_:11, _r3_:sender_count})).combine
        (let sender_count =
           (route_to_ATIMESD_mS2 (Some S_C)).fold
             ((\count -> (\ip ->  count + 1))) 0 in
        (shuffle_ATIMESD_mS2_ATIMESD_mR1
           {_r1_:Some S_B, _r2_:empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
            } @ { Set }, _r3_:true}).map
          (\_b1_ -> 
            bind _b1_ as {_r1_:ip, _r2_:tuples} in 
            {_r1_:ip, _r2_:13, _r3_:sender_count})))))).groupby
        (\_b1_ -> 
          bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in 
          {_r1_:ip, _r2_:stmt_id}) ((\acc -> (\_b3_ -> 
          bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupby
       (\_b1_ -> 
         bind _b1_ as {_r1_:_b2_, _r2_:count} in 
         bind _b2_ as {_r1_:ip, _r2_:stmt_id} in ip) ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:ip_and_stmt_id, _r2_:count} in 
         bind ip_and_stmt_id as {_r1_:ip, _r2_:stmt_id} in acc.combine
         ({| _r1_:int, _r2_:int |
         {_r1_:stmt_id, _r2_:count}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int } @ { Collection }).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_id_cnt_list} in (
          (delete_S_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list, _r3_:vid,
                                    _r4_:S_B, _r5_:S_C}
          ));
    ((((route_to_ATIMESD_mS2 (Some S_C)).map
         (\ip ->  {_r1_:13, _r2_:5, _r3_:ip})).combine
       (((route_to_ATIMESD_mS1 (Some S_B)).map
           (\ip ->  {_r1_:11, _r2_:4, _r3_:ip})).combine
       (((route_to_ATIMESD_mS2 (Some S_C)).map
           (\ip ->  {_r1_:10, _r2_:5, _r3_:ip})).combine
       (((route_to_ATIMESD_mS1 (Some S_B)).map
           (\ip ->  {_r1_:10, _r2_:4, _r3_:ip})).combine
       empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection })))).groupby
       (\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip)
       ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
         ({| _r1_:int, _r2_:int |
         {_r1_:stmt_id, _r2_:map_id}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int } @ { Collection }).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_map_ids} in 
        (delete_S_rcv_fetch, ip)<- {_r1_:stmt_map_ids, _r2_:vid, _r3_:S_B,
                                    _r4_:S_C})
    )

trigger delete_S_rcv_put : {
_r1_:address, _r2_:collection { _r1_:int, _r2_:int } @ { Set }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid, _r4_:S_B,
                _r5_:S_C} in (
    stmt_id_cnt_list.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:stmt_id, _r2_:count} in 
        if __stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:_, _r2_:_, _r3_:old_count} in 
          let new_count = old_count + count in (
            __stmt_cntrs__.update
              {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
              {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
            if new_count == 0
            then
              if stmt_id == 13
              then
                (delete_S_do_complete_s13, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
              else
                if stmt_id == 12
                then
                  (delete_S_do_complete_s12, me)<- {_r1_:vid, _r2_:S_B,
                                                    _r3_:S_C}
                else
                  if stmt_id == 11
                  then
                    (delete_S_do_complete_s11, me)<- {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C}
                  else
                    if stmt_id == 10
                    then
                      (delete_S_do_complete_s10, me)<- {_r1_:vid, _r2_:S_B,
                                                        _r3_:S_C}
                    else ()
            else ()
            )
        else __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count})
    )

trigger delete_S_rcv_fetch : {
_r1_:collection { _r1_:int, _r2_:int } @ { Set }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_delete_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    stmts_and_map_ids.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:stmt_id, _r2_:map_id} in 
        if stmt_id == 10
        then
          if map_id == 4
          then
            (delete_S_send_push_s10_m_ATIMESD_mS1, me)<- {_r1_:vid, _r2_:S_B,
                                                          _r3_:S_C}
          else
            if map_id == 5
            then
              (delete_S_send_push_s10_m_ATIMESD_mS2, me)<- {_r1_:vid, _r2_:S_B,
                                                            _r3_:S_C}
            else ()
        else
          if stmt_id == 11
          then
            if map_id == 4
            then
              (delete_S_send_push_s11_m_ATIMESD_mS1, me)<- {_r1_:vid, _r2_:S_B,
                                                            _r3_:S_C}
            else ()
          else
            if stmt_id == 13
            then
              if map_id == 5
              then
                (delete_S_send_push_s13_m_ATIMESD_mS2, me)<- {_r1_:vid,
                                                              _r2_:S_B,
                                                              _r3_:S_C}
              else ()
            else ())
    )

trigger delete_S_send_push_s10_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    log_master_write {_r1_:vid, _r2_:3, _r3_:10};
    (shuffle_ATIMESD_mS2_ATIMESD
       {_r1_:(),
        _r2_:bind (ATIMESD_mS2.filter
                    (\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      S_C)).fold
                    ((\_b2_ ->
                    bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {_r1_:map_vid, _r2_:vid}
                      then
                        if vid_eq {_r1_:map_vid, _r2_:max_vid}
                        then
                          {_r1_:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:int |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, _r2_:max_vid}
                        else
                          if vid_gt {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:int |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             _r2_:map_vid}
                          else {_r1_:acc, _r2_:max_vid}
                      else {_r1_:acc, _r2_:max_vid})))
                    {_r1_:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                     } @ { Set }, _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {
        _r1_:__1, _r2_:__2} in __1, _r3_:true}).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
        (delete_S_rcv_push_s10_m_ATIMESD_mS2, ip)<- {_r1_:tuples, _r2_:vid,
                                                     _r3_:S_B, _r4_:S_C})
    )

trigger delete_S_send_push_s10_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    log_master_write {_r1_:vid, _r2_:3, _r3_:10};
    (shuffle_ATIMESD_mS1_ATIMESD
       {_r1_:(),
        _r2_:bind (ATIMESD_mS1.filter
                    (\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      S_B)).fold
                    ((\_b2_ ->
                    bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {_r1_:map_vid, _r2_:vid}
                      then
                        if vid_eq {_r1_:map_vid, _r2_:max_vid}
                        then
                          {_r1_:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:int |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, _r2_:max_vid}
                        else
                          if vid_gt {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:int |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             _r2_:map_vid}
                          else {_r1_:acc, _r2_:max_vid}
                      else {_r1_:acc, _r2_:max_vid})))
                    {_r1_:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                     } @ { Set }, _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {
        _r1_:__1, _r2_:__2} in __1, _r3_:true}).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
        (delete_S_rcv_push_s10_m_ATIMESD_mS1, ip)<- {_r1_:tuples, _r2_:vid,
                                                     _r3_:S_B, _r4_:S_C})
    )

trigger delete_S_send_push_s11_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    log_master_write {_r1_:vid, _r2_:3, _r3_:11};
    (shuffle_ATIMESD_mS1_ATIMESD_mT1
       {_r1_:Some S_C,
        _r2_:bind (ATIMESD_mS1.filter
                    (\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      S_B)).fold
                    ((\_b2_ ->
                    bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {_r1_:map_vid, _r2_:vid}
                      then
                        if vid_eq {_r1_:map_vid, _r2_:max_vid}
                        then
                          {_r1_:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:int |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, _r2_:max_vid}
                        else
                          if vid_gt {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:int |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             _r2_:map_vid}
                          else {_r1_:acc, _r2_:max_vid}
                      else {_r1_:acc, _r2_:max_vid})))
                    {_r1_:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                     } @ { Set }, _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {
        _r1_:__1, _r2_:__2} in __1, _r3_:true}).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
        (delete_S_rcv_push_s11_m_ATIMESD_mS1, ip)<- {_r1_:tuples, _r2_:vid,
                                                     _r3_:S_B, _r4_:S_C})
    )

trigger delete_S_send_push_s13_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in (
    log_master_write {_r1_:vid, _r2_:3, _r3_:13};
    (shuffle_ATIMESD_mS2_ATIMESD_mR1
       {_r1_:Some S_B,
        _r2_:bind (ATIMESD_mS2.filter
                    (\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      S_C)).fold
                    ((\_b2_ ->
                    bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {_r1_:map_vid, _r2_:vid}
                      then
                        if vid_eq {_r1_:map_vid, _r2_:max_vid}
                        then
                          {_r1_:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:int |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, _r2_:max_vid}
                        else
                          if vid_gt {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:int |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             _r2_:map_vid}
                          else {_r1_:acc, _r2_:max_vid}
                      else {_r1_:acc, _r2_:max_vid})))
                    {_r1_:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                     } @ { Set }, _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {
        _r1_:__1, _r2_:__2} in __1, _r3_:true}).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
        (delete_S_rcv_push_s13_m_ATIMESD_mS2, ip)<- {_r1_:tuples, _r2_:vid,
                                                     _r3_:S_B, _r4_:S_C})
    )

trigger delete_S_rcv_push_s10_m_ATIMESD_mS1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_delete_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    tuples.iterate
      (\tuple -> 
        if map_ATIMESD_mS1_s10_buf.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then
          map_ATIMESD_mS1_s10_buf.update
            (case ((map_ATIMESD_mS1_s10_buf.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1)).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_ATIMESD_mS1_s10_buf.insert tuple);
    if __stmt_cntrs__.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 10) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 10)).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 10)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:10, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 10)).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:10, _r3_:0}
        then (delete_S_do_complete_s10, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:10, _r3_:-1}
    )

trigger delete_S_rcv_push_s10_m_ATIMESD_mS2 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_delete_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    tuples.iterate
      (\tuple -> 
        if map_ATIMESD_mS2_s10_buf.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then
          map_ATIMESD_mS2_s10_buf.update
            (case ((map_ATIMESD_mS2_s10_buf.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1)).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_ATIMESD_mS2_s10_buf.insert tuple);
    if __stmt_cntrs__.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 10) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 10)).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 10)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:10, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 10)).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:10, _r3_:0}
        then (delete_S_do_complete_s10, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:10, _r3_:-1}
    )

trigger delete_S_rcv_push_s11_m_ATIMESD_mS1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_delete_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    tuples.iterate
      (\tuple -> 
        if map_ATIMESD_mS1_s11_buf.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then
          map_ATIMESD_mS1_s11_buf.update
            (case ((map_ATIMESD_mS1_s11_buf.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1)).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_ATIMESD_mS1_s11_buf.insert tuple);
    if __stmt_cntrs__.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 11) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 11)).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 11)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:11, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 11)).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:11, _r3_:0}
        then (delete_S_do_complete_s11, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:11, _r3_:-1}
    )

trigger delete_S_rcv_push_s13_m_ATIMESD_mS2 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:S_B, _r4_:S_C} in (
    log_write_delete_S {_r1_:vid, _r2_:S_B, _r3_:S_C};
    tuples.iterate
      (\tuple -> 
        if map_ATIMESD_mS2_s13_buf.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then
          map_ATIMESD_mS2_s13_buf.update
            (case ((map_ATIMESD_mS2_s13_buf.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1)).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_ATIMESD_mS2_s13_buf.insert tuple);
    if __stmt_cntrs__.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 13) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 13)).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 13)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:13, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 13)).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:13, _r3_:0}
        then (delete_S_do_complete_s13, me)<- {_r1_:vid, _r2_:S_B, _r3_:S_C}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:13, _r3_:-1}
    )

trigger delete_S_do_complete_s10 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in 
    let existing_out_tier = ATIMESD in
    let __prod_ret__10 =
      ((let wrapped_lookup_value =
          bind (map_ATIMESD_mS1_s10_buf.filter
                 (\_b1_ -> 
                   bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                   S_B)).fold
                 ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                   bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                   if vid_lt {_r1_:map_vid, _r2_:vid}
                   then
                     if vid_eq {_r1_:map_vid, _r2_:max_vid}
                     then
                       {_r1_:({| _r1_:int, _r2_:int |
                        {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                        acc, _r2_:max_vid}
                     else
                       if vid_gt {_r1_:map_vid, _r2_:max_vid}
                       then
                         {_r1_:{| _r1_:int, _r2_:int |
                          {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                          _r2_:map_vid}
                       else {_r1_:acc, _r2_:max_vid}
                   else {_r1_:acc, _r2_:max_vid})))
                 {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                  _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in __1 in
      if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {_r1_:_, _r2_:projected_field} in 
        projected_field) *
      let wrapped_lookup_value =
        bind (map_ATIMESD_mS2_s10_buf.filter
               (\_b1_ -> 
                 bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_C)).fold
               ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                 bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                 if vid_lt {_r1_:map_vid, _r2_:vid}
                 then
                   if vid_eq {_r1_:map_vid, _r2_:max_vid}
                   then
                     {_r1_:({| _r1_:int, _r2_:int |
                      {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine 
                      acc, _r2_:max_vid}
                   else
                     if vid_gt {_r1_:map_vid, _r2_:max_vid}
                     then
                       {_r1_:{| _r1_:int, _r2_:int |
                        {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                        _r2_:map_vid}
                     else {_r1_:acc, _r2_:max_vid}
                 else {_r1_:acc, _r2_:max_vid})))
               {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in __1 in
      if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {_r1_:_, _r2_:projected_field} in 
        projected_field) * -1 in (
      add_delta_to_ATIMESD
        {_r1_:vid, _r2_:{| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int |
         {_r1_:vid, _r2_:__prod_ret__10}|} @ { Set }}
      )

trigger delete_S_do_complete_s11 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in 
    let existing_out_tier = ATIMESD_mT1 in
    let __prod_ret__11 =
      (let wrapped_lookup_value =
         bind (map_ATIMESD_mS1_s11_buf.filter
                (\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_B)).fold
                ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                  if vid_lt {_r1_:map_vid, _r2_:vid}
                  then
                    if vid_eq {_r1_:map_vid, _r2_:max_vid}
                    then
                      {_r1_:({| _r1_:int, _r2_:int |
                       {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine 
                       acc, _r2_:max_vid}
                    else
                      if vid_gt {_r1_:map_vid, _r2_:max_vid}
                      then
                        {_r1_:{| _r1_:int, _r2_:int |
                         {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                         _r2_:map_vid}
                      else {_r1_:acc, _r2_:max_vid}
                  else {_r1_:acc, _r2_:max_vid})))
                {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                 _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in __1 in
      if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {_r1_:_, _r2_:projected_field} in 
        projected_field) * -1 in (
      add_delta_to_ATIMESD_mT1
        {_r1_:vid, _r2_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:S_C, _r3_:__prod_ret__11}|} @ { Set }};
      (ATIMESD_mT1_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                            _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                            }, _r2_:int, _r3_:int |
                                            {_r1_:vid, _r2_:S_C,
                                             _r3_:__prod_ret__11}|} @ { Set }}
      )

trigger delete_S_do_complete_s12 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in 
    let existing_out_tier = ATIMESD_mT1_mR1 in let __val_ret__13 = -1 in (
      add_delta_to_ATIMESD_mT1_mR1
        {_r1_:vid, _r2_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int |
         {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:__val_ret__13}|} @ { Set }};
      (ATIMESD_mT1_mR1_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                                _r1_:{
                                                _r1_:int, _r2_:int, _r3_:int },
                                                _r2_:int, _r3_:int, _r4_:int |
                                                {_r1_:vid, _r2_:S_B, _r3_:S_C,
                                                 _r4_:__val_ret__13}|} @ { Set }}
      )

trigger delete_S_do_complete_s13 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C} in 
    let existing_out_tier = ATIMESD_mR1 in
    let __prod_ret__12 =
      (let wrapped_lookup_value =
         bind (map_ATIMESD_mS2_s13_buf.filter
                (\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == S_C)).fold
                ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                  if vid_lt {_r1_:map_vid, _r2_:vid}
                  then
                    if vid_eq {_r1_:map_vid, _r2_:max_vid}
                    then
                      {_r1_:({| _r1_:int, _r2_:int |
                       {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine 
                       acc, _r2_:max_vid}
                    else
                      if vid_gt {_r1_:map_vid, _r2_:max_vid}
                      then
                        {_r1_:{| _r1_:int, _r2_:int |
                         {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                         _r2_:map_vid}
                      else {_r1_:acc, _r2_:max_vid}
                  else {_r1_:acc, _r2_:max_vid})))
                {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                 _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in __1 in
      if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {_r1_:_, _r2_:projected_field} in 
        projected_field) * -1 in (
      add_delta_to_ATIMESD_mR1
        {_r1_:vid, _r2_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:S_B, _r3_:__prod_ret__12}|} @ { Set }};
      (ATIMESD_mR1_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                            _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                            }, _r2_:int, _r3_:int |
                                            {_r1_:vid, _r2_:S_B,
                                             _r3_:__prod_ret__12}|} @ { Set }}
      )

trigger delete_S_rcv_corrective_s10_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_ATIMESD_mS1_s10_buf {_r1_:vid, _r2_:delta_tuples};
    compute_vids.iterate
      (\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 10)).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:10, _r3_:0}
        then
          bind log_get_bound_delete_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C} in 
          (delete_S_do_corrective_s10_m_ATIMESD_mS1, me)<- {_r1_:compute_vid,
                                                            _r2_:S_B, _r3_:S_C,
                                                            _r4_:delta_tuples}
        else ())
    )

trigger delete_S_rcv_corrective_s10_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_ATIMESD_mS2_s10_buf {_r1_:vid, _r2_:delta_tuples};
    compute_vids.iterate
      (\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 10)).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:10, _r3_:0}
        then
          bind log_get_bound_delete_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C} in 
          (delete_S_do_corrective_s10_m_ATIMESD_mS2, me)<- {_r1_:compute_vid,
                                                            _r2_:S_B, _r3_:S_C,
                                                            _r4_:delta_tuples}
        else ())
    )

trigger delete_S_rcv_corrective_s11_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_ATIMESD_mS1_s11_buf {_r1_:vid, _r2_:delta_tuples};
    compute_vids.iterate
      (\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 11)).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:11, _r3_:0}
        then
          bind log_get_bound_delete_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C} in 
          (delete_S_do_corrective_s11_m_ATIMESD_mS1, me)<- {_r1_:compute_vid,
                                                            _r2_:S_B, _r3_:S_C,
                                                            _r4_:delta_tuples}
        else ())
    )

trigger delete_S_rcv_corrective_s13_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_ATIMESD_mS2_s13_buf {_r1_:vid, _r2_:delta_tuples};
    compute_vids.iterate
      (\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 13)).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:13, _r3_:0}
        then
          bind log_get_bound_delete_S compute_vid as {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C} in 
          (delete_S_do_corrective_s13_m_ATIMESD_mS2, me)<- {_r1_:compute_vid,
                                                            _r2_:S_B, _r3_:S_C,
                                                            _r4_:delta_tuples}
        else ())
    )

trigger delete_S_do_corrective_s10_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
    delta_tuples.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ATIMESD_mSS_B, _r3_:delta_ATIMESD_mS1} in 
        let existing_out_tier = ATIMESD in
        let __prod_ret__44 = ((if S_B == delta_ATIMESD_mSS_B then 1 else 0) *
          let wrapped_lookup_value =
            bind (map_ATIMESD_mS2_s10_buf.filter
                   (\_b1_ -> 
                     bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                     S_C)).fold
                   ((\_b2_ ->
                   bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                     bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                     if vid_lt {_r1_:map_vid, _r2_:vid}
                     then
                       if vid_eq {_r1_:map_vid, _r2_:max_vid}
                       then
                         {_r1_:({| _r1_:int, _r2_:int |
                          {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                          acc, _r2_:max_vid}
                       else
                         if vid_gt {_r1_:map_vid, _r2_:max_vid}
                         then
                           {_r1_:{| _r1_:int, _r2_:int |
                            {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                            _r2_:map_vid}
                         else {_r1_:acc, _r2_:max_vid}
                     else {_r1_:acc, _r2_:max_vid})))
                   {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                    _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
            __1 in
          if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
          then 0
          else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
            { None -> error () } as {_r1_:_, _r2_:projected_field} in 
            projected_field) * -delta_ATIMESD_mS1 in (
          cond_add_delta_to_ATIMESD
            {_r1_:vid, _r2_:{| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int
             | {_r1_:vid, _r2_:__prod_ret__44}|} @ { Set }}
          ))

trigger delete_S_do_corrective_s10_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
    delta_tuples.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ATIMESD_mSS_C, _r3_:delta_ATIMESD_mS2} in 
        let existing_out_tier = ATIMESD in
        let __prod_ret__54 = ((if S_C == delta_ATIMESD_mSS_C then 1 else 0) *
          let wrapped_lookup_value =
            bind (map_ATIMESD_mS1_s10_buf.filter
                   (\_b1_ -> 
                     bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                     S_B)).fold
                   ((\_b2_ ->
                   bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                     bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                     if vid_lt {_r1_:map_vid, _r2_:vid}
                     then
                       if vid_eq {_r1_:map_vid, _r2_:max_vid}
                       then
                         {_r1_:({| _r1_:int, _r2_:int |
                          {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine
                          acc, _r2_:max_vid}
                       else
                         if vid_gt {_r1_:map_vid, _r2_:max_vid}
                         then
                           {_r1_:{| _r1_:int, _r2_:int |
                            {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                            _r2_:map_vid}
                         else {_r1_:acc, _r2_:max_vid}
                     else {_r1_:acc, _r2_:max_vid})))
                   {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                    _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in 
            __1 in
          if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
          then 0
          else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
            { None -> error () } as {_r1_:_, _r2_:projected_field} in 
            projected_field) * -delta_ATIMESD_mS2 in (
          cond_add_delta_to_ATIMESD
            {_r1_:vid, _r2_:{| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int
             | {_r1_:vid, _r2_:__prod_ret__54}|} @ { Set }}
          ))

trigger delete_S_do_corrective_s11_m_ATIMESD_mS1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
    delta_tuples.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ATIMESD_mSS_B, _r3_:delta_ATIMESD_mS1} in 
        let existing_out_tier = ATIMESD_mT1 in
        let __prod_ret__46 = (if S_B == delta_ATIMESD_mSS_B then 1 else 0) *
          -delta_ATIMESD_mS1 in (
          cond_add_delta_to_ATIMESD_mT1
            {_r1_:vid, _r2_:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
             {_r1_:vid, _r2_:S_C, _r3_:__prod_ret__46}|} @ { Set }};
          (ATIMESD_mT1_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                                _r1_:{
                                                _r1_:int, _r2_:int, _r3_:int },
                                                _r2_:int, _r3_:int |
                                                {_r1_:vid, _r2_:S_C,
                                                 _r3_:__prod_ret__46}|} @ { Set }}
          ))

trigger delete_S_do_corrective_s13_m_ATIMESD_mS2 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:S_B, _r3_:S_C, _r4_:delta_tuples} in 
    delta_tuples.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ATIMESD_mSS_C, _r3_:delta_ATIMESD_mS2} in 
        let existing_out_tier = ATIMESD_mR1 in
        let __prod_ret__56 = (if S_C == delta_ATIMESD_mSS_C then 1 else 0) *
          -delta_ATIMESD_mS2 in (
          cond_add_delta_to_ATIMESD_mR1
            {_r1_:vid, _r2_:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
             {_r1_:vid, _r2_:S_B, _r3_:__prod_ret__56}|} @ { Set }};
          (ATIMESD_mR1_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                                _r1_:{
                                                _r1_:int, _r2_:int, _r3_:int },
                                                _r2_:int, _r3_:int |
                                                {_r1_:vid, _r2_:S_B,
                                                 _r3_:__prod_ret__56}|} @ { Set }}
          ))

trigger insert_R : {
_r1_:int, _r2_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:R_A, _r2_:R_B} in (
    let vid =
      {_r1_:case (__epoch__.peek ()) of { Some x -> x } { None -> error () },
       _r2_:case (__vid_counter__.peek ()) of { Some x -> x }
       { None -> error () }, _r3_:hash me} in
    (
      (insert_R_send_fetch, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B};
      __vid_counter__.update
        (case (__vid_counter__.peek ()) of { Some x -> x }
        { None -> error () }) (1 + case (__vid_counter__.peek ()) of
        { Some x -> x } { None -> error () })
      )
    )

trigger insert_R_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
    (route_to_ATIMESD_mS1 (Some R_B)).iterate
      (\ip ->  (insert_R_do_complete_s16, ip)<- {_r1_:vid, _r2_:R_A, _r3_:R_B});
    ((((empty {
        _r1_:address, _r2_:int, _r3_:int
        } @ { Collection }).combine
        (let sender_count =
           (route_to_ATIMESD_mR1 (Some R_B)).fold
             ((\count -> (\ip ->  count + 1))) 0 in
        ((shuffle_ATIMESD_mR1_ATIMESD
            {_r1_:(), _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }, _r3_:true}).map
           (\_b1_ -> 
             bind _b1_ as {_r1_:ip, _r2_:tuples} in 
             {_r1_:ip, _r2_:14, _r3_:sender_count})).combine
        (let sender_count =
           (route_to_ATIMESD_mT1_mR1 {_r1_:Some R_B, _r2_:None immut}).fold
             ((\count -> (\ip ->  count + 1))) 0 in
        (shuffle_ATIMESD_mT1_mR1_ATIMESD_mT1_0t1
           {_r1_:None immut, _r2_:empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
            } @ { Set }, _r3_:true}).map
          (\_b1_ -> 
            bind _b1_ as {_r1_:ip, _r2_:tuples} in 
            {_r1_:ip, _r2_:15, _r3_:sender_count})))).groupby
        (\_b1_ -> 
          bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in 
          {_r1_:ip, _r2_:stmt_id}) ((\acc -> (\_b3_ -> 
          bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupby
       (\_b1_ -> 
         bind _b1_ as {_r1_:_b2_, _r2_:count} in 
         bind _b2_ as {_r1_:ip, _r2_:stmt_id} in ip) ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:ip_and_stmt_id, _r2_:count} in 
         bind ip_and_stmt_id as {_r1_:ip, _r2_:stmt_id} in acc.combine
         ({| _r1_:int, _r2_:int |
         {_r1_:stmt_id, _r2_:count}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int } @ { Collection }).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_id_cnt_list} in (
          (insert_R_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list, _r3_:vid,
                                    _r4_:R_A, _r5_:R_B}
          ));
    ((((route_to_ATIMESD_mT1_mR1 {_r1_:Some R_B, _r2_:None immut}).map
         (\ip ->  {_r1_:15, _r2_:3, _r3_:ip})).combine
       (((route_to_ATIMESD_mR1 (Some R_B)).map
           (\ip ->  {_r1_:14, _r2_:6, _r3_:ip})).combine
       empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection })).groupby
       (\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip)
       ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
         ({| _r1_:int, _r2_:int |
         {_r1_:stmt_id, _r2_:map_id}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int } @ { Collection }).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_map_ids} in 
        (insert_R_rcv_fetch, ip)<- {_r1_:stmt_map_ids, _r2_:vid, _r3_:R_A,
                                    _r4_:R_B})
    )

trigger insert_R_rcv_put : {
_r1_:address, _r2_:collection { _r1_:int, _r2_:int } @ { Set }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid, _r4_:R_A,
                _r5_:R_B} in (
    stmt_id_cnt_list.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:stmt_id, _r2_:count} in 
        if __stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:_, _r2_:_, _r3_:old_count} in 
          let new_count = old_count + count in (
            __stmt_cntrs__.update
              {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
              {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
            if new_count == 0
            then
              if stmt_id == 16
              then
                (insert_R_do_complete_s16, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
              else
                if stmt_id == 15
                then
                  (insert_R_do_complete_s15, me)<- {_r1_:vid, _r2_:R_A,
                                                    _r3_:R_B}
                else
                  if stmt_id == 14
                  then
                    (insert_R_do_complete_s14, me)<- {_r1_:vid, _r2_:R_A,
                                                      _r3_:R_B}
                  else ()
            else ()
            )
        else __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count})
    )

trigger insert_R_rcv_fetch : {
_r1_:collection { _r1_:int, _r2_:int } @ { Set }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
    log_write_insert_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
    stmts_and_map_ids.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:stmt_id, _r2_:map_id} in 
        if stmt_id == 14
        then
          if map_id == 6
          then
            (insert_R_send_push_s14_m_ATIMESD_mR1, me)<- {_r1_:vid, _r2_:R_A,
                                                          _r3_:R_B}
          else ()
        else
          if stmt_id == 15
          then
            if map_id == 3
            then
              (insert_R_send_push_s15_m_ATIMESD_mT1_mR1, me)<- {_r1_:vid,
                                                                _r2_:R_A,
                                                                _r3_:R_B}
            else ()
          else ())
    )

trigger insert_R_send_push_s14_m_ATIMESD_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
    log_master_write {_r1_:vid, _r2_:4, _r3_:14};
    (shuffle_ATIMESD_mR1_ATIMESD
       {_r1_:(),
        _r2_:bind (ATIMESD_mR1.filter
                    (\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      R_B)).fold
                    ((\_b2_ ->
                    bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {_r1_:map_vid, _r2_:vid}
                      then
                        if vid_eq {_r1_:map_vid, _r2_:max_vid}
                        then
                          {_r1_:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:int |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, _r2_:max_vid}
                        else
                          if vid_gt {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:int |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             _r2_:map_vid}
                          else {_r1_:acc, _r2_:max_vid}
                      else {_r1_:acc, _r2_:max_vid})))
                    {_r1_:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                     } @ { Set }, _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {
        _r1_:__1, _r2_:__2} in __1, _r3_:true}).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
        (insert_R_rcv_push_s14_m_ATIMESD_mR1, ip)<- {_r1_:tuples, _r2_:vid,
                                                     _r3_:R_A, _r4_:R_B})
    )

trigger insert_R_send_push_s15_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
    log_master_write {_r1_:vid, _r2_:4, _r3_:15};
    (shuffle_ATIMESD_mT1_mR1_ATIMESD_mT1_0t1
       {_r1_:None immut,
        _r2_:((ATIMESD_mT1_mR1.filter
                (\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
                  _r2_ == R_B)).groupby
                (\_b1_ -> 
                  bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_val} in {_r1_:__map_0, _r2_:__map_1})
                ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_val} in 
                  if vid_lt {_r1_:map_vid, _r2_:vid}
                  then
                    if vid_eq {_r1_:map_vid, _r2_:max_vid}
                    then
                      {_r1_:({|
                       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                       _r3_:int, _r4_:int |
                       {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                        _r4_:__map_val}|} @ { Set }).combine acc, _r2_:max_vid}
                    else
                      if vid_gt {_r1_:map_vid, _r2_:max_vid}
                      then
                        {_r1_:{|
                         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                         _r3_:int, _r4_:int |
                         {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                          _r4_:__map_val}|} @ { Set }, _r2_:map_vid}
                      else {_r1_:acc, _r2_:max_vid}
                  else {_r1_:acc, _r2_:max_vid})))
                {_r1_:empty {
                 _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                 _r4_:int } @ { Set }, _r2_:{_r1_:0, _r2_:0, _r3_:0}}).ext
               (\_b1_ -> 
                 bind _b1_ as {_r1_:_, _r2_:_b2_} in 
                 bind _b2_ as {_r1_:project, _r2_:_} in project), _r3_:true}).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
        (insert_R_rcv_push_s15_m_ATIMESD_mT1_mR1, ip)<- {_r1_:tuples, _r2_:vid,
                                                         _r3_:R_A, _r4_:R_B})
    )

trigger insert_R_rcv_push_s14_m_ATIMESD_mR1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
    log_write_insert_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
    tuples.iterate
      (\tuple -> 
        if map_ATIMESD_mR1_s14_buf.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then
          map_ATIMESD_mR1_s14_buf.update
            (case ((map_ATIMESD_mR1_s14_buf.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1)).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_ATIMESD_mR1_s14_buf.insert tuple);
    if __stmt_cntrs__.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 14) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 14)).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 14)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:14, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 14)).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:14, _r3_:0}
        then (insert_R_do_complete_s14, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:14, _r3_:-1}
    )

trigger insert_R_rcv_push_s15_m_ATIMESD_mT1_mR1 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
    log_write_insert_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
    tuples.iterate
      (\tuple -> 
        if map_ATIMESD_mT1_mR1_s15_buf.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                           _r4_:__temp_3} in (_r1_ == __temp_0 and _r3_ ==
            __temp_2) * _r2_ == __temp_1) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
          } @ { Set }
        then
          map_ATIMESD_mT1_mR1_s15_buf.update
            (case ((map_ATIMESD_mT1_mR1_s15_buf.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                             _r4_:__temp_3} in (_r1_ == __temp_0 and _r3_ ==
              __temp_2) * _r2_ == __temp_1)).peek ()) of { Some x -> x }
            { None -> error () }) tuple
        else map_ATIMESD_mT1_mR1_s15_buf.insert tuple);
    if __stmt_cntrs__.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 15) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 15)).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 15)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:15, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 15)).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:15, _r3_:0}
        then (insert_R_do_complete_s15, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:15, _r3_:-1}
    )

trigger insert_R_do_complete_s14 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in 
    let existing_out_tier = ATIMESD in
    let __prod_ret__13 =
      (let wrapped_lookup_value =
         bind (map_ATIMESD_mR1_s14_buf.filter
                (\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == R_B)).fold
                ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                  if vid_lt {_r1_:map_vid, _r2_:vid}
                  then
                    if vid_eq {_r1_:map_vid, _r2_:max_vid}
                    then
                      {_r1_:({| _r1_:int, _r2_:int |
                       {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine 
                       acc, _r2_:max_vid}
                    else
                      if vid_gt {_r1_:map_vid, _r2_:max_vid}
                      then
                        {_r1_:{| _r1_:int, _r2_:int |
                         {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                         _r2_:map_vid}
                      else {_r1_:acc, _r2_:max_vid}
                  else {_r1_:acc, _r2_:max_vid})))
                {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                 _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in __1 in
      if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {_r1_:_, _r2_:projected_field} in 
        projected_field) * R_A in (
      add_delta_to_ATIMESD
        {_r1_:vid, _r2_:{| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int |
         {_r1_:vid, _r2_:__prod_ret__13}|} @ { Set }}
      )

trigger insert_R_do_complete_s15 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in 
    let existing_out_tier = ATIMESD_mT1 in
    let __delta_values__ =
      ((((map_ATIMESD_mT1_mR1_s15_buf.filter
           (\_b1_ -> 
             bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in _r2_
             == R_B)).groupby
           (\_b1_ -> 
             bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                           _r4_:__map_val} in {_r1_:__map_0, _r2_:__map_1})
           ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
             bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                           _r4_:__map_val} in 
             if vid_lt {_r1_:map_vid, _r2_:vid}
             then
               if vid_eq {_r1_:map_vid, _r2_:max_vid}
               then
                 {_r1_:({| _r1_:int, _r2_:int, _r3_:int |
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set }).combine
                  acc, _r2_:max_vid}
               else
                 if vid_gt {_r1_:map_vid, _r2_:max_vid}
                 then
                   {_r1_:{| _r1_:int, _r2_:int, _r3_:int |
                    {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set },
                    _r2_:map_vid}
                 else {_r1_:acc, _r2_:max_vid}
             else {_r1_:acc, _r2_:max_vid})))
           {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Set },
            _r2_:{_r1_:0, _r2_:0, _r3_:0}}).ext
          (\_b1_ -> 
            bind _b1_ as {_r1_:_, _r2_:_b2_} in 
            bind _b2_ as {_r1_:project, _r2_:_} in project)).map
         (\_b1_ -> 
           bind _b1_ as {_r1_:R_B, _r2_:ATIMESD_mTT_C, _r3_:__map_ret__14} in 
           {_r1_:ATIMESD_mTT_C, _r2_:__map_ret__14})).map
        (\_b1_ -> 
          bind _b1_ as {_r1_:ATIMESD_mTT_C, _r2_:__map_ret__14} in 
          {_r1_:ATIMESD_mTT_C, _r2_:__map_ret__14 * R_A}) in
    let __delta_with_vid__ =
      __delta_values__.map
        (\_b1_ -> 
          bind _b1_ as {_r1_:ATIMESD_mTT_C, _r2_:__prod_ret__14} in 
          {_r1_:vid, _r2_:ATIMESD_mTT_C, _r3_:__prod_ret__14}) in (
      add_delta_to_ATIMESD_mT1 {_r1_:vid, _r2_:__delta_with_vid__};
      (ATIMESD_mT1_send_correctives, me)<- {_r1_:vid, _r2_:__delta_with_vid__}
      )

trigger insert_R_do_complete_s16 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in 
    let existing_out_tier = ATIMESD_mS1 in let __val_ret__17 = R_A in (
      add_delta_to_ATIMESD_mS1
        {_r1_:vid, _r2_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:R_B, _r3_:__val_ret__17}|} @ { Set }};
      (ATIMESD_mS1_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                            _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                            }, _r2_:int, _r3_:int |
                                            {_r1_:vid, _r2_:R_B,
                                             _r3_:__val_ret__17}|} @ { Set }}
      )

trigger insert_R_rcv_corrective_s14_m_ATIMESD_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_ATIMESD_mR1_s14_buf {_r1_:vid, _r2_:delta_tuples};
    compute_vids.iterate
      (\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 14)).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:14, _r3_:0}
        then
          bind log_get_bound_insert_R compute_vid as {_r1_:vid, _r2_:R_A,
                                                      _r3_:R_B} in 
          (insert_R_do_corrective_s14_m_ATIMESD_mR1, me)<- {_r1_:compute_vid,
                                                            _r2_:R_A, _r3_:R_B,
                                                            _r4_:delta_tuples}
        else ())
    )

trigger insert_R_rcv_corrective_s15_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int } @ { Set }
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_ATIMESD_mT1_mR1_s15_buf {_r1_:vid, _r2_:delta_tuples};
    compute_vids.iterate
      (\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 15)).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:15, _r3_:0}
        then
          bind log_get_bound_insert_R compute_vid as {_r1_:vid, _r2_:R_A,
                                                      _r3_:R_B} in 
          (insert_R_do_corrective_s15_m_ATIMESD_mT1_mR1, me)<- {_r1_:compute_vid,
                                                                _r2_:R_A,
                                                                _r3_:R_B,
                                                                _r4_:delta_tuples}
        else ())
    )

trigger insert_R_do_corrective_s14_m_ATIMESD_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples} in 
    delta_tuples.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ATIMESD_mRR_B, _r3_:delta_ATIMESD_mR1} in 
        let existing_out_tier = ATIMESD in
        let __prod_ret__21 = ((if R_B == delta_ATIMESD_mRR_B then 1 else 0) *
          delta_ATIMESD_mR1) * R_A in (
          cond_add_delta_to_ATIMESD
            {_r1_:vid, _r2_:{| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int
             | {_r1_:vid, _r2_:__prod_ret__21}|} @ { Set }}
          ))

trigger insert_R_do_corrective_s15_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples} in 
    delta_tuples.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ATIMESD_mT1_mRR_B,
                      _r3_:delta_ATIMESD_mTT_C, _r4_:delta_ATIMESD_mT1_mR1} in 
        let existing_out_tier = ATIMESD_mT1 in
        let __prod_ret__23 = ((if R_B == delta_ATIMESD_mT1_mRR_B then 1 else 0)
          * delta_ATIMESD_mT1_mR1) * R_A in (
          cond_add_delta_to_ATIMESD_mT1
            {_r1_:vid, _r2_:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
             {_r1_:vid, _r2_:delta_ATIMESD_mTT_C, _r3_:__prod_ret__23}|} @ { Set }};
          (ATIMESD_mT1_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                                _r1_:{
                                                _r1_:int, _r2_:int, _r3_:int },
                                                _r2_:int, _r3_:int |
                                                {_r1_:vid,
                                                 _r2_:delta_ATIMESD_mTT_C,
                                                 _r3_:__prod_ret__23}|} @ { Set }}
          ))

trigger delete_R : {
_r1_:int, _r2_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:R_A, _r2_:R_B} in (
    let vid =
      {_r1_:case (__epoch__.peek ()) of { Some x -> x } { None -> error () },
       _r2_:case (__vid_counter__.peek ()) of { Some x -> x }
       { None -> error () }, _r3_:hash me} in
    (
      (delete_R_send_fetch, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B};
      __vid_counter__.update
        (case (__vid_counter__.peek ()) of { Some x -> x }
        { None -> error () }) (1 + case (__vid_counter__.peek ()) of
        { Some x -> x } { None -> error () })
      )
    )

trigger delete_R_send_fetch : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
    (route_to_ATIMESD_mS1 (Some R_B)).iterate
      (\ip ->  (delete_R_do_complete_s19, ip)<- {_r1_:vid, _r2_:R_A, _r3_:R_B});
    ((((empty {
        _r1_:address, _r2_:int, _r3_:int
        } @ { Collection }).combine
        (let sender_count =
           (route_to_ATIMESD_mR1 (Some R_B)).fold
             ((\count -> (\ip ->  count + 1))) 0 in
        ((shuffle_ATIMESD_mR1_ATIMESD
            {_r1_:(), _r2_:empty {
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
             } @ { Set }, _r3_:true}).map
           (\_b1_ -> 
             bind _b1_ as {_r1_:ip, _r2_:tuples} in 
             {_r1_:ip, _r2_:17, _r3_:sender_count})).combine
        (let sender_count =
           (route_to_ATIMESD_mT1_mR1 {_r1_:Some R_B, _r2_:None immut}).fold
             ((\count -> (\ip ->  count + 1))) 0 in
        (shuffle_ATIMESD_mT1_mR1_ATIMESD_mT1_0t1
           {_r1_:None immut, _r2_:empty {
            _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
            } @ { Set }, _r3_:true}).map
          (\_b1_ -> 
            bind _b1_ as {_r1_:ip, _r2_:tuples} in 
            {_r1_:ip, _r2_:18, _r3_:sender_count})))).groupby
        (\_b1_ -> 
          bind _b1_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in 
          {_r1_:ip, _r2_:stmt_id}) ((\acc -> (\_b3_ -> 
          bind _b3_ as {_r1_:ip, _r2_:stmt_id, _r3_:count} in acc + count))) 0).groupby
       (\_b1_ -> 
         bind _b1_ as {_r1_:_b2_, _r2_:count} in 
         bind _b2_ as {_r1_:ip, _r2_:stmt_id} in ip) ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:ip_and_stmt_id, _r2_:count} in 
         bind ip_and_stmt_id as {_r1_:ip, _r2_:stmt_id} in acc.combine
         ({| _r1_:int, _r2_:int |
         {_r1_:stmt_id, _r2_:count}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int } @ { Collection }).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_id_cnt_list} in (
          (delete_R_rcv_put, ip)<- {_r1_:me, _r2_:stmt_id_cnt_list, _r3_:vid,
                                    _r4_:R_A, _r5_:R_B}
          ));
    ((((route_to_ATIMESD_mT1_mR1 {_r1_:Some R_B, _r2_:None immut}).map
         (\ip ->  {_r1_:18, _r2_:3, _r3_:ip})).combine
       (((route_to_ATIMESD_mR1 (Some R_B)).map
           (\ip ->  {_r1_:17, _r2_:6, _r3_:ip})).combine
       empty { _r1_:int, _r2_:int, _r3_:address } @ { Collection })).groupby
       (\_b1_ ->  bind _b1_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in ip)
       ((\acc -> (\_b3_ -> 
         bind _b3_ as {_r1_:stmt_id, _r2_:map_id, _r3_:ip} in acc.combine
         ({| _r1_:int, _r2_:int |
         {_r1_:stmt_id, _r2_:map_id}|} @ { Collection })))) empty {
       _r1_:int, _r2_:int } @ { Collection }).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:stmt_map_ids} in 
        (delete_R_rcv_fetch, ip)<- {_r1_:stmt_map_ids, _r2_:vid, _r3_:R_A,
                                    _r4_:R_B})
    )

trigger delete_R_rcv_put : {
_r1_:address, _r2_:collection { _r1_:int, _r2_:int } @ { Set }, _r3_:{
_r1_:int, _r2_:int, _r3_:int }, _r4_:int, _r5_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:sender_ip, _r2_:stmt_id_cnt_list, _r3_:vid, _r4_:R_A,
                _r5_:R_B} in (
    stmt_id_cnt_list.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:stmt_id, _r2_:count} in 
        if __stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == stmt_id)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:_, _r2_:_, _r3_:old_count} in 
          let new_count = old_count + count in (
            __stmt_cntrs__.update
              {_r1_:vid, _r2_:stmt_id, _r3_:old_count}
              {_r1_:vid, _r2_:stmt_id, _r3_:new_count};
            if new_count == 0
            then
              if stmt_id == 19
              then
                (delete_R_do_complete_s19, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
              else
                if stmt_id == 18
                then
                  (delete_R_do_complete_s18, me)<- {_r1_:vid, _r2_:R_A,
                                                    _r3_:R_B}
                else
                  if stmt_id == 17
                  then
                    (delete_R_do_complete_s17, me)<- {_r1_:vid, _r2_:R_A,
                                                      _r3_:R_B}
                  else ()
            else ()
            )
        else __stmt_cntrs__.insert {_r1_:vid, _r2_:stmt_id, _r3_:count})
    )

trigger delete_R_rcv_fetch : {
_r1_:collection { _r1_:int, _r2_:int } @ { Set }, _r2_:{
_r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:stmts_and_map_ids, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
    log_write_delete_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
    stmts_and_map_ids.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:stmt_id, _r2_:map_id} in 
        if stmt_id == 17
        then
          if map_id == 6
          then
            (delete_R_send_push_s17_m_ATIMESD_mR1, me)<- {_r1_:vid, _r2_:R_A,
                                                          _r3_:R_B}
          else ()
        else
          if stmt_id == 18
          then
            if map_id == 3
            then
              (delete_R_send_push_s18_m_ATIMESD_mT1_mR1, me)<- {_r1_:vid,
                                                                _r2_:R_A,
                                                                _r3_:R_B}
            else ()
          else ())
    )

trigger delete_R_send_push_s17_m_ATIMESD_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
    log_master_write {_r1_:vid, _r2_:5, _r3_:17};
    (shuffle_ATIMESD_mR1_ATIMESD
       {_r1_:(),
        _r2_:bind (ATIMESD_mR1.filter
                    (\_b1_ -> 
                      bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ ==
                      R_B)).fold
                    ((\_b2_ ->
                    bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                      bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                      if vid_lt {_r1_:map_vid, _r2_:vid}
                      then
                        if vid_eq {_r1_:map_vid, _r2_:max_vid}
                        then
                          {_r1_:({|
                           _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                           _r3_:int |
                           {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set }).combine
                           acc, _r2_:max_vid}
                        else
                          if vid_gt {_r1_:map_vid, _r2_:max_vid}
                          then
                            {_r1_:{|
                             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                             _r3_:int |
                             {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val}|} @ { Set },
                             _r2_:map_vid}
                          else {_r1_:acc, _r2_:max_vid}
                      else {_r1_:acc, _r2_:max_vid})))
                    {_r1_:empty {
                     _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                     } @ { Set }, _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {
        _r1_:__1, _r2_:__2} in __1, _r3_:true}).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
        (delete_R_rcv_push_s17_m_ATIMESD_mR1, ip)<- {_r1_:tuples, _r2_:vid,
                                                     _r3_:R_A, _r4_:R_B})
    )

trigger delete_R_send_push_s18_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in (
    log_master_write {_r1_:vid, _r2_:5, _r3_:18};
    (shuffle_ATIMESD_mT1_mR1_ATIMESD_mT1_0t1
       {_r1_:None immut,
        _r2_:((ATIMESD_mT1_mR1.filter
                (\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
                  _r2_ == R_B)).groupby
                (\_b1_ -> 
                  bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_val} in {_r1_:__map_0, _r2_:__map_1})
                ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                                _r4_:__map_val} in 
                  if vid_lt {_r1_:map_vid, _r2_:vid}
                  then
                    if vid_eq {_r1_:map_vid, _r2_:max_vid}
                    then
                      {_r1_:({|
                       _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                       _r3_:int, _r4_:int |
                       {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                        _r4_:__map_val}|} @ { Set }).combine acc, _r2_:max_vid}
                    else
                      if vid_gt {_r1_:map_vid, _r2_:max_vid}
                      then
                        {_r1_:{|
                         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int,
                         _r3_:int, _r4_:int |
                         {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                          _r4_:__map_val}|} @ { Set }, _r2_:map_vid}
                      else {_r1_:acc, _r2_:max_vid}
                  else {_r1_:acc, _r2_:max_vid})))
                {_r1_:empty {
                 _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                 _r4_:int } @ { Set }, _r2_:{_r1_:0, _r2_:0, _r3_:0}}).ext
               (\_b1_ -> 
                 bind _b1_ as {_r1_:_, _r2_:_b2_} in 
                 bind _b2_ as {_r1_:project, _r2_:_} in project), _r3_:true}).iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
        (delete_R_rcv_push_s18_m_ATIMESD_mT1_mR1, ip)<- {_r1_:tuples, _r2_:vid,
                                                         _r3_:R_A, _r4_:R_B})
    )

trigger delete_R_rcv_push_s17_m_ATIMESD_mR1 : {
_r1_:collection { _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
    log_write_delete_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
    tuples.iterate
      (\tuple -> 
        if map_ATIMESD_mR1_s17_buf.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in _r1_
            == __temp_0 and _r2_ == __temp_1) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
        then
          map_ATIMESD_mR1_s17_buf.update
            (case ((map_ATIMESD_mR1_s17_buf.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2} in 
              _r1_ == __temp_0 and _r2_ == __temp_1)).peek ()) of
            { Some x -> x } { None -> error () }) tuple
        else map_ATIMESD_mR1_s17_buf.insert tuple);
    if __stmt_cntrs__.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 17) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 17)).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 17)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:17, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 17)).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:17, _r3_:0}
        then (delete_R_do_complete_s17, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:17, _r3_:-1}
    )

trigger delete_R_rcv_push_s18_m_ATIMESD_mT1_mR1 : {
_r1_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
} @ { Set }, _r2_:{ _r1_:int, _r2_:int, _r3_:int }, _r3_:int, _r4_:int
}
= \_b1_ ->

  bind _b1_ as {_r1_:tuples, _r2_:vid, _r3_:R_A, _r4_:R_B} in (
    log_write_delete_R {_r1_:vid, _r2_:R_A, _r3_:R_B};
    tuples.iterate
      (\tuple -> 
        if map_ATIMESD_mT1_mR1_s18_buf.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
            bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                           _r4_:__temp_3} in (_r1_ == __temp_0 and _r3_ ==
            __temp_2) * _r2_ == __temp_1) != empty {
          _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int
          } @ { Set }
        then
          map_ATIMESD_mT1_mR1_s18_buf.update
            (case ((map_ATIMESD_mT1_mR1_s18_buf.filter
            (\_b1_ -> 
              bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in 
              bind tuple as {_r1_:__temp_0, _r2_:__temp_1, _r3_:__temp_2,
                             _r4_:__temp_3} in (_r1_ == __temp_0 and _r3_ ==
              __temp_2) * _r2_ == __temp_1)).peek ()) of { Some x -> x }
            { None -> error () }) tuple
        else map_ATIMESD_mT1_mR1_s18_buf.insert tuple);
    if __stmt_cntrs__.filter
      (\_b1_ -> 
        bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and _r2_
        == 18) != empty {
      _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
    then (
        __stmt_cntrs__.update
          (case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 18)).peek ()) of { Some x -> x } { None -> error () })
          (bind case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 18)).peek ()) of { Some x -> x }
          { None -> error () } as {_r1_:vid, _r2_:stmt_id, _r3_:count} in 
          {_r1_:vid, _r2_:18, _r3_:count - 1});
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ == vid and
            _r2_ == 18)).peek ()) of { Some x -> x } { None -> error () } ==
          {_r1_:vid, _r2_:18, _r3_:0}
        then (delete_R_do_complete_s18, me)<- {_r1_:vid, _r2_:R_A, _r3_:R_B}
        else ()
        )
    else __stmt_cntrs__.insert {_r1_:vid, _r2_:18, _r3_:-1}
    )

trigger delete_R_do_complete_s17 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in 
    let existing_out_tier = ATIMESD in
    let __prod_ret__16 =
      (let wrapped_lookup_value =
         bind (map_ATIMESD_mR1_s17_buf.filter
                (\_b1_ -> 
                  bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r2_ == R_B)).fold
                ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
                  bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_val} in 
                  if vid_lt {_r1_:map_vid, _r2_:vid}
                  then
                    if vid_eq {_r1_:map_vid, _r2_:max_vid}
                    then
                      {_r1_:({| _r1_:int, _r2_:int |
                       {_r1_:__map_0, _r2_:__map_val}|} @ { Set }).combine 
                       acc, _r2_:max_vid}
                    else
                      if vid_gt {_r1_:map_vid, _r2_:max_vid}
                      then
                        {_r1_:{| _r1_:int, _r2_:int |
                         {_r1_:__map_0, _r2_:__map_val}|} @ { Set },
                         _r2_:map_vid}
                      else {_r1_:acc, _r2_:max_vid}
                  else {_r1_:acc, _r2_:max_vid})))
                {_r1_:empty { _r1_:int, _r2_:int } @ { Set },
                 _r2_:{_r1_:0, _r2_:0, _r3_:0}} as {_r1_:__1, _r2_:__2} in __1 in
      if wrapped_lookup_value == empty { _r1_:int, _r2_:int } @ { Set }
      then 0
      else bind case (wrapped_lookup_value.peek ()) of { Some x -> x }
        { None -> error () } as {_r1_:_, _r2_:projected_field} in 
        projected_field) * -R_A in (
      add_delta_to_ATIMESD
        {_r1_:vid, _r2_:{| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int |
         {_r1_:vid, _r2_:__prod_ret__16}|} @ { Set }}
      )

trigger delete_R_do_complete_s18 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in 
    let existing_out_tier = ATIMESD_mT1 in
    let __delta_values__ =
      ((((map_ATIMESD_mT1_mR1_s18_buf.filter
           (\_b1_ -> 
             bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_, _r4_:_r4_} in _r2_
             == R_B)).groupby
           (\_b1_ -> 
             bind _b1_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                           _r4_:__map_val} in {_r1_:__map_0, _r2_:__map_1})
           ((\_b2_ -> bind _b2_ as {_r1_:acc, _r2_:max_vid} in (\_b5_ -> 
             bind _b5_ as {_r1_:map_vid, _r2_:__map_0, _r3_:__map_1,
                           _r4_:__map_val} in 
             if vid_lt {_r1_:map_vid, _r2_:vid}
             then
               if vid_eq {_r1_:map_vid, _r2_:max_vid}
               then
                 {_r1_:({| _r1_:int, _r2_:int, _r3_:int |
                  {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set }).combine
                  acc, _r2_:max_vid}
               else
                 if vid_gt {_r1_:map_vid, _r2_:max_vid}
                 then
                   {_r1_:{| _r1_:int, _r2_:int, _r3_:int |
                    {_r1_:__map_0, _r2_:__map_1, _r3_:__map_val}|} @ { Set },
                    _r2_:map_vid}
                 else {_r1_:acc, _r2_:max_vid}
             else {_r1_:acc, _r2_:max_vid})))
           {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Set },
            _r2_:{_r1_:0, _r2_:0, _r3_:0}}).ext
          (\_b1_ -> 
            bind _b1_ as {_r1_:_, _r2_:_b2_} in 
            bind _b2_ as {_r1_:project, _r2_:_} in project)).map
         (\_b1_ -> 
           bind _b1_ as {_r1_:R_B, _r2_:ATIMESD_mTT_C, _r3_:__map_ret__16} in 
           {_r1_:ATIMESD_mTT_C, _r2_:__map_ret__16})).map
        (\_b1_ -> 
          bind _b1_ as {_r1_:ATIMESD_mTT_C, _r2_:__map_ret__16} in 
          {_r1_:ATIMESD_mTT_C, _r2_:__map_ret__16 * -R_A}) in
    let __delta_with_vid__ =
      __delta_values__.map
        (\_b1_ -> 
          bind _b1_ as {_r1_:ATIMESD_mTT_C, _r2_:__prod_ret__18} in 
          {_r1_:vid, _r2_:ATIMESD_mTT_C, _r3_:__prod_ret__18}) in (
      add_delta_to_ATIMESD_mT1 {_r1_:vid, _r2_:__delta_with_vid__};
      (ATIMESD_mT1_send_correctives, me)<- {_r1_:vid, _r2_:__delta_with_vid__}
      )

trigger delete_R_do_complete_s19 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B} in 
    let existing_out_tier = ATIMESD_mS1 in let __prod_ret__19 = -R_A in (
      add_delta_to_ATIMESD_mS1
        {_r1_:vid, _r2_:{|
         _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
         {_r1_:vid, _r2_:R_B, _r3_:__prod_ret__19}|} @ { Set }};
      (ATIMESD_mS1_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                            _r1_:{ _r1_:int, _r2_:int, _r3_:int
                                            }, _r2_:int, _r3_:int |
                                            {_r1_:vid, _r2_:R_B,
                                             _r3_:__prod_ret__19}|} @ { Set }}
      )

trigger delete_R_rcv_corrective_s17_m_ATIMESD_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_ATIMESD_mR1_s17_buf {_r1_:vid, _r2_:delta_tuples};
    compute_vids.iterate
      (\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 17)).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:17, _r3_:0}
        then
          bind log_get_bound_delete_R compute_vid as {_r1_:vid, _r2_:R_A,
                                                      _r3_:R_B} in 
          (delete_R_do_corrective_s17_m_ATIMESD_mR1, me)<- {_r1_:compute_vid,
                                                            _r2_:R_A, _r3_:R_B,
                                                            _r4_:delta_tuples}
        else ())
    )

trigger delete_R_rcv_corrective_s18_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:int, _r2_:int, _r3_:int } @ { Seq }, _r3_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int } @ { Set }
}
= \_b1_ ->

  bind _b1_ as {_r1_:vid, _r2_:compute_vids, _r3_:delta_tuples} in (
    add_delta_to_map_ATIMESD_mT1_mR1_s18_buf {_r1_:vid, _r2_:delta_tuples};
    compute_vids.iterate
      (\compute_vid -> 
        if case ((__stmt_cntrs__.filter
          (\_b1_ -> 
            bind _b1_ as {_r1_:_r1_, _r2_:_r2_, _r3_:_r3_} in _r1_ ==
            compute_vid and _r2_ == 18)).peek ()) of { Some x -> x }
          { None -> error () } == {_r1_:compute_vid, _r2_:18, _r3_:0}
        then
          bind log_get_bound_delete_R compute_vid as {_r1_:vid, _r2_:R_A,
                                                      _r3_:R_B} in 
          (delete_R_do_corrective_s18_m_ATIMESD_mT1_mR1, me)<- {_r1_:compute_vid,
                                                                _r2_:R_A,
                                                                _r3_:R_B,
                                                                _r4_:delta_tuples}
        else ())
    )

trigger delete_R_do_corrective_s17_m_ATIMESD_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples} in 
    delta_tuples.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ATIMESD_mRR_B, _r3_:delta_ATIMESD_mR1} in 
        let existing_out_tier = ATIMESD in
        let __prod_ret__26 = (if R_B == delta_ATIMESD_mRR_B then 1 else 0) *
          (-delta_ATIMESD_mR1 * R_A) in (
          cond_add_delta_to_ATIMESD
            {_r1_:vid, _r2_:{| _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int
             | {_r1_:vid, _r2_:__prod_ret__26}|} @ { Set }}
          ))

trigger delete_R_do_corrective_s18_m_ATIMESD_mT1_mR1 : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:vid, _r2_:R_A, _r3_:R_B, _r4_:delta_tuples} in 
    delta_tuples.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:_, _r2_:delta_ATIMESD_mT1_mRR_B,
                      _r3_:delta_ATIMESD_mTT_C, _r4_:delta_ATIMESD_mT1_mR1} in 
        let existing_out_tier = ATIMESD_mT1 in
        let __prod_ret__29 = (if R_B == delta_ATIMESD_mT1_mRR_B then 1 else 0)
          * (-delta_ATIMESD_mT1_mR1 * R_A) in (
          cond_add_delta_to_ATIMESD_mT1
            {_r1_:vid, _r2_:{|
             _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int |
             {_r1_:vid, _r2_:delta_ATIMESD_mTT_C, _r3_:__prod_ret__29}|} @ { Set }};
          (ATIMESD_mT1_send_correctives, me)<- {_r1_:vid, _r2_:{|
                                                _r1_:{
                                                _r1_:int, _r2_:int, _r3_:int },
                                                _r2_:int, _r3_:int |
                                                {_r1_:vid,
                                                 _r2_:delta_ATIMESD_mTT_C,
                                                 _r3_:__prod_ret__29}|} @ { Set }}
          ))

trigger ATIMESD_mT1_send_correctives : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:corrective_vid, _r2_:delta_tuples} in 
    let corrective_list =
      filter_corrective_list
        {_r1_:corrective_vid, _r2_:{| _r1_:int, _r2_:int | {_r1_:1, _r2_:3},
         {_r1_:0, _r2_:0}|} @ { Set }} in
    corrective_list.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:stmt_id, _r2_:vid_list} in 
        if stmt_id == 3
        then
          ((vid_list.ext
              (\vid -> 
                bind log_get_bound_delete_T vid as {_r1_:vid, _r2_:T_C,
                                                    _r3_:T_D} in 
                (shuffle_ATIMESD_mT1_ATIMESD
                   {_r1_:(), _r2_:delta_tuples, _r3_:false}).map
                  (\_b1_ -> 
                    bind _b1_ as {_r1_:ip, _r2_:tuples} in 
                    {_r1_:ip, _r2_:vid, _r3_:tuples}))).groupby
             (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip)
             ((\_b2_ ->
             bind _b2_ as {_r1_:acc_vid, _r2_:acc_tuples} in (\_b5_ -> 
               bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
               {_r1_:acc_vid.combine
                ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                _r2_:acc_tuples.combine tuples})))
             {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
              _r2_:empty {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
              } @ { Set }}).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:ip, _r2_:_b3_} in 
              bind _b3_ as {_r1_:vid_send_list, _r2_:tuple} in 
              (delete_T_rcv_corrective_s3_m_ATIMESD_mT1, ip)<- {_r1_:corrective_vid,
                                                                _r2_:vid_send_list,
                                                                _r3_:tuple})
        else
          if stmt_id == 0
          then
            ((vid_list.ext
                (\vid -> 
                  bind log_get_bound_insert_T vid as {_r1_:vid, _r2_:T_C,
                                                      _r3_:T_D} in 
                  (shuffle_ATIMESD_mT1_ATIMESD
                     {_r1_:(), _r2_:delta_tuples, _r3_:false}).map
                    (\_b1_ -> 
                      bind _b1_ as {_r1_:ip, _r2_:tuples} in 
                      {_r1_:ip, _r2_:vid, _r3_:tuples}))).groupby
               (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip)
               ((\_b2_ ->
               bind _b2_ as {_r1_:acc_vid, _r2_:acc_tuples} in (\_b5_ -> 
                 bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                 {_r1_:acc_vid.combine
                  ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                  _r2_:acc_tuples.combine tuples})))
               {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                _r2_:empty {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                } @ { Set }}).iterate
              (\_b1_ -> 
                bind _b1_ as {_r1_:ip, _r2_:_b3_} in 
                bind _b3_ as {_r1_:vid_send_list, _r2_:tuple} in 
                (insert_T_rcv_corrective_s0_m_ATIMESD_mT1, ip)<- {_r1_:corrective_vid,
                                                                  _r2_:vid_send_list,
                                                                  _r3_:tuple})
          else ())

trigger ATIMESD_mR1_send_correctives : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:corrective_vid, _r2_:delta_tuples} in 
    let corrective_list =
      filter_corrective_list
        {_r1_:corrective_vid, _r2_:{| _r1_:int, _r2_:int | {_r1_:5, _r2_:17},
         {_r1_:4, _r2_:14}|} @ { Set }} in
    corrective_list.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:stmt_id, _r2_:vid_list} in 
        if stmt_id == 17
        then
          ((vid_list.ext
              (\vid -> 
                bind log_get_bound_delete_R vid as {_r1_:vid, _r2_:R_A,
                                                    _r3_:R_B} in 
                (shuffle_ATIMESD_mR1_ATIMESD
                   {_r1_:(), _r2_:delta_tuples, _r3_:false}).map
                  (\_b1_ -> 
                    bind _b1_ as {_r1_:ip, _r2_:tuples} in 
                    {_r1_:ip, _r2_:vid, _r3_:tuples}))).groupby
             (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip)
             ((\_b2_ ->
             bind _b2_ as {_r1_:acc_vid, _r2_:acc_tuples} in (\_b5_ -> 
               bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
               {_r1_:acc_vid.combine
                ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                _r2_:acc_tuples.combine tuples})))
             {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
              _r2_:empty {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
              } @ { Set }}).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:ip, _r2_:_b3_} in 
              bind _b3_ as {_r1_:vid_send_list, _r2_:tuple} in 
              (delete_R_rcv_corrective_s17_m_ATIMESD_mR1, ip)<- {_r1_:corrective_vid,
                                                                 _r2_:vid_send_list,
                                                                 _r3_:tuple})
        else
          if stmt_id == 14
          then
            ((vid_list.ext
                (\vid -> 
                  bind log_get_bound_insert_R vid as {_r1_:vid, _r2_:R_A,
                                                      _r3_:R_B} in 
                  (shuffle_ATIMESD_mR1_ATIMESD
                     {_r1_:(), _r2_:delta_tuples, _r3_:false}).map
                    (\_b1_ -> 
                      bind _b1_ as {_r1_:ip, _r2_:tuples} in 
                      {_r1_:ip, _r2_:vid, _r3_:tuples}))).groupby
               (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip)
               ((\_b2_ ->
               bind _b2_ as {_r1_:acc_vid, _r2_:acc_tuples} in (\_b5_ -> 
                 bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                 {_r1_:acc_vid.combine
                  ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                  _r2_:acc_tuples.combine tuples})))
               {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                _r2_:empty {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                } @ { Set }}).iterate
              (\_b1_ -> 
                bind _b1_ as {_r1_:ip, _r2_:_b3_} in 
                bind _b3_ as {_r1_:vid_send_list, _r2_:tuple} in 
                (insert_R_rcv_corrective_s14_m_ATIMESD_mR1, ip)<- {_r1_:corrective_vid,
                                                                   _r2_:vid_send_list,
                                                                   _r3_:tuple})
          else ())

trigger ATIMESD_mT1_mR1_send_correctives : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int, _r4_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:corrective_vid, _r2_:delta_tuples} in 
    let corrective_list =
      filter_corrective_list
        {_r1_:corrective_vid, _r2_:{| _r1_:int, _r2_:int | {_r1_:5, _r2_:18},
         {_r1_:4, _r2_:15}, {_r1_:1, _r2_:5}, {_r1_:0, _r2_:2}|} @ { Set }} in
    corrective_list.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:stmt_id, _r2_:vid_list} in 
        if stmt_id == 18
        then
          ((vid_list.ext
              (\vid -> 
                bind log_get_bound_delete_R vid as {_r1_:vid, _r2_:R_A,
                                                    _r3_:R_B} in 
                (shuffle_ATIMESD_mT1_mR1_ATIMESD_mT1_0t1
                   {_r1_:None immut, _r2_:delta_tuples, _r3_:false}).map
                  (\_b1_ -> 
                    bind _b1_ as {_r1_:ip, _r2_:tuples} in 
                    {_r1_:ip, _r2_:vid, _r3_:tuples}))).groupby
             (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip)
             ((\_b2_ ->
             bind _b2_ as {_r1_:acc_vid, _r2_:acc_tuples} in (\_b5_ -> 
               bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
               {_r1_:acc_vid.combine
                ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                _r2_:acc_tuples.combine tuples})))
             {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
              _r2_:empty {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
              _r4_:int } @ { Set }}).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:ip, _r2_:_b3_} in 
              bind _b3_ as {_r1_:vid_send_list, _r2_:tuple} in 
              (delete_R_rcv_corrective_s18_m_ATIMESD_mT1_mR1, ip)<- {
                _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple})
        else
          if stmt_id == 15
          then
            ((vid_list.ext
                (\vid -> 
                  bind log_get_bound_insert_R vid as {_r1_:vid, _r2_:R_A,
                                                      _r3_:R_B} in 
                  (shuffle_ATIMESD_mT1_mR1_ATIMESD_mT1_0t1
                     {_r1_:None immut, _r2_:delta_tuples, _r3_:false}).map
                    (\_b1_ -> 
                      bind _b1_ as {_r1_:ip, _r2_:tuples} in 
                      {_r1_:ip, _r2_:vid, _r3_:tuples}))).groupby
               (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip)
               ((\_b2_ ->
               bind _b2_ as {_r1_:acc_vid, _r2_:acc_tuples} in (\_b5_ -> 
                 bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                 {_r1_:acc_vid.combine
                  ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                  _r2_:acc_tuples.combine tuples})))
               {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                _r2_:empty {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                _r4_:int } @ { Set }}).iterate
              (\_b1_ -> 
                bind _b1_ as {_r1_:ip, _r2_:_b3_} in 
                bind _b3_ as {_r1_:vid_send_list, _r2_:tuple} in 
                (insert_R_rcv_corrective_s15_m_ATIMESD_mT1_mR1, ip)<- {
                  _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple})
          else
            if stmt_id == 5
            then
              ((vid_list.ext
                  (\vid -> 
                    bind log_get_bound_delete_T vid as {_r1_:vid, _r2_:T_C,
                                                        _r3_:T_D} in 
                    (shuffle_ATIMESD_mT1_mR1_ATIMESD_mR1_0t0
                       {_r1_:None immut, _r2_:delta_tuples, _r3_:false}).map
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
                        {_r1_:ip, _r2_:vid, _r3_:tuples}))).groupby
                 (\_b1_ -> 
                   bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip)
                 ((\_b2_ ->
                 bind _b2_ as {_r1_:acc_vid, _r2_:acc_tuples} in (\_b5_ -> 
                   bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                   {_r1_:acc_vid.combine
                    ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                    _r2_:acc_tuples.combine tuples})))
                 {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                  _r2_:empty {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                  _r4_:int } @ { Set }}).iterate
                (\_b1_ -> 
                  bind _b1_ as {_r1_:ip, _r2_:_b3_} in 
                  bind _b3_ as {_r1_:vid_send_list, _r2_:tuple} in 
                  (delete_T_rcv_corrective_s5_m_ATIMESD_mT1_mR1, ip)<- {
                    _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple})
            else
              if stmt_id == 2
              then
                ((vid_list.ext
                    (\vid -> 
                      bind log_get_bound_insert_T vid as {_r1_:vid, _r2_:T_C,
                                                          _r3_:T_D} in 
                      (shuffle_ATIMESD_mT1_mR1_ATIMESD_mR1_0t0
                         {_r1_:None immut, _r2_:delta_tuples, _r3_:false}).map
                        (\_b1_ -> 
                          bind _b1_ as {_r1_:ip, _r2_:tuples} in 
                          {_r1_:ip, _r2_:vid, _r3_:tuples}))).groupby
                   (\_b1_ -> 
                     bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip)
                   ((\_b2_ ->
                   bind _b2_ as {_r1_:acc_vid, _r2_:acc_tuples} in (\_b5_ -> 
                     bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                     {_r1_:acc_vid.combine
                      ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                      _r2_:acc_tuples.combine tuples})))
                   {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                    _r2_:empty {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int,
                    _r4_:int } @ { Set }}).iterate
                  (\_b1_ -> 
                    bind _b1_ as {_r1_:ip, _r2_:_b3_} in 
                    bind _b3_ as {_r1_:vid_send_list, _r2_:tuple} in 
                    (insert_T_rcv_corrective_s2_m_ATIMESD_mT1_mR1, ip)<- {
                      _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple})
              else ())

trigger ATIMESD_mS1_send_correctives : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:corrective_vid, _r2_:delta_tuples} in 
    let corrective_list =
      filter_corrective_list
        {_r1_:corrective_vid, _r2_:{| _r1_:int, _r2_:int | {_r1_:3, _r2_:11},
         {_r1_:3, _r2_:10}, {_r1_:2, _r2_:7}, {_r1_:2, _r2_:6}|} @ { Set }} in
    corrective_list.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:stmt_id, _r2_:vid_list} in 
        if stmt_id == 11
        then
          ((vid_list.ext
              (\vid -> 
                bind log_get_bound_delete_S vid as {_r1_:vid, _r2_:S_B,
                                                    _r3_:S_C} in 
                (shuffle_ATIMESD_mS1_ATIMESD_mT1
                   {_r1_:Some S_C, _r2_:delta_tuples, _r3_:false}).map
                  (\_b1_ -> 
                    bind _b1_ as {_r1_:ip, _r2_:tuples} in 
                    {_r1_:ip, _r2_:vid, _r3_:tuples}))).groupby
             (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip)
             ((\_b2_ ->
             bind _b2_ as {_r1_:acc_vid, _r2_:acc_tuples} in (\_b5_ -> 
               bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
               {_r1_:acc_vid.combine
                ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                _r2_:acc_tuples.combine tuples})))
             {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
              _r2_:empty {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
              } @ { Set }}).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:ip, _r2_:_b3_} in 
              bind _b3_ as {_r1_:vid_send_list, _r2_:tuple} in 
              (delete_S_rcv_corrective_s11_m_ATIMESD_mS1, ip)<- {_r1_:corrective_vid,
                                                                 _r2_:vid_send_list,
                                                                 _r3_:tuple})
        else
          if stmt_id == 10
          then
            ((vid_list.ext
                (\vid -> 
                  bind log_get_bound_delete_S vid as {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C} in 
                  (shuffle_ATIMESD_mS1_ATIMESD
                     {_r1_:(), _r2_:delta_tuples, _r3_:false}).map
                    (\_b1_ -> 
                      bind _b1_ as {_r1_:ip, _r2_:tuples} in 
                      {_r1_:ip, _r2_:vid, _r3_:tuples}))).groupby
               (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip)
               ((\_b2_ ->
               bind _b2_ as {_r1_:acc_vid, _r2_:acc_tuples} in (\_b5_ -> 
                 bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                 {_r1_:acc_vid.combine
                  ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                  _r2_:acc_tuples.combine tuples})))
               {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                _r2_:empty {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                } @ { Set }}).iterate
              (\_b1_ -> 
                bind _b1_ as {_r1_:ip, _r2_:_b3_} in 
                bind _b3_ as {_r1_:vid_send_list, _r2_:tuple} in 
                (delete_S_rcv_corrective_s10_m_ATIMESD_mS1, ip)<- {_r1_:corrective_vid,
                                                                   _r2_:vid_send_list,
                                                                   _r3_:tuple})
          else
            if stmt_id == 7
            then
              ((vid_list.ext
                  (\vid -> 
                    bind log_get_bound_insert_S vid as {_r1_:vid, _r2_:S_B,
                                                        _r3_:S_C} in 
                    (shuffle_ATIMESD_mS1_ATIMESD_mT1
                       {_r1_:Some S_C, _r2_:delta_tuples, _r3_:false}).map
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
                        {_r1_:ip, _r2_:vid, _r3_:tuples}))).groupby
                 (\_b1_ -> 
                   bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip)
                 ((\_b2_ ->
                 bind _b2_ as {_r1_:acc_vid, _r2_:acc_tuples} in (\_b5_ -> 
                   bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                   {_r1_:acc_vid.combine
                    ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                    _r2_:acc_tuples.combine tuples})))
                 {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                  _r2_:empty {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                  } @ { Set }}).iterate
                (\_b1_ -> 
                  bind _b1_ as {_r1_:ip, _r2_:_b3_} in 
                  bind _b3_ as {_r1_:vid_send_list, _r2_:tuple} in 
                  (insert_S_rcv_corrective_s7_m_ATIMESD_mS1, ip)<- {_r1_:corrective_vid,
                                                                    _r2_:vid_send_list,
                                                                    _r3_:tuple})
            else
              if stmt_id == 6
              then
                ((vid_list.ext
                    (\vid -> 
                      bind log_get_bound_insert_S vid as {_r1_:vid, _r2_:S_B,
                                                          _r3_:S_C} in 
                      (shuffle_ATIMESD_mS1_ATIMESD
                         {_r1_:(), _r2_:delta_tuples, _r3_:false}).map
                        (\_b1_ -> 
                          bind _b1_ as {_r1_:ip, _r2_:tuples} in 
                          {_r1_:ip, _r2_:vid, _r3_:tuples}))).groupby
                   (\_b1_ -> 
                     bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip)
                   ((\_b2_ ->
                   bind _b2_ as {_r1_:acc_vid, _r2_:acc_tuples} in (\_b5_ -> 
                     bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                     {_r1_:acc_vid.combine
                      ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                      _r2_:acc_tuples.combine tuples})))
                   {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                    _r2_:empty {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                    } @ { Set }}).iterate
                  (\_b1_ -> 
                    bind _b1_ as {_r1_:ip, _r2_:_b3_} in 
                    bind _b3_ as {_r1_:vid_send_list, _r2_:tuple} in 
                    (insert_S_rcv_corrective_s6_m_ATIMESD_mS1, ip)<- {
                      _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple})
              else ())

trigger ATIMESD_mS2_send_correctives : {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:collection {
_r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int } @ { Set }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:corrective_vid, _r2_:delta_tuples} in 
    let corrective_list =
      filter_corrective_list
        {_r1_:corrective_vid, _r2_:{| _r1_:int, _r2_:int | {_r1_:3, _r2_:13},
         {_r1_:3, _r2_:10}, {_r1_:2, _r2_:9}, {_r1_:2, _r2_:6}|} @ { Set }} in
    corrective_list.iterate
      (\_b1_ -> 
        bind _b1_ as {_r1_:stmt_id, _r2_:vid_list} in 
        if stmt_id == 13
        then
          ((vid_list.ext
              (\vid -> 
                bind log_get_bound_delete_S vid as {_r1_:vid, _r2_:S_B,
                                                    _r3_:S_C} in 
                (shuffle_ATIMESD_mS2_ATIMESD_mR1
                   {_r1_:Some S_B, _r2_:delta_tuples, _r3_:false}).map
                  (\_b1_ -> 
                    bind _b1_ as {_r1_:ip, _r2_:tuples} in 
                    {_r1_:ip, _r2_:vid, _r3_:tuples}))).groupby
             (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip)
             ((\_b2_ ->
             bind _b2_ as {_r1_:acc_vid, _r2_:acc_tuples} in (\_b5_ -> 
               bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
               {_r1_:acc_vid.combine
                ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                _r2_:acc_tuples.combine tuples})))
             {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
              _r2_:empty {
              _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
              } @ { Set }}).iterate
            (\_b1_ -> 
              bind _b1_ as {_r1_:ip, _r2_:_b3_} in 
              bind _b3_ as {_r1_:vid_send_list, _r2_:tuple} in 
              (delete_S_rcv_corrective_s13_m_ATIMESD_mS2, ip)<- {_r1_:corrective_vid,
                                                                 _r2_:vid_send_list,
                                                                 _r3_:tuple})
        else
          if stmt_id == 10
          then
            ((vid_list.ext
                (\vid -> 
                  bind log_get_bound_delete_S vid as {_r1_:vid, _r2_:S_B,
                                                      _r3_:S_C} in 
                  (shuffle_ATIMESD_mS2_ATIMESD
                     {_r1_:(), _r2_:delta_tuples, _r3_:false}).map
                    (\_b1_ -> 
                      bind _b1_ as {_r1_:ip, _r2_:tuples} in 
                      {_r1_:ip, _r2_:vid, _r3_:tuples}))).groupby
               (\_b1_ ->  bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip)
               ((\_b2_ ->
               bind _b2_ as {_r1_:acc_vid, _r2_:acc_tuples} in (\_b5_ -> 
                 bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                 {_r1_:acc_vid.combine
                  ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                  _r2_:acc_tuples.combine tuples})))
               {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                _r2_:empty {
                _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                } @ { Set }}).iterate
              (\_b1_ -> 
                bind _b1_ as {_r1_:ip, _r2_:_b3_} in 
                bind _b3_ as {_r1_:vid_send_list, _r2_:tuple} in 
                (delete_S_rcv_corrective_s10_m_ATIMESD_mS2, ip)<- {_r1_:corrective_vid,
                                                                   _r2_:vid_send_list,
                                                                   _r3_:tuple})
          else
            if stmt_id == 9
            then
              ((vid_list.ext
                  (\vid -> 
                    bind log_get_bound_insert_S vid as {_r1_:vid, _r2_:S_B,
                                                        _r3_:S_C} in 
                    (shuffle_ATIMESD_mS2_ATIMESD_mR1
                       {_r1_:Some S_B, _r2_:delta_tuples, _r3_:false}).map
                      (\_b1_ -> 
                        bind _b1_ as {_r1_:ip, _r2_:tuples} in 
                        {_r1_:ip, _r2_:vid, _r3_:tuples}))).groupby
                 (\_b1_ -> 
                   bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip)
                 ((\_b2_ ->
                 bind _b2_ as {_r1_:acc_vid, _r2_:acc_tuples} in (\_b5_ -> 
                   bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                   {_r1_:acc_vid.combine
                    ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                    _r2_:acc_tuples.combine tuples})))
                 {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                  _r2_:empty {
                  _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                  } @ { Set }}).iterate
                (\_b1_ -> 
                  bind _b1_ as {_r1_:ip, _r2_:_b3_} in 
                  bind _b3_ as {_r1_:vid_send_list, _r2_:tuple} in 
                  (insert_S_rcv_corrective_s9_m_ATIMESD_mS2, ip)<- {_r1_:corrective_vid,
                                                                    _r2_:vid_send_list,
                                                                    _r3_:tuple})
            else
              if stmt_id == 6
              then
                ((vid_list.ext
                    (\vid -> 
                      bind log_get_bound_insert_S vid as {_r1_:vid, _r2_:S_B,
                                                          _r3_:S_C} in 
                      (shuffle_ATIMESD_mS2_ATIMESD
                         {_r1_:(), _r2_:delta_tuples, _r3_:false}).map
                        (\_b1_ -> 
                          bind _b1_ as {_r1_:ip, _r2_:tuples} in 
                          {_r1_:ip, _r2_:vid, _r3_:tuples}))).groupby
                   (\_b1_ -> 
                     bind _b1_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in ip)
                   ((\_b2_ ->
                   bind _b2_ as {_r1_:acc_vid, _r2_:acc_tuples} in (\_b5_ -> 
                     bind _b5_ as {_r1_:ip, _r2_:vid, _r3_:tuples} in 
                     {_r1_:acc_vid.combine
                      ({| _r1_:int, _r2_:int, _r3_:int | vid|} @ { Seq }),
                      _r2_:acc_tuples.combine tuples})))
                   {_r1_:empty { _r1_:int, _r2_:int, _r3_:int } @ { Seq },
                    _r2_:empty {
                    _r1_:{ _r1_:int, _r2_:int, _r3_:int }, _r2_:int, _r3_:int
                    } @ { Set }}).iterate
                  (\_b1_ -> 
                    bind _b1_ as {_r1_:ip, _r2_:_b3_} in 
                    bind _b3_ as {_r1_:vid_send_list, _r2_:tuple} in 
                    (insert_S_rcv_corrective_s6_m_ATIMESD_mS2, ip)<- {
                      _r1_:corrective_vid, _r2_:vid_send_list, _r3_:tuple})
              else ())

trigger demux_T : {
_r1_:int, _r2_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:T_C, _r2_:T_D} in (insert_T, me)<- {_r1_:T_C, _r2_:T_D}

trigger demux_S : {
_r1_:int, _r2_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:S_B, _r2_:S_C} in (insert_S, me)<- {_r1_:S_B, _r2_:S_C}

trigger demux_R : {
_r1_:int, _r2_:int
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:R_A, _r2_:R_B} in (insert_R, me)<- {_r1_:R_A, _r2_:R_B}

trigger node_dummy : int
=
  \x ->  ()

trigger switch_main : {
_r1_:string, _r2_:option { _r1_:int, _r2_:int }, _r3_:option {
_r1_:int, _r2_:int }, _r4_:option { _r1_:int, _r2_:int }
}
=
  \_b1_ -> 
    bind _b1_ as {_r1_:trigger_id, _r2_:insert_T_args, _r3_:insert_S_args,
                  _r4_:insert_R_args} in 
    if trigger_id == "insert_R"
    then
      (insert_R, me)<- let insert_R_args_unwrap = case insert_R_args of
        { Some x -> x }
        { None -> error () } in
        insert_R_args_unwrap
    else
      if trigger_id == "insert_S"
      then
        (insert_S, me)<- let insert_S_args_unwrap = case insert_S_args of
          { Some x -> x }
          { None -> error () } in
          insert_S_args_unwrap
      else
        if trigger_id == "insert_T"
        then
          (insert_T, me)<- let insert_T_args_unwrap = case insert_T_args of
            { Some x -> x }
            { None -> error () } in
            insert_T_args_unwrap
        else ()

source s1 : {
_r1_:string, _r2_:option { _r1_:int, _r2_:int }, _r3_:option {
_r1_:int, _r2_:int }, _r4_:option { _r1_:int, _r2_:int }
} = file "default.k3" k3
feed s1 |> switch_main

