annotation Collection {
  provides lifted peek    : immut (() -> option immut content);
  provides lifted slice   : immut (int -> self);

  provides lifted insert  : immut (content -> ());
  provides lifted delete  : immut (content -> ());
  provides lifted update  : immut (content -> content -> ());

  provides lifted iterate : immut ((content -> ()) -> ());  

  provides lifted combine : immut (self -> self);
  provides lifted split   : immut (self -> (immut self, immut self));

  provides lifted map     : immut ((content -> int) -> collection { elem : immut int } @ {Collection});

  provides lifted fold    : immut ((int -> content -> int) -> int -> int);

  provides lifted groupBy : immut ((content -> int) -> (int -> content -> int) -> int
                                    -> collection { key : immut int; value : immut int } @ {Collection});

  provides lifted ext     : immut ((content -> collection { elem : immut int } @ {Collection}) 
                                    -> collection { elem : immut int } @ {Collection});
}


declare myCollection : immut collection { x : immut int } @ { Collection }
declare c1 : immut collection { x : immut int } @ { Collection }
declare c2 : immut collection { x : immut int } @ { Collection }

declare y : mut int = 0

trigger t : int = \x -> (
  myCollection.insert x;
  c1.insert x;
  c2.insert (x + 1);
  myCollection = c1.combine c2;
  y = myCollection.fold (\a -> (\b -> a + b)) 0 
)

source s1 : int = value 5

~~ s1 |> t
