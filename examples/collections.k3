annotation Collection {
  provides lifted add     : immut (int -> collection { x : immut int } @ {Collection});

  provides lifted combine : immut (collection { x : immut int } @ {Collection}
                                   -> collection { x : immut int } @ {Collection});

  provides lifted split   : immut (collection { x : immut int } @ {Collection}
                                   -> (immut collection { x : immut int } @ {Collection},
                                       immut collection { x : immut int } @ {Collection}));

  provides lifted ext     : immut ((int -> collection { x : immut int } @ {Collection})
                                   -> collection { x : immut int } @ {Collection});

  provides lifted fold    : immut ((int -> int -> int) -> int -> int);
}

declare myCollection : immut collection { x : immut int } @ { Collection }
declare c1 : immut collection { x : immut int } @ { Collection }
declare c2 : immut collection { x : immut int } @ { Collection }

declare y : mut int = 0

trigger t : int = \x -> 
  (myCollection = myCollection.add x;
   c1 = c1.add x;
   c2 = c2.add (x + 1);
   myCollection = c1.combine c2;
   y = myCollection.fold (\a -> (\b -> a + b)) 0)

source s1 : int = value 5

~~ s1 |> t
