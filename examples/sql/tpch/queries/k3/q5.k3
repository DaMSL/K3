include "Distributed/Transformers.k3"
include "tpch/schema.k3"
include "tpch/benchmark.k3"
include "tpch/loader.k3"

/**********************
* SQL query
***********************
select
        n_name,
        sum(l_extendedprice * (1 - l_discount)) as revenue
from
        customer,
        orders,
        lineitem,
        supplier,
        nation,
        region
where
        c_custkey = o_custkey
        and l_orderkey = o_orderkey
        and l_suppkey = s_suppkey
        and c_nationkey = s_nationkey
        and s_nationkey = n_nationkey
        and n_regionkey = r_regionkey
        and r_name = 'ASIA'
        and o_orderdate >= date '1994-01-01'
        and o_orderdate < date '1995-01-01'
group by
        n_name
order by
        revenue desc
****************************
* Join graph:
*   l -- o -- c
*     \- s -/
*        |
*        n
*        |
*        r
*
****************************
* Join order:
*   l-o-c-s-n-r
****************************/

declare master : address

declare lineitem : lineitem_bag
declare orders   : orders_bag
declare customer : customer_bag
declare supplier : supplier_bag
declare nation   : nation_bag
declare region   : region_bag

// Final result.
typedef q5_r_by_n_r     = {key : string, value: real}
typedef q5_r_by_n_map   = collection q5_r_by_n_r @Map

declare q5_result : q5_r_by_n_map

// Intermediates for Q5 plans.
typedef li_se_r       = {l_suppkey : int, l_epd : real}
typedef li_se_bag     = collection li_se_r @Collection
typedef li_se_by_o_r  = {key : int, value : {l_suppkey : int, l_epd : real} }
typedef li_cse_by_o_r = {key : int, value : li_se_bag}
typedef li_ocse_map   = collection li_cse_by_o_r @Map

typedef lior_cse_by_ck_r   = {key: int, value: li_se_bag}
typedef lior_cse_by_ck_map = collection lior_cse_by_ck_r @Map

typedef loc_epd_by_sn_r   = {key : {s_suppkey : int, s_nationkey : int}, value : real}
typedef loc_epd_by_sn_map = collection loc_epd_by_sn_r @Map

typedef locs_epd_by_nk_r   = {key : int, value: real}
typedef locs_epd_by_nk_map = collection locs_epd_by_nk_r @Map

typedef locsn_nepd_by_rk_r   = {key : int, value: collection {key: string, value: real} @Map}
typedef locsn_nepd_by_rk_map = collection locsn_nepd_by_rk_r @Map

typedef locsnr_epd_by_n_r   = {key : string, value: real}
typedef locsnr_epd_by_n_map = collection locsnr_epd_by_n_r @Map


// Plan intermediates.
declare lior_build     : li_ocse_map
declare lior_cse_by_ck : lior_cse_by_ck_map

declare loc_build     : lior_cse_by_ck_map
declare loc_epd_by_sn : loc_epd_by_sn_map

declare locs_build     : loc_epd_by_sn_map
declare locs_epd_by_nk : locs_epd_by_nk_map

declare locsn_build      : locs_epd_by_nk_map
declare locsn_nepd_by_rk : locsn_nepd_by_rk_map

declare locsnr_build     : locsn_nepd_by_rk_map
declare locsnr_epd_by_n  : locsnr_epd_by_n_map

// Plan helpers.
declare merge_lior_build : li_cse_by_o_r -> li_cse_by_o_r -> li_cse_by_o_r
  = \a -> \b -> {key: a.key, value: a.value.fold (\acc -> \r -> ((acc.insert r); acc)) b.value}

declare merge_lior_cse_by_ck_r : lior_cse_by_ck_r -> lior_cse_by_ck_r -> lior_cse_by_ck_r
  = \a -> \b -> {key: a.key, value: a.value.fold (\acc -> \r -> ((acc.insert r); acc)) b.value}

declare merge_epd_by_sn_r : loc_epd_by_sn_r -> loc_epd_by_sn_r -> loc_epd_by_sn_r
  = \a -> \b -> {key: a.key, value: a.value + b.value}

declare merge_epd_by_nk_r : locs_epd_by_nk_r -> locs_epd_by_nk_r -> locs_epd_by_nk_r
  = \a -> \b -> {key : a.key, value: a.value + b.value}

declare merge_nepd_r : locsnr_epd_by_n_r -> locsnr_epd_by_n_r -> locsnr_epd_by_n_r
  = \x -> \y -> {key: x.key, value: x.value + y.value}

declare merge_nepd_by_rk_r : locsn_nepd_by_rk_r -> locsn_nepd_by_rk_r -> locsn_nepd_by_rk_r
  = \a -> \b -> {key : a.key, value: a.value.fold (\acc -> \r -> ((acc.insert_with r merge_nepd_r); acc)) b.value}

trigger q5_lo_start : () = \_ -> (
  () @DistributedHashJoin
        ( lbl       = [# lo ]
        , lhs_query = [$
            lineitem.groupBy (\li -> li.l_orderkey)
                             (\acc -> \li ->
                               ((acc.insert { l_suppkey : li.l_suppkey
                                            , l_epd     : li.l_extendedprice * (1 - li.l_discount)}) ;
                                 acc))
                             empty {l_suppkey : int, l_epd : real} @Collection ]

        , rhs_query = [$ (orders.filter  (\o ->     o.o_orderdate >= "1994-01-01"
                                                and o.o_orderdate >= "1995-01-01" ))
                                .groupBy (\o -> o.o_orderkey)
                                         (\_ -> \o -> o.o_custkey)
                                         0 ]

        , lhs_build_merge = [$ (\li -> lior_build.insert_with li merge_lior_build) ]

        , rhs_probe_merge = [$
            (\o ->
              case lior_build.lookup
                     { key: o.key
                     , value: empty {l_suppkey : int, l_epd : real} @Collection }
              of
              { Some li -> lior_cse_by_ck.insert_with { key: o.value, value: li.value }
                                                      merge_lior_cse_by_ck_r
              }
              { None   -> ()  }
              )]

        , peer_next       = [$ print "LI-OR join finished orders probe."]
        , next            = [$ print "LI-OR join all nodes finished." ;
                               (q5_loc_start, master) <- () ]
        , coordinator     = [$ master]
        , nodes           = [$ peers ]
        , lhs_build_ty    = [: collection
                                 { key : int
                                 , value : collection {l_suppkey : int, l_epd : real} @Collection
                                 } @Collection
                            ]
        , rhs_probe_ty    = [: collection {key : int, value : int } @Collection ]
        )
)

trigger q5_loc_start : () = \_ -> (
  () @DistributedHashJoin
        ( lbl       = [# loc ]
        , lhs_query = [$ lior_cse_by_ck ]
        , rhs_query = [$ customer.fold
                            (\acc -> \c -> ((acc.insert {key: c.c_custkey, value: c.c_nationkey}); acc))
                            empty {key: int, value: int} @Collection
                      ]
        , lhs_build_merge = [$ (\li -> loc_build.insert_with li merge_lior_cse_by_ck_r) ]
        , rhs_probe_merge = [$
            (\c ->
              case loc_build.lookup
                     { key: c.key
                     , value: empty {l_suppkey : int, l_epd : real} @Collection }
              of
              { Some lo -> ((lo.value.groupBy (\lo_r -> {s_suppkey : lo_r.l_suppkey, s_nationkey: c.value})
                                              (\acc -> \lo_r -> acc + lo_r.l_epd )
                                              0.0)
                                     .iterate (\kv -> loc_epd_by_sn.insert_with kv merge_epd_by_sn_r))
              }
              { None   -> ()  }
              )]

        , peer_next       = [$ print "LI-OR-CS join finished customer probe." ]
        , next            = [$ print "LI-OR-CS join all nodes finished." ;
                               (q5_locs_start, master) <- () ]
        , coordinator     = [$ master]
        , nodes           = [$ peers ]
        , lhs_build_ty    = [: collection
                                { key   : int
                                , value : collection {l_suppkey : int, l_epd : real} @Collection
                                } @Collection ]
        , rhs_probe_ty    = [: collection {key : int, value : int } @Collection ]
        )
)

trigger q5_locs_start : () = \_ -> (
  () @DistributedHashJoin
        ( lbl       = [# locs ]
        , lhs_query = [$ loc_epd_by_sn ]
        , rhs_query = [$ supplier.fold
                           (\acc -> \s -> ((acc.insert {key: s.s_suppkey, value : s.s_nationkey}); acc))
                           empty {key: int, value : int} @Collection ]
        , lhs_build_merge = [$ (\epd_by_sn -> locs_build.insert_with epd_by_sn merge_epd_by_sn_r) ]
        , rhs_probe_merge = [$
            (\s ->
              case locs_build.lookup {key: {s_suppkey: s.key, s_nationkey: s.value}, value: 0.0} of
              { Some loc -> locs_epd_by_nk.insert_with
                              {key: loc.key.s_nationkey, value: loc.value} merge_epd_by_nk_r
              }
              { None   -> ()  }
              )]

        , peer_next       = [$ print "LI-OR-CS-SUP join finished supplier probe." ]
        , next            = [$ print "LI-OR-CS-SUP join all nodes finished." ;
                               (q5_locsn_start, master) <- () ]
        , coordinator     = [$ master]
        , nodes           = [$ peers ]
        , lhs_build_ty    = [: collection {key : {s_suppkey : int, s_nationkey : int}, value : real} @Collection ]
        , rhs_probe_ty    = [: collection {key : int, value : int } @Collection ]
        )
)

trigger q5_locsn_start : () = \_ -> (
  () @DistributedHashJoin
        ( lbl       = [# locsn ]
        , lhs_query = [$ locs_epd_by_nk ]

        , rhs_query = [$ nation.fold
                           (\acc -> \n ->
                             ((acc.insert { key: n.n_nationkey
                                          , value: {n_regionkey: n.n_regionkey, n_name: n.n_name}});
                               acc))
                           empty {key: int, value: {n_regionkey: int, n_name: string}} @Collection ]

        , lhs_build_merge = [$ (\epd_by_nk -> locsn_build.insert_with epd_by_nk merge_epd_by_nk_r) ]
        , rhs_probe_merge = [$
            (\n ->
              case locsn_build.lookup {key: n.key, value: 0.0} of
              { Some locs -> locsn_nepd_by_rk.insert_with
                               { key: n.value.n_regionkey
                               , value: {| key:string, value:real
                                         | {key: n.value.n_name, value: locs.value}
                                         |} @Map }
                               merge_nepd_by_rk_r
              }
              { None   -> ()  }
              )]

        , peer_next       = [$ print "LI-OR-CS-SUP-NT join finished nation probe." ]
        , next            = [$ print "LI-OR-CS-SUP-NT join all nodes finished." ;
                               (q5_locsnr_start, master) <- () ]
        , coordinator     = [$ master]
        , nodes           = [$ peers ]
        , lhs_build_ty    = [: collection {key : int, value : real} @Collection ]
        , rhs_probe_ty    = [: collection {key : int, value : {n_regionkey: int, n_name: string} } @Collection ]
        )
)

trigger q5_locsnr_start : () = \_ -> (
  () @DistributedHashJoin
        ( lbl       = [# locsnr ]
        , lhs_query = [$ locsn_nepd_by_rk ]
        , rhs_query = [$ (region.filter  (\r -> r.r_name == "ASIA"))
                                .fold    (\acc -> \r -> ((acc.insert {key : r.r_regionkey, value: ()}); acc))
                                         empty {key: int, value: ()} @Collection ]
        , lhs_build_merge = [$ (\nepd_by_rk -> locsnr_build.insert_with nepd_by_rk merge_nepd_by_rk_r) ]
        , rhs_probe_merge = [$
            (\r ->
              case locsnr_build.lookup
                      {key: r.key, value: empty {key: string, value: real} @Map}
              of
              { Some locsn -> locsn.value.iterate (\kv -> locsnr_epd_by_n.insert_with kv merge_nepd_r) }
              { None       -> ()  }
              )]

        , peer_next       = [$ print "LI-OR-CS-SUP-NT-RG join finished region probe." ;
                               (q5_result_aggregate, master) <- locsnr_epd_by_n ;
                               ((() @:Result) @TPCHBenchmarkWithoutMaster) ]
        , next            = [$ print "LI-OR-CS-SUP-NT-RG join all nodes finished." ]
        , coordinator     = [$ master]
        , nodes           = [$ peers ]
        , lhs_build_ty    = [: collection {key : int, value : collection {key:string, value:real} @Map } @Collection ]
        , rhs_probe_ty    = [: collection {key : int, value : () } @Collection ]
        )
)

trigger q5_result_aggregate : q5_r_by_n_map = \vals -> (
  vals.iterate (\kv -> q5_result.insert_with kv merge_nepd_r)
)

trigger start : () = \_ -> (() @:Start) @TPCHBenchmarkWithoutMaster(
  nodes              = [$ peers],
  loadExpr           = [$ ( lineitemFiles.iterate (\e -> lineitemLoaderP e.path lineitem);
                            ordersFiles.iterate   (\e -> ordersLoaderP   e.path orders);
                            customerFiles.iterate (\e -> customerLoaderP e.path customer);
                            supplierFiles.iterate (\e -> supplierLoaderP e.path supplier);
                            nationFiles.iterate   (\e -> nationLoaderP   e.path nation);
                            regionFiles.iterate   (\e -> regionLoaderP   e.path region)
                          ) ],
  preLoadExpr        = [$ ()],
  preReadyExpr       = [$ ()],
  onReadyExpr        = [$ (q5_lo_start, me) <- ()],
  finishArgT         = [: ()],
  preTestFinishExpr  = [$ (\_ -> ())],
  preFinishExpr      = [$ (print (concat "Q5 num results:" (itos (q5_result.size()))))],
  preShutdownExpr    = [$ ()]
)

source rows : () = value ()
feed rows |> start
