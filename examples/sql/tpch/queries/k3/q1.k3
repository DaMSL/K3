include "Annotation/Collection.k3"
include "Annotation/Seq.k3"
include "Core/Profile.k3"
include "Core/Barrier.k3"
include "tpch/benchmark.k3"
include "tpch/schema.k3"
include "tpch/loader.k3"

typedef q1_agg = { sum_qty: real, sum_base_price: real, sum_disc_price: real, sum_charge: real
                 , avg_qty_sum : real, avg_price_sum : real, avg_disc_sum : real, count_order : int }

typedef q1_result_r = { l_returnflag   : string
                      , l_linestatus   : string
                      , sum_qty        : real
                      , sum_base_price : real
                      , sum_disc_price : real
                      , sum_charge     : real
                      , avg_qty        : real
                      , avg_price      : real
                      , avg_disc       : real
                      , count_order    : int }

typedef q1_result = collection {elem : q1_result_r} @Seq

// TODO
declare strcomp : string -> string -> int = \x -> \y -> 0
declare ignore : forall a . a -> ()

declare lineitem : lineitem_seq
declare init_agg : q1_agg

declare accum_agg : q1_agg -> lineitem_r -> q1_agg = \acc -> \r ->
  { sum_qty        : acc.sum_qty        + r.l_quantity
  , sum_base_price : acc.sum_base_price + r.l_extendedprice
  , sum_disc_price : acc.sum_disc_price + (r.l_extendedprice * (1 - r.l_discount))
  , sum_charge     : acc.sum_charge     + (r.l_extendedprice * (1 - r.l_discount) * (1 + r.l_tax))
  , avg_qty_sum    : acc.avg_qty_sum    + r.l_quantity
  , avg_price_sum  : acc.avg_price_sum  + r.l_extendedprice
  , avg_disc_sum   : acc.avg_disc_sum   + r.l_discount
  , count_order    : acc.count_order    + 1
  }


declare merge_agg : {key: (string, string), value: q1_agg} -> {key: (string, string), value: q1_agg} -> {key: (string, string), value: q1_agg} = \a -> \b -> (
  { key: a.key
  , value:
      { sum_qty        : a.value.sum_qty        + b.value.sum_qty
      , sum_base_price : a.value.sum_base_price + b.value.sum_base_price
      , sum_disc_price : a.value.sum_disc_price + b.value.sum_disc_price
      , sum_charge     : a.value.sum_charge     + b.value.sum_charge
      , avg_qty_sum    : a.value.avg_qty_sum    + b.value.avg_qty_sum
      , avg_price_sum  : a.value.avg_price_sum  + b.value.avg_price_sum
      , avg_disc_sum   : a.value.avg_disc_sum   + b.value.avg_disc_sum
      , count_order    : a.value.count_order    + b.value.count_order
      }
  }
)

declare finalize_agg : {key: (string, string), value: q1_agg} -> q1_result_r = \r ->
  bind r.key as (retflag, linestat) in
  { l_returnflag   : retflag
  , l_linestatus   : linestat
  , sum_qty        : r.value.sum_qty
  , sum_base_price : r.value.sum_base_price
  , sum_disc_price : r.value.sum_disc_price
  , sum_charge     : r.value.sum_charge
  , avg_qty        : r.value.avg_qty_sum   / r.value.count_order
  , avg_price      : r.value.avg_price_sum / r.value.count_order
  , avg_disc       : r.value.avg_disc_sum  / r.value.count_order
  , count_order    : r.value.count_order }




declare order_agg : {elem : q1_result_r} -> {elem : q1_result_r} -> int =
  \a -> \b -> let strdiff = strcomp a.elem.l_returnflag b.elem.l_returnflag
              in if strdiff <> 0 then strdiff
                 else strcomp a.elem.l_linestatus b.elem.l_linestatus

trigger q1_local : () = \_ -> (
  ignore
    (((let a = lineitem.filter (\r -> (strcomp r.l_shipdate "1998-12-01") <= 0) in
    let b = a.groupBy (\r -> (r.l_returnflag, r.l_linestatus)) accum_agg init_agg in
    let c = b.map finalize_agg in
    c.sort order_agg

      ) @Profile(lbl=[# worker], tag=[$ "Worker time"])
      ) @:Result) @TPCHBenchmark
)

declare global_result : q1_result

trigger start : () = \_ -> (() @:Start) @TPCHBenchmark(
  queryTrigger       = [$ q1_local],
  loadExpr           = [$ dataFiles.iterate (\e -> lineitemLoader e.path lineitem)],
  preLoadExpr        = [$ ()],
  preReadyExpr       = [$ ()],
  finishArgT         = [: collection {elem : q1_result_r} @Seq],
  preTestFinishExpr  = [$ (\vals -> vals.iterate (\e -> global_result.insert e))],
  preFinishExpr      = [$ print (concat "Num results: " (itos (global_result.size ())))],
  preShutdownExpr    = [$ ()]
)

source rows : () = value ()
feed rows |> start
