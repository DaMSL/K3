include "Annotation/Collection.k3"
include "Annotation/Seq.k3"
include "Core/Profile.k3"
include "Core/Barrier.k3"
include "tpch/benchmark.k3"
include "tpch/schema.k3"
include "tpch/loader.k3"
include "Transformers.k3"

typedef q1_agg = { sum_qty: real, sum_base_price: real, sum_disc_price: real, sum_charge: real
                 , avg_qty_sum : real, avg_price_sum : real, avg_disc_sum : real, count_order : int }

typedef q1_result_r = { l_returnflag   : string
                      , l_linestatus   : string
                      , sum_qty        : real
                      , sum_base_price : real
                      , sum_disc_price : real
                      , sum_charge     : real
                      , avg_qty        : real
                      , avg_price      : real
                      , avg_disc       : real
                      , count_order    : int }

typedef q1_result = collection q1_result_r @Collection

declare lineitem    : lineitem_bag
declare init_agg    : q1_agg
declare peer_result : mut q1_result

// TODO
declare strcomp : string -> string -> int = \x -> \y -> 0
declare ignore : forall a . a -> ()

declare accum_agg : q1_agg -> lineitem_r -> q1_agg = \acc -> \r ->
  { sum_qty        : acc.sum_qty        + r.l_quantity
  , sum_base_price : acc.sum_base_price + r.l_extendedprice
  , sum_disc_price : acc.sum_disc_price + (r.l_extendedprice * (1 - r.l_discount))
  , sum_charge     : acc.sum_charge     + (r.l_extendedprice * (1 - r.l_discount) * (1 + r.l_tax))
  , avg_qty_sum    : acc.avg_qty_sum    + r.l_quantity
  , avg_price_sum  : acc.avg_price_sum  + r.l_extendedprice
  , avg_disc_sum   : acc.avg_disc_sum   + r.l_discount
  , count_order    : acc.count_order    + 1
  }

declare merge_agg : q1_agg -> q1_agg -> q1_agg= \a -> \b -> (
  { sum_qty        : a.sum_qty        + b.sum_qty
  , sum_base_price : a.sum_base_price + b.sum_base_price
  , sum_disc_price : a.sum_disc_price + b.sum_disc_price
  , sum_charge     : a.sum_charge     + b.sum_charge
  , avg_qty_sum    : a.avg_qty_sum    + b.avg_qty_sum
  , avg_price_sum  : a.avg_price_sum  + b.avg_price_sum
  , avg_disc_sum   : a.avg_disc_sum   + b.avg_disc_sum
  , count_order    : a.count_order    + b.count_order
  }
)

declare finalize_agg : {key: (string, string), value: q1_agg} -> q1_result_r = \r ->
  bind r.key as (retflag, linestat) in
  { l_returnflag   : retflag
  , l_linestatus   : linestat
  , sum_qty        : r.value.sum_qty
  , sum_base_price : r.value.sum_base_price
  , sum_disc_price : r.value.sum_disc_price
  , sum_charge     : r.value.sum_charge
  , avg_qty        : r.value.avg_qty_sum   / r.value.count_order
  , avg_price      : r.value.avg_price_sum / r.value.count_order
  , avg_disc       : r.value.avg_disc_sum  / r.value.count_order
  , count_order    : r.value.count_order }


declare order_agg : {elem : q1_result_r} -> {elem : q1_result_r} -> int =
  \a -> \b -> let strdiff = strcomp a.elem.l_returnflag b.elem.l_returnflag
              in if strdiff <> 0 then strdiff
                 else strcomp a.elem.l_linestatus b.elem.l_linestatus

trigger t : () = \_ -> (
  (ignore
    ((lineitem.filter  (\r -> (strcomp r.l_shipdate "1998-12-01") <= 0))
              .groupBy (\r -> (r.l_returnflag, r.l_linestatus))
                       accum_agg
                       init_agg)
  ) @DistributedGroupBy(
      lbl         = [# groupby],
      peer_next   = [$ (\x -> ((x.iterate (\kv -> peer_result.insert (finalize_agg kv)));
                               ((() @:Result) @TPCHBenchmark))) ],
      next        = [$ ()],
      merge       = [$ merge_agg],
      coordinator = [$ master],
      nodes       = [$ peers] )
)

trigger q1_local : () = \_ -> ()

trigger start : () = \_ -> (
  (() @:Start) @TPCHBenchmark(
    queryTrigger       = [$ q1_local],
    loadExpr           = [$ dataFiles.iterate (\e -> lineitemLoader e.path lineitem)],
    preLoadExpr        = [$ ()],
    preReadyExpr       = [$ ()],
    finishArgT         = [: ()],
    preTestFinishExpr  = [$ (\_ -> ())],
    preFinishExpr      = [$ ()],
    preShutdownExpr    = [$ ()]
  )
)

source rows : () = value ()
feed rows |> start
