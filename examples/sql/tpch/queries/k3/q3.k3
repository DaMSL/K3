include "Distributed/Transformers.k3"
include "tpch/schema.k3"
include "tpch/benchmark.k3"
include "tpch/loader.k3"

/**********************
* SQL query
***********************
select top 10
        l_orderkey,
        sum(l_extendedprice * (1 - l_discount)) as revenue,
        o_orderdate,
        o_shippriority
from
        customer,
        orders,
        lineitem
where
        c_mktsegment = 'BUILDING'
        and c_custkey = o_custkey
        and l_orderkey = o_orderkey
        and o_orderdate < date '1995-03-15'
        and l_shipdate > date '1995-03-15'
group by
        l_orderkey,
        o_orderdate,
        o_shippriority
order by
        revenue desc,
        o_orderdate
****************************/


declare lineitem : lineitem_bag
declare customer : customer_bag
declare orders   : orders_bag

// Final result.
typedef lior_epd_by_ods_r     = {key : {ok: int, od: string, sp: int}, value: real}
typedef lior_epd_by_ods_map   = collection lior_epd_by_ods_r @Map

declare q3_peer_result : lior_epd_by_ods_map

// Intermediates for Q3 plans.
typedef li_epd_by_ok_r  = {key: int , value: real }  // l_orderkey => l_extendedprice * (1 - l_discount)

typedef lineitem_epd_by_orderkey_bag = collection li_epd_by_ok_r @Collection
typedef lineitem_epd_by_orderkey_map = collection li_epd_by_ok_r @Map

typedef lior_epdods_by_ck_r   = {key: int, value : lior_epd_by_ods_map }
typedef lior_epdods_by_ck_map = collection lior_epdods_by_ck_r @Map

typedef cs_ck_bag = collection {elem: {c_custkey : int}} @Collection

// Plan intermediates.
declare li_epd_by_ok_map : lineitem_epd_by_orderkey_map
declare lior_epdods_map  : lior_epdods_by_ck_map

// Needed only for pipelining
//typedef or_cos_by_ok_r  = {key: int , value: {o_custkey : int, o_orderdate : string, o_shippriority : int} }
//typedef orders_cos_by_orderkey_bag   = collection or_cos_by_ok_r @Collection
//typedef orders_cos_by_orderkey_map   = collection or_cos_by_ok_r @Map
//declare or_cos_by_ok_map : orders_cos_by_orderkey_map

declare merge_li_epd_by_ok : li_epd_by_ok_r -> li_epd_by_ok_r -> li_epd_by_ok_r =
  \a -> \b -> {key : a.key, value : a.value + b.value}

declare merge_lior_epd_by_ods : lior_epd_by_ods_r -> lior_epd_by_ods_r -> lior_epd_by_ods_r =
  \a -> \b -> {key : a.key, value : a.value + b.value}

declare merge_lior_r : lior_epdods_by_ck_r -> lior_epdods_by_ck_r -> lior_epdods_by_ck_r =
  \a -> \b -> {key : a.key, value : a.value.fold (\acc -> \r -> ((acc.insert_with r merge_lior_epd_by_ods); acc)) b.value}

// Distributed plan: dist. hash-join on li-or, broadcast semi-join on lior-cs.
trigger lineitem_orders : () = \_ -> (
  () @DistributedHashJoin
        ( lbl       = [# lo ]
        , lhs_query = [$ (lineitem.filter  (\l -> l.l_shipdate > "1995-03-15" ))
                                  .groupBy (\l -> l.l_orderkey)
                                           (\acc -> \l -> acc + (l.l_extendedprice * (1 - l.l_discount)))
                                           0.0
                      ]

        , rhs_query = [$
           (orders.filter (\o -> o.o_orderdate < "1995-03-15" ))
                  .fold   (\acc -> \o ->
                             ((acc.insert
                               { key : o.o_orderkey , value : { od : o.o_orderdate
                                                              , ck : o.o_custkey
                                                              , sp : o.o_shippriority} } );
                              acc))
                          empty { key   : int
                                , value : { od : string, ck : int, sp : int }
                                } @Collection
                      ]

        , lhs_build_merge = [$ (\li -> li_epd_by_ok_map.insert_with li merge_li_epd_by_ok) ]

        , rhs_probe_merge = [$
            (\o ->
                case li_epd_by_ok_map.lookup {key: o.key, value: 0.0}
                of
                  { Some li -> lior_epdods_map.insert_with
                                { key: o.value.ck
                                , value: {|key : {ok: int, od: string, sp: int}, value: real
                                          | { key   : {ok: o.key, od: o.value.od, sp: o.value.sp }
                                            , value : li.value }
                                          |} @Map }
                                merge_lior_r
                  }
                  { None   -> ()  }
              ) ]

        , peer_next       = [$ print "LI-OR join finished orders probe." ;
                               (lineitem_orders_customer, me) <- ()
                            ]
        , next            = [$ print "LI-OR join all nodes finished." ]
        , coordinator     = [$ master]
        , nodes           = [$ peers]
        , lhs_build_ty    = [: collection {key : int, value : real } @Collection ]
        , rhs_probe_ty    = [: collection {key : int, value : {od:string, ck:int, sp:int}} @Collection ]
        )
)


trigger lineitem_orders_customer : () = \_ -> (
  // Broadcast customers to all peers with li-or buckets for semi-join.
  let building_customers = (customer.filter  (\c -> c.c_mktsegment == "BUILDING" ))
                                    .map     (\c -> { c_custkey : c.c_custkey })
  in
  peers.iterate (\p -> (loc_probe_rhs, p.addr) <- building_customers)
)

// TODO: sort and limit on q3_peer_result
trigger loc_probe_rhs : cs_ck_bag = \vals -> (
  vals.iterate (\v ->
       case lior_epdods_map.lookup
              {key: v.elem.c_custkey, value: empty lior_epd_by_ods_r @Map}
       of
       { Some lo_r -> lo_r.value.iterate (\kv -> q3_peer_result.insert_with kv merge_lior_epd_by_ods) }
       { None -> () }
    ) ;
  ( (() @:Result) @TPCHBenchmark
  ) @OnCounter(id=[# loc_done], eq=[$ peers.size()])
)

trigger start : () = \_ -> (() @:Start) @TPCHBenchmark(
  nodes              = [$ peers ],
  loadExpr           = [$ ( lineitemFiles.iterate (\e -> lineitemLoader e.path lineitem);
                            ordersFiles.iterate   (\e -> ordersLoader   e.path orders);
                            customerFiles.iterate (\e -> customerLoader e.path customer)
                          ) ],
  preLoadExpr        = [$ ()],
  preReadyExpr       = [$ ()],
  onReadyExpr        = [$ (lineitem_orders, me) <- ()],
  finishArgT         = [: ()],
  preTestFinishExpr  = [$ (\_ -> ())],
  preFinishExpr      = [$ ()],
  preShutdownExpr    = [$ ()]
)

source rows : () = value ()
feed rows |> start
