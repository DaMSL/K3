include "tpch/benchmark.k3"

/**********************
* SQL query
***********************
select cntrycode,
       count(*) as numcust,
       sum(c_acctbal) as totacctbal
from
  (
    select substring(c_phone from 1 for 2) as cntrycode,
           c_acctbal
    from   customer
    where  substring(c_phone from 1 for 2) in
              ('13', '31', '23', '29', '30', '18', '17')
           and c_acctbal > (
             select avg(c_acctbal)
             from   customer
             where  c_acctbal > 0.00
                    and substring(c_phone from 1 for 2) in
                          ('13', '31', '23', '29', '30', '18', '17')
           )
           and not exists (
             select *
             from   orders
             where  o_custkey = c_custkey
           )
  ) as custsale
group by cntrycode
order by cntrycode
****************************
* Plan:
* 1st aggregate subquery ;
* groupby on master
*   join no-match
*     orders
*     filter customer
****************************/

declare master   : address = 127.0.0.1:4000
declare customer : customer_bag
declare orders   : orders_bag

declare c_valid_phone : collection {key : string, value : ()} @Map =
  {| key:string, value:()
   | {key:"13", value:()}, {key:"31", value:()}, {key:"23", value:()},
     {key:"29", value:()}, {key:"30", value:()}, {key:"18", value:()},
     {key:"17", value:()}
   |} @Map

declare c_avg_acctbal : mut real
declare c_acc_acctbal : mut {sum: real, cnt: int}

typedef c_nt_by_cc_r   = {key: string, value: {nc:int, tab:real}}
typedef c_nt_by_cc_map = collection c_nt_by_cc_r @Map

declare o_ck         : collection {key: int, value: ()} @Map
declare c_nt_by_cc   : c_nt_by_cc_map
declare q22_result   : c_nt_by_cc_map
declare results : collection { cntrycode: string, numcust: int, totacctbal: real} @Collection

declare merge_c_nt_by_cc : c_nt_by_cc_r -> c_nt_by_cc_r -> c_nt_by_cc_r
  = \a -> \b -> {key: a.key, value: {nc:a.value.nc + b.value.nc, tab:a.value.tab + b.value.tab}}

trigger customer_subagg : () = \_ -> (
  peers.iterate (\p -> (customer_subagg_local, p.addr) <- ())
)

trigger customer_set_avg_acctbal : real = \avg_acctbal -> (
  c_avg_acctbal = avg_acctbal
)

trigger customer_subagg_local : () = \_ -> (
  let c_acctbal_agg =
    (customer.filter (\c -> case c_valid_phone.lookup {key: (slice_string c.c_phone 0 2), value:()}
                            of {Some x -> c.c_acctbal > 0.0}
                               {None -> false}
                     ))
             .fold   (\acc -> \c -> {sum:acc.sum+c.c_acctbal, cnt:acc.cnt+1})
                     {sum: 0.0, cnt: 0}
  in (customer_subagg_final, master) <- c_acctbal_agg
)

trigger customer_subagg_final : {sum:real, cnt:int} = \partial ->
(
  c_acc_acctbal = { sum: c_acc_acctbal.sum + partial.sum
                  , cnt: c_acc_acctbal.cnt + partial.cnt } ;

  ( c_avg_acctbal = c_acc_acctbal.sum / c_acc_acctbal.cnt ;

    print "Computed customer avg acctbal." ;
    peers.iterate (\p -> (customer_set_avg_acctbal, p.addr) <- c_avg_acctbal) ;

    () @DistributedHashJoin(
          lbl       = [# co ]

        , lhs_query = [$ orders.groupBy (\o -> o.o_custkey)
                                        (\acc -> \_ -> acc)
                                        ()
                      ]

        , rhs_query = [$ (customer.filter  (\c -> case c_valid_phone.lookup
                                                         {key: (slice_string c.c_phone 0 2), value:()}
                                                  of {Some x -> c.c_acctbal > c_avg_acctbal}
                                                     {None -> false}))
                                  .groupBy (\c -> c.c_custkey)
                                           (\acc -> \c -> ((acc.insert { cntrycode : (slice_string c.c_phone 0 2)
                                                                       , c_acctbal : c.c_acctbal })
                                                            ; acc))
                                           empty {cntrycode: string, c_acctbal: real} @Collection
                      ]

        , lhs_build_merge = [$ (\o -> o_ck.insert_with o (\a -> \b -> {key: a.key, value: ()})) ]

        , rhs_probe_merge = [$
            (\c ->
                case o_ck.lookup {key: c.key, value: ()}
                of { Some _ -> () }
                   { None   -> c.value.iterate (\ca ->
                                 c_nt_by_cc.insert_with
                                   {key: ca.cntrycode, value: {nc: 1, tab:ca.c_acctbal}}
                                   merge_c_nt_by_cc)
                   }
              ) ]

        , peer_next       = [$ print "OR-CS join finished customer probe." ;
                               (q22_final_aggregate, master) <- c_nt_by_cc ;
                               ((() @:Result) @TPCHBenchmarkWithoutMaster)
                            ]

        , next            = [$ print "OR-CS join all nodes finished." ]
        , coordinator     = [$ master]
        , nodes           = [$ peers]
        , lhs_build_ty    = [: collection {key : int, value : () } @Collection ]
        , rhs_probe_ty    = [: collection
                                 { key : int
                                 , value : collection {cntrycode:string, c_acctbal : real}
                                              @Collection
                                 } @Collection ]
        )

  ) @OnCounter(id=[# customer_subagg_done], eq=[$ peers.size()], reset=[$ false], profile=[$ false])
)

trigger q22_final_aggregate : c_nt_by_cc_map = \vals -> (
  vals.iterate (\kv -> q22_result.insert_with kv merge_c_nt_by_cc) ;
  ( print "Q22 final aggregation done."
  ) @OnCounter(id=[# q22_aggregate_done], eq=[$ peers.size()], reset=[$ false], profile=[$ false])
)

trigger start : () = \_ -> (() @:Start) @TPCHBenchmarkWithoutMaster(
  nodes              = [$ peers ],
  loadExpr           = [$ ( ordersFiles.iterate   (\e -> ordersLoaderP   e.path orders);
                            customerFiles.iterate (\e -> customerLoaderP e.path customer)
                          ) ],
  preLoadExpr        = [$ ()],
  preReadyExpr       = [$ ()],
  onReadyExpr        = [$ (customer_subagg, me) <- ()],
  finishArgT         = [: ()],
  preTestFinishExpr  = [$ (\_ -> ())],
  preFinishExpr      = [$ ()],
  preShutdownExpr    = [$ (q22_result.iterate (\r -> results.insert {cntrycode: r.key, numcust: r.value.nc, totacctbal: r.value.tab} ))]
)

source rows : () = value ()
feed rows |> start
