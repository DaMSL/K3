include "Core/Builtins.k3"
include "Annotation/Map.k3"
include "Annotation/Set.k3"
include "Annotation/Seq.k3"
declare my_peers : collection { i:address } @ {Collection} =
  peers.fold (\acc -> (\x -> (acc.insert {i:x.addr}; acc))) empty { i:address} @ Collection
declare switch_path : string = "agenda.csv"


declare nd_sent_done : mut bool = false


declare sw_sent_done : mut bool = false


declare ms_rcv_sw_init_ack_cnt : mut int = 0


declare ms_rcv_jobs_ack_cnt : mut int = 0


declare ms_rcv_job_cnt : mut int = 0


declare ms_rcv_node_done_cnt : mut int = 0


declare ms_rcv_switch_done_cnt : mut int = 0


declare g_init_vid : { key:int, value:int } = {key:0, value:0}


declare g_min_vid : { key:int, value:int } = {key:0, value:0}


declare g_max_vid : { key:int, value:int } = {key:get_max_int (),
  value:get_max_int ()}


declare g_start_vid : { key:int, value:int } = {key:0, value:1}


declare job_master : int = 0


declare job_switch : int = 1


declare job_node : int = 2


declare job_timer : int = 3


declare job : mut int = if role == "master" then job_master
  else if role == "switch" then job_switch
    else if role == "node" then job_node
      else if role == "timer" then job_timer
        else error (print "failed to find proper role")


declare jobs : mut collection { key:address, value:int } @ { Map }


declare master_addr : mut address


declare timer_addr : mut address


declare nodes : mut collection {i:address} @ { Collection }


declare switches : mut collection {i:address} @ { Collection }


declare num_peers : mut int = my_peers.size ()


declare num_switches : mut int = 0


declare num_nodes : mut int = 0


declare map_ids : collection { ra:int, rb:string, rc:int } @ { Collection } =
  {| ra:int, rb:string, rc:int | {ra:1, rb:"ATIMESD", rc:1}, {ra:2,
  rb:"ATIMESD_mT1", rc:2}, {ra:3, rb:"ATIMESD_mT1_mR1", rc:3}, {ra:4,
  rb:"ATIMESD_mS1", rc:2}, {ra:5, rb:"ATIMESD_mS2", rc:2}, {ra:6,
  rb:"ATIMESD_mR1", rc:2}|} @ { Collection }


declare nd_stmt_cntrs : collection { key:{ key:{ key:int, value:int },
  value:int }, value:{ key:int, value:collection { key:int, value:int
  } @ { Map } } } @ { Map }


declare nd_log_master : collection { key:{ key:int, value:int }, value:int
  } @ { Set }


declare nd_rcvd_sys_done : mut bool = false


declare sw_init : mut bool = false


declare sw_seen_sentry : mut bool = false


declare sw_trig_buf_idx : collection {i:int} @ { Seq }


declare ms_start_time : mut int = 0


declare ms_end_time : mut int = 0


declare sw_buf_insert_T : collection { key:int, value:int } @ { Seq }


declare sw_buf_delete_T : collection { key:int, value:int } @ { Seq }


declare sw_buf_insert_S : collection { key:int, value:int } @ { Seq }


declare sw_buf_delete_S : collection { key:int, value:int } @ { Seq }


declare sw_buf_insert_R : collection { key:int, value:int } @ { Seq }


declare sw_buf_delete_R : collection { key:int, value:int } @ { Seq }


declare nd_log_insert_T : collection { key:{ key:int, value:int }, value:{
  key:int, value:int } } @ { Map }


declare nd_log_delete_T : collection { key:{ key:int, value:int }, value:{
  key:int, value:int } } @ { Map }


declare nd_log_insert_S : collection { key:{ key:int, value:int }, value:{
  key:int, value:int } } @ { Map }


declare nd_log_delete_S : collection { key:{ key:int, value:int }, value:{
  key:int, value:int } } @ { Map }


declare nd_log_insert_R : collection { key:{ key:int, value:int }, value:{
  key:int, value:int } } @ { Map }


declare nd_log_delete_R : collection { key:{ key:int, value:int }, value:{
  key:int, value:int } } @ { Map }


declare ATIMESD : ind collection { key:{ key:int, value:int }, value:int
  } @ { Set } = ind {| key:{ key:int, value:int }, value:int | {key:g_init_vid,
  value:0}|} @ { Set }


declare ATIMESD_mT1 : ind collection { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int, rc:int
  } @ { Set }


declare ATIMESD_mT1_mR1 : ind collection { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:int } @ { Set }


declare ATIMESD_mS1 : ind collection { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int, rc:int
  } @ { Set }


declare ATIMESD_mS2 : ind collection { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int, rc:int
  } @ { Set }


declare ATIMESD_mR1 : ind collection { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int, rc:int
  } @ { Set }


declare map_ATIMESD_mT1_s0_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mT1_mR1_s2_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int, rd:int } @ { Set }


declare map_ATIMESD_mT1_s3_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mT1_mR1_s5_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int, rd:int } @ { Set }


declare map_ATIMESD_mS1_s6_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mS2_s6_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mS1_s7_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mS2_s9_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mS1_s10_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mS2_s10_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mS1_s11_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mS2_s13_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mR1_s14_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mT1_mR1_s15_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int, rd:int } @ { Set }


declare map_ATIMESD_mR1_s17_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mT1_mR1_s18_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int, rd:int } @ { Set }


declare map_ATIMESD_mS2_s24_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mS2_s26_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mS1_s28_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mS1_s30_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mS2_s32_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mS2_s34_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mS1_s36_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_ATIMESD_mS1_s38_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare tm_timer_list : mut collection { ra:int, rb:int, rc:address } @ { Seq }


declare sw_next_switch_addr : mut address


declare sw_need_vid_cntr : mut int = 0


declare sw_token_vid_list : collection { key:{ key:int, value:int }, value:int
  } @ { Seq }


declare sw_highest_vid : mut { key:int, value:int }


declare node_ring : mut collection { key:address, value:int } @ { Seq }


declare replicas : mut int = 8


declare pmap_input : collection { key:string, value:collection { key:int,
  value:int } @ { Seq } } @ { Seq } = {| key:string, value:collection {
  key:int, value:int } @ { Seq } | {key:"ATIMESD_mT1", value:{| key:int,
  value:int | {key:0, value:16}|} @ { Seq }}, {key:"ATIMESD_mT1_mR1", value:{|
  key:int, value:int | {key:0, value:4}, {key:1, value:4}|} @ { Seq }},
  {key:"ATIMESD_mS1", value:{| key:int, value:int | {key:0,
  value:16}|} @ { Seq }}, {key:"ATIMESD_mS2", value:{| key:int, value:int |
  {key:0, value:16}|} @ { Seq }}, {key:"ATIMESD_mR1", value:{| key:int,
  value:int | {key:0, value:16}|} @ { Seq }}|} @ { Seq }


declare pmap_data : collection { key:int, value:collection { key:int, value:int
  } @ { Seq } } @ { Seq } = pmap_input.fold ((\_accmap -> (\b3 ->
  bind b3 as {key:map_name, value:map_types} in 
  (_accmap.insert {key:(case ((map_ids.filter ((\b1 -> bind b1 as {ra:ra,
   rb:rb, rc:rc} in rb == map_name))).peek ()) of
   {Some x -> x}{None -> error (print "can't find map in map_ids")}).ra,
   value:map_types};
   _accmap)))) empty { key:int, value:collection { key:int, value:int
  } @ { Seq } } @ { Seq }


declare sw_num_ack : mut int = 0


declare sw_num_sent : mut int = 0


declare sw_ack_log : collection { key:{ key:int, value:int }, value:int
  } @ { Map }


declare ms_gc_interval : mut int = 20000


declare ms_gc_vid_map : mut collection { key:address, value:{ key:int,
  value:int } } @ { Map }


declare ms_gc_vid_ctr : mut int = 0


declare ms_num_gc_expected : mut int = my_peers.size ()


declare nd_log_master_write : { key:{ key:int, value:int }, value:int } -> () =
  (\b1 -> bind b1 as {key:vid, value:stmt_id} in nd_log_master.insert {key:vid,
  value:stmt_id})


declare nd_log_write_insert_T : { ra:{ key:int, value:int }, rb:int, rc:int
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:T_C, rc:T_D} in 
  nd_log_insert_T.insert {key:vid, value:{key:T_C, value:T_D}})


declare nd_log_write_delete_T : { ra:{ key:int, value:int }, rb:int, rc:int
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:T_C, rc:T_D} in 
  nd_log_delete_T.insert {key:vid, value:{key:T_C, value:T_D}})


declare nd_log_write_insert_S : { ra:{ key:int, value:int }, rb:int, rc:int
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in 
  nd_log_insert_S.insert {key:vid, value:{key:S_B, value:S_C}})


declare nd_log_write_delete_S : { ra:{ key:int, value:int }, rb:int, rc:int
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in 
  nd_log_delete_S.insert {key:vid, value:{key:S_B, value:S_C}})


declare nd_log_write_insert_R : { ra:{ key:int, value:int }, rb:int, rc:int
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:R_A, rc:R_B} in 
  nd_log_insert_R.insert {key:vid, value:{key:R_A, value:R_B}})


declare nd_log_write_delete_R : { ra:{ key:int, value:int }, rb:int, rc:int
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:R_A, rc:R_B} in 
  nd_log_delete_R.insert {key:vid, value:{key:R_A, value:R_B}})


declare nd_log_get_bound_insert_T : { key:int, value:int } -> { key:int,
  value:int } = (\vid -> (case ((nd_log_insert_T.filter ((\b1 ->
  bind b1 as {key:key, value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_delete_T : { key:int, value:int } -> { key:int,
  value:int } = (\vid -> (case ((nd_log_delete_T.filter ((\b1 ->
  bind b1 as {key:key, value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_insert_S : { key:int, value:int } -> { key:int,
  value:int } = (\vid -> (case ((nd_log_insert_S.filter ((\b1 ->
  bind b1 as {key:key, value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_delete_S : { key:int, value:int } -> { key:int,
  value:int } = (\vid -> (case ((nd_log_delete_S.filter ((\b1 ->
  bind b1 as {key:key, value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_insert_R : { key:int, value:int } -> { key:int,
  value:int } = (\vid -> (case ((nd_log_insert_R.filter ((\b1 ->
  bind b1 as {key:key, value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_delete_R : { key:int, value:int } -> { key:int,
  value:int } = (\vid -> (case ((nd_log_delete_R.filter ((\b1 ->
  bind b1 as {key:key, value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_read_geq : { key:int, value:int } -> collection { key:{ key:int,
  value:int }, value:int } @ { Set } = (\vid2 -> nd_log_master.filter ((\b1 ->
  bind b1 as {key:vid, value:stmt_id} in vid >= vid2)))


declare nd_check_stmt_cntr_index : { ra:{ key:int, value:int }, rb:int, rc:int
  } -> bool = (\b1 -> bind b1 as {ra:vid, rb:stmt_id, rc:add_to_count} in case
  ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
  {key:vid, value:stmt_id}))).peek ()) of
  {Some lookup_value -> let new_count = add_to_count + (lookup_value.value).key
    in
    (nd_stmt_cntrs.update lookup_value {key:{key:vid, value:stmt_id},
     value:{key:new_count, value:(lookup_value.value).value}};
     0 == new_count)}{None ->
                       (nd_stmt_cntrs.insert {key:{key:vid, value:stmt_id},
                        value:{key:add_to_count, value:empty { key:int,
                        value:int } @ { Map }}};
                        false)})


declare nd_complete_stmt_cntr_check : { key:{ key:int, value:int }, value:int
  } -> () = (\b1 -> bind b1 as {key:vid, value:stmt_id} in 
  ((case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
   key == {key:vid, value:stmt_id}))).peek ()) of
   {Some lookup_data -> nd_stmt_cntrs.erase lookup_data}{None -> ()});
   (if nd_rcvd_sys_done
   then if not nd_sent_done and nd_stmt_cntrs.size () == 0
     then ((ms_rcv_node_done, master_addr)<- true;nd_sent_done = true) 
     else () else ())))


declare nd_update_stmt_cntr_corr_map : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:int, re:bool, rf:bool } -> () = (\b1 -> bind b1 as {ra:vid,
  rb:stmt_id, rc:hop, rd:count, re:root, rf:create} in 
  ((if create
   then nd_stmt_cntrs.insert {key:{key:vid, value:stmt_id}, value:{key:0,
     value:empty { key:int, value:int } @ { Map }}} else ());
   (case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
   key == {key:vid, value:stmt_id}))).peek ()) of
   {Some lkup -> nd_stmt_cntrs.update lkup {key:{key:vid, value:stmt_id},
     value:let sc_corr_map = (lkup.value).value in
     ((case ((sc_corr_map.filter ((\b1 -> bind b1 as {key:key, value:value} in 
      key == hop))).peek ()) of
      {Some lkup2 -> sc_corr_map.update lkup2 {key:hop, value:lkup2.value +
        count}}{None -> sc_corr_map.insert {key:hop, value:count}});
      (if root then ()
      else case ((sc_corr_map.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == hop))).peek ()) of
        {Some lkup2 -> let new_corr_cnt = lkup2.value - 1 in
          if new_corr_cnt == 0 then sc_corr_map.erase lkup2
            else sc_corr_map.update lkup2 {key:hop, value:new_corr_cnt}}
        {None -> sc_corr_map.insert {key:hop, value:-1}});
      {key:(lkup.value).key, value:sc_corr_map})}}{None ->
                                                    error
                                                      (print
                                                         "nd_update_stmt_cntr_corr_map: missing stmt_cntrs value")})))


declare nd_filter_corrective_list : { key:{ key:int, value:int },
  value:collection { key:int, value:int } @ { Collection } } -> collection {
  key:int, value:collection { key:int, value:int } @ { Seq }
  } @ { Collection } = (\b1 -> bind b1 as {key:request_vid,
  value:trig_stmt_list} in ((((nd_log_read_geq request_vid).fold ((\acc_conv ->
  (\x -> (acc_conv.insert x;acc_conv)))) empty { key:{ key:int, value:int },
  value:int } @ { Seq }).sort ((\b2 -> (\b5 -> bind b2 as {key:vid1,
  value:stmt1} in bind b5 as {key:vid2, value:stmt2} in if vid1 < vid2 
  then -1 else 1)))).groupBy ((\b1 -> bind b1 as {value:stmt_id} in stmt_id))
  ((\vid_list -> (\b3 -> bind b3 as {key:vid} in 
  (vid_list.insert vid;vid_list)))) empty { key:int, value:int
  } @ { Seq }).fold ((\acc_conv -> (\x -> (acc_conv.insert x;acc_conv))))
  empty { key:int, value:collection { key:int, value:int } @ { Seq }
  } @ { Collection })


declare add_node : address -> () = (\addr -> let rng = range replicas in
  let new_elems =
    rng.fold ((\_accmap -> (\b3 -> bind b3 as {i:i} in 
      (_accmap.insert {key:addr, value:abs (hash ((i * 2683) + hash addr))};
       _accmap)))) empty { key:address, value:int } @ { Seq } in
    (node_ring = node_ring.combine new_elems;
     node_ring = node_ring.sort ((\b2 -> (\b5 -> bind b2 as {key:addr,
     value:hash1} in bind b5 as {key:addr, value:hash2} in if hash1 < hash2
     then -1 else 1)))))


declare get_ring_node : { key:int, value:int } -> address = (\b1 ->
  bind b1 as {key:data, value:max_val} in let scaled =
  truncate (real_of_int (get_max_int ()) * (real_of_int data /
    real_of_int max_val)) in
  let results =
    node_ring.filter ((\b1 -> bind b1 as {key:addr, value:hash} in hash >=
      scaled)) in
    bind
      case (results.peek ()) of
        {Some x -> x}{None -> case (node_ring.peek ()) of
                       {Some x -> x}{None -> error (print "empty node ring")}}
      as {key:addr, value:_} in addr)


declare frontier_int_int : { key:{ key:int, value:int }, value:collection {
  ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } } -> collection { ra:{
  key:int, value:int }, rb:int, rc:int } @ { Collection } = (\b1 ->
  bind b1 as {key:vid, value:input_map} in (input_map.groupBy ((\b1 ->
  bind b1 as {ra:map_vid, rb:map_0, rc:map_val} in map_0)) ((\b2 -> (\b5 ->
  bind b2 as {key:acc, value:max_vid} in bind b5 as {ra:map_vid, rb:map_0,
  rc:map_val} in if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {ra:map_vid, rb:map_0, rc:map_val};{key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| ra:{ key:int, value:int }, rb:int, rc:int | {ra:map_vid,
        rb:map_0, rc:map_val}|} @ { Collection }, value:map_vid}
      else {key:acc, value:max_vid} else {key:acc, value:max_vid})))
  {key:empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection },
  value:g_min_vid}).fold ((\_accext -> (\b3 -> bind b3 as {value:b4} in 
  bind b4 as {key:project} in _accext.combine project))) empty { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Collection })


declare frontier_int_int_int : { key:{ key:int, value:int }, value:collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }
  } -> collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection } = (\b1 -> bind b1 as {key:vid, value:input_map} in 
  (input_map.groupBy ((\b1 -> bind b1 as {ra:map_vid, rb:map_0, rc:map_1,
  rd:map_val} in {key:map_0, value:map_1})) ((\b2 -> (\b5 ->
  bind b2 as {key:acc, value:max_vid} in bind b5 as {ra:map_vid, rb:map_0,
  rc:map_1, rd:map_val} in if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {ra:map_vid, rb:map_0, rc:map_1, rd:map_val};
       {key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| ra:{ key:int, value:int }, rb:int, rc:int, rd:int |
        {ra:map_vid, rb:map_0, rc:map_1, rd:map_val}|} @ { Collection },
        value:map_vid} else {key:acc, value:max_vid}
  else {key:acc, value:max_vid}))) {key:empty { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int } @ { Collection }, value:g_min_vid}).fold
  ((\_accext -> (\b3 -> bind b3 as {value:b4} in bind b4 as {key:project} in 
  _accext.combine project))) empty { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int } @ { Collection })


declare frontier_int : { key:{ key:int, value:int }, value:collection { key:{
  key:int, value:int }, value:int } @ { Set } } -> collection { key:{ key:int,
  value:int }, value:int } @ { Collection } = (\b1 -> bind b1 as {key:vid,
  value:input_map} in (input_map.fold ((\b2 -> (\b5 -> bind b2 as {key:acc,
  value:max_vid} in bind b5 as {key:map_vid, value:map_val} in if map_vid < vid
  then if map_vid == max_vid
    then (acc.insert {key:map_vid, value:map_val};{key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| key:{ key:int, value:int }, value:int | {key:map_vid,
        value:map_val}|} @ { Collection }, value:map_vid}
      else {key:acc, value:max_vid} else {key:acc, value:max_vid})))
  {key:empty { key:{ key:int, value:int }, value:int } @ { Collection },
  value:g_min_vid}).key)


declare nd_add_delta_to_int_int : { ra:ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }, rb:bool, rc:{ key:int, value:int },
  rd:collection { key:int, value:int } @ { Collection } } -> () = (\b1 ->
  bind b1 as {ra:target_map, rb:corrective, rc:min_vid, rd:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {key:map_0, value:map_val} in bind
   target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc} in ra
         == min_vid and rb == map_0))
       else empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.rc in
         target_map_d.update val {ra:min_vid, rb:map_0, rc:update_value}}
       {None -> let lookup_value =
         frontier_int_int {key:min_vid, value:target_map_d.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == map_0))} in
         let update_value =
           map_val + case (lookup_value.peek ()) of
             {Some val -> val.rc}{None -> 0} in
           target_map_d.insert {ra:min_vid, rb:map_0, rc:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {key:map_0_delta,
   value:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc} in rb ==
       map_0_delta))).filter ((\b1 -> bind b1 as {ra:vid, rb:map_0,
       rc:map_val} in vid > min_vid)) in
   filtered.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_val} in bind
     target_map as ind target_map_d in
     target_map_d.update {ra:vid, rb:map_0, rc:map_val} {ra:vid, rb:map_0,
       rc:map_val + map_val_delta}))))))


declare nd_add_delta_to_int_int_int : { ra:ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set }, rb:bool, rc:{ key:int,
  value:int }, rd:collection { ra:int, rb:int, rc:int } @ { Collection }
  } -> () = (\b1 -> bind b1 as {ra:target_map, rb:corrective, rc:min_vid,
  rd:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
   rc:map_val} in bind target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc,
         rd:rd} in (ra == min_vid and rc == map_1) and rb == map_0))
       else empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
         } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.rd in
         target_map_d.update val {ra:min_vid, rb:map_0, rc:map_1,
           rd:update_value}}{None -> let lookup_value =
                              frontier_int_int_int {key:min_vid,
                                value:target_map_d.filter ((\b1 ->
                                bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb
                                == map_0 and rc == map_1))} in
                              let update_value =
                                map_val + case (lookup_value.peek ()) of
                                  {Some val -> val.rd}{None -> 0} in
                                target_map_d.insert {ra:min_vid, rb:map_0,
                                  rc:map_1, rd:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0_delta, rb:map_1_delta,
   rc:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in 
       rb == map_0_delta and rc == map_1_delta))).filter ((\b1 ->
       bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in vid > min_vid))
   in
   filtered.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1,
     rd:map_val} in bind target_map as ind target_map_d in
     target_map_d.update {ra:vid, rb:map_0, rc:map_1, rd:map_val} {ra:vid,
       rb:map_0, rc:map_1, rd:map_val + map_val_delta}))))))


declare nd_add_delta_to_int : { ra:ind collection { key:{ key:int, value:int },
  value:int } @ { Set }, rb:bool, rc:{ key:int, value:int },
  rd:collection {i:int} @ { Collection } } -> () = (\b1 ->
  bind b1 as {ra:target_map, rb:corrective, rc:min_vid, rd:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {i:map_val} in bind target_map as
   ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {key:key, value:value} in 
         key == min_vid))
       else empty { key:{ key:int, value:int }, value:int } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.value in
         target_map_d.update val {key:min_vid, value:update_value}}{None -> let
                                                                    lookup_value
                                                                    =
                                                                    frontier_int
                                                                    {key:min_vid,
                                                                    value:target_map_d}
                                                                    in
                                                                    let
                                                                    update_value
                                                                    =
                                                                    map_val +
                                                                    case
                                                                    (lookup_value.peek
                                                                    ()) of
                                                                    {Some val ->
                                                                    val.value}
                                                                    {None -> 0}
                                                                    in
                                                                    target_map_d.insert
                                                                    {key:min_vid,
                                                                    value:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {i:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     target_map_d.filter ((\b1 -> bind b1 as {key:vid, value:map_val} in vid >
       min_vid)) in
   filtered.iterate ((\b1 -> bind b1 as {key:vid, value:map_val} in bind
     target_map as ind target_map_d in
     target_map_d.update {key:vid, value:map_val} {key:vid, value:map_val +
       map_val_delta}))))))


declare sw_gen_vid : () -> option { key:int, value:int } = (\_ -> case
  (sw_token_vid_list.peek ()) of
  {Some vid_num -> let num_new = vid_num.value - 1 in
    let vid_new = {key:(vid_num.key).key, value:(vid_num.key).value + 1} in
      ((if num_new <= 0 then sw_token_vid_list.erase vid_num
       else sw_token_vid_list.update vid_num {key:vid_new, value:num_new});
       Some (vid_num.key))}{None -> None immut})


declare calc_dim_bounds : collection { key:int, value:int } @ { Seq } -> {
  key:collection { key:int, value:int } @ { Seq }, value:int } = (\pmap ->
  pmap.fold ((\b2 -> (\b5 -> bind b2 as {key:xs, value:acc_size} in 
  bind b5 as {key:pos, value:bin_size} in {key:xs.combine ({| key:int,
  value:int | {key:pos, value:acc_size}|} @ { Seq }), value:bin_size *
  acc_size}))) {key:empty { key:int, value:int } @ { Seq }, value:1})


declare route_to_int_int : { ra:int, rb:option int, rc:option int
  } -> collection {i:address} @ { Collection } = (\b1 -> bind b1 as {ra:map_id,
  rb:key_0, rc:key_1} in let pmap =
  (case ((pmap_data.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
    map_id))).peek ()) of
    {Some x -> x}{None -> error (print "can't find map_id in pmap_data")}).value
  in
  case (pmap.peek ()) of
    {Some _ -> bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in
      let bound_bucket =
        case key_1 of
          {Some key_1_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              1)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_1_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 1))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 1 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_0 of
          {Some key_0_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              0)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_0_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 0))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 0 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + 0) in
        let free_dims =
          (if key_1 != None immut then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 1))).combine ((if key_0 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 0))).combine empty { key:int, value:int } @ { Seq }) in
          let free_domains =
            free_dims.fold ((\_accmap -> (\b3 -> bind b3 as {key:i,
              value:b_i} in 
              (_accmap.insert {key:i, value:range b_i};_accmap)))) empty {
              key:int, value:collection {i:int} @ { Seq } } @ { Seq } in
            let free_cart_prod =
              free_domains.fold ((\prev_cart_prod -> (\b3 -> bind b3 as {key:i,
                value:domain} in domain.fold ((\_accext -> (\b3 ->
                bind b3 as {i:domain_element} in _accext.combine
                (if 0 == prev_cart_prod.size ()
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int | {key:i,
                  value:domain_element}|} @ { Seq }|} @ { Seq }
                else prev_cart_prod.fold ((\_accmap -> (\b3 ->
                  bind b3 as {i:rest_tup} in 
                  (_accmap.insert ({i:rest_tup.combine ({| key:int, value:int |
                   {key:i, value:domain_element}|} @ { Seq })});
                   _accmap)))) empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq })))) empty {i:collection { key:int,
                value:int } @ { Seq }} @ { Seq }))) empty {i:collection {
                key:int, value:int } @ { Seq }} @ { Seq } in
              let sorted_ip_list =
                (free_cart_prod.fold ((\acc_ips -> (\b3 ->
                  bind b3 as {i:free_bucket} in acc_ips.combine ({|i:address|
                  get_ring_node {key:free_bucket.fold ((\acc -> (\b3 ->
                    bind b3 as {key:i, value:val} in acc + (val * (case
                    ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                    value:value} in key == i))).peek ()) of
                    {Some x -> x}{None ->
                                   error (print "can't find i in dim_bounds")}).value))))
                    bound_bucket, value:max_val}|} @ { Collection }))))
                  empty {i:address} @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {i:ip} in ip)) ((\_ -> (\_ -> ()))) () in
                if 0 == sorted_ip_list.size ()
                  then {|i:address|
                    get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
                  else sorted_ip_list.fold ((\_accmap -> (\x ->
                    (_accmap.insert ({i:x.key});_accmap))))
                    empty {i:address} @ { Collection }}{None -> nodes})


declare route_to_ : { key:int, value:()
  } -> collection {i:address} @ { Collection } = (\b1 -> {|i:address|
  get_ring_node {key:1, value:1}|} @ { Collection })


declare route_to_int : { key:int, value:option int
  } -> collection {i:address} @ { Collection } = (\b1 ->
  bind b1 as {key:map_id, value:key_0} in let pmap =
  (case ((pmap_data.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
    map_id))).peek ()) of
    {Some x -> x}{None -> error (print "can't find map_id in pmap_data")}).value
  in
  case (pmap.peek ()) of
    {Some _ -> bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in
      let bound_bucket =
        case key_0 of
          {Some key_0_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              0)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_0_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 0))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 0 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + 0 in
        let free_dims =
          (if key_0 != None immut then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 0))).combine empty { key:int, value:int } @ { Seq } in
          let free_domains =
            free_dims.fold ((\_accmap -> (\b3 -> bind b3 as {key:i,
              value:b_i} in 
              (_accmap.insert {key:i, value:range b_i};_accmap)))) empty {
              key:int, value:collection {i:int} @ { Seq } } @ { Seq } in
            let free_cart_prod =
              free_domains.fold ((\prev_cart_prod -> (\b3 -> bind b3 as {key:i,
                value:domain} in domain.fold ((\_accext -> (\b3 ->
                bind b3 as {i:domain_element} in _accext.combine
                (if 0 == prev_cart_prod.size ()
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int | {key:i,
                  value:domain_element}|} @ { Seq }|} @ { Seq }
                else prev_cart_prod.fold ((\_accmap -> (\b3 ->
                  bind b3 as {i:rest_tup} in 
                  (_accmap.insert ({i:rest_tup.combine ({| key:int, value:int |
                   {key:i, value:domain_element}|} @ { Seq })});
                   _accmap)))) empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq })))) empty {i:collection { key:int,
                value:int } @ { Seq }} @ { Seq }))) empty {i:collection {
                key:int, value:int } @ { Seq }} @ { Seq } in
              let sorted_ip_list =
                (free_cart_prod.fold ((\acc_ips -> (\b3 ->
                  bind b3 as {i:free_bucket} in acc_ips.combine ({|i:address|
                  get_ring_node {key:free_bucket.fold ((\acc -> (\b3 ->
                    bind b3 as {key:i, value:val} in acc + (val * (case
                    ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                    value:value} in key == i))).peek ()) of
                    {Some x -> x}{None ->
                                   error (print "can't find i in dim_bounds")}).value))))
                    bound_bucket, value:max_val}|} @ { Collection }))))
                  empty {i:address} @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {i:ip} in ip)) ((\_ -> (\_ -> ()))) () in
                if 0 == sorted_ip_list.size ()
                  then {|i:address|
                    get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
                  else sorted_ip_list.fold ((\_accmap -> (\x ->
                    (_accmap.insert ({i:x.key});_accmap))))
                    empty {i:address} @ { Collection }}{None -> nodes})


declare shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mT1_bind_0t1 : { ra:option int,
  rb:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rc:bool } -> collection { key:address, value:collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:tuples,
  rc:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int {key:2, value:lkey_0}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3} in
    (route_to_int {key:2, value:Some rkey_2}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int, rd:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection })


declare shuffle_ATIMESD_mR1_to_ATIMESD : { ra:(), rb:collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Collection }, rc:bool } -> collection {
  key:address, value:collection { ra:{ key:int, value:int }, rb:int, rc:int
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {rb:tuples,
  rc:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_ {key:1, value:()}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2} in
    (route_to_ {key:1, value:()}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int } @ { Collection })


declare shuffle_ATIMESD_mS2_to_ATIMESD_mR1 : { ra:option int, rb:collection {
  ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection }, rc:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:tuples, rc:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int {key:6, value:lkey_0}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2} in
    (route_to_int {key:6, value:lkey_0}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int } @ { Collection })


declare shuffle_ATIMESD_mS1_to_ATIMESD_mT1 : { ra:option int, rb:collection {
  ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection }, rc:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:tuples, rc:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int {key:2, value:lkey_0}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2} in
    (route_to_int {key:2, value:lkey_0}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int } @ { Collection })


declare shuffle_ATIMESD_mS2_to_ATIMESD : { ra:(), rb:collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Collection }, rc:bool } -> collection {
  key:address, value:collection { ra:{ key:int, value:int }, rb:int, rc:int
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {rb:tuples,
  rc:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_ {key:1, value:()}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2} in
    (route_to_ {key:1, value:()}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int } @ { Collection })


declare shuffle_ATIMESD_mS1_to_ATIMESD : { ra:(), rb:collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Collection }, rc:bool } -> collection {
  key:address, value:collection { ra:{ key:int, value:int }, rb:int, rc:int
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {rb:tuples,
  rc:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_ {key:1, value:()}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2} in
    (route_to_ {key:1, value:()}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int } @ { Collection })


declare shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mR1_bind_0t0 : { ra:option int,
  rb:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rc:bool } -> collection { key:address, value:collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:tuples,
  rc:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int {key:6, value:lkey_0}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3} in
    (route_to_int {key:6, value:Some rkey_1}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int, rd:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection })


declare shuffle_ATIMESD_mT1_to_ATIMESD : { ra:(), rb:collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Collection }, rc:bool } -> collection {
  key:address, value:collection { ra:{ key:int, value:int }, rb:int, rc:int
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {rb:tuples,
  rc:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_ {key:1, value:()}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2} in
    (route_to_ {key:1, value:()}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int } @ { Collection })


declare do_gc_nd_log_master : { key:int, value:int } -> () = (\min_gc_vid ->
  let temp = empty { key:{ key:int, value:int }, value:int } @ { Set } in
  (nd_log_master.iterate ((\b1 -> bind b1 as {key:vid, value:stmt_id} in 
   if vid < min_gc_vid then temp.insert {key:vid, value:stmt_id} else ()));
   temp.iterate ((\val -> nd_log_master.erase val))))


declare do_gc_nd_log_insert_T : { key:int, value:int } -> () = (\min_gc_vid ->
  let temp =
  empty { key:{ key:int, value:int }, value:{ key:int, value:int } } @ { Map }
  in
  (nd_log_insert_T.iterate ((\b1 -> bind b1 as {key:vid, value:args} in 
   if vid < min_gc_vid then temp.insert {key:vid, value:args} else ()));
   temp.iterate ((\val -> nd_log_insert_T.erase val))))


declare do_gc_nd_log_delete_T : { key:int, value:int } -> () = (\min_gc_vid ->
  let temp =
  empty { key:{ key:int, value:int }, value:{ key:int, value:int } } @ { Map }
  in
  (nd_log_delete_T.iterate ((\b1 -> bind b1 as {key:vid, value:args} in 
   if vid < min_gc_vid then temp.insert {key:vid, value:args} else ()));
   temp.iterate ((\val -> nd_log_delete_T.erase val))))


declare do_gc_nd_log_insert_S : { key:int, value:int } -> () = (\min_gc_vid ->
  let temp =
  empty { key:{ key:int, value:int }, value:{ key:int, value:int } } @ { Map }
  in
  (nd_log_insert_S.iterate ((\b1 -> bind b1 as {key:vid, value:args} in 
   if vid < min_gc_vid then temp.insert {key:vid, value:args} else ()));
   temp.iterate ((\val -> nd_log_insert_S.erase val))))


declare do_gc_nd_log_delete_S : { key:int, value:int } -> () = (\min_gc_vid ->
  let temp =
  empty { key:{ key:int, value:int }, value:{ key:int, value:int } } @ { Map }
  in
  (nd_log_delete_S.iterate ((\b1 -> bind b1 as {key:vid, value:args} in 
   if vid < min_gc_vid then temp.insert {key:vid, value:args} else ()));
   temp.iterate ((\val -> nd_log_delete_S.erase val))))


declare do_gc_nd_log_insert_R : { key:int, value:int } -> () = (\min_gc_vid ->
  let temp =
  empty { key:{ key:int, value:int }, value:{ key:int, value:int } } @ { Map }
  in
  (nd_log_insert_R.iterate ((\b1 -> bind b1 as {key:vid, value:args} in 
   if vid < min_gc_vid then temp.insert {key:vid, value:args} else ()));
   temp.iterate ((\val -> nd_log_insert_R.erase val))))


declare do_gc_nd_log_delete_R : { key:int, value:int } -> () = (\min_gc_vid ->
  let temp =
  empty { key:{ key:int, value:int }, value:{ key:int, value:int } } @ { Map }
  in
  (nd_log_delete_R.iterate ((\b1 -> bind b1 as {key:vid, value:args} in 
   if vid < min_gc_vid then temp.insert {key:vid, value:args} else ()));
   temp.iterate ((\val -> nd_log_delete_R.erase val))))


declare do_gc_map_ATIMESD_mT1_s0_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mT1_s0_buf as ind map_ATIMESD_mT1_s0_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mT1_s0_buf_unwrap} in
      (map_ATIMESD_mT1_s0_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mT1_s0_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mT1_s0_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mT1_mR1_s2_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
  bind map_ATIMESD_mT1_mR1_s2_buf as ind map_ATIMESD_mT1_mR1_s2_buf_unwrap in
    let frontier =
      frontier_int_int_int {key:min_gc_vid,
        value:map_ATIMESD_mT1_mR1_s2_buf_unwrap} in
      (map_ATIMESD_mT1_mR1_s2_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_1, rd:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mT1_mR1_s2_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mT1_mR1_s2_buf_unwrap.insert
       val))))


declare do_gc_map_ATIMESD_mT1_s3_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mT1_s3_buf as ind map_ATIMESD_mT1_s3_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mT1_s3_buf_unwrap} in
      (map_ATIMESD_mT1_s3_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mT1_s3_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mT1_s3_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mT1_mR1_s5_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
  bind map_ATIMESD_mT1_mR1_s5_buf as ind map_ATIMESD_mT1_mR1_s5_buf_unwrap in
    let frontier =
      frontier_int_int_int {key:min_gc_vid,
        value:map_ATIMESD_mT1_mR1_s5_buf_unwrap} in
      (map_ATIMESD_mT1_mR1_s5_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_1, rd:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mT1_mR1_s5_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mT1_mR1_s5_buf_unwrap.insert
       val))))


declare do_gc_map_ATIMESD_mS1_s6_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mS1_s6_buf as ind map_ATIMESD_mS1_s6_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mS1_s6_buf_unwrap} in
      (map_ATIMESD_mS1_s6_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mS1_s6_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mS1_s6_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mS2_s6_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mS2_s6_buf as ind map_ATIMESD_mS2_s6_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mS2_s6_buf_unwrap} in
      (map_ATIMESD_mS2_s6_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mS2_s6_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mS2_s6_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mS1_s7_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mS1_s7_buf as ind map_ATIMESD_mS1_s7_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mS1_s7_buf_unwrap} in
      (map_ATIMESD_mS1_s7_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mS1_s7_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mS1_s7_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mS2_s9_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mS2_s9_buf as ind map_ATIMESD_mS2_s9_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mS2_s9_buf_unwrap} in
      (map_ATIMESD_mS2_s9_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mS2_s9_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mS2_s9_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mS1_s10_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mS1_s10_buf as ind map_ATIMESD_mS1_s10_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mS1_s10_buf_unwrap}
      in
      (map_ATIMESD_mS1_s10_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mS1_s10_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mS1_s10_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mS2_s10_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mS2_s10_buf as ind map_ATIMESD_mS2_s10_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mS2_s10_buf_unwrap}
      in
      (map_ATIMESD_mS2_s10_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mS2_s10_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mS2_s10_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mS1_s11_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mS1_s11_buf as ind map_ATIMESD_mS1_s11_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mS1_s11_buf_unwrap}
      in
      (map_ATIMESD_mS1_s11_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mS1_s11_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mS1_s11_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mS2_s13_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mS2_s13_buf as ind map_ATIMESD_mS2_s13_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mS2_s13_buf_unwrap}
      in
      (map_ATIMESD_mS2_s13_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mS2_s13_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mS2_s13_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mR1_s14_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mR1_s14_buf as ind map_ATIMESD_mR1_s14_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mR1_s14_buf_unwrap}
      in
      (map_ATIMESD_mR1_s14_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mR1_s14_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mR1_s14_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mT1_mR1_s15_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
  bind map_ATIMESD_mT1_mR1_s15_buf as ind map_ATIMESD_mT1_mR1_s15_buf_unwrap in
    let frontier =
      frontier_int_int_int {key:min_gc_vid,
        value:map_ATIMESD_mT1_mR1_s15_buf_unwrap} in
      (map_ATIMESD_mT1_mR1_s15_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_1, rd:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mT1_mR1_s15_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mT1_mR1_s15_buf_unwrap.insert
       val))))


declare do_gc_map_ATIMESD_mR1_s17_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mR1_s17_buf as ind map_ATIMESD_mR1_s17_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mR1_s17_buf_unwrap}
      in
      (map_ATIMESD_mR1_s17_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mR1_s17_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mR1_s17_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mT1_mR1_s18_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
  bind map_ATIMESD_mT1_mR1_s18_buf as ind map_ATIMESD_mT1_mR1_s18_buf_unwrap in
    let frontier =
      frontier_int_int_int {key:min_gc_vid,
        value:map_ATIMESD_mT1_mR1_s18_buf_unwrap} in
      (map_ATIMESD_mT1_mR1_s18_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_1, rd:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mT1_mR1_s18_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mT1_mR1_s18_buf_unwrap.insert
       val))))


declare do_gc_map_ATIMESD_mS2_s24_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mS2_s24_buf as ind map_ATIMESD_mS2_s24_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mS2_s24_buf_unwrap}
      in
      (map_ATIMESD_mS2_s24_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mS2_s24_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mS2_s24_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mS2_s26_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mS2_s26_buf as ind map_ATIMESD_mS2_s26_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mS2_s26_buf_unwrap}
      in
      (map_ATIMESD_mS2_s26_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mS2_s26_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mS2_s26_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mS1_s28_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mS1_s28_buf as ind map_ATIMESD_mS1_s28_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mS1_s28_buf_unwrap}
      in
      (map_ATIMESD_mS1_s28_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mS1_s28_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mS1_s28_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mS1_s30_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mS1_s30_buf as ind map_ATIMESD_mS1_s30_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mS1_s30_buf_unwrap}
      in
      (map_ATIMESD_mS1_s30_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mS1_s30_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mS1_s30_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mS2_s32_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mS2_s32_buf as ind map_ATIMESD_mS2_s32_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mS2_s32_buf_unwrap}
      in
      (map_ATIMESD_mS2_s32_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mS2_s32_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mS2_s32_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mS2_s34_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mS2_s34_buf as ind map_ATIMESD_mS2_s34_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mS2_s34_buf_unwrap}
      in
      (map_ATIMESD_mS2_s34_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mS2_s34_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mS2_s34_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mS1_s36_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mS1_s36_buf as ind map_ATIMESD_mS1_s36_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mS1_s36_buf_unwrap}
      in
      (map_ATIMESD_mS1_s36_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mS1_s36_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mS1_s36_buf_unwrap.insert val))))


declare do_gc_map_ATIMESD_mS1_s38_buf : { key:int, value:int } -> () =
  (\min_gc_vid -> let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind map_ATIMESD_mS1_s38_buf as ind map_ATIMESD_mS1_s38_buf_unwrap in
    let frontier =
      frontier_int_int {key:min_gc_vid, value:map_ATIMESD_mS1_s38_buf_unwrap}
      in
      (map_ATIMESD_mS1_s38_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
       rb:map_0, rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> map_ATIMESD_mS1_s38_buf_unwrap.erase val));
       frontier.iterate ((\val -> map_ATIMESD_mS1_s38_buf_unwrap.insert val))))


declare do_gc_ATIMESD : { key:int, value:int } -> () = (\min_gc_vid -> let temp
  = empty { key:{ key:int, value:int }, value:int } @ { Set } in
  bind ATIMESD as ind ATIMESD_unwrap in
    let frontier = frontier_int {key:min_gc_vid, value:ATIMESD_unwrap} in
      (ATIMESD_unwrap.iterate ((\b1 -> bind b1 as {key:vid, value:map_val} in 
       if vid < min_gc_vid then temp.insert {key:vid, value:map_val} 
       else ()));
       temp.iterate ((\val -> ATIMESD_unwrap.erase val));
       frontier.iterate ((\val -> ATIMESD_unwrap.insert val))))


declare do_gc_ATIMESD_mT1 : { key:int, value:int } -> () = (\min_gc_vid -> let
  temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind ATIMESD_mT1 as ind ATIMESD_mT1_unwrap in
    let frontier = frontier_int_int {key:min_gc_vid, value:ATIMESD_mT1_unwrap}
      in
      (ATIMESD_mT1_unwrap.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0,
       rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> ATIMESD_mT1_unwrap.erase val));
       frontier.iterate ((\val -> ATIMESD_mT1_unwrap.insert val))))


declare do_gc_ATIMESD_mT1_mR1 : { key:int, value:int } -> () = (\min_gc_vid ->
  let temp =
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
  bind ATIMESD_mT1_mR1 as ind ATIMESD_mT1_mR1_unwrap in
    let frontier =
      frontier_int_int_int {key:min_gc_vid, value:ATIMESD_mT1_mR1_unwrap} in
      (ATIMESD_mT1_mR1_unwrap.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0,
       rc:map_1, rd:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
       temp.iterate ((\val -> ATIMESD_mT1_mR1_unwrap.erase val));
       frontier.iterate ((\val -> ATIMESD_mT1_mR1_unwrap.insert val))))


declare do_gc_ATIMESD_mS1 : { key:int, value:int } -> () = (\min_gc_vid -> let
  temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind ATIMESD_mS1 as ind ATIMESD_mS1_unwrap in
    let frontier = frontier_int_int {key:min_gc_vid, value:ATIMESD_mS1_unwrap}
      in
      (ATIMESD_mS1_unwrap.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0,
       rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> ATIMESD_mS1_unwrap.erase val));
       frontier.iterate ((\val -> ATIMESD_mS1_unwrap.insert val))))


declare do_gc_ATIMESD_mS2 : { key:int, value:int } -> () = (\min_gc_vid -> let
  temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind ATIMESD_mS2 as ind ATIMESD_mS2_unwrap in
    let frontier = frontier_int_int {key:min_gc_vid, value:ATIMESD_mS2_unwrap}
      in
      (ATIMESD_mS2_unwrap.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0,
       rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> ATIMESD_mS2_unwrap.erase val));
       frontier.iterate ((\val -> ATIMESD_mS2_unwrap.insert val))))


declare do_gc_ATIMESD_mR1 : { key:int, value:int } -> () = (\min_gc_vid -> let
  temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
  bind ATIMESD_mR1 as ind ATIMESD_mR1_unwrap in
    let frontier = frontier_int_int {key:min_gc_vid, value:ATIMESD_mR1_unwrap}
      in
      (ATIMESD_mR1_unwrap.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0,
       rc:map_val} in if vid < min_gc_vid
       then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
       temp.iterate ((\val -> ATIMESD_mR1_unwrap.erase val));
       frontier.iterate ((\val -> ATIMESD_mR1_unwrap.insert val))))


declare nd_ATIMESD_mS1_send_correctives : { ra:address, rb:int, rc:{ key:int,
  value:int }, rd:int, re:{ key:int, value:int }, rf:collection { key:int,
  value:int } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid, rf:delta_tuples} in 
  let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:2, value:6}, {key:2, value:7}, {key:3, value:10}, {key:3,
    value:11}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {key:map_0,
        value:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_val};_accmap))))
        empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 11
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_S vid as {key:S_B, value:S_C} in
            (shuffle_ATIMESD_mS1_to_ATIMESD_mT1 {ra:Some S_C, rb:delta_tuples2,
               rc:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
              value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
               key:int, value:int } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { key:int, value:int } @ { Collection }
              } @ { Collection })))) empty { ra:address, rb:{ key:int,
            value:int }, rc:collection { key:int, value:int } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
             value:int } @ { Collection }})))) {key:empty { key:int, value:int
            } @ { Seq }, value:empty { key:int, value:int } @ { Collection }}
          in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_S_rcv_corrective_s11_m_ATIMESD_mS1, ip)<- {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
             rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 10
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_delete_S vid as {key:S_B, value:S_C} in
              (shuffle_ATIMESD_mS1_to_ATIMESD {ra:(), rb:delta_tuples2,
                 rc:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
                 (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
                 key:int, value:int } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { key:int, value:int } @ { Collection }
                } @ { Collection })))) empty { ra:address, rb:{ key:int,
              value:int }, rc:collection { key:int, value:int
              } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
              bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
              bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
              rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
               value:int } @ { Collection }})))) {key:empty { key:int,
              value:int } @ { Seq }, value:empty { key:int, value:int
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((delete_S_rcv_corrective_s10_m_ATIMESD_mS1, ip)<- {ra:orig_addr,
               rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
               rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 7
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_insert_S vid as {key:S_B, value:S_C} in
                (shuffle_ATIMESD_mS1_to_ATIMESD_mT1 {ra:Some S_C,
                   rb:delta_tuples2, rc:false}).fold ((\_accmap -> (\b3 ->
                  bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
                   (_accmap.insert {key:map_0, value:map_val};_accmap))))
                   empty { key:int, value:int } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { key:int, value:int } @ { Collection }
                  } @ { Collection })))) empty { ra:address, rb:{ key:int,
                value:int }, rc:collection { key:int, value:int
                } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                bind b2 as {key:acc_vid, value:acc_tuples} in 
                bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { key:int, value:int } @ { Collection }}))))
                {key:empty { key:int, value:int } @ { Seq }, value:empty {
                key:int, value:int } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((insert_S_rcv_corrective_s7_m_ATIMESD_mS1, ip)<- {ra:orig_addr,
                 rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
                 rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 6
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_insert_S vid as {key:S_B, value:S_C} in
                  (shuffle_ATIMESD_mS1_to_ATIMESD {ra:(), rb:delta_tuples2,
                     rc:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                    value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_val} in 
                     (_accmap.insert {key:map_0, value:map_val};_accmap))))
                     empty { key:int, value:int } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { key:int, value:int } @ { Collection }
                    } @ { Collection })))) empty { ra:address, rb:{ key:int,
                  value:int }, rc:collection { key:int, value:int
                  } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                  (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { key:int, value:int } @ { Collection }}))))
                  {key:empty { key:int, value:int } @ { Seq }, value:empty {
                  key:int, value:int } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((insert_S_rcv_corrective_s6_m_ATIMESD_mS1, ip)<- {ra:orig_addr,
                   rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
                   rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_ATIMESD_mT1_mR1_send_correctives : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  ra:int, rb:int, rc:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:0, value:2}, {key:1, value:5}, {key:4, value:15}, {key:5,
    value:18}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_val};_accmap))))
        empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
        } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 18
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_R vid as {key:R_A, value:R_B} in
            (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mT1_bind_0t1 {ra:None immut,
               rb:delta_tuples2, rc:false}).fold ((\_accmap -> (\b3 ->
              bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
               empty { ra:int, rb:int, rc:int } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:int, rb:int, rc:int } @ { Collection }
              } @ { Collection })))) empty { ra:address, rb:{ key:int,
            value:int }, rc:collection { ra:int, rb:int, rc:int
            } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
            bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
            bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
            rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int, rb:int,
             rc:int } @ { Collection }})))) {key:empty { key:int, value:int
            } @ { Seq }, value:empty { ra:int, rb:int, rc:int
            } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_R_rcv_corrective_s18_m_ATIMESD_mT1_mR1, ip)<- {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
             rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 15
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_R vid as {key:R_A, value:R_B} in
              (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mT1_bind_0t1 {ra:None immut,
                 rb:delta_tuples2, rc:false}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
                 rd:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
                 empty { ra:int, rb:int, rc:int } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:int, rb:int, rc:int } @ { Collection }
                } @ { Collection })))) empty { ra:address, rb:{ key:int,
              value:int }, rc:collection { ra:int, rb:int, rc:int
              } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
              bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
              bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
              rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int,
               rb:int, rc:int } @ { Collection }})))) {key:empty { key:int,
              value:int } @ { Seq }, value:empty { ra:int, rb:int, rc:int
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_R_rcv_corrective_s15_m_ATIMESD_mT1_mR1, ip)<- {ra:orig_addr,
               rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
               rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 5
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_delete_T vid as {key:T_C, value:T_D} in
                (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mR1_bind_0t0
                   {ra:None immut, rb:delta_tuples2, rc:false}).fold
                  ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
                   rd:map_val} in 
                   (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
                   empty { ra:int, rb:int, rc:int } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { ra:int, rb:int, rc:int } @ { Collection }
                  } @ { Collection })))) empty { ra:address, rb:{ key:int,
                value:int }, rc:collection { ra:int, rb:int, rc:int
                } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                bind b2 as {key:acc_vid, value:acc_tuples} in 
                bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { ra:int, rb:int, rc:int } @ { Collection }}))))
                {key:empty { key:int, value:int } @ { Seq }, value:empty {
                ra:int, rb:int, rc:int } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((delete_T_rcv_corrective_s5_m_ATIMESD_mT1_mR1, ip)<- {ra:orig_addr,
                 rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
                 rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 2
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_insert_T vid as {key:T_C, value:T_D} in
                  (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mR1_bind_0t0
                     {ra:None immut, rb:delta_tuples2, rc:false}).fold
                    ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_1, rd:map_val} in 
                     (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
                     empty { ra:int, rb:int, rc:int } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { ra:int, rb:int, rc:int } @ { Collection }
                    } @ { Collection })))) empty { ra:address, rb:{ key:int,
                  value:int }, rc:collection { ra:int, rb:int, rc:int
                  } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                  (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { ra:int, rb:int, rc:int } @ { Collection }}))))
                  {key:empty { key:int, value:int } @ { Seq }, value:empty {
                  ra:int, rb:int, rc:int } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((insert_T_rcv_corrective_s2_m_ATIMESD_mT1_mR1, ip)<- {ra:orig_addr,
                   rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
                   rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_ATIMESD_mT1_send_correctives : { ra:address, rb:int, rc:{ key:int,
  value:int }, rd:int, re:{ key:int, value:int }, rf:collection { key:int,
  value:int } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid, rf:delta_tuples} in 
  let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:0, value:0}, {key:1, value:3}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {key:map_0,
        value:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_val};_accmap))))
        empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 3
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_T vid as {key:T_C, value:T_D} in
            (shuffle_ATIMESD_mT1_to_ATIMESD {ra:(), rb:delta_tuples2, rc:false}).fold
              ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
               key:int, value:int } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { key:int, value:int } @ { Collection }
              } @ { Collection })))) empty { ra:address, rb:{ key:int,
            value:int }, rc:collection { key:int, value:int } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
             value:int } @ { Collection }})))) {key:empty { key:int, value:int
            } @ { Seq }, value:empty { key:int, value:int } @ { Collection }}
          in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_T_rcv_corrective_s3_m_ATIMESD_mT1, ip)<- {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
             rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 0
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_T vid as {key:T_C, value:T_D} in
              (shuffle_ATIMESD_mT1_to_ATIMESD {ra:(), rb:delta_tuples2,
                 rc:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
                 (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
                 key:int, value:int } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { key:int, value:int } @ { Collection }
                } @ { Collection })))) empty { ra:address, rb:{ key:int,
              value:int }, rc:collection { key:int, value:int
              } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
              bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
              bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
              rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
               value:int } @ { Collection }})))) {key:empty { key:int,
              value:int } @ { Seq }, value:empty { key:int, value:int
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_T_rcv_corrective_s0_m_ATIMESD_mT1, ip)<- {ra:orig_addr,
               rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
               rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_ATIMESD_mR1_send_correctives : { ra:address, rb:int, rc:{ key:int,
  value:int }, rd:int, re:{ key:int, value:int }, rf:collection { key:int,
  value:int } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid, rf:delta_tuples} in 
  let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:4, value:14}, {key:5, value:17}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {key:map_0,
        value:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_val};_accmap))))
        empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 17
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_R vid as {key:R_A, value:R_B} in
            (shuffle_ATIMESD_mR1_to_ATIMESD {ra:(), rb:delta_tuples2, rc:false}).fold
              ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
               key:int, value:int } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { key:int, value:int } @ { Collection }
              } @ { Collection })))) empty { ra:address, rb:{ key:int,
            value:int }, rc:collection { key:int, value:int } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
             value:int } @ { Collection }})))) {key:empty { key:int, value:int
            } @ { Seq }, value:empty { key:int, value:int } @ { Collection }}
          in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_R_rcv_corrective_s17_m_ATIMESD_mR1, ip)<- {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
             rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 14
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_R vid as {key:R_A, value:R_B} in
              (shuffle_ATIMESD_mR1_to_ATIMESD {ra:(), rb:delta_tuples2,
                 rc:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
                 (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
                 key:int, value:int } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { key:int, value:int } @ { Collection }
                } @ { Collection })))) empty { ra:address, rb:{ key:int,
              value:int }, rc:collection { key:int, value:int
              } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
              bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
              bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
              rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
               value:int } @ { Collection }})))) {key:empty { key:int,
              value:int } @ { Seq }, value:empty { key:int, value:int
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_R_rcv_corrective_s14_m_ATIMESD_mR1, ip)<- {ra:orig_addr,
               rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
               rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_ATIMESD_mS2_send_correctives : { ra:address, rb:int, rc:{ key:int,
  value:int }, rd:int, re:{ key:int, value:int }, rf:collection { key:int,
  value:int } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid, rf:delta_tuples} in 
  let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:2, value:6}, {key:2, value:9}, {key:3, value:10}, {key:3,
    value:13}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {key:map_0,
        value:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_val};_accmap))))
        empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 13
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_S vid as {key:S_B, value:S_C} in
            (shuffle_ATIMESD_mS2_to_ATIMESD_mR1 {ra:Some S_B, rb:delta_tuples2,
               rc:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
              value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
               key:int, value:int } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { key:int, value:int } @ { Collection }
              } @ { Collection })))) empty { ra:address, rb:{ key:int,
            value:int }, rc:collection { key:int, value:int } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
             value:int } @ { Collection }})))) {key:empty { key:int, value:int
            } @ { Seq }, value:empty { key:int, value:int } @ { Collection }}
          in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_S_rcv_corrective_s13_m_ATIMESD_mS2, ip)<- {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
             rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 10
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_delete_S vid as {key:S_B, value:S_C} in
              (shuffle_ATIMESD_mS2_to_ATIMESD {ra:(), rb:delta_tuples2,
                 rc:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
                 (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
                 key:int, value:int } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { key:int, value:int } @ { Collection }
                } @ { Collection })))) empty { ra:address, rb:{ key:int,
              value:int }, rc:collection { key:int, value:int
              } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
              bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
              bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
              rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
               value:int } @ { Collection }})))) {key:empty { key:int,
              value:int } @ { Seq }, value:empty { key:int, value:int
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((delete_S_rcv_corrective_s10_m_ATIMESD_mS2, ip)<- {ra:orig_addr,
               rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
               rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 9
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_insert_S vid as {key:S_B, value:S_C} in
                (shuffle_ATIMESD_mS2_to_ATIMESD_mR1 {ra:Some S_B,
                   rb:delta_tuples2, rc:false}).fold ((\_accmap -> (\b3 ->
                  bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
                   (_accmap.insert {key:map_0, value:map_val};_accmap))))
                   empty { key:int, value:int } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { key:int, value:int } @ { Collection }
                  } @ { Collection })))) empty { ra:address, rb:{ key:int,
                value:int }, rc:collection { key:int, value:int
                } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                bind b2 as {key:acc_vid, value:acc_tuples} in 
                bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { key:int, value:int } @ { Collection }}))))
                {key:empty { key:int, value:int } @ { Seq }, value:empty {
                key:int, value:int } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((insert_S_rcv_corrective_s9_m_ATIMESD_mS2, ip)<- {ra:orig_addr,
                 rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
                 rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 6
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_insert_S vid as {key:S_B, value:S_C} in
                  (shuffle_ATIMESD_mS2_to_ATIMESD {ra:(), rb:delta_tuples2,
                     rc:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                    value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_val} in 
                     (_accmap.insert {key:map_0, value:map_val};_accmap))))
                     empty { key:int, value:int } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { key:int, value:int } @ { Collection }
                    } @ { Collection })))) empty { ra:address, rb:{ key:int,
                  value:int }, rc:collection { key:int, value:int
                  } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                  (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { key:int, value:int } @ { Collection }}))))
                  {key:empty { key:int, value:int } @ { Seq }, value:empty {
                  key:int, value:int } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((insert_S_rcv_corrective_s6_m_ATIMESD_mS2, ip)<- {ra:orig_addr,
                   rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
                   rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count else acc_count))) 0)


declare sw_insert_T : { key:int, value:int } -> () = (\args ->
  (sw_buf_insert_T.insert args;
   sw_trig_buf_idx.insert {i:0};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_insert_T_send_fetch : { key:int, value:int } -> () = (\vid -> case
  (sw_buf_insert_T.peek ()) of
  {Some args ->
    (sw_buf_insert_T.erase args;
     bind args as {key:T_C, value:T_D} in
     ((route_to_int {key:5, value:Some T_C}).iterate ((\b1 ->
      bind b1 as {i:ip} in (nd_insert_T_do_complete_s1_trig, ip)<- {ra:vid,
      rb:T_C, rc:T_D}));
      ((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_int {key:2, value:Some T_C}).fold ((\count -> (\b3 ->
        bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_ATIMESD_mT1_to_ATIMESD {ra:(), rb:empty { ra:{ key:int,
          value:int }, rb:int, rc:int } @ { Collection }, rc:true}).fold
        ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:0, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_int_int {ra:3, rb:None immut, rc:Some T_C}).fold ((\count ->
          (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
        (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mR1_bind_0t0 {ra:None immut,
           rb:empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
           } @ { Collection }, rc:true}).fold ((\_accmap -> (\b3 ->
          bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:2, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }))).groupBy ((\b1 ->
      bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip, value:stmt_id}))
      ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id, rc:count} in acc +
      count))) 0).groupBy ((\b1 -> bind b1 as {key:b2, value:count} in 
      bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc -> (\b3 ->
      bind b3 as {key:ip_and_stmt_id, value:count} in bind ip_and_stmt_id as
      {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_insert_T_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid, rd:T_C,
       re:T_D};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_int_int {ra:3, rb:None immut, rc:Some T_C}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:2, rb:3, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:2, value:Some T_C}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:0, rb:2, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine empty {
      ra:int, rb:int, rc:address } @ { Collection })).groupBy ((\b1 ->
      bind b1 as {ra:stmt_id, rb:map_id, rc:ip} in ip)) ((\acc -> (\b3 ->
      bind b3 as {ra:stmt_id, rb:map_id, rc:ip} in 
      (acc.insert {key:stmt_id, value:map_id};acc)))) empty { key:int,
      value:int } @ { Collection }).iterate ((\b1 -> bind b1 as {key:ip,
      value:stmt_map_ids} in (nd_insert_T_rcv_fetch, ip)<- {ra:stmt_map_ids,
      rb:vid, rc:T_C, rd:T_D}))))}{None ->
                                    error
                                      (print
                                         "unexpected missing arguments in sw_buf_insert_T")})


declare nd_insert_T_do_complete_s0 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:T_C, rc:T_D} in let
  __prod_ret__1 =
  (let wrapped_lookup_value =
    bind map_ATIMESD_mT1_s0_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == T_C))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * T_D in
  ((nd_add_delta_to_int {ra:ATIMESD, rb:false, rc:vid, rd:{|i:int|
      __prod_ret__1|} @ { Collection }});
   (nd_complete_stmt_cntr_check {key:vid, value:0})))


declare nd_insert_T_do_complete_s2 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:T_C, rc:T_D} in let
  delta_values =
  (((bind map_ATIMESD_mT1_mR1_s2_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == T_C))}).fold ((\acc ->
      (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:ATIMESD_mRR_B, rb:T_C, rc:__map_ret__2} in 
    (_accmap.insert {key:ATIMESD_mRR_B, value:__map_ret__2};_accmap)))) empty {
    key:int, value:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:ATIMESD_mRR_B, value:__map_ret__2} in 
    (_accmap.insert {key:ATIMESD_mRR_B, value:__map_ret__2 * T_D};_accmap))))
    empty { key:int, value:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:ATIMESD_mRR_B, value:__prod_ret__2} in 
    (_accmap.insert {key:ATIMESD_mRR_B, value:__prod_ret__2};_accmap))))
    empty { key:int, value:int } @ { Collection } in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mR1, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_ATIMESD_mR1_send_correctives {ra:me, rb:2, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:2}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:2, rc:1, rd:sent_msgs, re:true,
         rf:false}))


declare nd_insert_T_do_complete_s1 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:T_C, rc:T_D} in let
  __val_ret__2 = T_D in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mS2, rb:false, rc:vid, rd:{| key:int,
      value:int | {key:T_C, value:__val_ret__2}|} @ { Collection }});
   let sent_msgs =
   nd_ATIMESD_mS2_send_correctives {ra:me, rb:1, rc:vid, rd:1, re:vid, rf:{|
     key:int, value:int | {key:T_C, value:__val_ret__2}|} @ { Collection }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:1, rc:1, rd:sent_msgs, re:true,
         rf:true}))


declare insert_T_do_corrective_s0_m_ATIMESD_mT1 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int, rg:int,
  rh:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:T_C, rg:T_D, rh:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_ATIMESD_mTT_C,
    value:delta_ATIMESD_mT1} in _accext.combine (let __prod_ret__63 =
    ((if T_C == delta_ATIMESD_mTT_C then 1 else 0) * delta_ATIMESD_mT1) * T_D
    in {|i:int| __prod_ret__63|} @ { Collection }))))
    empty {i:int} @ { Collection }).filter ((\b1 -> bind b1 as {i:map_val} in 0
    != map_val)) in
  ((nd_add_delta_to_int {ra:ATIMESD, rb:true, rc:vid, rd:new_tuples});0))


declare insert_T_do_corrective_s2_m_ATIMESD_mT1_mR1 : { ra:address, rb:int,
  rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int, rg:int,
  rh:collection { ra:int, rb:int, rc:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:T_C, rg:T_D, rh:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_ATIMESD_mT1_mRR_B, rb:delta_ATIMESD_mTT_C,
    rc:delta_ATIMESD_mT1_mR1} in _accext.combine (let __prod_ret__65 =
    ((if T_C == delta_ATIMESD_mTT_C then 1 else 0) * delta_ATIMESD_mT1_mR1) *
      T_D in
    {| key:int, value:int | {key:delta_ATIMESD_mT1_mRR_B,
      value:__prod_ret__65}|} @ { Collection })))) empty { key:int, value:int
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mR1, rb:true, rc:vid, rd:new_tuples});
   (nd_ATIMESD_mR1_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare sw_delete_T : { key:int, value:int } -> () = (\args ->
  (sw_buf_delete_T.insert args;
   sw_trig_buf_idx.insert {i:1};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_delete_T_send_fetch : { key:int, value:int } -> () = (\vid -> case
  (sw_buf_delete_T.peek ()) of
  {Some args ->
    (sw_buf_delete_T.erase args;
     bind args as {key:T_C, value:T_D} in
     ((route_to_int {key:5, value:Some T_C}).iterate ((\b1 ->
      bind b1 as {i:ip} in (nd_delete_T_do_complete_s4_trig, ip)<- {ra:vid,
      rb:T_C, rc:T_D}));
      ((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_int {key:2, value:Some T_C}).fold ((\count -> (\b3 ->
        bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_ATIMESD_mT1_to_ATIMESD {ra:(), rb:empty { ra:{ key:int,
          value:int }, rb:int, rc:int } @ { Collection }, rc:true}).fold
        ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:3, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_int_int {ra:3, rb:None immut, rc:Some T_C}).fold ((\count ->
          (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
        (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mR1_bind_0t0 {ra:None immut,
           rb:empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
           } @ { Collection }, rc:true}).fold ((\_accmap -> (\b3 ->
          bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:5, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }))).groupBy ((\b1 ->
      bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip, value:stmt_id}))
      ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id, rc:count} in acc +
      count))) 0).groupBy ((\b1 -> bind b1 as {key:b2, value:count} in 
      bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc -> (\b3 ->
      bind b3 as {key:ip_and_stmt_id, value:count} in bind ip_and_stmt_id as
      {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_delete_T_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid, rd:T_C,
       re:T_D};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_int_int {ra:3, rb:None immut, rc:Some T_C}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:5, rb:3, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:2, value:Some T_C}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:3, rb:2, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine empty {
      ra:int, rb:int, rc:address } @ { Collection })).groupBy ((\b1 ->
      bind b1 as {ra:stmt_id, rb:map_id, rc:ip} in ip)) ((\acc -> (\b3 ->
      bind b3 as {ra:stmt_id, rb:map_id, rc:ip} in 
      (acc.insert {key:stmt_id, value:map_id};acc)))) empty { key:int,
      value:int } @ { Collection }).iterate ((\b1 -> bind b1 as {key:ip,
      value:stmt_map_ids} in (nd_delete_T_rcv_fetch, ip)<- {ra:stmt_map_ids,
      rb:vid, rc:T_C, rd:T_D}))))}{None ->
                                    error
                                      (print
                                         "unexpected missing arguments in sw_buf_delete_T")})


declare nd_delete_T_do_complete_s3 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:T_C, rc:T_D} in let
  __prod_ret__4 =
  (let wrapped_lookup_value =
    bind map_ATIMESD_mT1_s3_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == T_C))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * -T_D
  in
  ((nd_add_delta_to_int {ra:ATIMESD, rb:false, rc:vid, rd:{|i:int|
      __prod_ret__4|} @ { Collection }});
   (nd_complete_stmt_cntr_check {key:vid, value:3})))


declare nd_delete_T_do_complete_s5 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:T_C, rc:T_D} in let
  delta_values =
  (((bind map_ATIMESD_mT1_mR1_s5_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == T_C))}).fold ((\acc ->
      (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:ATIMESD_mRR_B, rb:T_C, rc:__map_ret__4} in 
    (_accmap.insert {key:ATIMESD_mRR_B, value:__map_ret__4};_accmap)))) empty {
    key:int, value:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:ATIMESD_mRR_B, value:__map_ret__4} in 
    (_accmap.insert {key:ATIMESD_mRR_B, value:__map_ret__4 * -T_D};_accmap))))
    empty { key:int, value:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:ATIMESD_mRR_B, value:__prod_ret__7} in 
    (_accmap.insert {key:ATIMESD_mRR_B, value:__prod_ret__7};_accmap))))
    empty { key:int, value:int } @ { Collection } in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mR1, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_ATIMESD_mR1_send_correctives {ra:me, rb:5, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:5}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:5, rc:1, rd:sent_msgs, re:true,
         rf:false}))


declare nd_delete_T_do_complete_s4 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:T_C, rc:T_D} in let
  __prod_ret__5 = -T_D in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mS2, rb:false, rc:vid, rd:{| key:int,
      value:int | {key:T_C, value:__prod_ret__5}|} @ { Collection }});
   let sent_msgs =
   nd_ATIMESD_mS2_send_correctives {ra:me, rb:4, rc:vid, rd:1, re:vid, rf:{|
     key:int, value:int | {key:T_C, value:__prod_ret__5}|} @ { Collection }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:4, rc:1, rd:sent_msgs, re:true,
         rf:true}))


declare delete_T_do_corrective_s3_m_ATIMESD_mT1 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int, rg:int,
  rh:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:T_C, rg:T_D, rh:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_ATIMESD_mTT_C,
    value:delta_ATIMESD_mT1} in _accext.combine (let __prod_ret__68 =
    (if T_C == delta_ATIMESD_mTT_C then 1 else 0) * (-delta_ATIMESD_mT1 * T_D)
    in {|i:int| __prod_ret__68|} @ { Collection }))))
    empty {i:int} @ { Collection }).filter ((\b1 -> bind b1 as {i:map_val} in 0
    != map_val)) in
  ((nd_add_delta_to_int {ra:ATIMESD, rb:true, rc:vid, rd:new_tuples});0))


declare delete_T_do_corrective_s5_m_ATIMESD_mT1_mR1 : { ra:address, rb:int,
  rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int, rg:int,
  rh:collection { ra:int, rb:int, rc:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:T_C, rg:T_D, rh:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_ATIMESD_mT1_mRR_B, rb:delta_ATIMESD_mTT_C,
    rc:delta_ATIMESD_mT1_mR1} in _accext.combine (let __prod_ret__71 =
    (if T_C == delta_ATIMESD_mTT_C then 1 else 0) * (-delta_ATIMESD_mT1_mR1 *
      T_D) in
    {| key:int, value:int | {key:delta_ATIMESD_mT1_mRR_B,
      value:__prod_ret__71}|} @ { Collection })))) empty { key:int, value:int
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mR1, rb:true, rc:vid, rd:new_tuples});
   (nd_ATIMESD_mR1_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare sw_insert_S : { key:int, value:int } -> () = (\args ->
  (sw_buf_insert_S.insert args;
   sw_trig_buf_idx.insert {i:2};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_insert_S_send_fetch : { key:int, value:int } -> () = (\vid -> case
  (sw_buf_insert_S.peek ()) of
  {Some args ->
    (sw_buf_insert_S.erase args;
     bind args as {key:S_B, value:S_C} in
     ((route_to_int_int {ra:3, rb:Some S_B, rc:Some S_C}).iterate ((\b1 ->
      bind b1 as {i:ip} in (nd_insert_S_do_complete_s8_trig, ip)<- {ra:vid,
      rb:S_B, rc:S_C}));
      ((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_int {key:4, value:Some S_B}).fold ((\count -> (\b3 ->
        bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_ATIMESD_mS1_to_ATIMESD {ra:(), rb:empty { ra:{ key:int,
          value:int }, rb:int, rc:int } @ { Collection }, rc:true}).fold
        ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:6, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_int {key:5, value:Some S_C}).fold ((\count -> (\b3 ->
          bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_ATIMESD_mS2_to_ATIMESD {ra:(), rb:empty { ra:{ key:int,
            value:int }, rb:int, rc:int } @ { Collection }, rc:true}).fold
          ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:6, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }).combine (let
          sender_count =
          (route_to_int {key:4, value:Some S_B}).fold ((\count -> (\b3 ->
            bind b3 as {i:ip} in count + 1))) 0 in
          ((shuffle_ATIMESD_mS1_to_ATIMESD_mT1 {ra:Some S_C, rb:empty { ra:{
              key:int, value:int }, rb:int, rc:int } @ { Collection }, rc:true}).fold
            ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {ra:ip, rb:7, rc:sender_count};_accmap)))) empty {
            ra:address, rb:int, rc:int } @ { Collection }).combine (let
            sender_count =
            (route_to_int {key:5, value:Some S_C}).fold ((\count -> (\b3 ->
              bind b3 as {i:ip} in count + 1))) 0 in
            (shuffle_ATIMESD_mS2_to_ATIMESD_mR1 {ra:Some S_B, rb:empty { ra:{
               key:int, value:int }, rb:int, rc:int } @ { Collection },
               rc:true}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
              value:tuples} in 
              (_accmap.insert {ra:ip, rb:9, rc:sender_count};_accmap))))
              empty { ra:address, rb:int, rc:int } @ { Collection }))))).groupBy
      ((\b1 -> bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip,
      value:stmt_id})) ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id,
      rc:count} in acc + count))) 0).groupBy ((\b1 -> bind b1 as {key:b2,
      value:count} in bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc ->
      (\b3 -> bind b3 as {key:ip_and_stmt_id, value:count} in bind
      ip_and_stmt_id as {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_insert_S_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid, rd:S_B,
       re:S_C};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_int {key:5, value:Some S_C}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:9, rb:5, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int {key:4, value:Some S_B}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:7, rb:4, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int {key:5, value:Some S_C}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:6, rb:5, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int {key:4, value:Some S_B}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:6, rb:4, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine empty {
      ra:int, rb:int, rc:address } @ { Collection })))).groupBy ((\b1 ->
      bind b1 as {ra:stmt_id, rb:map_id, rc:ip} in ip)) ((\acc -> (\b3 ->
      bind b3 as {ra:stmt_id, rb:map_id, rc:ip} in 
      (acc.insert {key:stmt_id, value:map_id};acc)))) empty { key:int,
      value:int } @ { Collection }).iterate ((\b1 -> bind b1 as {key:ip,
      value:stmt_map_ids} in (nd_insert_S_rcv_fetch, ip)<- {ra:stmt_map_ids,
      rb:vid, rc:S_B, rd:S_C}))))}{None ->
                                    error
                                      (print
                                         "unexpected missing arguments in sw_buf_insert_S")})


declare nd_insert_S_do_complete_s6 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in let
  __prod_ret__8 =
  (let wrapped_lookup_value =
    bind map_ATIMESD_mS1_s6_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == S_B))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * let
    wrapped_lookup_value =
    bind map_ATIMESD_mS2_s6_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == S_C))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0} in
  ((nd_add_delta_to_int {ra:ATIMESD, rb:false, rc:vid, rd:{|i:int|
      __prod_ret__8|} @ { Collection }});
   (nd_complete_stmt_cntr_check {key:vid, value:6})))


declare nd_insert_S_do_complete_s7 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in let
  __map_ret__7 =
  let wrapped_lookup_value =
    bind map_ATIMESD_mS1_s7_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == S_B))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0} in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mT1, rb:false, rc:vid, rd:{| key:int,
      value:int | {key:S_C, value:__map_ret__7}|} @ { Collection }});
   let sent_msgs =
   nd_ATIMESD_mT1_send_correctives {ra:me, rb:7, rc:vid, rd:1, re:vid, rf:{|
     key:int, value:int | {key:S_C, value:__map_ret__7}|} @ { Collection }} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:7}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:7, rc:1, rd:sent_msgs, re:true,
         rf:false}))


declare nd_insert_S_do_complete_s9 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in let
  __map_ret__8 =
  let wrapped_lookup_value =
    bind map_ATIMESD_mS2_s9_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == S_C))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0} in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mR1, rb:false, rc:vid, rd:{| key:int,
      value:int | {key:S_B, value:__map_ret__8}|} @ { Collection }});
   let sent_msgs =
   nd_ATIMESD_mR1_send_correctives {ra:me, rb:9, rc:vid, rd:1, re:vid, rf:{|
     key:int, value:int | {key:S_B, value:__map_ret__8}|} @ { Collection }} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:9}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:9, rc:1, rd:sent_msgs, re:true,
         rf:false}))


declare nd_insert_S_do_complete_s8 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in let
  __val_ret__10 = 1 in
  ((nd_add_delta_to_int_int_int {ra:ATIMESD_mT1_mR1, rb:false, rc:vid, rd:{|
      ra:int, rb:int, rc:int | {ra:S_B, rb:S_C,
      rc:__val_ret__10}|} @ { Collection }});
   let sent_msgs =
   nd_ATIMESD_mT1_mR1_send_correctives {ra:me, rb:8, rc:vid, rd:1, re:vid,
     rf:{| ra:int, rb:int, rc:int | {ra:S_B, rb:S_C,
     rc:__val_ret__10}|} @ { Collection }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:8, rc:1, rd:sent_msgs, re:true,
         rf:true}))


declare insert_S_do_corrective_s6_m_ATIMESD_mS1 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int, rg:int,
  rh:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:S_B, rg:S_C, rh:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_ATIMESD_mSS_B,
    value:delta_ATIMESD_mS1} in _accext.combine (let __prod_ret__31 =
    ((if S_B == delta_ATIMESD_mSS_B then 1 else 0) * let wrapped_lookup_value =
      bind map_ATIMESD_mS2_s6_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == S_C))}).fold ((\acc ->
          (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) *
      delta_ATIMESD_mS1 in {|i:int| __prod_ret__31|} @ { Collection }))))
    empty {i:int} @ { Collection }).filter ((\b1 -> bind b1 as {i:map_val} in 0
    != map_val)) in
  ((nd_add_delta_to_int {ra:ATIMESD, rb:true, rc:vid, rd:new_tuples});0))


declare insert_S_do_corrective_s6_m_ATIMESD_mS2 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int, rg:int,
  rh:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:S_B, rg:S_C, rh:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_ATIMESD_mSS_C,
    value:delta_ATIMESD_mS2} in _accext.combine (let __prod_ret__37 =
    ((if S_C == delta_ATIMESD_mSS_C then 1 else 0) * let wrapped_lookup_value =
      bind map_ATIMESD_mS1_s6_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == S_B))}).fold ((\acc ->
          (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) *
      delta_ATIMESD_mS2 in {|i:int| __prod_ret__37|} @ { Collection }))))
    empty {i:int} @ { Collection }).filter ((\b1 -> bind b1 as {i:map_val} in 0
    != map_val)) in
  ((nd_add_delta_to_int {ra:ATIMESD, rb:true, rc:vid, rd:new_tuples});0))


declare insert_S_do_corrective_s7_m_ATIMESD_mS1 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int, rg:int,
  rh:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:S_B, rg:S_C, rh:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_ATIMESD_mSS_B,
    value:delta_ATIMESD_mS1} in _accext.combine (let __prod_ret__32 =
    (if S_B == delta_ATIMESD_mSS_B then 1 else 0) * delta_ATIMESD_mS1 in
    {| key:int, value:int | {key:S_C, value:__prod_ret__32}|} @ { Collection }))))
    empty { key:int, value:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {key:map_0, value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mT1, rb:true, rc:vid, rd:new_tuples});
   (nd_ATIMESD_mT1_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_S_do_corrective_s9_m_ATIMESD_mS2 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int, rg:int,
  rh:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:S_B, rg:S_C, rh:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_ATIMESD_mSS_C,
    value:delta_ATIMESD_mS2} in _accext.combine (let __prod_ret__38 =
    (if S_C == delta_ATIMESD_mSS_C then 1 else 0) * delta_ATIMESD_mS2 in
    {| key:int, value:int | {key:S_B, value:__prod_ret__38}|} @ { Collection }))))
    empty { key:int, value:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {key:map_0, value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mR1, rb:true, rc:vid, rd:new_tuples});
   (nd_ATIMESD_mR1_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare sw_delete_S : { key:int, value:int } -> () = (\args ->
  (sw_buf_delete_S.insert args;
   sw_trig_buf_idx.insert {i:3};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_delete_S_send_fetch : { key:int, value:int } -> () = (\vid -> case
  (sw_buf_delete_S.peek ()) of
  {Some args ->
    (sw_buf_delete_S.erase args;
     bind args as {key:S_B, value:S_C} in
     ((route_to_int_int {ra:3, rb:Some S_B, rc:Some S_C}).iterate ((\b1 ->
      bind b1 as {i:ip} in (nd_delete_S_do_complete_s12_trig, ip)<- {ra:vid,
      rb:S_B, rc:S_C}));
      ((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_int {key:4, value:Some S_B}).fold ((\count -> (\b3 ->
        bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_ATIMESD_mS1_to_ATIMESD {ra:(), rb:empty { ra:{ key:int,
          value:int }, rb:int, rc:int } @ { Collection }, rc:true}).fold
        ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:10, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_int {key:5, value:Some S_C}).fold ((\count -> (\b3 ->
          bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_ATIMESD_mS2_to_ATIMESD {ra:(), rb:empty { ra:{ key:int,
            value:int }, rb:int, rc:int } @ { Collection }, rc:true}).fold
          ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:10, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }).combine (let
          sender_count =
          (route_to_int {key:4, value:Some S_B}).fold ((\count -> (\b3 ->
            bind b3 as {i:ip} in count + 1))) 0 in
          ((shuffle_ATIMESD_mS1_to_ATIMESD_mT1 {ra:Some S_C, rb:empty { ra:{
              key:int, value:int }, rb:int, rc:int } @ { Collection }, rc:true}).fold
            ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {ra:ip, rb:11, rc:sender_count};_accmap)))) empty {
            ra:address, rb:int, rc:int } @ { Collection }).combine (let
            sender_count =
            (route_to_int {key:5, value:Some S_C}).fold ((\count -> (\b3 ->
              bind b3 as {i:ip} in count + 1))) 0 in
            (shuffle_ATIMESD_mS2_to_ATIMESD_mR1 {ra:Some S_B, rb:empty { ra:{
               key:int, value:int }, rb:int, rc:int } @ { Collection },
               rc:true}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
              value:tuples} in 
              (_accmap.insert {ra:ip, rb:13, rc:sender_count};_accmap))))
              empty { ra:address, rb:int, rc:int } @ { Collection }))))).groupBy
      ((\b1 -> bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip,
      value:stmt_id})) ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id,
      rc:count} in acc + count))) 0).groupBy ((\b1 -> bind b1 as {key:b2,
      value:count} in bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc ->
      (\b3 -> bind b3 as {key:ip_and_stmt_id, value:count} in bind
      ip_and_stmt_id as {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_delete_S_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid, rd:S_B,
       re:S_C};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_int {key:5, value:Some S_C}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:13, rb:5, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int {key:4, value:Some S_B}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:11, rb:4, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int {key:5, value:Some S_C}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:10, rb:5, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int {key:4, value:Some S_B}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:10, rb:4, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine empty {
      ra:int, rb:int, rc:address } @ { Collection })))).groupBy ((\b1 ->
      bind b1 as {ra:stmt_id, rb:map_id, rc:ip} in ip)) ((\acc -> (\b3 ->
      bind b3 as {ra:stmt_id, rb:map_id, rc:ip} in 
      (acc.insert {key:stmt_id, value:map_id};acc)))) empty { key:int,
      value:int } @ { Collection }).iterate ((\b1 -> bind b1 as {key:ip,
      value:stmt_map_ids} in (nd_delete_S_rcv_fetch, ip)<- {ra:stmt_map_ids,
      rb:vid, rc:S_B, rd:S_C}))))}{None ->
                                    error
                                      (print
                                         "unexpected missing arguments in sw_buf_delete_S")})


declare nd_delete_S_do_complete_s10 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in let
  __prod_ret__10 =
  ((let wrapped_lookup_value =
    bind map_ATIMESD_mS1_s10_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == S_B))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * let
    wrapped_lookup_value =
    bind map_ATIMESD_mS2_s10_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == S_C))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * -1 in
  ((nd_add_delta_to_int {ra:ATIMESD, rb:false, rc:vid, rd:{|i:int|
      __prod_ret__10|} @ { Collection }});
   (nd_complete_stmt_cntr_check {key:vid, value:10})))


declare nd_delete_S_do_complete_s11 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in let
  __prod_ret__11 =
  (let wrapped_lookup_value =
    bind map_ATIMESD_mS1_s11_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == S_B))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * -1 in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mT1, rb:false, rc:vid, rd:{| key:int,
      value:int | {key:S_C, value:__prod_ret__11}|} @ { Collection }});
   let sent_msgs =
   nd_ATIMESD_mT1_send_correctives {ra:me, rb:11, rc:vid, rd:1, re:vid, rf:{|
     key:int, value:int | {key:S_C, value:__prod_ret__11}|} @ { Collection }}
   in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:11}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:11, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_S_do_complete_s13 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in let
  __prod_ret__12 =
  (let wrapped_lookup_value =
    bind map_ATIMESD_mS2_s13_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == S_C))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * -1 in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mR1, rb:false, rc:vid, rd:{| key:int,
      value:int | {key:S_B, value:__prod_ret__12}|} @ { Collection }});
   let sent_msgs =
   nd_ATIMESD_mR1_send_correctives {ra:me, rb:13, rc:vid, rd:1, re:vid, rf:{|
     key:int, value:int | {key:S_B, value:__prod_ret__12}|} @ { Collection }}
   in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:13}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:13, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_S_do_complete_s12 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in let
  __val_ret__13 = -1 in
  ((nd_add_delta_to_int_int_int {ra:ATIMESD_mT1_mR1, rb:false, rc:vid, rd:{|
      ra:int, rb:int, rc:int | {ra:S_B, rb:S_C,
      rc:__val_ret__13}|} @ { Collection }});
   let sent_msgs =
   nd_ATIMESD_mT1_mR1_send_correctives {ra:me, rb:12, rc:vid, rd:1, re:vid,
     rf:{| ra:int, rb:int, rc:int | {ra:S_B, rb:S_C,
     rc:__val_ret__13}|} @ { Collection }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:12, rc:1, rd:sent_msgs,
         re:true, rf:true}))


declare delete_S_do_corrective_s10_m_ATIMESD_mS1 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int, rg:int,
  rh:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:S_B, rg:S_C, rh:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_ATIMESD_mSS_B,
    value:delta_ATIMESD_mS1} in _accext.combine (let __prod_ret__44 =
    ((if S_B == delta_ATIMESD_mSS_B then 1 else 0) * let wrapped_lookup_value =
      bind map_ATIMESD_mS2_s10_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == S_C))}).fold ((\acc ->
          (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) *
      -delta_ATIMESD_mS1 in {|i:int| __prod_ret__44|} @ { Collection }))))
    empty {i:int} @ { Collection }).filter ((\b1 -> bind b1 as {i:map_val} in 0
    != map_val)) in
  ((nd_add_delta_to_int {ra:ATIMESD, rb:true, rc:vid, rd:new_tuples});0))


declare delete_S_do_corrective_s10_m_ATIMESD_mS2 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int, rg:int,
  rh:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:S_B, rg:S_C, rh:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_ATIMESD_mSS_C,
    value:delta_ATIMESD_mS2} in _accext.combine (let __prod_ret__54 =
    ((if S_C == delta_ATIMESD_mSS_C then 1 else 0) * let wrapped_lookup_value =
      bind map_ATIMESD_mS1_s10_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == S_B))}).fold ((\acc ->
          (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) *
      -delta_ATIMESD_mS2 in {|i:int| __prod_ret__54|} @ { Collection }))))
    empty {i:int} @ { Collection }).filter ((\b1 -> bind b1 as {i:map_val} in 0
    != map_val)) in
  ((nd_add_delta_to_int {ra:ATIMESD, rb:true, rc:vid, rd:new_tuples});0))


declare delete_S_do_corrective_s11_m_ATIMESD_mS1 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int, rg:int,
  rh:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:S_B, rg:S_C, rh:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_ATIMESD_mSS_B,
    value:delta_ATIMESD_mS1} in _accext.combine (let __prod_ret__46 =
    (if S_B == delta_ATIMESD_mSS_B then 1 else 0) * -delta_ATIMESD_mS1 in
    {| key:int, value:int | {key:S_C, value:__prod_ret__46}|} @ { Collection }))))
    empty { key:int, value:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {key:map_0, value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mT1, rb:true, rc:vid, rd:new_tuples});
   (nd_ATIMESD_mT1_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_S_do_corrective_s13_m_ATIMESD_mS2 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int, rg:int,
  rh:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:S_B, rg:S_C, rh:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_ATIMESD_mSS_C,
    value:delta_ATIMESD_mS2} in _accext.combine (let __prod_ret__56 =
    (if S_C == delta_ATIMESD_mSS_C then 1 else 0) * -delta_ATIMESD_mS2 in
    {| key:int, value:int | {key:S_B, value:__prod_ret__56}|} @ { Collection }))))
    empty { key:int, value:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {key:map_0, value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mR1, rb:true, rc:vid, rd:new_tuples});
   (nd_ATIMESD_mR1_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare sw_insert_R : { key:int, value:int } -> () = (\args ->
  (sw_buf_insert_R.insert args;
   sw_trig_buf_idx.insert {i:4};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_insert_R_send_fetch : { key:int, value:int } -> () = (\vid -> case
  (sw_buf_insert_R.peek ()) of
  {Some args ->
    (sw_buf_insert_R.erase args;
     bind args as {key:R_A, value:R_B} in
     ((route_to_int {key:4, value:Some R_B}).iterate ((\b1 ->
      bind b1 as {i:ip} in (nd_insert_R_do_complete_s16_trig, ip)<- {ra:vid,
      rb:R_A, rc:R_B}));
      ((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_int {key:6, value:Some R_B}).fold ((\count -> (\b3 ->
        bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_ATIMESD_mR1_to_ATIMESD {ra:(), rb:empty { ra:{ key:int,
          value:int }, rb:int, rc:int } @ { Collection }, rc:true}).fold
        ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:14, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_int_int {ra:3, rb:Some R_B, rc:None immut}).fold ((\count ->
          (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
        (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mT1_bind_0t1 {ra:None immut,
           rb:empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
           } @ { Collection }, rc:true}).fold ((\_accmap -> (\b3 ->
          bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:15, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }))).groupBy ((\b1 ->
      bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip, value:stmt_id}))
      ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id, rc:count} in acc +
      count))) 0).groupBy ((\b1 -> bind b1 as {key:b2, value:count} in 
      bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc -> (\b3 ->
      bind b3 as {key:ip_and_stmt_id, value:count} in bind ip_and_stmt_id as
      {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_insert_R_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid, rd:R_A,
       re:R_B};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_int_int {ra:3, rb:Some R_B, rc:None immut}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:15, rb:3, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:6, value:Some R_B}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:14, rb:6, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine empty {
      ra:int, rb:int, rc:address } @ { Collection })).groupBy ((\b1 ->
      bind b1 as {ra:stmt_id, rb:map_id, rc:ip} in ip)) ((\acc -> (\b3 ->
      bind b3 as {ra:stmt_id, rb:map_id, rc:ip} in 
      (acc.insert {key:stmt_id, value:map_id};acc)))) empty { key:int,
      value:int } @ { Collection }).iterate ((\b1 -> bind b1 as {key:ip,
      value:stmt_map_ids} in (nd_insert_R_rcv_fetch, ip)<- {ra:stmt_map_ids,
      rb:vid, rc:R_A, rd:R_B}))))}{None ->
                                    error
                                      (print
                                         "unexpected missing arguments in sw_buf_insert_R")})


declare nd_insert_R_do_complete_s14 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:R_A, rc:R_B} in let
  __prod_ret__13 =
  (let wrapped_lookup_value =
    bind map_ATIMESD_mR1_s14_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == R_B))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * R_A in
  ((nd_add_delta_to_int {ra:ATIMESD, rb:false, rc:vid, rd:{|i:int|
      __prod_ret__13|} @ { Collection }});
   (nd_complete_stmt_cntr_check {key:vid, value:14})))


declare nd_insert_R_do_complete_s15 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:R_A, rc:R_B} in let
  delta_values =
  (((bind map_ATIMESD_mT1_mR1_s15_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == R_B))}).fold ((\acc ->
      (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:R_B, rb:ATIMESD_mTT_C, rc:__map_ret__14} in 
    (_accmap.insert {key:ATIMESD_mTT_C, value:__map_ret__14};_accmap))))
    empty { key:int, value:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:ATIMESD_mTT_C, value:__map_ret__14} in 
    (_accmap.insert {key:ATIMESD_mTT_C, value:__map_ret__14 * R_A};_accmap))))
    empty { key:int, value:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:ATIMESD_mTT_C, value:__prod_ret__14} in 
    (_accmap.insert {key:ATIMESD_mTT_C, value:__prod_ret__14};_accmap))))
    empty { key:int, value:int } @ { Collection } in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mT1, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_ATIMESD_mT1_send_correctives {ra:me, rb:15, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:15}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:15, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_R_do_complete_s16 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:R_A, rc:R_B} in let
  __val_ret__17 = R_A in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mS1, rb:false, rc:vid, rd:{| key:int,
      value:int | {key:R_B, value:__val_ret__17}|} @ { Collection }});
   let sent_msgs =
   nd_ATIMESD_mS1_send_correctives {ra:me, rb:16, rc:vid, rd:1, re:vid, rf:{|
     key:int, value:int | {key:R_B, value:__val_ret__17}|} @ { Collection }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:16, rc:1, rd:sent_msgs,
         re:true, rf:true}))


declare insert_R_do_corrective_s14_m_ATIMESD_mR1 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int, rg:int,
  rh:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:R_A, rg:R_B, rh:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_ATIMESD_mRR_B,
    value:delta_ATIMESD_mR1} in _accext.combine (let __prod_ret__21 =
    ((if R_B == delta_ATIMESD_mRR_B then 1 else 0) * delta_ATIMESD_mR1) * R_A
    in {|i:int| __prod_ret__21|} @ { Collection }))))
    empty {i:int} @ { Collection }).filter ((\b1 -> bind b1 as {i:map_val} in 0
    != map_val)) in
  ((nd_add_delta_to_int {ra:ATIMESD, rb:true, rc:vid, rd:new_tuples});0))


declare insert_R_do_corrective_s15_m_ATIMESD_mT1_mR1 : { ra:address, rb:int,
  rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int, rg:int,
  rh:collection { ra:int, rb:int, rc:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:R_A, rg:R_B, rh:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_ATIMESD_mT1_mRR_B, rb:delta_ATIMESD_mTT_C,
    rc:delta_ATIMESD_mT1_mR1} in _accext.combine (let __prod_ret__23 =
    ((if R_B == delta_ATIMESD_mT1_mRR_B then 1 else 0) * delta_ATIMESD_mT1_mR1)
      * R_A in
    {| key:int, value:int | {key:delta_ATIMESD_mTT_C,
      value:__prod_ret__23}|} @ { Collection })))) empty { key:int, value:int
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mT1, rb:true, rc:vid, rd:new_tuples});
   (nd_ATIMESD_mT1_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare sw_delete_R : { key:int, value:int } -> () = (\args ->
  (sw_buf_delete_R.insert args;
   sw_trig_buf_idx.insert {i:5};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_delete_R_send_fetch : { key:int, value:int } -> () = (\vid -> case
  (sw_buf_delete_R.peek ()) of
  {Some args ->
    (sw_buf_delete_R.erase args;
     bind args as {key:R_A, value:R_B} in
     ((route_to_int {key:4, value:Some R_B}).iterate ((\b1 ->
      bind b1 as {i:ip} in (nd_delete_R_do_complete_s19_trig, ip)<- {ra:vid,
      rb:R_A, rc:R_B}));
      ((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_int {key:6, value:Some R_B}).fold ((\count -> (\b3 ->
        bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_ATIMESD_mR1_to_ATIMESD {ra:(), rb:empty { ra:{ key:int,
          value:int }, rb:int, rc:int } @ { Collection }, rc:true}).fold
        ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:17, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_int_int {ra:3, rb:Some R_B, rc:None immut}).fold ((\count ->
          (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
        (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mT1_bind_0t1 {ra:None immut,
           rb:empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
           } @ { Collection }, rc:true}).fold ((\_accmap -> (\b3 ->
          bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:18, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }))).groupBy ((\b1 ->
      bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip, value:stmt_id}))
      ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id, rc:count} in acc +
      count))) 0).groupBy ((\b1 -> bind b1 as {key:b2, value:count} in 
      bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc -> (\b3 ->
      bind b3 as {key:ip_and_stmt_id, value:count} in bind ip_and_stmt_id as
      {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_delete_R_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid, rd:R_A,
       re:R_B};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_int_int {ra:3, rb:Some R_B, rc:None immut}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:18, rb:3, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:6, value:Some R_B}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:17, rb:6, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine empty {
      ra:int, rb:int, rc:address } @ { Collection })).groupBy ((\b1 ->
      bind b1 as {ra:stmt_id, rb:map_id, rc:ip} in ip)) ((\acc -> (\b3 ->
      bind b3 as {ra:stmt_id, rb:map_id, rc:ip} in 
      (acc.insert {key:stmt_id, value:map_id};acc)))) empty { key:int,
      value:int } @ { Collection }).iterate ((\b1 -> bind b1 as {key:ip,
      value:stmt_map_ids} in (nd_delete_R_rcv_fetch, ip)<- {ra:stmt_map_ids,
      rb:vid, rc:R_A, rd:R_B}))))}{None ->
                                    error
                                      (print
                                         "unexpected missing arguments in sw_buf_delete_R")})


declare nd_delete_R_do_complete_s17 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:R_A, rc:R_B} in let
  __prod_ret__16 =
  (let wrapped_lookup_value =
    bind map_ATIMESD_mR1_s17_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == R_B))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * -R_A
  in
  ((nd_add_delta_to_int {ra:ATIMESD, rb:false, rc:vid, rd:{|i:int|
      __prod_ret__16|} @ { Collection }});
   (nd_complete_stmt_cntr_check {key:vid, value:17})))


declare nd_delete_R_do_complete_s18 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:R_A, rc:R_B} in let
  delta_values =
  (((bind map_ATIMESD_mT1_mR1_s18_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == R_B))}).fold ((\acc ->
      (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:R_B, rb:ATIMESD_mTT_C, rc:__map_ret__16} in 
    (_accmap.insert {key:ATIMESD_mTT_C, value:__map_ret__16};_accmap))))
    empty { key:int, value:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:ATIMESD_mTT_C, value:__map_ret__16} in 
    (_accmap.insert {key:ATIMESD_mTT_C, value:__map_ret__16 * -R_A};_accmap))))
    empty { key:int, value:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:ATIMESD_mTT_C, value:__prod_ret__18} in 
    (_accmap.insert {key:ATIMESD_mTT_C, value:__prod_ret__18};_accmap))))
    empty { key:int, value:int } @ { Collection } in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mT1, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_ATIMESD_mT1_send_correctives {ra:me, rb:18, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:18}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:18, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_R_do_complete_s19 : { ra:{ key:int, value:int }, rb:int,
  rc:int } -> () = (\b1 -> bind b1 as {ra:vid, rb:R_A, rc:R_B} in let
  __prod_ret__19 = -R_A in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mS1, rb:false, rc:vid, rd:{| key:int,
      value:int | {key:R_B, value:__prod_ret__19}|} @ { Collection }});
   let sent_msgs =
   nd_ATIMESD_mS1_send_correctives {ra:me, rb:19, rc:vid, rd:1, re:vid, rf:{|
     key:int, value:int | {key:R_B, value:__prod_ret__19}|} @ { Collection }}
   in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:19, rc:1, rd:sent_msgs,
         re:true, rf:true}))


declare delete_R_do_corrective_s17_m_ATIMESD_mR1 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int, rg:int,
  rh:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:R_A, rg:R_B, rh:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_ATIMESD_mRR_B,
    value:delta_ATIMESD_mR1} in _accext.combine (let __prod_ret__26 =
    (if R_B == delta_ATIMESD_mRR_B then 1 else 0) * (-delta_ATIMESD_mR1 * R_A)
    in {|i:int| __prod_ret__26|} @ { Collection }))))
    empty {i:int} @ { Collection }).filter ((\b1 -> bind b1 as {i:map_val} in 0
    != map_val)) in
  ((nd_add_delta_to_int {ra:ATIMESD, rb:true, rc:vid, rd:new_tuples});0))


declare delete_R_do_corrective_s18_m_ATIMESD_mT1_mR1 : { ra:address, rb:int,
  rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int, rg:int,
  rh:collection { ra:int, rb:int, rc:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:R_A, rg:R_B, rh:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_ATIMESD_mT1_mRR_B, rb:delta_ATIMESD_mTT_C,
    rc:delta_ATIMESD_mT1_mR1} in _accext.combine (let __prod_ret__29 =
    (if R_B == delta_ATIMESD_mT1_mRR_B then 1 else 0) * (-delta_ATIMESD_mT1_mR1
      * R_A) in
    {| key:int, value:int | {key:delta_ATIMESD_mTT_C,
      value:__prod_ret__29}|} @ { Collection })))) empty { key:int, value:int
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int {ra:ATIMESD_mT1, rb:true, rc:vid, rd:new_tuples});
   (nd_ATIMESD_mT1_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


trigger ms_rcv_sw_init_ack : () = (\_u ->
  (ms_rcv_sw_init_ack_cnt = ms_rcv_sw_init_ack_cnt + 1;
   (if ms_rcv_sw_init_ack_cnt == num_switches
   then
     (ms_start_time = now_int ();
      (sw_rcv_token, sw_next_switch_addr)<- g_start_vid;
      (tm_insert_timer, timer_addr)<- {ra:ms_gc_interval, rb:0, rc:me})
   else ())))
trigger sw_rcv_init : () = (\_u ->
  (sw_init = true;
   (sw_driver_trig, me)<- ();
   (ms_rcv_sw_init_ack, master_addr)<- ()))
trigger ms_rcv_jobs_ack : () = (\_u ->
  (ms_rcv_jobs_ack_cnt = ms_rcv_jobs_ack_cnt + 1;
   (if ms_rcv_jobs_ack_cnt == num_peers
   then
     (switches.iterate ((\b1 -> bind b1 as {i:addr} in 
      (sw_rcv_init, addr)<- ()))) else ())))
trigger rcv_jobs : collection { key:address, value:int } @ { Map } =
  (\jobs_in ->
  (jobs = jobs_in;
   timer_addr = case ((jobs.filter ((\b1 -> bind b1 as {key:addr,
   value:job} in job == job_timer))).peek ()) of
   {Some timer -> timer.key}{None -> error (print "no timer peer found")};
   nodes = (jobs.filter ((\b1 -> bind b1 as {key:addr, value:job} in job ==
   job_node))).fold ((\_accmap -> (\x ->
   (_accmap.insert ({i:x.key});_accmap)))) empty {i:address} @ { Collection };
   num_nodes = nodes.size ();
   switches = (jobs.filter ((\b1 -> bind b1 as {key:addr, value:job} in job ==
   job_switch))).fold ((\_accmap -> (\x ->
   (_accmap.insert ({i:x.key});_accmap)))) empty {i:address} @ { Collection };
   num_switches = switches.size ();
   (if job <= job_switch
   then sw_next_switch_addr = let addr_list =
     (switches.fold ((\acc_conv -> (\b3 -> bind b3 as {i:x} in 
       (acc_conv.insert {i:x};acc_conv)))) empty {i:address} @ { Seq }).sort
       ((\b2 -> (\b3 -> bind b2 as {i:addr1} in bind b3 as {i:addr2} in 
       if addr1 < addr2 then -1 else 1))) in
     case (addr_list.peek ()) of
       {Some first_addr -> (addr_list.fold ((\b2 -> (\b5 ->
         bind b2 as {key:take, value:result} in bind b5 as {i:x} in if take
         then {key:false, value:x}
         else if x == me then {key:true, value:result}
           else {key:take, value:result}))) {key:false,
         value:first_addr.i}).value}{None ->
                                      error (print "no addresses in addr_list")}
   else ());
   nodes.iterate ((\b1 -> bind b1 as {i:addr} in add_node addr));
   (ms_rcv_jobs_ack, master_addr)<- ()))
trigger ms_rcv_job : { key:address, value:int } = (\b1 -> bind b1 as {key:addr,
  value:job} in 
  (jobs.insert {key:addr, value:job};
   ms_rcv_job_cnt = ms_rcv_job_cnt + 1;
   (if ms_rcv_job_cnt == num_peers
   then my_peers.iterate ((\b1 -> bind b1 as {i:addr} in 
     (rcv_jobs, addr)<- jobs)) else ())))
trigger rcv_master_addr : address = (\addr ->
  (master_addr = addr;(ms_rcv_job, addr)<- {key:me, value:job}))
trigger ms_send_addr_self : () = (\_u -> my_peers.iterate ((\b1 ->
  bind b1 as {i:addr} in (rcv_master_addr, addr)<- me)))
trigger shutdown_trig : () = (\_u -> haltEngine ())
trigger ms_shutdown : () = (\_u -> if ms_rcv_node_done_cnt == num_nodes
  then my_peers.iterate ((\b1 -> bind b1 as {i:addr} in 
    (shutdown_trig, addr)<- ())) else ())
trigger ms_rcv_node_done : bool = (\done -> if done
  then
    (ms_rcv_node_done_cnt = ms_rcv_node_done_cnt + 1;
     (if ms_rcv_node_done_cnt == num_nodes
     then (ms_end_time = now_int ();(ms_shutdown, me)<- ()) else ()))
  else ms_rcv_node_done_cnt = ms_rcv_node_done_cnt - 1)
trigger nd_rcv_done : () = (\_u ->
  (nd_rcvd_sys_done = true;
   (if not nd_sent_done and nd_stmt_cntrs.size () == 0
   then ((ms_rcv_node_done, master_addr)<- true;nd_sent_done = true) 
   else ())))
trigger ms_rcv_switch_done : () = (\_u ->
  (ms_rcv_switch_done_cnt = ms_rcv_switch_done_cnt + 1;
   (if ms_rcv_switch_done_cnt == num_switches
   then nodes.iterate ((\b1 -> bind b1 as {i:addr} in 
     (nd_rcv_done, addr)<- ())) else ())))
trigger sw_ack_rcv : { key:address, value:{ key:int, value:int } } = (\b1 ->
  bind b1 as {key:addr, value:vid} in 
  (sw_num_ack = sw_num_ack + 1;
   (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key, value:value} in key
   == vid))).peek ()) of
   {Some x -> if x.value == 0 then sw_ack_log.erase x
     else sw_ack_log.update x {key:vid, value:x.value - 1}}{None -> ()});
   (if not sw_sent_done and (sw_trig_buf_idx.size () == 0 and (sw_num_ack ==
      sw_num_sent and sw_seen_sentry == true))
   then ((ms_rcv_switch_done, master_addr)<- ();sw_sent_done = true) 
   else ())))
trigger ms_rcv_gc_vid : { key:address, value:{ key:int, value:int } } =
  (\data ->
  (ms_gc_vid_map.insert data;
   ms_gc_vid_ctr = ms_gc_vid_ctr + 1;
   (if ms_gc_vid_ctr >= ms_num_gc_expected
   then let min_vid =
     ms_gc_vid_map.fold ((\min_vid -> (\b3 -> bind b3 as {key:addr,
       value:vid} in if min_vid < vid then min_vid else vid))) g_min_vid in
     (ms_gc_vid_ctr = 0;
      ms_gc_vid_map = empty { key:address, value:{ key:int, value:int }
      } @ { Map };
      my_peers.iterate ((\b1 -> bind b1 as {i:addr} in 
      (do_gc, addr)<- min_vid));
      (tm_insert_timer, timer_addr)<- {ra:ms_gc_interval, rb:0, rc:me})
   else ())))
trigger rcv_req_gc_vid : () = (\_u -> if job == job_switch or job == job_master
  then (ms_rcv_gc_vid, master_addr)<- {key:me, value:sw_ack_log.fold
    ((\min_vid -> (\b3 -> bind b3 as {key:vid, value:count} in if min_vid < vid
    then min_vid else vid))) sw_highest_vid}
  else if job == job_node
    then (ms_rcv_gc_vid, master_addr)<- {key:me, value:nd_stmt_cntrs.fold
      ((\min_vid -> (\b3 -> bind b3 as {key:vid_stmt_id, value:ctr_corrs} in 
      if min_vid < vid_stmt_id.key then min_vid else vid_stmt_id.key)))
      g_max_vid} else ())
trigger ms_send_gc_req : () = (\_u -> my_peers.iterate ((\b1 ->
  bind b1 as {i:addr} in (rcv_req_gc_vid, addr)<- ())))
trigger do_gc : { key:int, value:int } = (\min_gc_vid ->
  ((do_gc_nd_log_master min_gc_vid);
   (do_gc_nd_log_insert_T min_gc_vid);
   (do_gc_nd_log_delete_T min_gc_vid);
   (do_gc_nd_log_insert_S min_gc_vid);
   (do_gc_nd_log_delete_S min_gc_vid);
   (do_gc_nd_log_insert_R min_gc_vid);
   (do_gc_nd_log_delete_R min_gc_vid);
   (do_gc_map_ATIMESD_mT1_s0_buf min_gc_vid);
   (do_gc_map_ATIMESD_mT1_mR1_s2_buf min_gc_vid);
   (do_gc_map_ATIMESD_mT1_s3_buf min_gc_vid);
   (do_gc_map_ATIMESD_mT1_mR1_s5_buf min_gc_vid);
   (do_gc_map_ATIMESD_mS1_s6_buf min_gc_vid);
   (do_gc_map_ATIMESD_mS2_s6_buf min_gc_vid);
   (do_gc_map_ATIMESD_mS1_s7_buf min_gc_vid);
   (do_gc_map_ATIMESD_mS2_s9_buf min_gc_vid);
   (do_gc_map_ATIMESD_mS1_s10_buf min_gc_vid);
   (do_gc_map_ATIMESD_mS2_s10_buf min_gc_vid);
   (do_gc_map_ATIMESD_mS1_s11_buf min_gc_vid);
   (do_gc_map_ATIMESD_mS2_s13_buf min_gc_vid);
   (do_gc_map_ATIMESD_mR1_s14_buf min_gc_vid);
   (do_gc_map_ATIMESD_mT1_mR1_s15_buf min_gc_vid);
   (do_gc_map_ATIMESD_mR1_s17_buf min_gc_vid);
   (do_gc_map_ATIMESD_mT1_mR1_s18_buf min_gc_vid);
   (do_gc_map_ATIMESD_mS2_s24_buf min_gc_vid);
   (do_gc_map_ATIMESD_mS2_s26_buf min_gc_vid);
   (do_gc_map_ATIMESD_mS1_s28_buf min_gc_vid);
   (do_gc_map_ATIMESD_mS1_s30_buf min_gc_vid);
   (do_gc_map_ATIMESD_mS2_s32_buf min_gc_vid);
   (do_gc_map_ATIMESD_mS2_s34_buf min_gc_vid);
   (do_gc_map_ATIMESD_mS1_s36_buf min_gc_vid);
   (do_gc_map_ATIMESD_mS1_s38_buf min_gc_vid);
   (do_gc_ATIMESD min_gc_vid);
   (do_gc_ATIMESD_mT1 min_gc_vid);
   (do_gc_ATIMESD_mT1_mR1 min_gc_vid);
   (do_gc_ATIMESD_mS1 min_gc_vid);
   (do_gc_ATIMESD_mS2 min_gc_vid);
   (do_gc_ATIMESD_mR1 min_gc_vid)))
trigger sw_rcv_token : { key:int, value:int } = (\vid ->
  if sw_need_vid_cntr > 0
  then let next_vid = {key:vid.key, value:vid.value + sw_need_vid_cntr} in
    ((sw_rcv_token, sw_next_switch_addr)<- next_vid;
     sw_token_vid_list.insert {key:vid, value:sw_need_vid_cntr};
     sw_need_vid_cntr = 0;
     sw_highest_vid = next_vid;
     (if not sw_sent_done and (sw_trig_buf_idx.size () == 0 and (sw_num_ack ==
        sw_num_sent and sw_seen_sentry == true))
     then ((ms_rcv_switch_done, master_addr)<- ();sw_sent_done = true) 
     else ());
     (sw_driver_trig, me)<- ()) else (sw_rcv_token, sw_next_switch_addr)<- vid)
trigger tm_insert_timer : { ra:int, rb:int, rc:address } = (\b1 ->
  bind b1 as {ra:time, rb:trig_id, rc:addr} in 
  (tm_timer_list.insert {ra:time + now_int (), rb:trig_id, rc:addr};
   tm_timer_list = tm_timer_list.sort ((\b2 -> (\b6 -> bind b2 as {ra:time1,
   rb:trig_id1, rc:addr1} in bind b6 as {ra:time2, rb:trig_id2, rc:addr2} in 
   if time1 < time2 then -1 else 1)));
   (tm_check_time, me)<- ()))
trigger tm_check_time : () = (\_u -> case (tm_timer_list.peek ()) of
  {Some timer -> if now_int () >= timer.ra
    then
      (tm_timer_list.erase timer;
       bind timer as {ra:time, rb:trig_id, rc:addr} in
       if trig_id == 0 then (ms_send_gc_req, addr)<- () else ();
       (tm_check_time, me)<- ()) else ((tm_check_time, me)<- ();(sleep 1000))}
  {None -> ()})
trigger sw_demux : { ra:string, rb:int, rc:int, rd:int, re:int, rf:int } =
  (\args -> if args.ra == "T"
  then if args.rb == 1 then sw_insert_T {key:args.re, value:args.rf}
    else sw_delete_T {key:args.re, value:args.rf}
  else if args.ra == "S"
    then if args.rb == 1 then sw_insert_S {key:args.rd, value:args.re}
      else sw_delete_S {key:args.rd, value:args.re}
    else if args.ra == "R"
      then if args.rb == 1 then sw_insert_R {key:args.rc, value:args.rd}
        else sw_delete_R {key:args.rc, value:args.rd}
      else if args.ra == ""
        then
          (sw_trig_buf_idx.insert ({i:-1});
           sw_need_vid_cntr = sw_need_vid_cntr + 1)
        else error (print "unidentified trig id"))
trigger sw_driver_trig : () = (\_u ->
  if sw_init and sw_trig_buf_idx.size () > 0
  then case sw_gen_vid () of
    {Some vid -> case (sw_trig_buf_idx.peek ()) of
      {Some trig_id ->
        (sw_trig_buf_idx.erase {i:trig_id.i};
         (if trig_id.i == -1
         then
           (sw_seen_sentry = true;
            (if not sw_sent_done and (sw_trig_buf_idx.size () == 0 and
               (sw_num_ack == sw_num_sent and sw_seen_sentry == true))
            then ((ms_rcv_switch_done, master_addr)<- ();sw_sent_done = true)
            else ()))
         else
           ((if trig_id.i == 5 then sw_delete_R_send_fetch vid
            else if trig_id.i == 4 then sw_insert_R_send_fetch vid
              else if trig_id.i == 3 then sw_delete_S_send_fetch vid
                else if trig_id.i == 2 then sw_insert_S_send_fetch vid
                  else if trig_id.i == 1 then sw_delete_T_send_fetch vid
                    else if trig_id.i == 0 then sw_insert_T_send_fetch vid
                      else error (print "mismatch on trigger id"));
            (sw_driver_trig, me)<- ())))}{None -> ()}}{None -> ()} else ())
trigger nd_rcv_corr_done : { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } = (\b1 -> bind b1 as {ra:vid, rb:stmt_id, rc:hop, rd:count} in 
  ((nd_update_stmt_cntr_corr_map {ra:vid, rb:stmt_id, rc:hop, rd:count,
      re:false, rf:false});
   (case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
   key == {key:vid, value:stmt_id}))).peek ()) of
   {Some lkup -> if 0 == ((lkup.value).value).size ()
     then
       (nd_stmt_cntrs.erase lkup;
        (if nd_rcvd_sys_done
        then if not nd_sent_done and nd_stmt_cntrs.size () == 0
          then ((ms_rcv_node_done, master_addr)<- true;nd_sent_done = true)
          else () else ())) else ()}{None ->
                                      error
                                        (print
                                           "nd_rcv_corr_done: expected stmt_cntr value")})))
  
trigger nd_insert_T_rcv_put : { ra:address, rb:collection { key:int, value:int
  } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:int } = (\b1 ->
  bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid, rd:T_C, re:T_D} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 2
     then nd_insert_T_do_complete_s2 {ra:vid, rb:T_C, rc:T_D}
     else if stmt_id == 1
       then nd_insert_T_do_complete_s1 {ra:vid, rb:T_C, rc:T_D}
       else if stmt_id == 0
         then nd_insert_T_do_complete_s0 {ra:vid, rb:T_C, rc:T_D} else ()
   else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_insert_T_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:T_C, rd:T_D} in 
  ((nd_log_write_insert_T {ra:vid, rb:T_C, rc:T_D});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 0
   then if map_id == 2
     then (nd_insert_T_send_push_s0_m_ATIMESD_mT1, me)<- {ra:vid, rb:T_C,
       rc:T_D} else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 2
     then if map_id == 3
       then (nd_insert_T_send_push_s2_m_ATIMESD_mT1_mR1, me)<- {ra:vid, rb:T_C,
         rc:T_D} else error (print "nd_rcv_fetch: invalid map id")
     else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_insert_T_send_push_s0_m_ATIMESD_mT1 : { ra:{ key:int, value:int },
  rb:int, rc:int } = (\b1 -> bind b1 as {ra:vid, rb:T_C, rc:T_D} in bind
  ATIMESD_mT1 as ind ATIMESD_mT1_deref in
  ((nd_log_master_write {key:vid, value:0});
   (shuffle_ATIMESD_mT1_to_ATIMESD {ra:(),
      rb:frontier_int_int {key:vid, value:ATIMESD_mT1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == T_C))}, rc:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_T_rcv_push_s0_m_ATIMESD_mT1, ip)<- {ra:tuples, rb:vid, rc:T_C,
   rd:T_D}))))
trigger nd_insert_T_send_push_s2_m_ATIMESD_mT1_mR1 : { ra:{ key:int, value:int
  }, rb:int, rc:int } = (\b1 -> bind b1 as {ra:vid, rb:T_C, rc:T_D} in bind
  ATIMESD_mT1_mR1 as ind ATIMESD_mT1_mR1_deref in
  ((nd_log_master_write {key:vid, value:2});
   (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mR1_bind_0t0 {ra:None immut,
      rb:frontier_int_int_int {key:vid, value:ATIMESD_mT1_mR1_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == T_C))},
      rc:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_T_rcv_push_s2_m_ATIMESD_mT1_mR1, ip)<- {ra:tuples, rb:vid,
   rc:T_C, rd:T_D}))))
trigger nd_insert_T_rcv_push_s0_m_ATIMESD_mT1 : { ra:collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:int } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:T_C, rd:T_D} in 
  ((nd_log_write_insert_T {ra:vid, rb:T_C, rc:T_D});
   tuples.iterate ((\tuple -> bind map_ATIMESD_mT1_s0_buf as ind
   map_ATIMESD_mT1_s0_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_ATIMESD_mT1_s0_buf_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb,
       rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_ATIMESD_mT1_s0_buf_d.update vals tuple}{None ->
                                                                  map_ATIMESD_mT1_s0_buf_d.insert
                                                                  tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:0, rc:-1}
   then nd_insert_T_do_complete_s0 {ra:vid, rb:T_C, rc:T_D} else ())))
trigger nd_insert_T_rcv_push_s2_m_ATIMESD_mT1_mR1 : { ra:collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection }, rb:{
  key:int, value:int }, rc:int, rd:int } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:T_C, rd:T_D} in 
  ((nd_log_write_insert_T {ra:vid, rb:T_C, rc:T_D});
   tuples.iterate ((\tuple -> bind map_ATIMESD_mT1_mR1_s2_buf as ind
   map_ATIMESD_mT1_mR1_s2_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_ATIMESD_mT1_mR1_s2_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_ATIMESD_mT1_mR1_s2_buf_d.update vals tuple}{None ->
                                                                    map_ATIMESD_mT1_mR1_s2_buf_d.insert
                                                                    tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:2, rc:-1}
   then nd_insert_T_do_complete_s2 {ra:vid, rb:T_C, rc:T_D} else ())))
trigger nd_insert_T_do_complete_s1_trig : { ra:{ key:int, value:int }, rb:int,
  rc:int } = (\b1 -> bind b1 as {ra:vid, rb:T_C, rc:T_D} in 
  nd_insert_T_do_complete_s1 {ra:vid, rb:T_C, rc:T_D})
trigger insert_T_rcv_corrective_s0_m_ATIMESD_mT1 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Seq }, rg:collection { key:int, value:int
  } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id,
  rc:orig_vid, rd:hop, re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_ATIMESD_mT1_s0_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:0}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_T compute_vid as {key:T_C, value:T_D}
         in
         acc_count +
           insert_T_do_corrective_s0_m_ATIMESD_mT1 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid, rf:T_C,
             rg:T_D, rh:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_T_rcv_corrective_s2_m_ATIMESD_mT1_mR1 : { ra:address, rb:int,
  rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Seq }, rg:collection { ra:int, rb:int, rc:int
  } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id,
  rc:orig_vid, rd:hop, re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_ATIMESD_mT1_mR1_s2_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:2}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_T compute_vid as {key:T_C, value:T_D}
         in
         acc_count +
           insert_T_do_corrective_s2_m_ATIMESD_mT1_mR1 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid, rf:T_C,
             rg:T_D, rh:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger nd_delete_T_rcv_put : { ra:address, rb:collection { key:int, value:int
  } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:int } = (\b1 ->
  bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid, rd:T_C, re:T_D} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 5
     then nd_delete_T_do_complete_s5 {ra:vid, rb:T_C, rc:T_D}
     else if stmt_id == 4
       then nd_delete_T_do_complete_s4 {ra:vid, rb:T_C, rc:T_D}
       else if stmt_id == 3
         then nd_delete_T_do_complete_s3 {ra:vid, rb:T_C, rc:T_D} else ()
   else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_delete_T_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:T_C, rd:T_D} in 
  ((nd_log_write_delete_T {ra:vid, rb:T_C, rc:T_D});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 3
   then if map_id == 2
     then (nd_delete_T_send_push_s3_m_ATIMESD_mT1, me)<- {ra:vid, rb:T_C,
       rc:T_D} else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 5
     then if map_id == 3
       then (nd_delete_T_send_push_s5_m_ATIMESD_mT1_mR1, me)<- {ra:vid, rb:T_C,
         rc:T_D} else error (print "nd_rcv_fetch: invalid map id")
     else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_delete_T_send_push_s3_m_ATIMESD_mT1 : { ra:{ key:int, value:int },
  rb:int, rc:int } = (\b1 -> bind b1 as {ra:vid, rb:T_C, rc:T_D} in bind
  ATIMESD_mT1 as ind ATIMESD_mT1_deref in
  ((nd_log_master_write {key:vid, value:3});
   (shuffle_ATIMESD_mT1_to_ATIMESD {ra:(),
      rb:frontier_int_int {key:vid, value:ATIMESD_mT1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == T_C))}, rc:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_T_rcv_push_s3_m_ATIMESD_mT1, ip)<- {ra:tuples, rb:vid, rc:T_C,
   rd:T_D}))))
trigger nd_delete_T_send_push_s5_m_ATIMESD_mT1_mR1 : { ra:{ key:int, value:int
  }, rb:int, rc:int } = (\b1 -> bind b1 as {ra:vid, rb:T_C, rc:T_D} in bind
  ATIMESD_mT1_mR1 as ind ATIMESD_mT1_mR1_deref in
  ((nd_log_master_write {key:vid, value:5});
   (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mR1_bind_0t0 {ra:None immut,
      rb:frontier_int_int_int {key:vid, value:ATIMESD_mT1_mR1_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == T_C))},
      rc:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_T_rcv_push_s5_m_ATIMESD_mT1_mR1, ip)<- {ra:tuples, rb:vid,
   rc:T_C, rd:T_D}))))
trigger nd_delete_T_rcv_push_s3_m_ATIMESD_mT1 : { ra:collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:int } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:T_C, rd:T_D} in 
  ((nd_log_write_delete_T {ra:vid, rb:T_C, rc:T_D});
   tuples.iterate ((\tuple -> bind map_ATIMESD_mT1_s3_buf as ind
   map_ATIMESD_mT1_s3_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_ATIMESD_mT1_s3_buf_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb,
       rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_ATIMESD_mT1_s3_buf_d.update vals tuple}{None ->
                                                                  map_ATIMESD_mT1_s3_buf_d.insert
                                                                  tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:3, rc:-1}
   then nd_delete_T_do_complete_s3 {ra:vid, rb:T_C, rc:T_D} else ())))
trigger nd_delete_T_rcv_push_s5_m_ATIMESD_mT1_mR1 : { ra:collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection }, rb:{
  key:int, value:int }, rc:int, rd:int } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:T_C, rd:T_D} in 
  ((nd_log_write_delete_T {ra:vid, rb:T_C, rc:T_D});
   tuples.iterate ((\tuple -> bind map_ATIMESD_mT1_mR1_s5_buf as ind
   map_ATIMESD_mT1_mR1_s5_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_ATIMESD_mT1_mR1_s5_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_ATIMESD_mT1_mR1_s5_buf_d.update vals tuple}{None ->
                                                                    map_ATIMESD_mT1_mR1_s5_buf_d.insert
                                                                    tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:5, rc:-1}
   then nd_delete_T_do_complete_s5 {ra:vid, rb:T_C, rc:T_D} else ())))
trigger nd_delete_T_do_complete_s4_trig : { ra:{ key:int, value:int }, rb:int,
  rc:int } = (\b1 -> bind b1 as {ra:vid, rb:T_C, rc:T_D} in 
  nd_delete_T_do_complete_s4 {ra:vid, rb:T_C, rc:T_D})
trigger delete_T_rcv_corrective_s3_m_ATIMESD_mT1 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Seq }, rg:collection { key:int, value:int
  } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id,
  rc:orig_vid, rd:hop, re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_ATIMESD_mT1_s3_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:3}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_T compute_vid as {key:T_C, value:T_D}
         in
         acc_count +
           delete_T_do_corrective_s3_m_ATIMESD_mT1 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid, rf:T_C,
             rg:T_D, rh:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_T_rcv_corrective_s5_m_ATIMESD_mT1_mR1 : { ra:address, rb:int,
  rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Seq }, rg:collection { ra:int, rb:int, rc:int
  } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id,
  rc:orig_vid, rd:hop, re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_ATIMESD_mT1_mR1_s5_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:5}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_T compute_vid as {key:T_C, value:T_D}
         in
         acc_count +
           delete_T_do_corrective_s5_m_ATIMESD_mT1_mR1 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid, rf:T_C,
             rg:T_D, rh:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger nd_insert_S_rcv_put : { ra:address, rb:collection { key:int, value:int
  } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:int } = (\b1 ->
  bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid, rd:S_B, re:S_C} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 9
     then nd_insert_S_do_complete_s9 {ra:vid, rb:S_B, rc:S_C}
     else if stmt_id == 8
       then nd_insert_S_do_complete_s8 {ra:vid, rb:S_B, rc:S_C}
       else if stmt_id == 7
         then nd_insert_S_do_complete_s7 {ra:vid, rb:S_B, rc:S_C}
         else if stmt_id == 6
           then nd_insert_S_do_complete_s6 {ra:vid, rb:S_B, rc:S_C} else ()
   else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_insert_S_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:S_B, rd:S_C} in 
  ((nd_log_write_insert_S {ra:vid, rb:S_B, rc:S_C});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 6
   then if map_id == 4
     then (nd_insert_S_send_push_s6_m_ATIMESD_mS1, me)<- {ra:vid, rb:S_B,
       rc:S_C}
     else if map_id == 5
       then (nd_insert_S_send_push_s6_m_ATIMESD_mS2, me)<- {ra:vid, rb:S_B,
         rc:S_C} else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 7
     then if map_id == 4
       then (nd_insert_S_send_push_s7_m_ATIMESD_mS1, me)<- {ra:vid, rb:S_B,
         rc:S_C} else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 9
       then if map_id == 5
         then (nd_insert_S_send_push_s9_m_ATIMESD_mS2, me)<- {ra:vid, rb:S_B,
           rc:S_C} else error (print "nd_rcv_fetch: invalid map id")
       else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_insert_S_send_push_s6_m_ATIMESD_mS1 : { ra:{ key:int, value:int },
  rb:int, rc:int } = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in bind
  ATIMESD_mS1 as ind ATIMESD_mS1_deref in
  ((nd_log_master_write {key:vid, value:6});
   (shuffle_ATIMESD_mS1_to_ATIMESD {ra:(),
      rb:frontier_int_int {key:vid, value:ATIMESD_mS1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == S_B))}, rc:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_S_rcv_push_s6_m_ATIMESD_mS1, ip)<- {ra:tuples, rb:vid, rc:S_B,
   rd:S_C}))))
trigger nd_insert_S_send_push_s6_m_ATIMESD_mS2 : { ra:{ key:int, value:int },
  rb:int, rc:int } = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in bind
  ATIMESD_mS2 as ind ATIMESD_mS2_deref in
  ((nd_log_master_write {key:vid, value:6});
   (shuffle_ATIMESD_mS2_to_ATIMESD {ra:(),
      rb:frontier_int_int {key:vid, value:ATIMESD_mS2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == S_C))}, rc:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_S_rcv_push_s6_m_ATIMESD_mS2, ip)<- {ra:tuples, rb:vid, rc:S_B,
   rd:S_C}))))
trigger nd_insert_S_send_push_s7_m_ATIMESD_mS1 : { ra:{ key:int, value:int },
  rb:int, rc:int } = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in bind
  ATIMESD_mS1 as ind ATIMESD_mS1_deref in
  ((nd_log_master_write {key:vid, value:7});
   (shuffle_ATIMESD_mS1_to_ATIMESD_mT1 {ra:Some S_C,
      rb:frontier_int_int {key:vid, value:ATIMESD_mS1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == S_B))}, rc:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_S_rcv_push_s7_m_ATIMESD_mS1, ip)<- {ra:tuples, rb:vid, rc:S_B,
   rd:S_C}))))
trigger nd_insert_S_send_push_s9_m_ATIMESD_mS2 : { ra:{ key:int, value:int },
  rb:int, rc:int } = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in bind
  ATIMESD_mS2 as ind ATIMESD_mS2_deref in
  ((nd_log_master_write {key:vid, value:9});
   (shuffle_ATIMESD_mS2_to_ATIMESD_mR1 {ra:Some S_B,
      rb:frontier_int_int {key:vid, value:ATIMESD_mS2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == S_C))}, rc:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_S_rcv_push_s9_m_ATIMESD_mS2, ip)<- {ra:tuples, rb:vid, rc:S_B,
   rd:S_C}))))
trigger nd_insert_S_rcv_push_s6_m_ATIMESD_mS1 : { ra:collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:int } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:S_B, rd:S_C} in 
  ((nd_log_write_insert_S {ra:vid, rb:S_B, rc:S_C});
   tuples.iterate ((\tuple -> bind map_ATIMESD_mS1_s6_buf as ind
   map_ATIMESD_mS1_s6_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_ATIMESD_mS1_s6_buf_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb,
       rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_ATIMESD_mS1_s6_buf_d.update vals tuple}{None ->
                                                                  map_ATIMESD_mS1_s6_buf_d.insert
                                                                  tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:6, rc:-1}
   then nd_insert_S_do_complete_s6 {ra:vid, rb:S_B, rc:S_C} else ())))
trigger nd_insert_S_rcv_push_s6_m_ATIMESD_mS2 : { ra:collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:int } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:S_B, rd:S_C} in 
  ((nd_log_write_insert_S {ra:vid, rb:S_B, rc:S_C});
   tuples.iterate ((\tuple -> bind map_ATIMESD_mS2_s6_buf as ind
   map_ATIMESD_mS2_s6_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_ATIMESD_mS2_s6_buf_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb,
       rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_ATIMESD_mS2_s6_buf_d.update vals tuple}{None ->
                                                                  map_ATIMESD_mS2_s6_buf_d.insert
                                                                  tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:6, rc:-1}
   then nd_insert_S_do_complete_s6 {ra:vid, rb:S_B, rc:S_C} else ())))
trigger nd_insert_S_rcv_push_s7_m_ATIMESD_mS1 : { ra:collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:int } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:S_B, rd:S_C} in 
  ((nd_log_write_insert_S {ra:vid, rb:S_B, rc:S_C});
   tuples.iterate ((\tuple -> bind map_ATIMESD_mS1_s7_buf as ind
   map_ATIMESD_mS1_s7_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_ATIMESD_mS1_s7_buf_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb,
       rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_ATIMESD_mS1_s7_buf_d.update vals tuple}{None ->
                                                                  map_ATIMESD_mS1_s7_buf_d.insert
                                                                  tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:7, rc:-1}
   then nd_insert_S_do_complete_s7 {ra:vid, rb:S_B, rc:S_C} else ())))
trigger nd_insert_S_rcv_push_s9_m_ATIMESD_mS2 : { ra:collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:int } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:S_B, rd:S_C} in 
  ((nd_log_write_insert_S {ra:vid, rb:S_B, rc:S_C});
   tuples.iterate ((\tuple -> bind map_ATIMESD_mS2_s9_buf as ind
   map_ATIMESD_mS2_s9_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_ATIMESD_mS2_s9_buf_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb,
       rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_ATIMESD_mS2_s9_buf_d.update vals tuple}{None ->
                                                                  map_ATIMESD_mS2_s9_buf_d.insert
                                                                  tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:9, rc:-1}
   then nd_insert_S_do_complete_s9 {ra:vid, rb:S_B, rc:S_C} else ())))
trigger nd_insert_S_do_complete_s8_trig : { ra:{ key:int, value:int }, rb:int,
  rc:int } = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in 
  nd_insert_S_do_complete_s8 {ra:vid, rb:S_B, rc:S_C})
trigger insert_S_rcv_corrective_s6_m_ATIMESD_mS1 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Seq }, rg:collection { key:int, value:int
  } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id,
  rc:orig_vid, rd:hop, re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_ATIMESD_mS1_s6_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:6}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_S compute_vid as {key:S_B, value:S_C}
         in
         acc_count +
           insert_S_do_corrective_s6_m_ATIMESD_mS1 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid, rf:S_B,
             rg:S_C, rh:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_S_rcv_corrective_s6_m_ATIMESD_mS2 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Seq }, rg:collection { key:int, value:int
  } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id,
  rc:orig_vid, rd:hop, re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_ATIMESD_mS2_s6_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:6}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_S compute_vid as {key:S_B, value:S_C}
         in
         acc_count +
           insert_S_do_corrective_s6_m_ATIMESD_mS2 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid, rf:S_B,
             rg:S_C, rh:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_S_rcv_corrective_s7_m_ATIMESD_mS1 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Seq }, rg:collection { key:int, value:int
  } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id,
  rc:orig_vid, rd:hop, re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_ATIMESD_mS1_s7_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:7}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_S compute_vid as {key:S_B, value:S_C}
         in
         acc_count +
           insert_S_do_corrective_s7_m_ATIMESD_mS1 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid, rf:S_B,
             rg:S_C, rh:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_S_rcv_corrective_s9_m_ATIMESD_mS2 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Seq }, rg:collection { key:int, value:int
  } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id,
  rc:orig_vid, rd:hop, re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_ATIMESD_mS2_s9_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:9}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_S compute_vid as {key:S_B, value:S_C}
         in
         acc_count +
           insert_S_do_corrective_s9_m_ATIMESD_mS2 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid, rf:S_B,
             rg:S_C, rh:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger nd_delete_S_rcv_put : { ra:address, rb:collection { key:int, value:int
  } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:int } = (\b1 ->
  bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid, rd:S_B, re:S_C} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 13
     then nd_delete_S_do_complete_s13 {ra:vid, rb:S_B, rc:S_C}
     else if stmt_id == 12
       then nd_delete_S_do_complete_s12 {ra:vid, rb:S_B, rc:S_C}
       else if stmt_id == 11
         then nd_delete_S_do_complete_s11 {ra:vid, rb:S_B, rc:S_C}
         else if stmt_id == 10
           then nd_delete_S_do_complete_s10 {ra:vid, rb:S_B, rc:S_C} 
           else () else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_delete_S_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:S_B, rd:S_C} in 
  ((nd_log_write_delete_S {ra:vid, rb:S_B, rc:S_C});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 10
   then if map_id == 4
     then (nd_delete_S_send_push_s10_m_ATIMESD_mS1, me)<- {ra:vid, rb:S_B,
       rc:S_C}
     else if map_id == 5
       then (nd_delete_S_send_push_s10_m_ATIMESD_mS2, me)<- {ra:vid, rb:S_B,
         rc:S_C} else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 11
     then if map_id == 4
       then (nd_delete_S_send_push_s11_m_ATIMESD_mS1, me)<- {ra:vid, rb:S_B,
         rc:S_C} else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 13
       then if map_id == 5
         then (nd_delete_S_send_push_s13_m_ATIMESD_mS2, me)<- {ra:vid, rb:S_B,
           rc:S_C} else error (print "nd_rcv_fetch: invalid map id")
       else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_delete_S_send_push_s10_m_ATIMESD_mS1 : { ra:{ key:int, value:int },
  rb:int, rc:int } = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in bind
  ATIMESD_mS1 as ind ATIMESD_mS1_deref in
  ((nd_log_master_write {key:vid, value:10});
   (shuffle_ATIMESD_mS1_to_ATIMESD {ra:(),
      rb:frontier_int_int {key:vid, value:ATIMESD_mS1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == S_B))}, rc:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_S_rcv_push_s10_m_ATIMESD_mS1, ip)<- {ra:tuples, rb:vid, rc:S_B,
   rd:S_C}))))
trigger nd_delete_S_send_push_s10_m_ATIMESD_mS2 : { ra:{ key:int, value:int },
  rb:int, rc:int } = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in bind
  ATIMESD_mS2 as ind ATIMESD_mS2_deref in
  ((nd_log_master_write {key:vid, value:10});
   (shuffle_ATIMESD_mS2_to_ATIMESD {ra:(),
      rb:frontier_int_int {key:vid, value:ATIMESD_mS2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == S_C))}, rc:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_S_rcv_push_s10_m_ATIMESD_mS2, ip)<- {ra:tuples, rb:vid, rc:S_B,
   rd:S_C}))))
trigger nd_delete_S_send_push_s11_m_ATIMESD_mS1 : { ra:{ key:int, value:int },
  rb:int, rc:int } = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in bind
  ATIMESD_mS1 as ind ATIMESD_mS1_deref in
  ((nd_log_master_write {key:vid, value:11});
   (shuffle_ATIMESD_mS1_to_ATIMESD_mT1 {ra:Some S_C,
      rb:frontier_int_int {key:vid, value:ATIMESD_mS1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == S_B))}, rc:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_S_rcv_push_s11_m_ATIMESD_mS1, ip)<- {ra:tuples, rb:vid, rc:S_B,
   rd:S_C}))))
trigger nd_delete_S_send_push_s13_m_ATIMESD_mS2 : { ra:{ key:int, value:int },
  rb:int, rc:int } = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in bind
  ATIMESD_mS2 as ind ATIMESD_mS2_deref in
  ((nd_log_master_write {key:vid, value:13});
   (shuffle_ATIMESD_mS2_to_ATIMESD_mR1 {ra:Some S_B,
      rb:frontier_int_int {key:vid, value:ATIMESD_mS2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == S_C))}, rc:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_S_rcv_push_s13_m_ATIMESD_mS2, ip)<- {ra:tuples, rb:vid, rc:S_B,
   rd:S_C}))))
trigger nd_delete_S_rcv_push_s10_m_ATIMESD_mS1 : { ra:collection { ra:{
  key:int, value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int,
  value:int }, rc:int, rd:int } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:S_B, rd:S_C} in 
  ((nd_log_write_delete_S {ra:vid, rb:S_B, rc:S_C});
   tuples.iterate ((\tuple -> bind map_ATIMESD_mS1_s10_buf as ind
   map_ATIMESD_mS1_s10_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_ATIMESD_mS1_s10_buf_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb,
       rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_ATIMESD_mS1_s10_buf_d.update vals tuple}{None ->
                                                                   map_ATIMESD_mS1_s10_buf_d.insert
                                                                   tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:10, rc:-1}
   then nd_delete_S_do_complete_s10 {ra:vid, rb:S_B, rc:S_C} else ())))
trigger nd_delete_S_rcv_push_s10_m_ATIMESD_mS2 : { ra:collection { ra:{
  key:int, value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int,
  value:int }, rc:int, rd:int } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:S_B, rd:S_C} in 
  ((nd_log_write_delete_S {ra:vid, rb:S_B, rc:S_C});
   tuples.iterate ((\tuple -> bind map_ATIMESD_mS2_s10_buf as ind
   map_ATIMESD_mS2_s10_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_ATIMESD_mS2_s10_buf_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb,
       rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_ATIMESD_mS2_s10_buf_d.update vals tuple}{None ->
                                                                   map_ATIMESD_mS2_s10_buf_d.insert
                                                                   tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:10, rc:-1}
   then nd_delete_S_do_complete_s10 {ra:vid, rb:S_B, rc:S_C} else ())))
trigger nd_delete_S_rcv_push_s11_m_ATIMESD_mS1 : { ra:collection { ra:{
  key:int, value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int,
  value:int }, rc:int, rd:int } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:S_B, rd:S_C} in 
  ((nd_log_write_delete_S {ra:vid, rb:S_B, rc:S_C});
   tuples.iterate ((\tuple -> bind map_ATIMESD_mS1_s11_buf as ind
   map_ATIMESD_mS1_s11_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_ATIMESD_mS1_s11_buf_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb,
       rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_ATIMESD_mS1_s11_buf_d.update vals tuple}{None ->
                                                                   map_ATIMESD_mS1_s11_buf_d.insert
                                                                   tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:11, rc:-1}
   then nd_delete_S_do_complete_s11 {ra:vid, rb:S_B, rc:S_C} else ())))
trigger nd_delete_S_rcv_push_s13_m_ATIMESD_mS2 : { ra:collection { ra:{
  key:int, value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int,
  value:int }, rc:int, rd:int } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:S_B, rd:S_C} in 
  ((nd_log_write_delete_S {ra:vid, rb:S_B, rc:S_C});
   tuples.iterate ((\tuple -> bind map_ATIMESD_mS2_s13_buf as ind
   map_ATIMESD_mS2_s13_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_ATIMESD_mS2_s13_buf_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb,
       rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_ATIMESD_mS2_s13_buf_d.update vals tuple}{None ->
                                                                   map_ATIMESD_mS2_s13_buf_d.insert
                                                                   tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:13, rc:-1}
   then nd_delete_S_do_complete_s13 {ra:vid, rb:S_B, rc:S_C} else ())))
trigger nd_delete_S_do_complete_s12_trig : { ra:{ key:int, value:int }, rb:int,
  rc:int } = (\b1 -> bind b1 as {ra:vid, rb:S_B, rc:S_C} in 
  nd_delete_S_do_complete_s12 {ra:vid, rb:S_B, rc:S_C})
trigger delete_S_rcv_corrective_s10_m_ATIMESD_mS1 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Seq }, rg:collection { key:int, value:int
  } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id,
  rc:orig_vid, rd:hop, re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_ATIMESD_mS1_s10_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:10}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_S compute_vid as {key:S_B, value:S_C}
         in
         acc_count +
           delete_S_do_corrective_s10_m_ATIMESD_mS1 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid, rf:S_B,
             rg:S_C, rh:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_S_rcv_corrective_s10_m_ATIMESD_mS2 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Seq }, rg:collection { key:int, value:int
  } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id,
  rc:orig_vid, rd:hop, re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_ATIMESD_mS2_s10_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:10}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_S compute_vid as {key:S_B, value:S_C}
         in
         acc_count +
           delete_S_do_corrective_s10_m_ATIMESD_mS2 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid, rf:S_B,
             rg:S_C, rh:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_S_rcv_corrective_s11_m_ATIMESD_mS1 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Seq }, rg:collection { key:int, value:int
  } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id,
  rc:orig_vid, rd:hop, re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_ATIMESD_mS1_s11_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:11}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_S compute_vid as {key:S_B, value:S_C}
         in
         acc_count +
           delete_S_do_corrective_s11_m_ATIMESD_mS1 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid, rf:S_B,
             rg:S_C, rh:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_S_rcv_corrective_s13_m_ATIMESD_mS2 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Seq }, rg:collection { key:int, value:int
  } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id,
  rc:orig_vid, rd:hop, re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_ATIMESD_mS2_s13_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:13}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_S compute_vid as {key:S_B, value:S_C}
         in
         acc_count +
           delete_S_do_corrective_s13_m_ATIMESD_mS2 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid, rf:S_B,
             rg:S_C, rh:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger nd_insert_R_rcv_put : { ra:address, rb:collection { key:int, value:int
  } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:int } = (\b1 ->
  bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid, rd:R_A, re:R_B} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 16
     then nd_insert_R_do_complete_s16 {ra:vid, rb:R_A, rc:R_B}
     else if stmt_id == 15
       then nd_insert_R_do_complete_s15 {ra:vid, rb:R_A, rc:R_B}
       else if stmt_id == 14
         then nd_insert_R_do_complete_s14 {ra:vid, rb:R_A, rc:R_B} else ()
   else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_insert_R_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:R_A, rd:R_B} in 
  ((nd_log_write_insert_R {ra:vid, rb:R_A, rc:R_B});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 14
   then if map_id == 6
     then (nd_insert_R_send_push_s14_m_ATIMESD_mR1, me)<- {ra:vid, rb:R_A,
       rc:R_B} else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 15
     then if map_id == 3
       then (nd_insert_R_send_push_s15_m_ATIMESD_mT1_mR1, me)<- {ra:vid,
         rb:R_A, rc:R_B} else error (print "nd_rcv_fetch: invalid map id")
     else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_insert_R_send_push_s14_m_ATIMESD_mR1 : { ra:{ key:int, value:int },
  rb:int, rc:int } = (\b1 -> bind b1 as {ra:vid, rb:R_A, rc:R_B} in bind
  ATIMESD_mR1 as ind ATIMESD_mR1_deref in
  ((nd_log_master_write {key:vid, value:14});
   (shuffle_ATIMESD_mR1_to_ATIMESD {ra:(),
      rb:frontier_int_int {key:vid, value:ATIMESD_mR1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == R_B))}, rc:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_R_rcv_push_s14_m_ATIMESD_mR1, ip)<- {ra:tuples, rb:vid, rc:R_A,
   rd:R_B}))))
trigger nd_insert_R_send_push_s15_m_ATIMESD_mT1_mR1 : { ra:{ key:int, value:int
  }, rb:int, rc:int } = (\b1 -> bind b1 as {ra:vid, rb:R_A, rc:R_B} in bind
  ATIMESD_mT1_mR1 as ind ATIMESD_mT1_mR1_deref in
  ((nd_log_master_write {key:vid, value:15});
   (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mT1_bind_0t1 {ra:None immut,
      rb:frontier_int_int_int {key:vid, value:ATIMESD_mT1_mR1_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == R_B))},
      rc:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_R_rcv_push_s15_m_ATIMESD_mT1_mR1, ip)<- {ra:tuples, rb:vid,
   rc:R_A, rd:R_B}))))
trigger nd_insert_R_rcv_push_s14_m_ATIMESD_mR1 : { ra:collection { ra:{
  key:int, value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int,
  value:int }, rc:int, rd:int } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:R_A, rd:R_B} in 
  ((nd_log_write_insert_R {ra:vid, rb:R_A, rc:R_B});
   tuples.iterate ((\tuple -> bind map_ATIMESD_mR1_s14_buf as ind
   map_ATIMESD_mR1_s14_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_ATIMESD_mR1_s14_buf_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb,
       rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_ATIMESD_mR1_s14_buf_d.update vals tuple}{None ->
                                                                   map_ATIMESD_mR1_s14_buf_d.insert
                                                                   tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:14, rc:-1}
   then nd_insert_R_do_complete_s14 {ra:vid, rb:R_A, rc:R_B} else ())))
trigger nd_insert_R_rcv_push_s15_m_ATIMESD_mT1_mR1 : { ra:collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection }, rb:{
  key:int, value:int }, rc:int, rd:int } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:R_A, rd:R_B} in 
  ((nd_log_write_insert_R {ra:vid, rb:R_A, rc:R_B});
   tuples.iterate ((\tuple -> bind map_ATIMESD_mT1_mR1_s15_buf as ind
   map_ATIMESD_mT1_mR1_s15_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_ATIMESD_mT1_mR1_s15_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_ATIMESD_mT1_mR1_s15_buf_d.update vals tuple}
       {None -> map_ATIMESD_mT1_mR1_s15_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:15, rc:-1}
   then nd_insert_R_do_complete_s15 {ra:vid, rb:R_A, rc:R_B} else ())))
trigger nd_insert_R_do_complete_s16_trig : { ra:{ key:int, value:int }, rb:int,
  rc:int } = (\b1 -> bind b1 as {ra:vid, rb:R_A, rc:R_B} in 
  nd_insert_R_do_complete_s16 {ra:vid, rb:R_A, rc:R_B})
trigger insert_R_rcv_corrective_s14_m_ATIMESD_mR1 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Seq }, rg:collection { key:int, value:int
  } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id,
  rc:orig_vid, rd:hop, re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_ATIMESD_mR1_s14_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:14}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_R compute_vid as {key:R_A, value:R_B}
         in
         acc_count +
           insert_R_do_corrective_s14_m_ATIMESD_mR1 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid, rf:R_A,
             rg:R_B, rh:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_R_rcv_corrective_s15_m_ATIMESD_mT1_mR1 : { ra:address, rb:int,
  rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Seq }, rg:collection { ra:int, rb:int, rc:int
  } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id,
  rc:orig_vid, rd:hop, re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_ATIMESD_mT1_mR1_s15_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:15}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_R compute_vid as {key:R_A, value:R_B}
         in
         acc_count +
           insert_R_do_corrective_s15_m_ATIMESD_mT1_mR1 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid, rf:R_A,
             rg:R_B, rh:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger nd_delete_R_rcv_put : { ra:address, rb:collection { key:int, value:int
  } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:int } = (\b1 ->
  bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid, rd:R_A, re:R_B} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 19
     then nd_delete_R_do_complete_s19 {ra:vid, rb:R_A, rc:R_B}
     else if stmt_id == 18
       then nd_delete_R_do_complete_s18 {ra:vid, rb:R_A, rc:R_B}
       else if stmt_id == 17
         then nd_delete_R_do_complete_s17 {ra:vid, rb:R_A, rc:R_B} else ()
   else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_delete_R_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:R_A, rd:R_B} in 
  ((nd_log_write_delete_R {ra:vid, rb:R_A, rc:R_B});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 17
   then if map_id == 6
     then (nd_delete_R_send_push_s17_m_ATIMESD_mR1, me)<- {ra:vid, rb:R_A,
       rc:R_B} else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 18
     then if map_id == 3
       then (nd_delete_R_send_push_s18_m_ATIMESD_mT1_mR1, me)<- {ra:vid,
         rb:R_A, rc:R_B} else error (print "nd_rcv_fetch: invalid map id")
     else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_delete_R_send_push_s17_m_ATIMESD_mR1 : { ra:{ key:int, value:int },
  rb:int, rc:int } = (\b1 -> bind b1 as {ra:vid, rb:R_A, rc:R_B} in bind
  ATIMESD_mR1 as ind ATIMESD_mR1_deref in
  ((nd_log_master_write {key:vid, value:17});
   (shuffle_ATIMESD_mR1_to_ATIMESD {ra:(),
      rb:frontier_int_int {key:vid, value:ATIMESD_mR1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == R_B))}, rc:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_R_rcv_push_s17_m_ATIMESD_mR1, ip)<- {ra:tuples, rb:vid, rc:R_A,
   rd:R_B}))))
trigger nd_delete_R_send_push_s18_m_ATIMESD_mT1_mR1 : { ra:{ key:int, value:int
  }, rb:int, rc:int } = (\b1 -> bind b1 as {ra:vid, rb:R_A, rc:R_B} in bind
  ATIMESD_mT1_mR1 as ind ATIMESD_mT1_mR1_deref in
  ((nd_log_master_write {key:vid, value:18});
   (shuffle_ATIMESD_mT1_mR1_to_ATIMESD_mT1_bind_0t1 {ra:None immut,
      rb:frontier_int_int_int {key:vid, value:ATIMESD_mT1_mR1_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == R_B))},
      rc:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_R_rcv_push_s18_m_ATIMESD_mT1_mR1, ip)<- {ra:tuples, rb:vid,
   rc:R_A, rd:R_B}))))
trigger nd_delete_R_rcv_push_s17_m_ATIMESD_mR1 : { ra:collection { ra:{
  key:int, value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int,
  value:int }, rc:int, rd:int } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:R_A, rd:R_B} in 
  ((nd_log_write_delete_R {ra:vid, rb:R_A, rc:R_B});
   tuples.iterate ((\tuple -> bind map_ATIMESD_mR1_s17_buf as ind
   map_ATIMESD_mR1_s17_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_ATIMESD_mR1_s17_buf_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb,
       rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_ATIMESD_mR1_s17_buf_d.update vals tuple}{None ->
                                                                   map_ATIMESD_mR1_s17_buf_d.insert
                                                                   tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:17, rc:-1}
   then nd_delete_R_do_complete_s17 {ra:vid, rb:R_A, rc:R_B} else ())))
trigger nd_delete_R_rcv_push_s18_m_ATIMESD_mT1_mR1 : { ra:collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection }, rb:{
  key:int, value:int }, rc:int, rd:int } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:R_A, rd:R_B} in 
  ((nd_log_write_delete_R {ra:vid, rb:R_A, rc:R_B});
   tuples.iterate ((\tuple -> bind map_ATIMESD_mT1_mR1_s18_buf as ind
   map_ATIMESD_mT1_mR1_s18_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_ATIMESD_mT1_mR1_s18_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_ATIMESD_mT1_mR1_s18_buf_d.update vals tuple}
       {None -> map_ATIMESD_mT1_mR1_s18_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:18, rc:-1}
   then nd_delete_R_do_complete_s18 {ra:vid, rb:R_A, rc:R_B} else ())))
trigger nd_delete_R_do_complete_s19_trig : { ra:{ key:int, value:int }, rb:int,
  rc:int } = (\b1 -> bind b1 as {ra:vid, rb:R_A, rc:R_B} in 
  nd_delete_R_do_complete_s19 {ra:vid, rb:R_A, rc:R_B})
trigger delete_R_rcv_corrective_s17_m_ATIMESD_mR1 : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Seq }, rg:collection { key:int, value:int
  } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id,
  rc:orig_vid, rd:hop, re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_ATIMESD_mR1_s17_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:17}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_R compute_vid as {key:R_A, value:R_B}
         in
         acc_count +
           delete_R_do_corrective_s17_m_ATIMESD_mR1 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid, rf:R_A,
             rg:R_B, rh:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_R_rcv_corrective_s18_m_ATIMESD_mT1_mR1 : { ra:address, rb:int,
  rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Seq }, rg:collection { ra:int, rb:int, rc:int
  } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id,
  rc:orig_vid, rd:hop, re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_ATIMESD_mT1_mR1_s18_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:18}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_R compute_vid as {key:R_A, value:R_B}
         in
         acc_count +
           delete_R_do_corrective_s18_m_ATIMESD_mT1_mR1 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid, rf:R_A,
             rg:R_B, rh:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))


source master : () = value(())feed master |> ms_send_addr_self


source switch : { ra:string, rb:int, rc:int, rd:int, re:int, rf:int
} = file "/k3/K3/temp/rst.csv" psvfeed switch |> sw_demux








