include "Core/Builtins.k3"
include "Annotation/Map.k3"
include "Annotation/Set.k3"
include "Annotation/Seq.k3"
declare my_peers : collection { i:address } @ {Collection} =
  peers.fold (\acc -> (\x -> (acc.insert {i:x.addr}; acc))) empty { i:address} @ Collection
declare switch_path : string = "agenda.csv"


declare nd_sent_done : mut bool = false


declare sw_sent_done : mut bool = false


declare ms_rcv_sw_init_ack_cnt : mut int = 0


declare ms_rcv_jobs_ack_cnt : mut int = 0


declare ms_rcv_job_cnt : mut int = 0


declare ms_rcv_node_done_cnt : mut int = 0


declare ms_rcv_switch_done_cnt : mut int = 0


declare g_init_vid : { key:int, value:int } = {key:0, value:0}


declare g_min_vid : { key:int, value:int } = {key:0, value:0}


declare g_max_vid : { key:int, value:int } = {key:get_max_int (),
  value:get_max_int ()}


declare g_start_vid : { key:int, value:int } = {key:0, value:1}


declare job_master : int = 0


declare job_switch : int = 1


declare job_node : int = 2


declare job_timer : int = 3


declare job : mut int = if role == "master" then job_master
  else if role == "switch" then job_switch
    else if role == "node" then job_node
      else if role == "timer" then job_timer
        else error (print "failed to find proper role")


declare jobs : mut collection { key:address, value:int } @ { Map }


declare master_addr : mut address


declare timer_addr : mut address


declare nodes : mut collection {i:address} @ { Collection }


declare switches : mut collection {i:address} @ { Collection }


declare num_peers : mut int = my_peers.size ()


declare num_switches : mut int = 0


declare num_nodes : mut int = 0


declare map_ids : collection { ra:int, rb:string, rc:int } @ { Collection } =
  {| ra:int, rb:string, rc:int | {ra:1, rb:"QUERY18", rc:2}, {ra:2,
  rb:"QUERY18_mLINEITEM2", rc:3}, {ra:3, rb:"QUERY18_mLINEITEM2_mCUSTOMER1",
  rc:3}, {ra:4, rb:"QUERY18_mLINEITEM5", rc:3}, {ra:5, rb:"QUERY18_mORDERS2",
  rc:2}, {ra:6, rb:"QUERY18_mCUSTOMER1", rc:3}, {ra:7,
  rb:"QUERY18_mCUSTOMER1_L1_1_L1_1", rc:2}, {ra:8,
  rb:"QUERY18_mCUSTOMER1_L1_2", rc:2}|} @ { Collection }


declare nd_stmt_cntrs : collection { key:{ key:{ key:int, value:int },
  value:int }, value:{ key:int, value:collection { key:int, value:int
  } @ { Map } } } @ { Map }


declare nd_log_master : collection { key:{ key:int, value:int }, value:int
  } @ { Set }


declare nd_rcvd_sys_done : mut bool = false


declare sw_init : mut bool = false


declare sw_seen_sentry : mut bool = false


declare sw_trig_buf_idx : collection {i:int} @ { Seq }


declare ms_start_time : mut int = 0


declare ms_end_time : mut int = 0


declare sw_buf_insert_CUSTOMER : collection { ra:int, rb:string, rc:string,
  rd:int, re:string, rf:real, rg:string, rh:string } @ { Seq }


declare sw_buf_delete_CUSTOMER : collection { ra:int, rb:string, rc:string,
  rd:int, re:string, rf:real, rg:string, rh:string } @ { Seq }


declare sw_buf_insert_ORDERS : collection { ra:int, rb:int, rc:string, rd:real,
  re:int, rf:string, rg:string, rh:int, ri:string } @ { Seq }


declare sw_buf_delete_ORDERS : collection { ra:int, rb:int, rc:string, rd:real,
  re:int, rf:string, rg:string, rh:int, ri:string } @ { Seq }


declare sw_buf_insert_LINEITEM : collection { ra:int, rb:int, rc:int, rd:int,
  re:real, rf:real, rg:real, rh:real, ri:string, rj:string, rk:int, rl:int,
  rm:int, rn:string, ro:string, rp:string } @ { Seq }


declare sw_buf_delete_LINEITEM : collection { ra:int, rb:int, rc:int, rd:int,
  re:real, rf:real, rg:real, rh:real, ri:string, rj:string, rk:int, rl:int,
  rm:int, rn:string, ro:string, rp:string } @ { Seq }


declare nd_log_insert_CUSTOMER : collection { key:{ key:int, value:int },
  value:{ ra:int, rb:string, rc:string, rd:int, re:string, rf:real, rg:string,
  rh:string } } @ { Map }


declare nd_log_delete_CUSTOMER : collection { key:{ key:int, value:int },
  value:{ ra:int, rb:string, rc:string, rd:int, re:string, rf:real, rg:string,
  rh:string } } @ { Map }


declare nd_log_insert_ORDERS : collection { key:{ key:int, value:int }, value:{
  ra:int, rb:int, rc:string, rd:real, re:int, rf:string, rg:string, rh:int,
  ri:string } } @ { Map }


declare nd_log_delete_ORDERS : collection { key:{ key:int, value:int }, value:{
  ra:int, rb:int, rc:string, rd:real, re:int, rf:string, rg:string, rh:int,
  ri:string } } @ { Map }


declare nd_log_insert_LINEITEM : collection { key:{ key:int, value:int },
  value:{ ra:int, rb:int, rc:int, rd:int, re:real, rf:real, rg:real, rh:real,
  ri:string, rj:string, rk:int, rl:int, rm:int, rn:string, ro:string, rp:string
  } } @ { Map }


declare nd_log_delete_LINEITEM : collection { key:{ key:int, value:int },
  value:{ ra:int, rb:int, rc:int, rd:int, re:real, rf:real, rg:real, rh:real,
  ri:string, rj:string, rk:int, rl:int, rm:int, rn:string, ro:string, rp:string
  } } @ { Map }


declare QUERY18 : ind collection { ra:{ key:int, value:int }, rb:int, rc:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int, rc:real
  } @ { Set }


declare QUERY18_mLINEITEM2 : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int } @ { Set }


declare QUERY18_mLINEITEM2_mCUSTOMER1 : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set }


declare QUERY18_mLINEITEM5 : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int, rd:real } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int, rd:real } @ { Set }


declare QUERY18_mORDERS2 : ind collection { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int, rc:int
  } @ { Set }


declare QUERY18_mCUSTOMER1 : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int, rd:real } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int, rd:real } @ { Set }


declare QUERY18_mCUSTOMER1_L1_1_L1_1 : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:real } @ { Set }


declare QUERY18_mCUSTOMER1_L1_2 : ind collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:int,
  rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_s0_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s0_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mLINEITEM2_mCUSTOMER1_s1_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_s2_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_s4_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s4_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mLINEITEM2_mCUSTOMER1_s5_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_s6_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s8_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mORDERS2_s8_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mORDERS2_s9_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mORDERS2_s11_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s11_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s12_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s13_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mORDERS2_s13_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mORDERS2_s14_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mORDERS2_s16_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s16_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s17_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mLINEITEM2_s18_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s18_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mLINEITEM2_s19_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_QUERY18_mLINEITEM2_mCUSTOMER1_s20_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_QUERY18_mLINEITEM2_s23_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s23_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mLINEITEM5_s23_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set }


declare map_QUERY18_mLINEITEM2_s24_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_QUERY18_mLINEITEM2_mCUSTOMER1_s25_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s28_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s28_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s30_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s30_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mLINEITEM2_s32_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s32_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s32_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mLINEITEM2_s33_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s33_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s33_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s35_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s35_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s37_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s37_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mLINEITEM2_s39_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s39_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s39_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mLINEITEM5_s39_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set }


declare map_QUERY18_mLINEITEM2_s40_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s40_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s40_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mLINEITEM5_s40_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s41_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s41_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mORDERS2_s43_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s43_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s43_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mORDERS2_s44_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mORDERS2_s46_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s46_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s46_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mORDERS2_s47_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mORDERS2_s49_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s49_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s49_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mORDERS2_s50_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s52_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s52_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mORDERS2_s52_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s53_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s53_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s55_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s56_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s56_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s58_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s59_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s59_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s61_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mORDERS2_s62_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s62_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s62_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mORDERS2_s63_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mORDERS2_s65_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s65_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s65_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mORDERS2_s66_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mORDERS2_s68_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s68_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s68_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mORDERS2_s69_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s71_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s71_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mORDERS2_s71_buf : ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s72_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s72_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s74_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s75_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s75_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s77_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s78_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s78_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s80_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s81_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s81_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s83_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s83_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_s85_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s85_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s85_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_s86_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s86_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s86_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s88_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s88_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s90_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s90_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_s92_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s92_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s92_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_s93_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_1_L1_1_s93_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }


declare map_QUERY18_mCUSTOMER1_L1_2_s93_buf : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }


declare tm_timer_list : mut collection { ra:int, rb:int, rc:address } @ { Seq }


declare sw_next_switch_addr : mut address


declare sw_need_vid_cntr : mut int = 0


declare sw_token_vid_list : collection { key:{ key:int, value:int }, value:int
  } @ { Seq }


declare sw_highest_vid : mut { key:int, value:int }


declare node_ring : mut collection { key:address, value:int } @ { Seq }


declare replicas : mut int = 8


declare pmap_input : collection { key:string, value:collection { key:int,
  value:int } @ { Seq } } @ { Seq } = {| key:string, value:collection {
  key:int, value:int } @ { Seq } | {key:"QUERY18", value:{| key:int, value:int
  | {key:0, value:16}|} @ { Seq }}, {key:"QUERY18_mLINEITEM2", value:{|
  key:int, value:int | {key:0, value:4}, {key:1, value:4}|} @ { Seq }},
  {key:"QUERY18_mLINEITEM2_mCUSTOMER1", value:{| key:int, value:int | {key:0,
  value:4}, {key:1, value:4}|} @ { Seq }}, {key:"QUERY18_mLINEITEM5", value:{|
  key:int, value:int | {key:0, value:4}, {key:1, value:4}|} @ { Seq }},
  {key:"QUERY18_mORDERS2", value:{| key:int, value:int | {key:0,
  value:16}|} @ { Seq }}, {key:"QUERY18_mCUSTOMER1", value:{| key:int,
  value:int | {key:0, value:4}, {key:1, value:4}|} @ { Seq }},
  {key:"QUERY18_mCUSTOMER1_L1_1_L1_1", value:{| key:int, value:int | {key:0,
  value:16}|} @ { Seq }}, {key:"QUERY18_mCUSTOMER1_L1_2", value:{| key:int,
  value:int | {key:0, value:16}|} @ { Seq }}|} @ { Seq }


declare pmap_data : collection { key:int, value:collection { key:int, value:int
  } @ { Seq } } @ { Seq } = pmap_input.fold ((\_accmap -> (\b3 ->
  bind b3 as {key:map_name, value:map_types} in 
  (_accmap.insert {key:(case ((map_ids.filter ((\b1 -> bind b1 as {ra:ra,
   rb:rb, rc:rc} in rb == map_name))).peek ()) of
   {Some x -> x}{None -> error (print "can't find map in map_ids")}).ra,
   value:map_types};
   _accmap)))) empty { key:int, value:collection { key:int, value:int
  } @ { Seq } } @ { Seq }


declare sw_num_ack : mut int = 0


declare sw_num_sent : mut int = 0


declare sw_ack_log : collection { key:{ key:int, value:int }, value:int
  } @ { Map }


declare ms_gc_interval : mut int = 20000


declare ms_gc_vid_map : mut collection { key:address, value:{ key:int,
  value:int } } @ { Map }


declare ms_gc_vid_ctr : mut int = 0


declare ms_num_gc_expected : mut int = my_peers.size ()


declare nd_log_master_write : { key:{ key:int, value:int }, value:int } -> () =
  (\b1 -> bind b1 as {key:vid, value:stmt_id} in nd_log_master.insert {key:vid,
  value:stmt_id})


declare nd_log_write_insert_CUSTOMER : { ra:{ key:int, value:int }, rb:int,
  rc:string, rd:string, re:int, rf:string, rg:real, rh:string, ri:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
  rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE,
  rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in 
  nd_log_insert_CUSTOMER.insert {key:vid, value:{ra:CUSTOMER_CUSTKEY,
  rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY,
  re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT,
  rh:CUSTOMER_COMMENT}})


declare nd_log_write_delete_CUSTOMER : { ra:{ key:int, value:int }, rb:int,
  rc:string, rd:string, re:int, rf:string, rg:real, rh:string, ri:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
  rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE,
  rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in 
  nd_log_delete_CUSTOMER.insert {key:vid, value:{ra:CUSTOMER_CUSTKEY,
  rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY,
  re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT,
  rh:CUSTOMER_COMMENT}})


declare nd_log_write_insert_ORDERS : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in nd_log_insert_ORDERS.insert {key:vid,
  value:{ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS,
  rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY,
  rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}})


declare nd_log_write_delete_ORDERS : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in nd_log_delete_ORDERS.insert {key:vid,
  value:{ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS,
  rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY,
  rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}})


declare nd_log_write_insert_LINEITEM : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real, rj:string,
  rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
  rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
  rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
  rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
  rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
  rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in nd_log_insert_LINEITEM.insert
  {key:vid, value:{ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY,
  rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY,
  rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX,
  ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE,
  rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT,
  ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}})


declare nd_log_write_delete_LINEITEM : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real, rj:string,
  rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
  rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
  rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
  rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
  rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
  rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in nd_log_delete_LINEITEM.insert
  {key:vid, value:{ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY,
  rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY,
  rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX,
  ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE,
  rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT,
  ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}})


declare nd_log_get_bound_insert_CUSTOMER : { key:int, value:int } -> { ra:int,
  rb:string, rc:string, rd:int, re:string, rf:real, rg:string, rh:string } =
  (\vid -> (case ((nd_log_insert_CUSTOMER.filter ((\b1 -> bind b1 as {key:key,
  value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_delete_CUSTOMER : { key:int, value:int } -> { ra:int,
  rb:string, rc:string, rd:int, re:string, rf:real, rg:string, rh:string } =
  (\vid -> (case ((nd_log_delete_CUSTOMER.filter ((\b1 -> bind b1 as {key:key,
  value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_insert_ORDERS : { key:int, value:int } -> { ra:int,
  rb:int, rc:string, rd:real, re:int, rf:string, rg:string, rh:int, ri:string
  } = (\vid -> (case ((nd_log_insert_ORDERS.filter ((\b1 ->
  bind b1 as {key:key, value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_delete_ORDERS : { key:int, value:int } -> { ra:int,
  rb:int, rc:string, rd:real, re:int, rf:string, rg:string, rh:int, ri:string
  } = (\vid -> (case ((nd_log_delete_ORDERS.filter ((\b1 ->
  bind b1 as {key:key, value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_insert_LINEITEM : { key:int, value:int } -> { ra:int,
  rb:int, rc:int, rd:int, re:real, rf:real, rg:real, rh:real, ri:string,
  rj:string, rk:int, rl:int, rm:int, rn:string, ro:string, rp:string } =
  (\vid -> (case ((nd_log_insert_LINEITEM.filter ((\b1 -> bind b1 as {key:key,
  value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_delete_LINEITEM : { key:int, value:int } -> { ra:int,
  rb:int, rc:int, rd:int, re:real, rf:real, rg:real, rh:real, ri:string,
  rj:string, rk:int, rl:int, rm:int, rn:string, ro:string, rp:string } =
  (\vid -> (case ((nd_log_delete_LINEITEM.filter ((\b1 -> bind b1 as {key:key,
  value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_read_geq : { key:int, value:int } -> collection { key:{ key:int,
  value:int }, value:int } @ { Set } = (\vid2 -> nd_log_master.filter ((\b1 ->
  bind b1 as {key:vid, value:stmt_id} in vid >= vid2)))


declare nd_check_stmt_cntr_index : { ra:{ key:int, value:int }, rb:int, rc:int
  } -> bool = (\b1 -> bind b1 as {ra:vid, rb:stmt_id, rc:add_to_count} in case
  ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
  {key:vid, value:stmt_id}))).peek ()) of
  {Some lookup_value -> let new_count = add_to_count + (lookup_value.value).key
    in
    (nd_stmt_cntrs.update lookup_value {key:{key:vid, value:stmt_id},
     value:{key:new_count, value:(lookup_value.value).value}};
     0 == new_count)}{None ->
                       (nd_stmt_cntrs.insert {key:{key:vid, value:stmt_id},
                        value:{key:add_to_count, value:empty { key:int,
                        value:int } @ { Map }}};
                        false)})


declare nd_complete_stmt_cntr_check : { key:{ key:int, value:int }, value:int
  } -> () = (\b1 -> bind b1 as {key:vid, value:stmt_id} in 
  ((case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
   key == {key:vid, value:stmt_id}))).peek ()) of
   {Some lookup_data -> nd_stmt_cntrs.erase lookup_data}{None -> ()});
   (if nd_rcvd_sys_done
   then if not nd_sent_done and nd_stmt_cntrs.size () == 0
     then ((ms_rcv_node_done, master_addr)<- true;nd_sent_done = true) 
     else () else ())))


declare nd_update_stmt_cntr_corr_map : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:int, re:bool, rf:bool } -> () = (\b1 -> bind b1 as {ra:vid,
  rb:stmt_id, rc:hop, rd:count, re:root, rf:create} in 
  ((if create
   then nd_stmt_cntrs.insert {key:{key:vid, value:stmt_id}, value:{key:0,
     value:empty { key:int, value:int } @ { Map }}} else ());
   (case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
   key == {key:vid, value:stmt_id}))).peek ()) of
   {Some lkup -> nd_stmt_cntrs.update lkup {key:{key:vid, value:stmt_id},
     value:let sc_corr_map = (lkup.value).value in
     ((case ((sc_corr_map.filter ((\b1 -> bind b1 as {key:key, value:value} in 
      key == hop))).peek ()) of
      {Some lkup2 -> sc_corr_map.update lkup2 {key:hop, value:lkup2.value +
        count}}{None -> sc_corr_map.insert {key:hop, value:count}});
      (if root then ()
      else case ((sc_corr_map.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == hop))).peek ()) of
        {Some lkup2 -> let new_corr_cnt = lkup2.value - 1 in
          if new_corr_cnt == 0 then sc_corr_map.erase lkup2
            else sc_corr_map.update lkup2 {key:hop, value:new_corr_cnt}}
        {None -> sc_corr_map.insert {key:hop, value:-1}});
      {key:(lkup.value).key, value:sc_corr_map})}}{None ->
                                                    error
                                                      (print
                                                         "nd_update_stmt_cntr_corr_map: missing stmt_cntrs value")})))


declare nd_filter_corrective_list : { key:{ key:int, value:int },
  value:collection { key:int, value:int } @ { Collection } } -> collection {
  key:int, value:collection { key:int, value:int } @ { Seq }
  } @ { Collection } = (\b1 -> bind b1 as {key:request_vid,
  value:trig_stmt_list} in ((((nd_log_read_geq request_vid).fold ((\acc_conv ->
  (\x -> (acc_conv.insert x;acc_conv)))) empty { key:{ key:int, value:int },
  value:int } @ { Seq }).sort ((\b2 -> (\b5 -> bind b2 as {key:vid1,
  value:stmt1} in bind b5 as {key:vid2, value:stmt2} in if vid1 < vid2 
  then -1 else 1)))).groupBy ((\b1 -> bind b1 as {value:stmt_id} in stmt_id))
  ((\vid_list -> (\b3 -> bind b3 as {key:vid} in 
  (vid_list.insert vid;vid_list)))) empty { key:int, value:int
  } @ { Seq }).fold ((\acc_conv -> (\x -> (acc_conv.insert x;acc_conv))))
  empty { key:int, value:collection { key:int, value:int } @ { Seq }
  } @ { Collection })


declare add_node : address -> () = (\addr -> let rng = range replicas in
  let new_elems =
    rng.fold ((\_accmap -> (\b3 -> bind b3 as {i:i} in 
      (_accmap.insert {key:addr, value:abs (hash ((i * 2683) + hash addr))};
       _accmap)))) empty { key:address, value:int } @ { Seq } in
    (node_ring = node_ring.combine new_elems;
     node_ring = node_ring.sort ((\b2 -> (\b5 -> bind b2 as {key:addr,
     value:hash1} in bind b5 as {key:addr, value:hash2} in if hash1 < hash2
     then -1 else 1)))))


declare get_ring_node : { key:int, value:int } -> address = (\b1 ->
  bind b1 as {key:data, value:max_val} in let scaled =
  truncate (real_of_int (get_max_int ()) * (real_of_int data /
    real_of_int max_val)) in
  let results =
    node_ring.filter ((\b1 -> bind b1 as {key:addr, value:hash} in hash >=
      scaled)) in
    bind
      case (results.peek ()) of
        {Some x -> x}{None -> case (node_ring.peek ()) of
                       {Some x -> x}{None -> error (print "empty node ring")}}
      as {key:addr, value:_} in addr)


declare frontier_int_int_float : { key:{ key:int, value:int },
  value:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:real
  } @ { Set } } -> collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:real } @ { Collection } = (\b1 -> bind b1 as {key:vid,
  value:input_map} in (input_map.groupBy ((\b1 -> bind b1 as {ra:map_vid,
  rb:map_0, rc:map_1, rd:map_val} in {key:map_0, value:map_1})) ((\b2 ->
  (\b5 -> bind b2 as {key:acc, value:max_vid} in bind b5 as {ra:map_vid,
  rb:map_0, rc:map_1, rd:map_val} in if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {ra:map_vid, rb:map_0, rc:map_1, rd:map_val};
       {key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| ra:{ key:int, value:int }, rb:int, rc:int, rd:real |
        {ra:map_vid, rb:map_0, rc:map_1, rd:map_val}|} @ { Collection },
        value:map_vid} else {key:acc, value:max_vid}
  else {key:acc, value:max_vid}))) {key:empty { ra:{ key:int, value:int },
  rb:int, rc:int, rd:real } @ { Collection }, value:g_min_vid}).fold
  ((\_accext -> (\b3 -> bind b3 as {value:b4} in bind b4 as {key:project} in 
  _accext.combine project))) empty { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:real } @ { Collection })


declare frontier_int_int : { key:{ key:int, value:int }, value:collection {
  ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } } -> collection { ra:{
  key:int, value:int }, rb:int, rc:int } @ { Collection } = (\b1 ->
  bind b1 as {key:vid, value:input_map} in (input_map.groupBy ((\b1 ->
  bind b1 as {ra:map_vid, rb:map_0, rc:map_val} in map_0)) ((\b2 -> (\b5 ->
  bind b2 as {key:acc, value:max_vid} in bind b5 as {ra:map_vid, rb:map_0,
  rc:map_val} in if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {ra:map_vid, rb:map_0, rc:map_val};{key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| ra:{ key:int, value:int }, rb:int, rc:int | {ra:map_vid,
        rb:map_0, rc:map_val}|} @ { Collection }, value:map_vid}
      else {key:acc, value:max_vid} else {key:acc, value:max_vid})))
  {key:empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection },
  value:g_min_vid}).fold ((\_accext -> (\b3 -> bind b3 as {value:b4} in 
  bind b4 as {key:project} in _accext.combine project))) empty { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Collection })


declare frontier_int_int_int : { key:{ key:int, value:int }, value:collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }
  } -> collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection } = (\b1 -> bind b1 as {key:vid, value:input_map} in 
  (input_map.groupBy ((\b1 -> bind b1 as {ra:map_vid, rb:map_0, rc:map_1,
  rd:map_val} in {key:map_0, value:map_1})) ((\b2 -> (\b5 ->
  bind b2 as {key:acc, value:max_vid} in bind b5 as {ra:map_vid, rb:map_0,
  rc:map_1, rd:map_val} in if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {ra:map_vid, rb:map_0, rc:map_1, rd:map_val};
       {key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| ra:{ key:int, value:int }, rb:int, rc:int, rd:int |
        {ra:map_vid, rb:map_0, rc:map_1, rd:map_val}|} @ { Collection },
        value:map_vid} else {key:acc, value:max_vid}
  else {key:acc, value:max_vid}))) {key:empty { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int } @ { Collection }, value:g_min_vid}).fold
  ((\_accext -> (\b3 -> bind b3 as {value:b4} in bind b4 as {key:project} in 
  _accext.combine project))) empty { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int } @ { Collection })


declare frontier_int_float : { key:{ key:int, value:int }, value:collection {
  ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } } -> collection { ra:{
  key:int, value:int }, rb:int, rc:real } @ { Collection } = (\b1 ->
  bind b1 as {key:vid, value:input_map} in (input_map.groupBy ((\b1 ->
  bind b1 as {ra:map_vid, rb:map_0, rc:map_val} in map_0)) ((\b2 -> (\b5 ->
  bind b2 as {key:acc, value:max_vid} in bind b5 as {ra:map_vid, rb:map_0,
  rc:map_val} in if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {ra:map_vid, rb:map_0, rc:map_val};{key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| ra:{ key:int, value:int }, rb:int, rc:real | {ra:map_vid,
        rb:map_0, rc:map_val}|} @ { Collection }, value:map_vid}
      else {key:acc, value:max_vid} else {key:acc, value:max_vid})))
  {key:empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Collection },
  value:g_min_vid}).fold ((\_accext -> (\b3 -> bind b3 as {value:b4} in 
  bind b4 as {key:project} in _accext.combine project))) empty { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Collection })


declare nd_add_delta_to_int_int_float : { ra:ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:real } @ { Set }, rb:bool, rc:{ key:int,
  value:int }, rd:collection { ra:int, rb:int, rc:real } @ { Collection }
  } -> () = (\b1 -> bind b1 as {ra:target_map, rb:corrective, rc:min_vid,
  rd:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
   rc:map_val} in bind target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc,
         rd:rd} in (ra == min_vid and rc == map_1) and rb == map_0))
       else empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real
         } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.rd in
         target_map_d.update val {ra:min_vid, rb:map_0, rc:map_1,
           rd:update_value}}{None -> let lookup_value =
                              frontier_int_int_float {key:min_vid,
                                value:target_map_d.filter ((\b1 ->
                                bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb
                                == map_0 and rc == map_1))} in
                              let update_value =
                                map_val + case (lookup_value.peek ()) of
                                  {Some val -> val.rd}{None -> 0} in
                                target_map_d.insert {ra:min_vid, rb:map_0,
                                  rc:map_1, rd:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0_delta, rb:map_1_delta,
   rc:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in 
       rb == map_0_delta and rc == map_1_delta))).filter ((\b1 ->
       bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in vid > min_vid))
   in
   filtered.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1,
     rd:map_val} in bind target_map as ind target_map_d in
     target_map_d.update {ra:vid, rb:map_0, rc:map_1, rd:map_val} {ra:vid,
       rb:map_0, rc:map_1, rd:map_val + map_val_delta}))))))


declare nd_add_delta_to_int_int : { ra:ind collection { ra:{ key:int, value:int
  }, rb:int, rc:int } @ { Set }, rb:bool, rc:{ key:int, value:int },
  rd:collection { key:int, value:int } @ { Collection } } -> () = (\b1 ->
  bind b1 as {ra:target_map, rb:corrective, rc:min_vid, rd:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {key:map_0, value:map_val} in bind
   target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc} in ra
         == min_vid and rb == map_0))
       else empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.rc in
         target_map_d.update val {ra:min_vid, rb:map_0, rc:update_value}}
       {None -> let lookup_value =
         frontier_int_int {key:min_vid, value:target_map_d.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == map_0))} in
         let update_value =
           map_val + case (lookup_value.peek ()) of
             {Some val -> val.rc}{None -> 0} in
           target_map_d.insert {ra:min_vid, rb:map_0, rc:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {key:map_0_delta,
   value:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc} in rb ==
       map_0_delta))).filter ((\b1 -> bind b1 as {ra:vid, rb:map_0,
       rc:map_val} in vid > min_vid)) in
   filtered.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_val} in bind
     target_map as ind target_map_d in
     target_map_d.update {ra:vid, rb:map_0, rc:map_val} {ra:vid, rb:map_0,
       rc:map_val + map_val_delta}))))))


declare nd_add_delta_to_int_int_int : { ra:ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set }, rb:bool, rc:{ key:int,
  value:int }, rd:collection { ra:int, rb:int, rc:int } @ { Collection }
  } -> () = (\b1 -> bind b1 as {ra:target_map, rb:corrective, rc:min_vid,
  rd:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
   rc:map_val} in bind target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc,
         rd:rd} in (ra == min_vid and rc == map_1) and rb == map_0))
       else empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
         } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.rd in
         target_map_d.update val {ra:min_vid, rb:map_0, rc:map_1,
           rd:update_value}}{None -> let lookup_value =
                              frontier_int_int_int {key:min_vid,
                                value:target_map_d.filter ((\b1 ->
                                bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb
                                == map_0 and rc == map_1))} in
                              let update_value =
                                map_val + case (lookup_value.peek ()) of
                                  {Some val -> val.rd}{None -> 0} in
                                target_map_d.insert {ra:min_vid, rb:map_0,
                                  rc:map_1, rd:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0_delta, rb:map_1_delta,
   rc:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in 
       rb == map_0_delta and rc == map_1_delta))).filter ((\b1 ->
       bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in vid > min_vid))
   in
   filtered.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1,
     rd:map_val} in bind target_map as ind target_map_d in
     target_map_d.update {ra:vid, rb:map_0, rc:map_1, rd:map_val} {ra:vid,
       rb:map_0, rc:map_1, rd:map_val + map_val_delta}))))))


declare nd_add_delta_to_int_float : { ra:ind collection { ra:{ key:int,
  value:int }, rb:int, rc:real } @ { Set }, rb:bool, rc:{ key:int, value:int },
  rd:collection { key:int, value:real } @ { Collection } } -> () = (\b1 ->
  bind b1 as {ra:target_map, rb:corrective, rc:min_vid, rd:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {key:map_0, value:map_val} in bind
   target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc} in ra
         == min_vid and rb == map_0))
       else empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.rc in
         target_map_d.update val {ra:min_vid, rb:map_0, rc:update_value}}
       {None -> let lookup_value =
         frontier_int_float {key:min_vid, value:target_map_d.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == map_0))} in
         let update_value =
           map_val + case (lookup_value.peek ()) of
             {Some val -> val.rc}{None -> 0} in
           target_map_d.insert {ra:min_vid, rb:map_0, rc:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {key:map_0_delta,
   value:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc} in rb ==
       map_0_delta))).filter ((\b1 -> bind b1 as {ra:vid, rb:map_0,
       rc:map_val} in vid > min_vid)) in
   filtered.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_val} in bind
     target_map as ind target_map_d in
     target_map_d.update {ra:vid, rb:map_0, rc:map_val} {ra:vid, rb:map_0,
       rc:map_val + map_val_delta}))))))


declare sw_gen_vid : () -> option { key:int, value:int } = (\_ -> case
  (sw_token_vid_list.peek ()) of
  {Some vid_num -> let num_new = vid_num.value - 1 in
    let vid_new = {key:(vid_num.key).key, value:(vid_num.key).value + 1} in
      ((if num_new <= 0 then sw_token_vid_list.erase vid_num
       else sw_token_vid_list.update vid_num {key:vid_new, value:num_new});
       Some (vid_num.key))}{None -> None immut})


declare calc_dim_bounds : collection { key:int, value:int } @ { Seq } -> {
  key:collection { key:int, value:int } @ { Seq }, value:int } = (\pmap ->
  pmap.fold ((\b2 -> (\b5 -> bind b2 as {key:xs, value:acc_size} in 
  bind b5 as {key:pos, value:bin_size} in {key:xs.combine ({| key:int,
  value:int | {key:pos, value:acc_size}|} @ { Seq }), value:bin_size *
  acc_size}))) {key:empty { key:int, value:int } @ { Seq }, value:1})


declare route_to_int_int : { ra:int, rb:option int, rc:option int
  } -> collection {i:address} @ { Collection } = (\b1 -> bind b1 as {ra:map_id,
  rb:key_0, rc:key_1} in let pmap =
  (case ((pmap_data.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
    map_id))).peek ()) of
    {Some x -> x}{None -> error (print "can't find map_id in pmap_data")}).value
  in
  case (pmap.peek ()) of
    {Some _ -> bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in
      let bound_bucket =
        case key_1 of
          {Some key_1_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              1)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_1_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 1))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 1 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_0 of
          {Some key_0_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              0)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_0_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 0))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 0 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + 0) in
        let free_dims =
          (if key_1 != None immut then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 1))).combine ((if key_0 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 0))).combine empty { key:int, value:int } @ { Seq }) in
          let free_domains =
            free_dims.fold ((\_accmap -> (\b3 -> bind b3 as {key:i,
              value:b_i} in 
              (_accmap.insert {key:i, value:range b_i};_accmap)))) empty {
              key:int, value:collection {i:int} @ { Seq } } @ { Seq } in
            let free_cart_prod =
              free_domains.fold ((\prev_cart_prod -> (\b3 -> bind b3 as {key:i,
                value:domain} in domain.fold ((\_accext -> (\b3 ->
                bind b3 as {i:domain_element} in _accext.combine
                (if 0 == prev_cart_prod.size ()
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int | {key:i,
                  value:domain_element}|} @ { Seq }|} @ { Seq }
                else prev_cart_prod.fold ((\_accmap -> (\b3 ->
                  bind b3 as {i:rest_tup} in 
                  (_accmap.insert ({i:rest_tup.combine ({| key:int, value:int |
                   {key:i, value:domain_element}|} @ { Seq })});
                   _accmap)))) empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq })))) empty {i:collection { key:int,
                value:int } @ { Seq }} @ { Seq }))) empty {i:collection {
                key:int, value:int } @ { Seq }} @ { Seq } in
              let sorted_ip_list =
                (free_cart_prod.fold ((\acc_ips -> (\b3 ->
                  bind b3 as {i:free_bucket} in acc_ips.combine ({|i:address|
                  get_ring_node {key:free_bucket.fold ((\acc -> (\b3 ->
                    bind b3 as {key:i, value:val} in acc + (val * (case
                    ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                    value:value} in key == i))).peek ()) of
                    {Some x -> x}{None ->
                                   error (print "can't find i in dim_bounds")}).value))))
                    bound_bucket, value:max_val}|} @ { Collection }))))
                  empty {i:address} @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {i:ip} in ip)) ((\_ -> (\_ -> ()))) () in
                if 0 == sorted_ip_list.size ()
                  then {|i:address|
                    get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
                  else sorted_ip_list.fold ((\_accmap -> (\x ->
                    (_accmap.insert ({i:x.key});_accmap))))
                    empty {i:address} @ { Collection }}{None -> nodes})


declare route_to_int : { key:int, value:option int
  } -> collection {i:address} @ { Collection } = (\b1 ->
  bind b1 as {key:map_id, value:key_0} in let pmap =
  (case ((pmap_data.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
    map_id))).peek ()) of
    {Some x -> x}{None -> error (print "can't find map_id in pmap_data")}).value
  in
  case (pmap.peek ()) of
    {Some _ -> bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in
      let bound_bucket =
        case key_0 of
          {Some key_0_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              0)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_0_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 0))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 0 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + 0 in
        let free_dims =
          (if key_0 != None immut then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 0))).combine empty { key:int, value:int } @ { Seq } in
          let free_domains =
            free_dims.fold ((\_accmap -> (\b3 -> bind b3 as {key:i,
              value:b_i} in 
              (_accmap.insert {key:i, value:range b_i};_accmap)))) empty {
              key:int, value:collection {i:int} @ { Seq } } @ { Seq } in
            let free_cart_prod =
              free_domains.fold ((\prev_cart_prod -> (\b3 -> bind b3 as {key:i,
                value:domain} in domain.fold ((\_accext -> (\b3 ->
                bind b3 as {i:domain_element} in _accext.combine
                (if 0 == prev_cart_prod.size ()
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int | {key:i,
                  value:domain_element}|} @ { Seq }|} @ { Seq }
                else prev_cart_prod.fold ((\_accmap -> (\b3 ->
                  bind b3 as {i:rest_tup} in 
                  (_accmap.insert ({i:rest_tup.combine ({| key:int, value:int |
                   {key:i, value:domain_element}|} @ { Seq })});
                   _accmap)))) empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq })))) empty {i:collection { key:int,
                value:int } @ { Seq }} @ { Seq }))) empty {i:collection {
                key:int, value:int } @ { Seq }} @ { Seq } in
              let sorted_ip_list =
                (free_cart_prod.fold ((\acc_ips -> (\b3 ->
                  bind b3 as {i:free_bucket} in acc_ips.combine ({|i:address|
                  get_ring_node {key:free_bucket.fold ((\acc -> (\b3 ->
                    bind b3 as {key:i, value:val} in acc + (val * (case
                    ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                    value:value} in key == i))).peek ()) of
                    {Some x -> x}{None ->
                                   error (print "can't find i in dim_bounds")}).value))))
                    bound_bucket, value:max_val}|} @ { Collection }))))
                  empty {i:address} @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {i:ip} in ip)) ((\_ -> (\_ -> ()))) () in
                if 0 == sorted_ip_list.size ()
                  then {|i:address|
                    get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
                  else sorted_ip_list.fold ((\_accmap -> (\x ->
                    (_accmap.insert ({i:x.key});_accmap))))
                    empty {i:address} @ { Collection }}{None -> nodes})


declare shuffle_QUERY18_mLINEITEM2_mCUSTOMER1_to_QUERY18_mCUSTOMER1_bind_0t0_1t1 :
  { ra:option int, rb:option int, rc:collection { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int } @ { Collection }, rd:bool } -> collection {
  key:address, value:collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:tuples, rd:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_int {ra:6, rb:lkey_0, rc:lkey_1}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3} in
    (route_to_int_int {ra:6, rb:Some rkey_1, rc:Some rkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int, rd:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection })


declare shuffle_QUERY18_mLINEITEM2_to_QUERY18_mLINEITEM5_bind_0t0_1t1 : {
  ra:option int, rb:option int, rc:collection { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int } @ { Collection }, rd:bool } -> collection {
  key:address, value:collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:tuples, rd:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_int {ra:4, rb:lkey_0, rc:lkey_1}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3} in
    (route_to_int_int {ra:4, rb:Some rkey_1, rc:Some rkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int, rd:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection })


declare shuffle_QUERY18_mLINEITEM5_to_QUERY18_bind_0t0 : { ra:option int,
  rb:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:real
  } @ { Collection }, rc:bool } -> collection { key:address, value:collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:tuples,
  rc:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int {key:1, value:lkey_0}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:real } @ { Collection }
      } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3} in
    (route_to_int {key:1, value:Some rkey_1}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:real } @ { Collection }
      } @ { Collection })))) empty { key:address, value:collection { ra:{
    key:int, value:int }, rb:int, rc:int, rd:real } @ { Collection }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real
    } @ { Collection })


declare shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18 : { ra:option int,
  rb:collection { ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection },
  rc:bool } -> collection { key:address, value:collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:tuples, rc:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int {key:1, value:lkey_0}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2} in
    (route_to_int {key:1, value:lkey_0}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int } @ { Collection })


declare shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18 : { ra:option int,
  rb:collection { ra:{ key:int, value:int }, rb:int, rc:real
  } @ { Collection }, rc:bool } -> collection { key:address, value:collection {
  ra:{ key:int, value:int }, rb:int, rc:real } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:tuples,
  rc:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int {key:1, value:lkey_0}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:real } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2} in
    (route_to_int {key:1, value:lkey_0}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:real } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:real } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:real } @ { Collection })


declare shuffle_QUERY18_mLINEITEM2_to_QUERY18_bind_0t0 : { ra:option int,
  rb:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rc:bool } -> collection { key:address, value:collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:tuples,
  rc:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int {key:1, value:lkey_0}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3} in
    (route_to_int {key:1, value:Some rkey_1}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int, rd:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection })


declare shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18_mCUSTOMER1_bind_1t0 : {
  ra:option int, rb:option int, rc:collection { ra:{ key:int, value:int },
  rb:int, rc:real } @ { Collection }, rd:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:int, rc:real
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:tuples, rd:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_int {ra:6, rb:lkey_0, rc:lkey_1}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:real } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2} in
    (route_to_int_int {ra:6, rb:lkey_0, rc:Some rkey_1}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:real } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:real } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:real } @ { Collection })


declare shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18_mLINEITEM5_bind_1t0 : {
  ra:option int, rb:option int, rc:collection { ra:{ key:int, value:int },
  rb:int, rc:real } @ { Collection }, rd:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:int, rc:real
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:tuples, rd:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_int {ra:4, rb:lkey_0, rc:lkey_1}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:real } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2} in
    (route_to_int_int {ra:4, rb:lkey_0, rc:Some rkey_1}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:real } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:real } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:real } @ { Collection })


declare shuffle_QUERY18_mORDERS2_to_QUERY18_mLINEITEM5_bind_0t0 : {
  ra:option int, rb:option int, rc:collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Collection }, rd:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:int, rc:int
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:tuples, rd:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_int {ra:4, rb:lkey_0, rc:lkey_1}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2} in
    (route_to_int_int {ra:4, rb:Some rkey_1, rc:lkey_1}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int } @ { Collection })


declare shuffle_QUERY18_mORDERS2_to_QUERY18_mLINEITEM2_bind_0t0 : {
  ra:option int, rb:option int, rc:collection { ra:{ key:int, value:int },
  rb:int, rc:int } @ { Collection }, rd:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:int, rc:int
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:tuples, rd:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_int {ra:2, rb:lkey_0, rc:lkey_1}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2} in
    (route_to_int_int {ra:2, rb:Some rkey_1, rc:lkey_1}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int } @ { Collection })


declare shuffle_QUERY18_mORDERS2_to_QUERY18_bind_0t0 : { ra:option int,
  rb:collection { ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection },
  rc:bool } -> collection { key:address, value:collection { ra:{ key:int,
  value:int }, rb:int, rc:int } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:tuples, rc:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int {key:1, value:lkey_0}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2} in
    (route_to_int {key:1, value:Some rkey_1}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int } @ { Collection })


declare shuffle_QUERY18_mCUSTOMER1_to_QUERY18_mLINEITEM5_bind_0t0_1t1 : {
  ra:option int, rb:option int, rc:collection { ra:{ key:int, value:int },
  rb:int, rc:int, rd:real } @ { Collection }, rd:bool } -> collection {
  key:address, value:collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:real } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:tuples, rd:shuffle_on_empty} in let
  all_targets =
  if shuffle_on_empty == true
    then (route_to_int_int {ra:4, rb:lkey_0, rc:lkey_1}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:real } @ { Collection }
      } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3} in
    (route_to_int_int {ra:4, rb:Some rkey_1, rc:Some rkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:real } @ { Collection }
      } @ { Collection })))) empty { key:address, value:collection { ra:{
    key:int, value:int }, rb:int, rc:int, rd:real } @ { Collection }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real
    } @ { Collection })


declare shuffle_QUERY18_mLINEITEM2_mCUSTOMER1_to_QUERY18_mLINEITEM2_bind_0t0_1t1 :
  { ra:option int, rb:option int, rc:collection { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int } @ { Collection }, rd:bool } -> collection {
  key:address, value:collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:tuples, rd:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_int {ra:2, rb:lkey_0, rc:lkey_1}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3} in
    (route_to_int_int {ra:2, rb:Some rkey_1, rc:Some rkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int, rd:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection })


declare shuffle_QUERY18_mCUSTOMER1_to_QUERY18_bind_0t0 : { ra:option int,
  rb:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:real
  } @ { Collection }, rc:bool } -> collection { key:address, value:collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:tuples,
  rc:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int {key:1, value:lkey_0}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:real } @ { Collection }
      } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3} in
    (route_to_int {key:1, value:Some rkey_1}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:real } @ { Collection }
      } @ { Collection })))) empty { key:address, value:collection { ra:{
    key:int, value:int }, rb:int, rc:int, rd:real } @ { Collection }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real
    } @ { Collection })


declare nd_QUERY18_mCUSTOMER1_L1_2_send_correctives : { ra:address, rb:int,
  rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:0, value:0}, {key:1, value:4}, {key:2, value:8}, {key:3, value:13},
    {key:4, value:18}, {key:5, value:23}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {key:map_0,
        value:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_val};_accmap))))
        empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 23
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_LINEITEM vid as
            {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
            in
            (shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18 {ra:None immut,
               rb:delta_tuples2, rc:false}).fold ((\_accmap -> (\b3 ->
              bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
               key:int, value:int } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { key:int, value:int } @ { Collection }
              } @ { Collection })))) empty { ra:address, rb:{ key:int,
            value:int }, rc:collection { key:int, value:int } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
             value:int } @ { Collection }})))) {key:empty { key:int, value:int
            } @ { Seq }, value:empty { key:int, value:int } @ { Collection }}
          in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_LINEITEM_rcv_corrective_s23_m_QUERY18_mCUSTOMER1_L1_2, ip)<- {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
             rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 18
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_LINEITEM vid as
              {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
              in
              (shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18 {ra:None immut,
                 rb:delta_tuples2, rc:false}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
                 (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
                 key:int, value:int } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { key:int, value:int } @ { Collection }
                } @ { Collection })))) empty { ra:address, rb:{ key:int,
              value:int }, rc:collection { key:int, value:int
              } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
              bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
              bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
              rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
               value:int } @ { Collection }})))) {key:empty { key:int,
              value:int } @ { Seq }, value:empty { key:int, value:int
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_LINEITEM_rcv_corrective_s18_m_QUERY18_mCUSTOMER1_L1_2,
                 ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
               re:corrective_vid, rf:vid_send_list_tup.key,
               rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 13
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_delete_ORDERS vid as
                {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                in
                (shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18
                   {ra:Some ORDERS_CUSTKEY, rb:delta_tuples2, rc:false}).fold
                  ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
                   (_accmap.insert {key:map_0, value:map_val};_accmap))))
                   empty { key:int, value:int } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { key:int, value:int } @ { Collection }
                  } @ { Collection })))) empty { ra:address, rb:{ key:int,
                value:int }, rc:collection { key:int, value:int
                } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                bind b2 as {key:acc_vid, value:acc_tuples} in 
                bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { key:int, value:int } @ { Collection }}))))
                {key:empty { key:int, value:int } @ { Seq }, value:empty {
                key:int, value:int } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((delete_ORDERS_rcv_corrective_s13_m_QUERY18_mCUSTOMER1_L1_2,
                   ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                 re:corrective_vid, rf:vid_send_list_tup.key,
                 rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 8
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_insert_ORDERS vid as
                  {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                  in
                  (shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18
                     {ra:Some ORDERS_CUSTKEY, rb:delta_tuples2, rc:false}).fold
                    ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_val} in 
                     (_accmap.insert {key:map_0, value:map_val};_accmap))))
                     empty { key:int, value:int } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { key:int, value:int } @ { Collection }
                    } @ { Collection })))) empty { ra:address, rb:{ key:int,
                  value:int }, rc:collection { key:int, value:int
                  } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                  (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { key:int, value:int } @ { Collection }}))))
                  {key:empty { key:int, value:int } @ { Seq }, value:empty {
                  key:int, value:int } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((insert_ORDERS_rcv_corrective_s8_m_QUERY18_mCUSTOMER1_L1_2,
                     ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                   re:corrective_vid, rf:vid_send_list_tup.key,
                   rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count
              else if stmt_id == 4
                then let ips_vids =
                  (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                    nd_log_get_bound_delete_CUSTOMER vid as
                    {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                    in
                    (shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18
                       {ra:Some CUSTOMER_CUSTKEY, rb:delta_tuples2, rc:false}).fold
                      ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                      value:tuples} in 
                      (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                       ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                       rc:map_val} in 
                       (_accmap.insert {key:map_0, value:map_val};_accmap))))
                       empty { key:int, value:int } @ { Collection }};
                       _accmap)))) empty { ra:address, rb:{ key:int, value:int
                      }, rc:collection { key:int, value:int } @ { Collection }
                      } @ { Collection })))) empty { ra:address, rb:{ key:int,
                    value:int }, rc:collection { key:int, value:int
                    } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                    bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                    (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                    bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                    (acc_vid.insert vid;
                     {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                     ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                     ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                     empty { key:int, value:int } @ { Collection }}))))
                    {key:empty { key:int, value:int } @ { Seq }, value:empty {
                    key:int, value:int } @ { Collection }} in
                  ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                    value:vid_send_list_tup} in 
                    ((delete_CUSTOMER_rcv_corrective_s4_m_QUERY18_mCUSTOMER1_L1_2,
                       ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                     rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                     rg:vid_send_list_tup.value};
                     acc_count + 1)))) acc_count
                else if stmt_id == 0
                  then let ips_vids =
                    (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                      nd_log_get_bound_insert_CUSTOMER vid as
                      {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                      in
                      (shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18
                         {ra:Some CUSTOMER_CUSTKEY, rb:delta_tuples2, rc:false}).fold
                        ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                        value:tuples} in 
                        (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                         ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                         rc:map_val} in 
                         (_accmap.insert {key:map_0, value:map_val};_accmap))))
                         empty { key:int, value:int } @ { Collection }};
                         _accmap)))) empty { ra:address, rb:{ key:int,
                        value:int }, rc:collection { key:int, value:int
                        } @ { Collection } } @ { Collection })))) empty {
                      ra:address, rb:{ key:int, value:int }, rc:collection {
                      key:int, value:int } @ { Collection }
                      } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                      rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                      bind b2 as {key:acc_vid, value:acc_tuples} in 
                      bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                      (acc_vid.insert vid;
                       {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                       ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                       ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                       empty { key:int, value:int } @ { Collection }}))))
                      {key:empty { key:int, value:int } @ { Seq },
                      value:empty { key:int, value:int } @ { Collection }} in
                    ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                      value:vid_send_list_tup} in 
                      ((insert_CUSTOMER_rcv_corrective_s0_m_QUERY18_mCUSTOMER1_L1_2,
                         ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                       rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                       rg:vid_send_list_tup.value};
                       acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_QUERY18_mCUSTOMER1_L1_1_L1_1_send_correctives : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:real } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:0, value:0}, {key:1, value:4}, {key:2, value:8}, {key:2, value:11},
    {key:2, value:12}, {key:3, value:13}, {key:3, value:16}, {key:3, value:17},
    {key:4, value:18}, {key:5, value:23}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {key:map_0,
        value:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_val};_accmap))))
        empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Collection }
      in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 23
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_LINEITEM vid as
            {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
            in
            (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18 {ra:None immut,
               rb:delta_tuples2, rc:false}).fold ((\_accmap -> (\b3 ->
              bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
               key:int, value:real } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { key:int, value:real } @ { Collection }
              } @ { Collection })))) empty { ra:address, rb:{ key:int,
            value:int }, rc:collection { key:int, value:real } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
             value:real } @ { Collection }})))) {key:empty { key:int, value:int
            } @ { Seq }, value:empty { key:int, value:real } @ { Collection }}
          in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_LINEITEM_rcv_corrective_s23_m_QUERY18_mCUSTOMER1_L1_1_L1_1,
               ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:corrective_vid, rf:vid_send_list_tup.key,
             rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 18
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_LINEITEM vid as
              {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
              in
              (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18 {ra:None immut,
                 rb:delta_tuples2, rc:false}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
                 (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
                 key:int, value:real } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { key:int, value:real } @ { Collection }
                } @ { Collection })))) empty { ra:address, rb:{ key:int,
              value:int }, rc:collection { key:int, value:real
              } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
              bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
              bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
              rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
               value:real } @ { Collection }})))) {key:empty { key:int,
              value:int } @ { Seq }, value:empty { key:int, value:real
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_LINEITEM_rcv_corrective_s18_m_QUERY18_mCUSTOMER1_L1_1_L1_1,
                 ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
               re:corrective_vid, rf:vid_send_list_tup.key,
               rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 17
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_delete_ORDERS vid as
                {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                in
                (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18_mCUSTOMER1_bind_1t0
                   {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
                   rc:delta_tuples2, rd:false}).fold ((\_accmap -> (\b3 ->
                  bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
                   (_accmap.insert {key:map_0, value:map_val};_accmap))))
                   empty { key:int, value:real } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { key:int, value:real } @ { Collection }
                  } @ { Collection })))) empty { ra:address, rb:{ key:int,
                value:int }, rc:collection { key:int, value:real
                } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                bind b2 as {key:acc_vid, value:acc_tuples} in 
                bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { key:int, value:real } @ { Collection }}))))
                {key:empty { key:int, value:int } @ { Seq }, value:empty {
                key:int, value:real } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((delete_ORDERS_rcv_corrective_s17_m_QUERY18_mCUSTOMER1_L1_1_L1_1,
                   ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                 re:corrective_vid, rf:vid_send_list_tup.key,
                 rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 16
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_delete_ORDERS vid as
                  {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                  in
                  (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18_mLINEITEM5_bind_1t0
                     {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
                     rc:delta_tuples2, rd:false}).fold ((\_accmap -> (\b3 ->
                    bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_val} in 
                     (_accmap.insert {key:map_0, value:map_val};_accmap))))
                     empty { key:int, value:real } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { key:int, value:real } @ { Collection }
                    } @ { Collection })))) empty { ra:address, rb:{ key:int,
                  value:int }, rc:collection { key:int, value:real
                  } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                  (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { key:int, value:real } @ { Collection }}))))
                  {key:empty { key:int, value:int } @ { Seq }, value:empty {
                  key:int, value:real } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((delete_ORDERS_rcv_corrective_s16_m_QUERY18_mCUSTOMER1_L1_1_L1_1,
                     ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                   re:corrective_vid, rf:vid_send_list_tup.key,
                   rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count
              else if stmt_id == 13
                then let ips_vids =
                  (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                    nd_log_get_bound_delete_ORDERS vid as
                    {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                    in
                    (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18
                       {ra:Some ORDERS_CUSTKEY, rb:delta_tuples2, rc:false}).fold
                      ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                      value:tuples} in 
                      (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                       ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                       rc:map_val} in 
                       (_accmap.insert {key:map_0, value:map_val};_accmap))))
                       empty { key:int, value:real } @ { Collection }};
                       _accmap)))) empty { ra:address, rb:{ key:int, value:int
                      }, rc:collection { key:int, value:real } @ { Collection }
                      } @ { Collection })))) empty { ra:address, rb:{ key:int,
                    value:int }, rc:collection { key:int, value:real
                    } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                    bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                    (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                    bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                    (acc_vid.insert vid;
                     {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                     ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                     ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                     empty { key:int, value:real } @ { Collection }}))))
                    {key:empty { key:int, value:int } @ { Seq }, value:empty {
                    key:int, value:real } @ { Collection }} in
                  ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                    value:vid_send_list_tup} in 
                    ((delete_ORDERS_rcv_corrective_s13_m_QUERY18_mCUSTOMER1_L1_1_L1_1,
                       ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                     rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                     rg:vid_send_list_tup.value};
                     acc_count + 1)))) acc_count
                else if stmt_id == 12
                  then let ips_vids =
                    (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                      nd_log_get_bound_insert_ORDERS vid as
                      {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                      in
                      (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18_mCUSTOMER1_bind_1t0
                         {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
                         rc:delta_tuples2, rd:false}).fold ((\_accmap ->
                        (\b3 -> bind b3 as {key:ip, value:tuples} in 
                        (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                         ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                         rc:map_val} in 
                         (_accmap.insert {key:map_0, value:map_val};_accmap))))
                         empty { key:int, value:real } @ { Collection }};
                         _accmap)))) empty { ra:address, rb:{ key:int,
                        value:int }, rc:collection { key:int, value:real
                        } @ { Collection } } @ { Collection })))) empty {
                      ra:address, rb:{ key:int, value:int }, rc:collection {
                      key:int, value:real } @ { Collection }
                      } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                      rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                      bind b2 as {key:acc_vid, value:acc_tuples} in 
                      bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                      (acc_vid.insert vid;
                       {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                       ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                       ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                       empty { key:int, value:real } @ { Collection }}))))
                      {key:empty { key:int, value:int } @ { Seq },
                      value:empty { key:int, value:real } @ { Collection }} in
                    ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                      value:vid_send_list_tup} in 
                      ((insert_ORDERS_rcv_corrective_s12_m_QUERY18_mCUSTOMER1_L1_1_L1_1,
                         ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                       rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                       rg:vid_send_list_tup.value};
                       acc_count + 1)))) acc_count
                  else if stmt_id == 11
                    then let ips_vids =
                      (vid_list.fold ((\_accext -> (\vid -> _accext.combine
                        (bind nd_log_get_bound_insert_ORDERS vid as
                        {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                        in
                        (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18_mLINEITEM5_bind_1t0
                           {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
                           rc:delta_tuples2, rd:false}).fold ((\_accmap ->
                          (\b3 -> bind b3 as {key:ip, value:tuples} in 
                          (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                           ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                           rc:map_val} in 
                           (_accmap.insert {key:map_0, value:map_val};_accmap))))
                           empty { key:int, value:real } @ { Collection }};
                           _accmap)))) empty { ra:address, rb:{ key:int,
                          value:int }, rc:collection { key:int, value:real
                          } @ { Collection } } @ { Collection })))) empty {
                        ra:address, rb:{ key:int, value:int }, rc:collection {
                        key:int, value:real } @ { Collection }
                        } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                        rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                        bind b2 as {key:acc_vid, value:acc_tuples} in 
                        bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                        (acc_vid.insert vid;
                         {key:acc_vid, value:((acc_tuples.combine
                         tuples).groupBy ((\tuple -> tuple)) ((\_ -> (\_ ->
                         ()))) ()).fold ((\_accmap -> (\x ->
                         (_accmap.insert (x.key);_accmap)))) empty { key:int,
                         value:real } @ { Collection }})))) {key:empty {
                        key:int, value:int } @ { Seq }, value:empty { key:int,
                        value:real } @ { Collection }} in
                      ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                        value:vid_send_list_tup} in 
                        ((insert_ORDERS_rcv_corrective_s11_m_QUERY18_mCUSTOMER1_L1_1_L1_1,
                           ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                         rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                         rg:vid_send_list_tup.value};
                         acc_count + 1)))) acc_count
                    else if stmt_id == 8
                      then let ips_vids =
                        (vid_list.fold ((\_accext -> (\vid -> _accext.combine
                          (bind nd_log_get_bound_insert_ORDERS vid as
                          {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                          in
                          (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18
                             {ra:Some ORDERS_CUSTKEY, rb:delta_tuples2,
                             rc:false}).fold ((\_accmap -> (\b3 ->
                            bind b3 as {key:ip, value:tuples} in 
                            (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                             ((\_accmap -> (\b3 -> bind b3 as {ra:vid,
                             rb:map_0, rc:map_val} in 
                             (_accmap.insert {key:map_0, value:map_val};_accmap))))
                             empty { key:int, value:real } @ { Collection }};
                             _accmap)))) empty { ra:address, rb:{ key:int,
                            value:int }, rc:collection { key:int, value:real
                            } @ { Collection } } @ { Collection })))) empty {
                          ra:address, rb:{ key:int, value:int },
                          rc:collection { key:int, value:real
                          } @ { Collection } } @ { Collection }).groupBy
                          ((\b1 -> bind b1 as {ra:ip, rb:vid, rc:tuples} in 
                          ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                          value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                          rc:tuples} in 
                          (acc_vid.insert vid;
                           {key:acc_vid, value:((acc_tuples.combine
                           tuples).groupBy ((\tuple -> tuple)) ((\_ -> (\_ ->
                           ()))) ()).fold ((\_accmap -> (\x ->
                           (_accmap.insert (x.key);_accmap)))) empty { key:int,
                           value:real } @ { Collection }})))) {key:empty {
                          key:int, value:int } @ { Seq }, value:empty {
                          key:int, value:real } @ { Collection }} in
                        ips_vids.fold ((\acc_count -> (\b3 ->
                          bind b3 as {key:ip, value:vid_send_list_tup} in 
                          ((insert_ORDERS_rcv_corrective_s8_m_QUERY18_mCUSTOMER1_L1_1_L1_1,
                             ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                           rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                           rg:vid_send_list_tup.value};
                           acc_count + 1)))) acc_count
                      else if stmt_id == 4
                        then let ips_vids =
                          (vid_list.fold ((\_accext -> (\vid -> _accext.combine
                            (bind nd_log_get_bound_delete_CUSTOMER vid as
                            {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                            in
                            (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18
                               {ra:Some CUSTOMER_CUSTKEY, rb:delta_tuples2,
                               rc:false}).fold ((\_accmap -> (\b3 ->
                              bind b3 as {key:ip, value:tuples} in 
                              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                               ((\_accmap -> (\b3 -> bind b3 as {ra:vid,
                               rb:map_0, rc:map_val} in 
                               (_accmap.insert {key:map_0, value:map_val};
                                _accmap)))) empty { key:int, value:real
                               } @ { Collection }};
                               _accmap)))) empty { ra:address, rb:{ key:int,
                              value:int }, rc:collection { key:int, value:real
                              } @ { Collection } } @ { Collection })))) empty {
                            ra:address, rb:{ key:int, value:int },
                            rc:collection { key:int, value:real
                            } @ { Collection } } @ { Collection }).groupBy
                            ((\b1 -> bind b1 as {ra:ip, rb:vid, rc:tuples} in 
                            ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                            value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                            rc:tuples} in 
                            (acc_vid.insert vid;
                             {key:acc_vid, value:((acc_tuples.combine
                             tuples).groupBy ((\tuple -> tuple)) ((\_ -> (\_ ->
                             ()))) ()).fold ((\_accmap -> (\x ->
                             (_accmap.insert (x.key);_accmap)))) empty {
                             key:int, value:real } @ { Collection }}))))
                            {key:empty { key:int, value:int } @ { Seq },
                            value:empty { key:int, value:real
                            } @ { Collection }} in
                          ips_vids.fold ((\acc_count -> (\b3 ->
                            bind b3 as {key:ip, value:vid_send_list_tup} in 
                            ((delete_CUSTOMER_rcv_corrective_s4_m_QUERY18_mCUSTOMER1_L1_1_L1_1,
                               ip)<- {ra:orig_addr, rb:orig_stmt_id,
                             rc:orig_vid, rd:hop, re:corrective_vid,
                             rf:vid_send_list_tup.key,
                             rg:vid_send_list_tup.value};
                             acc_count + 1)))) acc_count
                        else if stmt_id == 0
                          then let ips_vids =
                            (vid_list.fold ((\_accext -> (\vid ->
                              _accext.combine (bind
                              nd_log_get_bound_insert_CUSTOMER vid as
                              {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                              in
                              (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18
                                 {ra:Some CUSTOMER_CUSTKEY, rb:delta_tuples2,
                                 rc:false}).fold ((\_accmap -> (\b3 ->
                                bind b3 as {key:ip, value:tuples} in 
                                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                                 ((\_accmap -> (\b3 -> bind b3 as {ra:vid,
                                 rb:map_0, rc:map_val} in 
                                 (_accmap.insert {key:map_0, value:map_val};
                                  _accmap)))) empty { key:int, value:real
                                 } @ { Collection }};
                                 _accmap)))) empty { ra:address, rb:{ key:int,
                                value:int }, rc:collection { key:int,
                                value:real } @ { Collection }
                                } @ { Collection })))) empty { ra:address, rb:{
                              key:int, value:int }, rc:collection { key:int,
                              value:real } @ { Collection }
                              } @ { Collection }).groupBy ((\b1 ->
                              bind b1 as {ra:ip, rb:vid, rc:tuples} in ip))
                              ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                              value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                              rc:tuples} in 
                              (acc_vid.insert vid;
                               {key:acc_vid, value:((acc_tuples.combine
                               tuples).groupBy ((\tuple -> tuple)) ((\_ ->
                               (\_ -> ()))) ()).fold ((\_accmap -> (\x ->
                               (_accmap.insert (x.key);_accmap)))) empty {
                               key:int, value:real } @ { Collection }}))))
                              {key:empty { key:int, value:int } @ { Seq },
                              value:empty { key:int, value:real
                              } @ { Collection }} in
                            ips_vids.fold ((\acc_count -> (\b3 ->
                              bind b3 as {key:ip, value:vid_send_list_tup} in 
                              ((insert_CUSTOMER_rcv_corrective_s0_m_QUERY18_mCUSTOMER1_L1_1_L1_1,
                                 ip)<- {ra:orig_addr, rb:orig_stmt_id,
                               rc:orig_vid, rd:hop, re:corrective_vid,
                               rf:vid_send_list_tup.key,
                               rg:vid_send_list_tup.value};
                               acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_QUERY18_mCUSTOMER1_send_correctives : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  ra:int, rb:int, rc:real } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:0, value:0}, {key:0, value:2}, {key:1, value:4}, {key:1,
    value:6}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_val};_accmap))))
        empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real
        } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 6
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_CUSTOMER vid as
            {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
            in
            (shuffle_QUERY18_mCUSTOMER1_to_QUERY18_mLINEITEM5_bind_0t0_1t1
               {ra:Some CUSTOMER_CUSTKEY, rb:None immut, rc:delta_tuples2,
               rd:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
              value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
               empty { ra:int, rb:int, rc:real } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:int, rb:int, rc:real } @ { Collection }
              } @ { Collection })))) empty { ra:address, rb:{ key:int,
            value:int }, rc:collection { ra:int, rb:int, rc:real
            } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
            bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
            bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
            rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int, rb:int,
             rc:real } @ { Collection }})))) {key:empty { key:int, value:int
            } @ { Seq }, value:empty { ra:int, rb:int, rc:real
            } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_CUSTOMER_rcv_corrective_s6_m_QUERY18_mCUSTOMER1, ip)<- {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
             rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 4
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_delete_CUSTOMER vid as
              {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
              in
              (shuffle_QUERY18_mCUSTOMER1_to_QUERY18_bind_0t0
                 {ra:Some CUSTOMER_CUSTKEY, rb:delta_tuples2, rc:false}).fold
                ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
                 rd:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
                 empty { ra:int, rb:int, rc:real } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:int, rb:int, rc:real } @ { Collection }
                } @ { Collection })))) empty { ra:address, rb:{ key:int,
              value:int }, rc:collection { ra:int, rb:int, rc:real
              } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
              bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
              bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
              rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int,
               rb:int, rc:real } @ { Collection }})))) {key:empty { key:int,
              value:int } @ { Seq }, value:empty { ra:int, rb:int, rc:real
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((delete_CUSTOMER_rcv_corrective_s4_m_QUERY18_mCUSTOMER1, ip)<- {ra:orig_addr,
               rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
               rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 2
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_insert_CUSTOMER vid as
                {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                in
                (shuffle_QUERY18_mCUSTOMER1_to_QUERY18_mLINEITEM5_bind_0t0_1t1
                   {ra:Some CUSTOMER_CUSTKEY, rb:None immut, rc:delta_tuples2,
                   rd:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                  value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
                   rd:map_val} in 
                   (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
                   empty { ra:int, rb:int, rc:real } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { ra:int, rb:int, rc:real } @ { Collection }
                  } @ { Collection })))) empty { ra:address, rb:{ key:int,
                value:int }, rc:collection { ra:int, rb:int, rc:real
                } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                bind b2 as {key:acc_vid, value:acc_tuples} in 
                bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { ra:int, rb:int, rc:real } @ { Collection }}))))
                {key:empty { key:int, value:int } @ { Seq }, value:empty {
                ra:int, rb:int, rc:real } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((insert_CUSTOMER_rcv_corrective_s2_m_QUERY18_mCUSTOMER1, ip)<- {ra:orig_addr,
                 rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
                 rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 0
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_insert_CUSTOMER vid as
                  {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                  in
                  (shuffle_QUERY18_mCUSTOMER1_to_QUERY18_bind_0t0
                     {ra:Some CUSTOMER_CUSTKEY, rb:delta_tuples2, rc:false}).fold
                    ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_1, rd:map_val} in 
                     (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
                     empty { ra:int, rb:int, rc:real } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { ra:int, rb:int, rc:real } @ { Collection }
                    } @ { Collection })))) empty { ra:address, rb:{ key:int,
                  value:int }, rc:collection { ra:int, rb:int, rc:real
                  } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                  (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { ra:int, rb:int, rc:real } @ { Collection }}))))
                  {key:empty { key:int, value:int } @ { Seq }, value:empty {
                  ra:int, rb:int, rc:real } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((insert_CUSTOMER_rcv_corrective_s0_m_QUERY18_mCUSTOMER1, ip)<- {ra:orig_addr,
                   rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
                   rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_QUERY18_mLINEITEM2_mCUSTOMER1_send_correctives : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { ra:int, rb:int, rc:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:0, value:1}, {key:1, value:5}, {key:4, value:20}, {key:5,
    value:25}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_val};_accmap))))
        empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
        } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 25
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_LINEITEM vid as
            {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
            in
            (shuffle_QUERY18_mLINEITEM2_mCUSTOMER1_to_QUERY18_mCUSTOMER1_bind_0t0_1t1
               {ra:None immut, rb:Some LINEITEM_ORDERKEY, rc:delta_tuples2,
               rd:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
              value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
               empty { ra:int, rb:int, rc:int } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:int, rb:int, rc:int } @ { Collection }
              } @ { Collection })))) empty { ra:address, rb:{ key:int,
            value:int }, rc:collection { ra:int, rb:int, rc:int
            } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
            bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
            bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
            rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int, rb:int,
             rc:int } @ { Collection }})))) {key:empty { key:int, value:int
            } @ { Seq }, value:empty { ra:int, rb:int, rc:int
            } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_LINEITEM_rcv_corrective_s25_m_QUERY18_mLINEITEM2_mCUSTOMER1,
               ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:corrective_vid, rf:vid_send_list_tup.key,
             rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 20
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_LINEITEM vid as
              {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
              in
              (shuffle_QUERY18_mLINEITEM2_mCUSTOMER1_to_QUERY18_mCUSTOMER1_bind_0t0_1t1
                 {ra:None immut, rb:Some LINEITEM_ORDERKEY, rc:delta_tuples2,
                 rd:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
                 rd:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
                 empty { ra:int, rb:int, rc:int } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:int, rb:int, rc:int } @ { Collection }
                } @ { Collection })))) empty { ra:address, rb:{ key:int,
              value:int }, rc:collection { ra:int, rb:int, rc:int
              } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
              bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
              bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
              rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int,
               rb:int, rc:int } @ { Collection }})))) {key:empty { key:int,
              value:int } @ { Seq }, value:empty { ra:int, rb:int, rc:int
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_LINEITEM_rcv_corrective_s20_m_QUERY18_mLINEITEM2_mCUSTOMER1,
                 ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
               re:corrective_vid, rf:vid_send_list_tup.key,
               rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 5
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_delete_CUSTOMER vid as
                {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                in
                (shuffle_QUERY18_mLINEITEM2_mCUSTOMER1_to_QUERY18_mLINEITEM2_bind_0t0_1t1
                   {ra:Some CUSTOMER_CUSTKEY, rb:None immut, rc:delta_tuples2,
                   rd:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                  value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
                   rd:map_val} in 
                   (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
                   empty { ra:int, rb:int, rc:int } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { ra:int, rb:int, rc:int } @ { Collection }
                  } @ { Collection })))) empty { ra:address, rb:{ key:int,
                value:int }, rc:collection { ra:int, rb:int, rc:int
                } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                bind b2 as {key:acc_vid, value:acc_tuples} in 
                bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { ra:int, rb:int, rc:int } @ { Collection }}))))
                {key:empty { key:int, value:int } @ { Seq }, value:empty {
                ra:int, rb:int, rc:int } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((delete_CUSTOMER_rcv_corrective_s5_m_QUERY18_mLINEITEM2_mCUSTOMER1,
                   ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                 re:corrective_vid, rf:vid_send_list_tup.key,
                 rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 1
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_insert_CUSTOMER vid as
                  {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                  in
                  (shuffle_QUERY18_mLINEITEM2_mCUSTOMER1_to_QUERY18_mLINEITEM2_bind_0t0_1t1
                     {ra:Some CUSTOMER_CUSTKEY, rb:None immut,
                     rc:delta_tuples2, rd:false}).fold ((\_accmap -> (\b3 ->
                    bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_1, rd:map_val} in 
                     (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
                     empty { ra:int, rb:int, rc:int } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { ra:int, rb:int, rc:int } @ { Collection }
                    } @ { Collection })))) empty { ra:address, rb:{ key:int,
                  value:int }, rc:collection { ra:int, rb:int, rc:int
                  } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                  (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { ra:int, rb:int, rc:int } @ { Collection }}))))
                  {key:empty { key:int, value:int } @ { Seq }, value:empty {
                  ra:int, rb:int, rc:int } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((insert_CUSTOMER_rcv_corrective_s1_m_QUERY18_mLINEITEM2_mCUSTOMER1,
                     ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                   re:corrective_vid, rf:vid_send_list_tup.key,
                   rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_QUERY18_mORDERS2_send_correctives : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:2, value:8}, {key:2, value:9}, {key:2, value:11}, {key:3, value:13},
    {key:3, value:14}, {key:3, value:16}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {key:map_0,
        value:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_val};_accmap))))
        empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 16
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_ORDERS vid as
            {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
            in
            (shuffle_QUERY18_mORDERS2_to_QUERY18_mLINEITEM5_bind_0t0
               {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
               rc:delta_tuples2, rd:false}).fold ((\_accmap -> (\b3 ->
              bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
               key:int, value:int } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { key:int, value:int } @ { Collection }
              } @ { Collection })))) empty { ra:address, rb:{ key:int,
            value:int }, rc:collection { key:int, value:int } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
             value:int } @ { Collection }})))) {key:empty { key:int, value:int
            } @ { Seq }, value:empty { key:int, value:int } @ { Collection }}
          in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_ORDERS_rcv_corrective_s16_m_QUERY18_mORDERS2, ip)<- {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
             rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 14
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_delete_ORDERS vid as
              {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
              in
              (shuffle_QUERY18_mORDERS2_to_QUERY18_mLINEITEM2_bind_0t0
                 {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
                 rc:delta_tuples2, rd:false}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
                 (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
                 key:int, value:int } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { key:int, value:int } @ { Collection }
                } @ { Collection })))) empty { ra:address, rb:{ key:int,
              value:int }, rc:collection { key:int, value:int
              } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
              bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
              bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
              rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
               value:int } @ { Collection }})))) {key:empty { key:int,
              value:int } @ { Seq }, value:empty { key:int, value:int
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((delete_ORDERS_rcv_corrective_s14_m_QUERY18_mORDERS2, ip)<- {ra:orig_addr,
               rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
               rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 13
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_delete_ORDERS vid as
                {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                in
                (shuffle_QUERY18_mORDERS2_to_QUERY18_bind_0t0
                   {ra:Some ORDERS_CUSTKEY, rb:delta_tuples2, rc:false}).fold
                  ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
                   (_accmap.insert {key:map_0, value:map_val};_accmap))))
                   empty { key:int, value:int } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { key:int, value:int } @ { Collection }
                  } @ { Collection })))) empty { ra:address, rb:{ key:int,
                value:int }, rc:collection { key:int, value:int
                } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                bind b2 as {key:acc_vid, value:acc_tuples} in 
                bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { key:int, value:int } @ { Collection }}))))
                {key:empty { key:int, value:int } @ { Seq }, value:empty {
                key:int, value:int } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((delete_ORDERS_rcv_corrective_s13_m_QUERY18_mORDERS2, ip)<- {ra:orig_addr,
                 rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
                 rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 11
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_insert_ORDERS vid as
                  {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                  in
                  (shuffle_QUERY18_mORDERS2_to_QUERY18_mLINEITEM5_bind_0t0
                     {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
                     rc:delta_tuples2, rd:false}).fold ((\_accmap -> (\b3 ->
                    bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_val} in 
                     (_accmap.insert {key:map_0, value:map_val};_accmap))))
                     empty { key:int, value:int } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { key:int, value:int } @ { Collection }
                    } @ { Collection })))) empty { ra:address, rb:{ key:int,
                  value:int }, rc:collection { key:int, value:int
                  } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                  (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { key:int, value:int } @ { Collection }}))))
                  {key:empty { key:int, value:int } @ { Seq }, value:empty {
                  key:int, value:int } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((insert_ORDERS_rcv_corrective_s11_m_QUERY18_mORDERS2, ip)<- {ra:orig_addr,
                   rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
                   rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count
              else if stmt_id == 9
                then let ips_vids =
                  (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                    nd_log_get_bound_insert_ORDERS vid as
                    {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                    in
                    (shuffle_QUERY18_mORDERS2_to_QUERY18_mLINEITEM2_bind_0t0
                       {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
                       rc:delta_tuples2, rd:false}).fold ((\_accmap -> (\b3 ->
                      bind b3 as {key:ip, value:tuples} in 
                      (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                       ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                       rc:map_val} in 
                       (_accmap.insert {key:map_0, value:map_val};_accmap))))
                       empty { key:int, value:int } @ { Collection }};
                       _accmap)))) empty { ra:address, rb:{ key:int, value:int
                      }, rc:collection { key:int, value:int } @ { Collection }
                      } @ { Collection })))) empty { ra:address, rb:{ key:int,
                    value:int }, rc:collection { key:int, value:int
                    } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                    bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                    (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                    bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                    (acc_vid.insert vid;
                     {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                     ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                     ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                     empty { key:int, value:int } @ { Collection }}))))
                    {key:empty { key:int, value:int } @ { Seq }, value:empty {
                    key:int, value:int } @ { Collection }} in
                  ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                    value:vid_send_list_tup} in 
                    ((insert_ORDERS_rcv_corrective_s9_m_QUERY18_mORDERS2, ip)<- {ra:orig_addr,
                     rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
                     rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
                     acc_count + 1)))) acc_count
                else if stmt_id == 8
                  then let ips_vids =
                    (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                      nd_log_get_bound_insert_ORDERS vid as
                      {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                      in
                      (shuffle_QUERY18_mORDERS2_to_QUERY18_bind_0t0
                         {ra:Some ORDERS_CUSTKEY, rb:delta_tuples2, rc:false}).fold
                        ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                        value:tuples} in 
                        (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                         ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                         rc:map_val} in 
                         (_accmap.insert {key:map_0, value:map_val};_accmap))))
                         empty { key:int, value:int } @ { Collection }};
                         _accmap)))) empty { ra:address, rb:{ key:int,
                        value:int }, rc:collection { key:int, value:int
                        } @ { Collection } } @ { Collection })))) empty {
                      ra:address, rb:{ key:int, value:int }, rc:collection {
                      key:int, value:int } @ { Collection }
                      } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                      rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                      bind b2 as {key:acc_vid, value:acc_tuples} in 
                      bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                      (acc_vid.insert vid;
                       {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                       ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                       ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                       empty { key:int, value:int } @ { Collection }}))))
                      {key:empty { key:int, value:int } @ { Seq },
                      value:empty { key:int, value:int } @ { Collection }} in
                    ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                      value:vid_send_list_tup} in 
                      ((insert_ORDERS_rcv_corrective_s8_m_QUERY18_mORDERS2, ip)<- {ra:orig_addr,
                       rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
                       rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
                       acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_QUERY18_mLINEITEM2_send_correctives : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  ra:int, rb:int, rc:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:4, value:18}, {key:4, value:19}, {key:5, value:23}, {key:5,
    value:24}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_val};_accmap))))
        empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
        } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 24
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_LINEITEM vid as
            {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
            in
            (shuffle_QUERY18_mLINEITEM2_to_QUERY18_mLINEITEM5_bind_0t0_1t1
               {ra:None immut, rb:Some LINEITEM_ORDERKEY, rc:delta_tuples2,
               rd:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
              value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
               empty { ra:int, rb:int, rc:int } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:int, rb:int, rc:int } @ { Collection }
              } @ { Collection })))) empty { ra:address, rb:{ key:int,
            value:int }, rc:collection { ra:int, rb:int, rc:int
            } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
            bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
            bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
            rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int, rb:int,
             rc:int } @ { Collection }})))) {key:empty { key:int, value:int
            } @ { Seq }, value:empty { ra:int, rb:int, rc:int
            } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_LINEITEM_rcv_corrective_s24_m_QUERY18_mLINEITEM2, ip)<- {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
             rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 23
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_delete_LINEITEM vid as
              {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
              in
              (shuffle_QUERY18_mLINEITEM2_to_QUERY18_bind_0t0 {ra:None immut,
                 rb:delta_tuples2, rc:false}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
                 rd:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
                 empty { ra:int, rb:int, rc:int } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:int, rb:int, rc:int } @ { Collection }
                } @ { Collection })))) empty { ra:address, rb:{ key:int,
              value:int }, rc:collection { ra:int, rb:int, rc:int
              } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
              bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
              bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
              rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int,
               rb:int, rc:int } @ { Collection }})))) {key:empty { key:int,
              value:int } @ { Seq }, value:empty { ra:int, rb:int, rc:int
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((delete_LINEITEM_rcv_corrective_s23_m_QUERY18_mLINEITEM2, ip)<- {ra:orig_addr,
               rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
               rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 19
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_insert_LINEITEM vid as
                {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                in
                (shuffle_QUERY18_mLINEITEM2_to_QUERY18_mLINEITEM5_bind_0t0_1t1
                   {ra:None immut, rb:Some LINEITEM_ORDERKEY, rc:delta_tuples2,
                   rd:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                  value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
                   rd:map_val} in 
                   (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
                   empty { ra:int, rb:int, rc:int } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { ra:int, rb:int, rc:int } @ { Collection }
                  } @ { Collection })))) empty { ra:address, rb:{ key:int,
                value:int }, rc:collection { ra:int, rb:int, rc:int
                } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                bind b2 as {key:acc_vid, value:acc_tuples} in 
                bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { ra:int, rb:int, rc:int } @ { Collection }}))))
                {key:empty { key:int, value:int } @ { Seq }, value:empty {
                ra:int, rb:int, rc:int } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((insert_LINEITEM_rcv_corrective_s19_m_QUERY18_mLINEITEM2, ip)<- {ra:orig_addr,
                 rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
                 rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 18
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_insert_LINEITEM vid as
                  {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                  in
                  (shuffle_QUERY18_mLINEITEM2_to_QUERY18_bind_0t0
                     {ra:None immut, rb:delta_tuples2, rc:false}).fold
                    ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_1, rd:map_val} in 
                     (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
                     empty { ra:int, rb:int, rc:int } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { ra:int, rb:int, rc:int } @ { Collection }
                    } @ { Collection })))) empty { ra:address, rb:{ key:int,
                  value:int }, rc:collection { ra:int, rb:int, rc:int
                  } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                  (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { ra:int, rb:int, rc:int } @ { Collection }}))))
                  {key:empty { key:int, value:int } @ { Seq }, value:empty {
                  ra:int, rb:int, rc:int } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((insert_LINEITEM_rcv_corrective_s18_m_QUERY18_mLINEITEM2,
                     ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                   re:corrective_vid, rf:vid_send_list_tup.key,
                   rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_QUERY18_mLINEITEM5_send_correctives : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  ra:int, rb:int, rc:real } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:5, value:23}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_val};_accmap))))
        empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real
        } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 23
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_LINEITEM vid as
            {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
            in
            (shuffle_QUERY18_mLINEITEM5_to_QUERY18_bind_0t0 {ra:None immut,
               rb:delta_tuples2, rc:false}).fold ((\_accmap -> (\b3 ->
              bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
               empty { ra:int, rb:int, rc:real } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:int, rb:int, rc:real } @ { Collection }
              } @ { Collection })))) empty { ra:address, rb:{ key:int,
            value:int }, rc:collection { ra:int, rb:int, rc:real
            } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
            bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
            bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
            rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int, rb:int,
             rc:real } @ { Collection }})))) {key:empty { key:int, value:int
            } @ { Seq }, value:empty { ra:int, rb:int, rc:real
            } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_LINEITEM_rcv_corrective_s23_m_QUERY18_mLINEITEM5, ip)<- {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
             rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count else acc_count))) 0)


declare sw_insert_CUSTOMER : { ra:int, rb:string, rc:string, rd:int, re:string,
  rf:real, rg:string, rh:string } -> () = (\args ->
  (sw_buf_insert_CUSTOMER.insert args;
   sw_trig_buf_idx.insert {i:0};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_insert_CUSTOMER_send_fetch : { key:int, value:int } -> () = (\vid ->
  case (sw_buf_insert_CUSTOMER.peek ()) of
  {Some args ->
    (sw_buf_insert_CUSTOMER.erase args;
     bind args as
     {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
     in
     ((route_to_int {key:5, value:Some CUSTOMER_CUSTKEY}).iterate ((\b1 ->
      bind b1 as {i:ip} in 
      (nd_insert_CUSTOMER_do_complete_s3_trig, ip)<- {ra:vid,
      rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
      re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
      rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}));
      ((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_int_int {ra:6, rb:Some CUSTOMER_CUSTKEY, rc:None immut}).fold
        ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_QUERY18_mCUSTOMER1_to_QUERY18_bind_0t0
          {ra:Some CUSTOMER_CUSTKEY, rb:empty { ra:{ key:int, value:int },
          rb:int, rc:int, rd:real } @ { Collection }, rc:true}).fold
        ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:0, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_int {key:7, value:None immut}).fold ((\count -> (\b3 ->
          bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18
            {ra:Some CUSTOMER_CUSTKEY, rb:empty { ra:{ key:int, value:int },
            rb:int, rc:real } @ { Collection }, rc:true}).fold ((\_accmap ->
          (\b3 -> bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:0, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }).combine (let
          sender_count =
          (route_to_int {key:8, value:None immut}).fold ((\count -> (\b3 ->
            bind b3 as {i:ip} in count + 1))) 0 in
          ((shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18
              {ra:Some CUSTOMER_CUSTKEY, rb:empty { ra:{ key:int, value:int },
              rb:int, rc:int } @ { Collection }, rc:true}).fold ((\_accmap ->
            (\b3 -> bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {ra:ip, rb:0, rc:sender_count};_accmap)))) empty {
            ra:address, rb:int, rc:int } @ { Collection }).combine (let
            sender_count =
            (route_to_int_int {ra:3, rb:Some CUSTOMER_CUSTKEY, rc:None immut}).fold
              ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
            ((shuffle_QUERY18_mLINEITEM2_mCUSTOMER1_to_QUERY18_mLINEITEM2_bind_0t0_1t1
                {ra:Some CUSTOMER_CUSTKEY, rb:None immut, rc:empty { ra:{
                key:int, value:int }, rb:int, rc:int, rd:int
                } @ { Collection }, rd:true}).fold ((\_accmap -> (\b3 ->
              bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:1, rc:sender_count};_accmap))))
              empty { ra:address, rb:int, rc:int } @ { Collection }).combine
              (let sender_count =
              (route_to_int_int {ra:6, rb:Some CUSTOMER_CUSTKEY, rc:None immut}).fold
                ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
              (shuffle_QUERY18_mCUSTOMER1_to_QUERY18_mLINEITEM5_bind_0t0_1t1
                 {ra:Some CUSTOMER_CUSTKEY, rb:None immut, rc:empty { ra:{
                 key:int, value:int }, rb:int, rc:int, rd:real
                 } @ { Collection }, rd:true}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:2, rc:sender_count};_accmap))))
                empty { ra:address, rb:int, rc:int } @ { Collection })))))).groupBy
      ((\b1 -> bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip,
      value:stmt_id})) ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id,
      rc:count} in acc + count))) 0).groupBy ((\b1 -> bind b1 as {key:b2,
      value:count} in bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc ->
      (\b3 -> bind b3 as {key:ip_and_stmt_id, value:count} in bind
      ip_and_stmt_id as {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_insert_CUSTOMER_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid,
       rd:CUSTOMER_CUSTKEY, re:CUSTOMER_NAME, rf:CUSTOMER_ADDRESS,
       rg:CUSTOMER_NATIONKEY, rh:CUSTOMER_PHONE, ri:CUSTOMER_ACCTBAL,
       rj:CUSTOMER_MKTSEGMENT, rk:CUSTOMER_COMMENT};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_int_int {ra:6, rb:Some CUSTOMER_CUSTKEY, rc:None immut}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:2, rb:6, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:3, rb:Some CUSTOMER_CUSTKEY, rc:None immut}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:1, rb:3, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:8, value:None immut}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:0, rb:8, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int {key:7, value:None immut}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:0, rb:7, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:6, rb:Some CUSTOMER_CUSTKEY, rc:None immut}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:0, rb:6, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine empty { ra:int, rb:int, rc:address
      } @ { Collection }))))).groupBy ((\b1 -> bind b1 as {ra:stmt_id,
      rb:map_id, rc:ip} in ip)) ((\acc -> (\b3 -> bind b3 as {ra:stmt_id,
      rb:map_id, rc:ip} in (acc.insert {key:stmt_id, value:map_id};acc))))
      empty { key:int, value:int } @ { Collection }).iterate ((\b1 ->
      bind b1 as {key:ip, value:stmt_map_ids} in 
      (nd_insert_CUSTOMER_rcv_fetch, ip)<- {ra:stmt_map_ids, rb:vid,
      rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
      rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
      ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))}{None ->
                                                         error
                                                           (print
                                                              "unexpected missing arguments in sw_buf_insert_CUSTOMER")})


declare nd_insert_CUSTOMER_do_complete_s0 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let __prod_ret__4 =
  ((((bind map_QUERY18_mCUSTOMER1_s0_buf as ind __x in
    (frontier_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:CUSTOMER_CUSTKEY, rb:O_ORDERKEY, rc:__map_ret__1} in 
    (_accmap.insert {key:O_ORDERKEY, value:__map_ret__1};_accmap)))) empty {
    key:int, value:real } @ { Collection }).fold ((\_accext -> (\b3 ->
    bind b3 as {key:O_ORDERKEY, value:__map_ret__1} in _accext.combine (({|
    key:int, value:int | let __prod_ret__2 =
    (({| key:real, value:int | let __map_ret__2 =
      let wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf as ind __x in
          (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == O_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:real } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__map_ret__2, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__1} in 
      (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__1 *
       if 100 < __sql_inline_agg_1 then 1 else 0};
       _accmap)))) empty { key:real, value:int } @ { Collection }).fold
      ((\__accv_1 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
      value:__prod_ret__1} in __accv_1 + __prod_ret__1))) 0 * let
      wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_L1_2_s0_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == O_ORDERKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0} in
    {key:__prod_ret__2, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__2} in 
    (_accmap.insert {ra:O_ORDERKEY, rb:__sql_inline_agg_2, rc:__map_ret__1 *
     __lift_ret__2};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection })))) empty {
    ra:int, rb:int, rc:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:O_ORDERKEY, rb:__sql_inline_agg_2, rc:__prod_ret__3} in 
    (_accmap.insert {ra:O_ORDERKEY, rb:__sql_inline_agg_2, rc:__prod_ret__3 *
     if 1 <= __sql_inline_agg_2 then 1 else 0};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\__accv_2 -> (\b3 -> bind b3 as {ra:O_ORDERKEY, rb:__sql_inline_agg_2,
    rc:__prod_ret__4} in __accv_2 + __prod_ret__4))) 0 in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:false, rc:vid, rd:{| key:int,
      value:real | {key:CUSTOMER_CUSTKEY,
      value:__prod_ret__4}|} @ { Collection }});
   (nd_complete_stmt_cntr_check {key:vid, value:0})))


declare nd_insert_CUSTOMER_do_complete_s1 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  ((bind map_QUERY18_mLINEITEM2_mCUSTOMER1_s1_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:CUSTOMER_CUSTKEY, rb:QUERY18_mLINEITEMLINEITEM_ORDERKEY,
    rc:__map_ret__4} in 
    (_accmap.insert {key:QUERY18_mLINEITEMLINEITEM_ORDERKEY,
     value:__map_ret__4};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:QUERY18_mLINEITEMLINEITEM_ORDERKEY,
    value:__map_ret__4} in 
    (_accmap.insert {ra:CUSTOMER_CUSTKEY,
     rb:QUERY18_mLINEITEMLINEITEM_ORDERKEY, rc:__map_ret__4};
     _accmap)))) empty { ra:int, rb:int, rc:int } @ { Collection } in
  ((nd_add_delta_to_int_int_int {ra:QUERY18_mLINEITEM2, rb:false, rc:vid,
      rd:delta_values});
   let sent_msgs =
   nd_QUERY18_mLINEITEM2_send_correctives {ra:me, rb:1, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:1}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:1, rc:1, rd:sent_msgs, re:true,
         rf:false}))


declare nd_insert_CUSTOMER_do_complete_s2 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  ((bind map_QUERY18_mCUSTOMER1_s2_buf as ind __x in
    (frontier_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:CUSTOMER_CUSTKEY, rb:O_ORDERKEY, rc:__map_ret__5} in 
    (_accmap.insert {key:O_ORDERKEY, value:__map_ret__5};_accmap)))) empty {
    key:int, value:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:O_ORDERKEY, value:__map_ret__5} in 
    (_accmap.insert {ra:CUSTOMER_CUSTKEY, rb:O_ORDERKEY, rc:__map_ret__5};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection } in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mLINEITEM5, rb:false, rc:vid,
      rd:delta_values});
   (nd_complete_stmt_cntr_check {key:vid, value:2})))


declare nd_insert_CUSTOMER_do_complete_s3 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let __val_ret__1 = 1 in
  ((nd_add_delta_to_int_int {ra:QUERY18_mORDERS2, rb:false, rc:vid, rd:{|
      key:int, value:int | {key:CUSTOMER_CUSTKEY,
      value:__val_ret__1}|} @ { Collection }});
   let sent_msgs =
   nd_QUERY18_mORDERS2_send_correctives {ra:me, rb:3, rc:vid, rd:1, re:vid,
     rf:{| key:int, value:int | {key:CUSTOMER_CUSTKEY,
     value:__val_ret__1}|} @ { Collection }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:3, rc:1, rd:sent_msgs, re:true,
         rf:true}))


declare insert_CUSTOMER_do_corrective_s0_m_QUERY18_mCUSTOMER1 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:string, rh:string, ri:int, rj:string, rk:real, rl:string, rm:string,
  rn:collection { ra:int, rb:int, rc:real } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS,
  ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL,
  rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT, rn:delta_tuples} in let
  new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_QUERY18_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_O_ORDERKEY, rc:delta_QUERY18_mCUSTOMER1} in _accext.combine (let
    __prod_ret__602 =
    ((if CUSTOMER_CUSTKEY == delta_QUERY18_mCUSTOMERCUSTOMER_CUSTKEY 
      then 1 else 0) * (({| key:int, value:int | let __prod_ret__599 =
      (({| key:real, value:int | let __map_ret__354 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__354, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__248} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__248 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_190 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__598} in __accv_190 + __prod_ret__598))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s0_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__599, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__249} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__249 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_191 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__600} in __accv_191 + __prod_ret__600))) 0) *
      delta_QUERY18_mCUSTOMER1 in
    {| key:int, value:real | {key:CUSTOMER_CUSTKEY,
      value:__prod_ret__602}|} @ { Collection })))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare insert_CUSTOMER_do_corrective_s0_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { key:int, value:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS,
  ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL,
  rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT, rn:delta_tuples} in let
  new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_O_ORDERKEY,
    value:delta_QUERY18_mCUSTOMER1_L1_1_L1_1} in _accext.combine (let
    __prod_ret__618 =
    (let wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_s0_buf as ind __x in
        (frontier_int_int_float {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY
           and rc == delta_O_ORDERKEY))}).fold ((\acc -> (\b3 ->
          bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
          (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
          rb:int, rc:real } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {ra:_, rb:_, rc:projected_field} in projected_field}{None -> 0}) *
      ((({| key:int, value:int | let __prod_ret__613 =
      (let wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s0_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) *
        ((({| key:real, value:int | let __map_ret__360 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__360, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__252} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__252 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_194 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__610} in __accv_194 + __prod_ret__610))) 0 + ((({|
        key:real, value:int | let __sum_ret__251 =
        (let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0}) +
          delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
        {key:__sum_ret__251, value:1}|} @ { Collection }).combine (({|
        key:real, value:int | let __map_ret__362 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__362, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__254} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__254 * -1};
         _accmap)))) empty { key:real, value:int } @ { Collection })).fold
        ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__sum_ret__252} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__sum_ret__252 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_195 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__612} in __accv_195 + __prod_ret__612))) 0) in
      {key:__prod_ret__613, value:1}|} @ { Collection }).combine (({| key:int,
      value:int | let __prod_ret__615 =
      (({| key:real, value:int | let __map_ret__363 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__363, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__256} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__256 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_196 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__614} in __accv_196 + __prod_ret__614))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s0_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__615, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__257} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__257 * -1};
       _accmap)))) empty { key:int, value:int } @ { Collection })).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__sum_ret__254} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__254 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_197 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__617} in __accv_197 + __prod_ret__617))) 0 in
    {| key:int, value:real | {key:CUSTOMER_CUSTKEY,
      value:__prod_ret__618}|} @ { Collection })))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare insert_CUSTOMER_do_corrective_s0_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { key:int, value:int } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS,
  ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL,
  rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT, rn:delta_tuples} in let
  new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_O_ORDERKEY,
    value:delta_QUERY18_mCUSTOMER1_L1_2} in _accext.combine (let
    __prod_ret__625 =
    (let wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_s0_buf as ind __x in
        (frontier_int_int_float {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY
           and rc == delta_O_ORDERKEY))}).fold ((\acc -> (\b3 ->
          bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
          (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
          rb:int, rc:real } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {ra:_, rb:_, rc:projected_field} in projected_field}{None -> 0}) *
      ((({| key:int, value:int | let __prod_ret__620 =
      (({| key:real, value:int | let __map_ret__366 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__366, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__258} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__258 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_198 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__619} in __accv_198 + __prod_ret__619))) 0 * ((let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s0_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) +
        delta_QUERY18_mCUSTOMER1_L1_2) in
      {key:__prod_ret__620, value:1}|} @ { Collection }).combine (({| key:int,
      value:int | let __prod_ret__622 =
      (({| key:real, value:int | let __map_ret__368 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__368, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__260} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__260 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_199 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__621} in __accv_199 + __prod_ret__621))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s0_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__622, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__261} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__261 * -1};
       _accmap)))) empty { key:int, value:int } @ { Collection })).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__sum_ret__256} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__256 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_200 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__624} in __accv_200 + __prod_ret__624))) 0 in
    {| key:int, value:real | {key:CUSTOMER_CUSTKEY,
      value:__prod_ret__625}|} @ { Collection })))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare insert_CUSTOMER_do_corrective_s1_m_QUERY18_mLINEITEM2_mCUSTOMER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:int, rb:int, rc:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_QUERY18_mLINEITEM2_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_QUERY18_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_QUERY18_mLINEITEM2_mCUSTOMER1} in _accext.combine (let
    __prod_ret__626 =
    (if CUSTOMER_CUSTKEY == delta_QUERY18_mLINEITEM2_mCUSTOMERCUSTOMER_CUSTKEY
      then 1 else 0) * delta_QUERY18_mLINEITEM2_mCUSTOMER1 in
    {| ra:int, rb:int, rc:int | {ra:CUSTOMER_CUSTKEY,
      rb:delta_QUERY18_mLINEITEMLINEITEM_ORDERKEY,
      rc:__prod_ret__626}|} @ { Collection })))) empty { ra:int, rb:int, rc:int
    } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_int {ra:QUERY18_mLINEITEM2, rb:true, rc:vid,
      rd:new_tuples});
   (nd_QUERY18_mLINEITEM2_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_CUSTOMER_do_corrective_s2_m_QUERY18_mCUSTOMER1 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:string, rh:string, ri:int, rj:string, rk:real, rl:string, rm:string,
  rn:collection { ra:int, rb:int, rc:real } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS,
  ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL,
  rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT, rn:delta_tuples} in let
  new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_QUERY18_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_O_ORDERKEY, rc:delta_QUERY18_mCUSTOMER1} in _accext.combine (let
    __prod_ret__603 =
    (if CUSTOMER_CUSTKEY == delta_QUERY18_mCUSTOMERCUSTOMER_CUSTKEY then 1
      else 0) * delta_QUERY18_mCUSTOMER1 in
    {| ra:int, rb:int, rc:real | {ra:CUSTOMER_CUSTKEY, rb:delta_O_ORDERKEY,
      rc:__prod_ret__603}|} @ { Collection })))) empty { ra:int, rb:int,
    rc:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mLINEITEM5, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare sw_delete_CUSTOMER : { ra:int, rb:string, rc:string, rd:int, re:string,
  rf:real, rg:string, rh:string } -> () = (\args ->
  (sw_buf_delete_CUSTOMER.insert args;
   sw_trig_buf_idx.insert {i:1};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_delete_CUSTOMER_send_fetch : { key:int, value:int } -> () = (\vid ->
  case (sw_buf_delete_CUSTOMER.peek ()) of
  {Some args ->
    (sw_buf_delete_CUSTOMER.erase args;
     bind args as
     {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
     in
     ((route_to_int {key:5, value:Some CUSTOMER_CUSTKEY}).iterate ((\b1 ->
      bind b1 as {i:ip} in 
      (nd_delete_CUSTOMER_do_complete_s7_trig, ip)<- {ra:vid,
      rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
      re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
      rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}));
      ((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_int_int {ra:6, rb:Some CUSTOMER_CUSTKEY, rc:None immut}).fold
        ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_QUERY18_mCUSTOMER1_to_QUERY18_bind_0t0
          {ra:Some CUSTOMER_CUSTKEY, rb:empty { ra:{ key:int, value:int },
          rb:int, rc:int, rd:real } @ { Collection }, rc:true}).fold
        ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:4, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_int {key:7, value:None immut}).fold ((\count -> (\b3 ->
          bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18
            {ra:Some CUSTOMER_CUSTKEY, rb:empty { ra:{ key:int, value:int },
            rb:int, rc:real } @ { Collection }, rc:true}).fold ((\_accmap ->
          (\b3 -> bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:4, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }).combine (let
          sender_count =
          (route_to_int {key:8, value:None immut}).fold ((\count -> (\b3 ->
            bind b3 as {i:ip} in count + 1))) 0 in
          ((shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18
              {ra:Some CUSTOMER_CUSTKEY, rb:empty { ra:{ key:int, value:int },
              rb:int, rc:int } @ { Collection }, rc:true}).fold ((\_accmap ->
            (\b3 -> bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {ra:ip, rb:4, rc:sender_count};_accmap)))) empty {
            ra:address, rb:int, rc:int } @ { Collection }).combine (let
            sender_count =
            (route_to_int_int {ra:3, rb:Some CUSTOMER_CUSTKEY, rc:None immut}).fold
              ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
            ((shuffle_QUERY18_mLINEITEM2_mCUSTOMER1_to_QUERY18_mLINEITEM2_bind_0t0_1t1
                {ra:Some CUSTOMER_CUSTKEY, rb:None immut, rc:empty { ra:{
                key:int, value:int }, rb:int, rc:int, rd:int
                } @ { Collection }, rd:true}).fold ((\_accmap -> (\b3 ->
              bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:5, rc:sender_count};_accmap))))
              empty { ra:address, rb:int, rc:int } @ { Collection }).combine
              (let sender_count =
              (route_to_int_int {ra:6, rb:Some CUSTOMER_CUSTKEY, rc:None immut}).fold
                ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
              (shuffle_QUERY18_mCUSTOMER1_to_QUERY18_mLINEITEM5_bind_0t0_1t1
                 {ra:Some CUSTOMER_CUSTKEY, rb:None immut, rc:empty { ra:{
                 key:int, value:int }, rb:int, rc:int, rd:real
                 } @ { Collection }, rd:true}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:6, rc:sender_count};_accmap))))
                empty { ra:address, rb:int, rc:int } @ { Collection })))))).groupBy
      ((\b1 -> bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip,
      value:stmt_id})) ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id,
      rc:count} in acc + count))) 0).groupBy ((\b1 -> bind b1 as {key:b2,
      value:count} in bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc ->
      (\b3 -> bind b3 as {key:ip_and_stmt_id, value:count} in bind
      ip_and_stmt_id as {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_delete_CUSTOMER_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid,
       rd:CUSTOMER_CUSTKEY, re:CUSTOMER_NAME, rf:CUSTOMER_ADDRESS,
       rg:CUSTOMER_NATIONKEY, rh:CUSTOMER_PHONE, ri:CUSTOMER_ACCTBAL,
       rj:CUSTOMER_MKTSEGMENT, rk:CUSTOMER_COMMENT};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_int_int {ra:6, rb:Some CUSTOMER_CUSTKEY, rc:None immut}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:6, rb:6, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:3, rb:Some CUSTOMER_CUSTKEY, rc:None immut}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:5, rb:3, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:8, value:None immut}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:4, rb:8, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int {key:7, value:None immut}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:4, rb:7, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:6, rb:Some CUSTOMER_CUSTKEY, rc:None immut}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:4, rb:6, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine empty { ra:int, rb:int, rc:address
      } @ { Collection }))))).groupBy ((\b1 -> bind b1 as {ra:stmt_id,
      rb:map_id, rc:ip} in ip)) ((\acc -> (\b3 -> bind b3 as {ra:stmt_id,
      rb:map_id, rc:ip} in (acc.insert {key:stmt_id, value:map_id};acc))))
      empty { key:int, value:int } @ { Collection }).iterate ((\b1 ->
      bind b1 as {key:ip, value:stmt_map_ids} in 
      (nd_delete_CUSTOMER_rcv_fetch, ip)<- {ra:stmt_map_ids, rb:vid,
      rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
      rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
      ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))}{None ->
                                                         error
                                                           (print
                                                              "unexpected missing arguments in sw_buf_delete_CUSTOMER")})


declare nd_delete_CUSTOMER_do_complete_s4 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let __prod_ret__9 =
  ((((bind map_QUERY18_mCUSTOMER1_s4_buf as ind __x in
    (frontier_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:CUSTOMER_CUSTKEY, rb:O_ORDERKEY, rc:__map_ret__6} in 
    (_accmap.insert {key:O_ORDERKEY, value:__map_ret__6};_accmap)))) empty {
    key:int, value:real } @ { Collection }).fold ((\_accext -> (\b3 ->
    bind b3 as {key:O_ORDERKEY, value:__map_ret__6} in _accext.combine (({|
    key:int, value:int | let __prod_ret__6 =
    (({| key:real, value:int | let __map_ret__7 =
      let wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf as ind __x in
          (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == O_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:real } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__map_ret__7, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__3} in 
      (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__3 *
       if 100 < __sql_inline_agg_1 then 1 else 0};
       _accmap)))) empty { key:real, value:int } @ { Collection }).fold
      ((\__accv_3 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
      value:__prod_ret__5} in __accv_3 + __prod_ret__5))) 0 * let
      wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_L1_2_s4_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == O_ORDERKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0} in
    {key:__prod_ret__6, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__4} in 
    (_accmap.insert {ra:O_ORDERKEY, rb:__sql_inline_agg_2, rc:__map_ret__6 *
     __lift_ret__4};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection })))) empty {
    ra:int, rb:int, rc:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:O_ORDERKEY, rb:__sql_inline_agg_2, rc:__prod_ret__7} in 
    (_accmap.insert {ra:O_ORDERKEY, rb:__sql_inline_agg_2, rc:__prod_ret__7 *
     if 1 <= __sql_inline_agg_2 then 1 else 0};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\__accv_4 -> (\b3 -> bind b3 as {ra:O_ORDERKEY, rb:__sql_inline_agg_2,
    rc:__prod_ret__8} in __accv_4 + __prod_ret__8))) 0 * -1 in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:false, rc:vid, rd:{| key:int,
      value:real | {key:CUSTOMER_CUSTKEY,
      value:__prod_ret__9}|} @ { Collection }});
   (nd_complete_stmt_cntr_check {key:vid, value:4})))


declare nd_delete_CUSTOMER_do_complete_s5 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  (((bind map_QUERY18_mLINEITEM2_mCUSTOMER1_s5_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:CUSTOMER_CUSTKEY, rb:QUERY18_mLINEITEMLINEITEM_ORDERKEY,
    rc:__map_ret__9} in 
    (_accmap.insert {key:QUERY18_mLINEITEMLINEITEM_ORDERKEY,
     value:__map_ret__9};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:QUERY18_mLINEITEMLINEITEM_ORDERKEY,
    value:__map_ret__9} in 
    (_accmap.insert {key:QUERY18_mLINEITEMLINEITEM_ORDERKEY, value:__map_ret__9
     * -1};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:QUERY18_mLINEITEMLINEITEM_ORDERKEY,
    value:__prod_ret__10} in 
    (_accmap.insert {ra:CUSTOMER_CUSTKEY,
     rb:QUERY18_mLINEITEMLINEITEM_ORDERKEY, rc:__prod_ret__10};
     _accmap)))) empty { ra:int, rb:int, rc:int } @ { Collection } in
  ((nd_add_delta_to_int_int_int {ra:QUERY18_mLINEITEM2, rb:false, rc:vid,
      rd:delta_values});
   let sent_msgs =
   nd_QUERY18_mLINEITEM2_send_correctives {ra:me, rb:5, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:5}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:5, rc:1, rd:sent_msgs, re:true,
         rf:false}))


declare nd_delete_CUSTOMER_do_complete_s6 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  (((bind map_QUERY18_mCUSTOMER1_s6_buf as ind __x in
    (frontier_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:CUSTOMER_CUSTKEY, rb:O_ORDERKEY, rc:__map_ret__10} in 
    (_accmap.insert {key:O_ORDERKEY, value:__map_ret__10};_accmap)))) empty {
    key:int, value:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:O_ORDERKEY, value:__map_ret__10} in 
    (_accmap.insert {key:O_ORDERKEY, value:__map_ret__10 * -1};_accmap))))
    empty { key:int, value:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:O_ORDERKEY, value:__prod_ret__11} in 
    (_accmap.insert {ra:CUSTOMER_CUSTKEY, rb:O_ORDERKEY, rc:__prod_ret__11};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection } in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mLINEITEM5, rb:false, rc:vid,
      rd:delta_values});
   let sent_msgs =
   nd_QUERY18_mLINEITEM5_send_correctives {ra:me, rb:6, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:6}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:6, rc:1, rd:sent_msgs, re:true,
         rf:false}))


declare nd_delete_CUSTOMER_do_complete_s7 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let __val_ret__5 = -1 in
  ((nd_add_delta_to_int_int {ra:QUERY18_mORDERS2, rb:false, rc:vid, rd:{|
      key:int, value:int | {key:CUSTOMER_CUSTKEY,
      value:__val_ret__5}|} @ { Collection }});
   let sent_msgs =
   nd_QUERY18_mORDERS2_send_correctives {ra:me, rb:7, rc:vid, rd:1, re:vid,
     rf:{| key:int, value:int | {key:CUSTOMER_CUSTKEY,
     value:__val_ret__5}|} @ { Collection }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:7, rc:1, rd:sent_msgs, re:true,
         rf:true}))


declare delete_CUSTOMER_do_corrective_s4_m_QUERY18_mCUSTOMER1 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:string, rh:string, ri:int, rj:string, rk:real, rl:string, rm:string,
  rn:collection { ra:int, rb:int, rc:real } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS,
  ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL,
  rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT, rn:delta_tuples} in let
  new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_QUERY18_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_O_ORDERKEY, rc:delta_QUERY18_mCUSTOMER1} in _accext.combine (let
    __prod_ret__632 =
    ((if CUSTOMER_CUSTKEY == delta_QUERY18_mCUSTOMERCUSTOMER_CUSTKEY 
      then 1 else 0) * (({| key:int, value:int | let __prod_ret__628 =
      (({| key:real, value:int | let __map_ret__370 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__370, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__262} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__262 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_201 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__627} in __accv_201 + __prod_ret__627))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s4_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__628, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__263} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__263 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_202 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__629} in __accv_202 + __prod_ret__629))) 0) *
      -delta_QUERY18_mCUSTOMER1 in
    {| key:int, value:real | {key:CUSTOMER_CUSTKEY,
      value:__prod_ret__632}|} @ { Collection })))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare delete_CUSTOMER_do_corrective_s4_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { key:int, value:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS,
  ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL,
  rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT, rn:delta_tuples} in let
  new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_O_ORDERKEY,
    value:delta_QUERY18_mCUSTOMER1_L1_1_L1_1} in _accext.combine (let
    __prod_ret__652 =
    ((let wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_s4_buf as ind __x in
        (frontier_int_int_float {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY
           and rc == delta_O_ORDERKEY))}).fold ((\acc -> (\b3 ->
          bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
          (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
          rb:int, rc:real } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {ra:_, rb:_, rc:projected_field} in projected_field}{None -> 0}) *
      ((({| key:int, value:int | let __prod_ret__646 =
      (let wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s4_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) *
        ((({| key:real, value:int | let __map_ret__376 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__376, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__266} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__266 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_205 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__643} in __accv_205 + __prod_ret__643))) 0 + ((({|
        key:real, value:int | let __sum_ret__257 =
        (let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0}) +
          delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
        {key:__sum_ret__257, value:1}|} @ { Collection }).combine (({|
        key:real, value:int | let __map_ret__378 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__378, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__268} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__268 * -1};
         _accmap)))) empty { key:real, value:int } @ { Collection })).fold
        ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__sum_ret__258} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__sum_ret__258 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_206 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__645} in __accv_206 + __prod_ret__645))) 0) in
      {key:__prod_ret__646, value:1}|} @ { Collection }).combine (({| key:int,
      value:int | let __prod_ret__648 =
      (({| key:real, value:int | let __map_ret__379 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__379, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__270} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__270 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_207 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__647} in __accv_207 + __prod_ret__647))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s4_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__648, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__271} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__271 * -1};
       _accmap)))) empty { key:int, value:int } @ { Collection })).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__sum_ret__260} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__260 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_208 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__650} in __accv_208 + __prod_ret__650))) 0) * -1 in
    {| key:int, value:real | {key:CUSTOMER_CUSTKEY,
      value:__prod_ret__652}|} @ { Collection })))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare delete_CUSTOMER_do_corrective_s4_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { key:int, value:int } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS,
  ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL,
  rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT, rn:delta_tuples} in let
  new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_O_ORDERKEY,
    value:delta_QUERY18_mCUSTOMER1_L1_2} in _accext.combine (let
    __prod_ret__660 =
    ((let wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_s4_buf as ind __x in
        (frontier_int_int_float {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY
           and rc == delta_O_ORDERKEY))}).fold ((\acc -> (\b3 ->
          bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
          (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
          rb:int, rc:real } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {ra:_, rb:_, rc:projected_field} in projected_field}{None -> 0}) *
      ((({| key:int, value:int | let __prod_ret__654 =
      (({| key:real, value:int | let __map_ret__382 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__382, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__272} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__272 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_209 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__653} in __accv_209 + __prod_ret__653))) 0 * ((let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s4_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) +
        delta_QUERY18_mCUSTOMER1_L1_2) in
      {key:__prod_ret__654, value:1}|} @ { Collection }).combine (({| key:int,
      value:int | let __prod_ret__656 =
      (({| key:real, value:int | let __map_ret__384 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__384, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__274} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__274 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_210 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__655} in __accv_210 + __prod_ret__655))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s4_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__656, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__275} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__275 * -1};
       _accmap)))) empty { key:int, value:int } @ { Collection })).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__sum_ret__262} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__262 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_211 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__658} in __accv_211 + __prod_ret__658))) 0) * -1 in
    {| key:int, value:real | {key:CUSTOMER_CUSTKEY,
      value:__prod_ret__660}|} @ { Collection })))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare delete_CUSTOMER_do_corrective_s5_m_QUERY18_mLINEITEM2_mCUSTOMER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:int, rb:int, rc:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_QUERY18_mLINEITEM2_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_QUERY18_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_QUERY18_mLINEITEM2_mCUSTOMER1} in _accext.combine (let
    __prod_ret__662 =
    (if CUSTOMER_CUSTKEY == delta_QUERY18_mLINEITEM2_mCUSTOMERCUSTOMER_CUSTKEY
      then 1 else 0) * -delta_QUERY18_mLINEITEM2_mCUSTOMER1 in
    {| ra:int, rb:int, rc:int | {ra:CUSTOMER_CUSTKEY,
      rb:delta_QUERY18_mLINEITEMLINEITEM_ORDERKEY,
      rc:__prod_ret__662}|} @ { Collection })))) empty { ra:int, rb:int, rc:int
    } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_int {ra:QUERY18_mLINEITEM2, rb:true, rc:vid,
      rd:new_tuples});
   (nd_QUERY18_mLINEITEM2_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_CUSTOMER_do_corrective_s6_m_QUERY18_mCUSTOMER1 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:string, rh:string, ri:int, rj:string, rk:real, rl:string, rm:string,
  rn:collection { ra:int, rb:int, rc:real } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS,
  ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL,
  rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT, rn:delta_tuples} in let
  new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_QUERY18_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_O_ORDERKEY, rc:delta_QUERY18_mCUSTOMER1} in _accext.combine (let
    __prod_ret__634 =
    (if CUSTOMER_CUSTKEY == delta_QUERY18_mCUSTOMERCUSTOMER_CUSTKEY then 1
      else 0) * -delta_QUERY18_mCUSTOMER1 in
    {| ra:int, rb:int, rc:real | {ra:CUSTOMER_CUSTKEY, rb:delta_O_ORDERKEY,
      rc:__prod_ret__634}|} @ { Collection })))) empty { ra:int, rb:int,
    rc:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mLINEITEM5, rb:true, rc:vid,
      rd:new_tuples});
   (nd_QUERY18_mLINEITEM5_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare sw_insert_ORDERS : { ra:int, rb:int, rc:string, rd:real, re:int,
  rf:string, rg:string, rh:int, ri:string } -> () = (\args ->
  (sw_buf_insert_ORDERS.insert args;
   sw_trig_buf_idx.insert {i:2};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_insert_ORDERS_send_fetch : { key:int, value:int } -> () = (\vid ->
  case (sw_buf_insert_ORDERS.peek ()) of
  {Some args ->
    (sw_buf_insert_ORDERS.erase args;
     bind args as
     {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
     in
     ((route_to_int_int {ra:3, rb:Some ORDERS_CUSTKEY, rc:Some ORDERS_ORDERKEY}).iterate
      ((\b1 -> bind b1 as {i:ip} in 
      (nd_insert_ORDERS_do_complete_s10_trig, ip)<- {ra:vid,
      rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
      re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
      rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}));
      ((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_int {key:7, value:Some ORDERS_ORDERKEY}).fold ((\count ->
        (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18
          {ra:Some ORDERS_CUSTKEY, rb:empty { ra:{ key:int, value:int },
          rb:int, rc:real } @ { Collection }, rc:true}).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:8, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_int {key:8, value:Some ORDERS_ORDERKEY}).fold ((\count ->
          (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18 {ra:Some ORDERS_CUSTKEY,
            rb:empty { ra:{ key:int, value:int }, rb:int, rc:int
            } @ { Collection }, rc:true}).fold ((\_accmap -> (\b3 ->
          bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:8, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }).combine (let
          sender_count =
          (route_to_int {key:5, value:Some ORDERS_CUSTKEY}).fold ((\count ->
            (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
          ((shuffle_QUERY18_mORDERS2_to_QUERY18_bind_0t0
              {ra:Some ORDERS_CUSTKEY, rb:empty { ra:{ key:int, value:int },
              rb:int, rc:int } @ { Collection }, rc:true}).fold ((\_accmap ->
            (\b3 -> bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {ra:ip, rb:8, rc:sender_count};_accmap)))) empty {
            ra:address, rb:int, rc:int } @ { Collection }).combine (let
            sender_count =
            (route_to_int {key:5, value:Some ORDERS_CUSTKEY}).fold ((\count ->
              (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
            ((shuffle_QUERY18_mORDERS2_to_QUERY18_mLINEITEM2_bind_0t0
                {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY, rc:empty {
                ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection },
                rd:true}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
              value:tuples} in 
              (_accmap.insert {ra:ip, rb:9, rc:sender_count};_accmap))))
              empty { ra:address, rb:int, rc:int } @ { Collection }).combine
              (let sender_count =
              (route_to_int {key:5, value:Some ORDERS_CUSTKEY}).fold
                ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
              ((shuffle_QUERY18_mORDERS2_to_QUERY18_mLINEITEM5_bind_0t0
                  {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY, rc:empty {
                  ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection },
                  rd:true}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                value:tuples} in 
                (_accmap.insert {ra:ip, rb:11, rc:sender_count};_accmap))))
                empty { ra:address, rb:int, rc:int } @ { Collection }).combine
                (let sender_count =
                (route_to_int {key:7, value:Some ORDERS_ORDERKEY}).fold
                  ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                ((shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18_mLINEITEM5_bind_1t0
                    {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
                    rc:empty { ra:{ key:int, value:int }, rb:int, rc:real
                    } @ { Collection }, rd:true}).fold ((\_accmap -> (\b3 ->
                  bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:11, rc:sender_count};_accmap))))
                  empty { ra:address, rb:int, rc:int
                  } @ { Collection }).combine (let sender_count =
                  (route_to_int {key:7, value:Some ORDERS_ORDERKEY}).fold
                    ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                  (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18_mCUSTOMER1_bind_1t0
                     {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
                     rc:empty { ra:{ key:int, value:int }, rb:int, rc:real
                     } @ { Collection }, rd:true}).fold ((\_accmap -> (\b3 ->
                    bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:12, rc:sender_count};_accmap))))
                    empty { ra:address, rb:int, rc:int } @ { Collection })))))))).groupBy
      ((\b1 -> bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip,
      value:stmt_id})) ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id,
      rc:count} in acc + count))) 0).groupBy ((\b1 -> bind b1 as {key:b2,
      value:count} in bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc ->
      (\b3 -> bind b3 as {key:ip_and_stmt_id, value:count} in bind
      ip_and_stmt_id as {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_insert_ORDERS_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid,
       rd:ORDERS_ORDERKEY, re:ORDERS_CUSTKEY, rf:ORDERS_ORDERSTATUS,
       rg:ORDERS_TOTALPRICE, rh:ORDERS_ORDERDATE, ri:ORDERS_ORDERPRIORITY,
       rj:ORDERS_CLERK, rk:ORDERS_SHIPPRIORITY, rl:ORDERS_COMMENT};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_int {key:7, value:Some ORDERS_ORDERKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:12, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:7, value:Some ORDERS_ORDERKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:11, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:5, value:Some ORDERS_CUSTKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:11, rb:5, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:5, value:Some ORDERS_CUSTKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:9, rb:5, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:5, value:Some ORDERS_CUSTKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:8, rb:5, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:8, value:Some ORDERS_ORDERKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:8, rb:8, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:7, value:Some ORDERS_ORDERKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:8, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine empty { ra:int, rb:int, rc:address
      } @ { Collection }))))))).groupBy ((\b1 -> bind b1 as {ra:stmt_id,
      rb:map_id, rc:ip} in ip)) ((\acc -> (\b3 -> bind b3 as {ra:stmt_id,
      rb:map_id, rc:ip} in (acc.insert {key:stmt_id, value:map_id};acc))))
      empty { key:int, value:int } @ { Collection }).iterate ((\b1 ->
      bind b1 as {key:ip, value:stmt_map_ids} in 
      (nd_insert_ORDERS_rcv_fetch, ip)<- {ra:stmt_map_ids, rb:vid,
      rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
      rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
      ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))}
  {None ->
    error (print "unexpected missing arguments in sw_buf_insert_ORDERS")})


declare nd_insert_ORDERS_do_complete_s8 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let __prod_ret__16 =
  ((({| key:int, value:int | let __prod_ret__13 =
    (({| key:real, value:int | let __map_ret__11 =
      let wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind __x in
          (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:real } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__map_ret__11, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__5} in 
      (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__5 *
       if 100 < __sql_inline_agg_1 then 1 else 0};
       _accmap)))) empty { key:real, value:int } @ { Collection }).fold
      ((\__accv_5 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
      value:__prod_ret__12} in __accv_5 + __prod_ret__12))) 0 * let
      wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_L1_2_s8_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0} in
    {key:__prod_ret__13, value:1}|} @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__6} in 
    (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__6 *
     if 1 <= __sql_inline_agg_2 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\__accv_6 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
    value:__prod_ret__14} in __accv_6 + __prod_ret__14))) 0 * let
    wrapped_lookup_value =
    bind map_QUERY18_mORDERS2_s8_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * let
    wrapped_lookup_value =
    bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind __x in
      (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:real } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0} in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:false, rc:vid, rd:{| key:int,
      value:real | {key:ORDERS_CUSTKEY,
      value:__prod_ret__16}|} @ { Collection }});
   (nd_complete_stmt_cntr_check {key:vid, value:8})))


declare nd_insert_ORDERS_do_complete_s9 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let __map_ret__15 =
  let wrapped_lookup_value =
    bind map_QUERY18_mORDERS2_s9_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0} in
  ((nd_add_delta_to_int_int_int {ra:QUERY18_mLINEITEM2, rb:false, rc:vid, rd:{|
      ra:int, rb:int, rc:int | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
      rc:__map_ret__15}|} @ { Collection }});
   let sent_msgs =
   nd_QUERY18_mLINEITEM2_send_correctives {ra:me, rb:9, rc:vid, rd:1, re:vid,
     rf:{| ra:int, rb:int, rc:int | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
     rc:__map_ret__15}|} @ { Collection }} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:9}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:9, rc:1, rd:sent_msgs, re:true,
         rf:false}))


declare nd_insert_ORDERS_do_complete_s11 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let __prod_ret__17 =
  (let wrapped_lookup_value =
    bind map_QUERY18_mORDERS2_s11_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * let
    wrapped_lookup_value =
    bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s11_buf as ind __x in
      (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:real } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0} in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mLINEITEM5, rb:false, rc:vid,
      rd:{| ra:int, rb:int, rc:real | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
      rc:__prod_ret__17}|} @ { Collection }});
   (nd_complete_stmt_cntr_check {key:vid, value:11})))


declare nd_insert_ORDERS_do_complete_s12 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let __map_ret__18 =
  let wrapped_lookup_value =
    bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s12_buf as ind __x in
      (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:real } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0} in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mCUSTOMER1, rb:false, rc:vid,
      rd:{| ra:int, rb:int, rc:real | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
      rc:__map_ret__18}|} @ { Collection }});
   let sent_msgs =
   nd_QUERY18_mCUSTOMER1_send_correctives {ra:me, rb:12, rc:vid, rd:1, re:vid,
     rf:{| ra:int, rb:int, rc:real | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
     rc:__map_ret__18}|} @ { Collection }} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:12}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:12, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_ORDERS_do_complete_s10 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let __val_ret__6 = 1 in
  ((nd_add_delta_to_int_int_int {ra:QUERY18_mLINEITEM2_mCUSTOMER1, rb:false,
      rc:vid, rd:{| ra:int, rb:int, rc:int | {ra:ORDERS_CUSTKEY,
      rb:ORDERS_ORDERKEY, rc:__val_ret__6}|} @ { Collection }});
   let sent_msgs =
   nd_QUERY18_mLINEITEM2_mCUSTOMER1_send_correctives {ra:me, rb:10, rc:vid,
     rd:1, re:vid, rf:{| ra:int, rb:int, rc:int | {ra:ORDERS_CUSTKEY,
     rb:ORDERS_ORDERKEY, rc:__val_ret__6}|} @ { Collection }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:10, rc:1, rd:sent_msgs,
         re:true, rf:true}))


declare insert_ORDERS_do_corrective_s8_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { key:int, value:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_O_ORDERKEY,
    value:delta_QUERY18_mCUSTOMER1_L1_1_L1_1} in _accext.combine (let
    __prod_ret__368 =
    ((if ORDERS_ORDERKEY == delta_O_ORDERKEY then 1 else 0) * let
      wrapped_lookup_value =
      bind map_QUERY18_mORDERS2_s8_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) *
      ((((({| key:int, value:int | let __prod_ret__348 =
      (let wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s8_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) *
        ((({| key:real, value:int | let __map_ret__218 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__218, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__138} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__138 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_112 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__345} in __accv_112 + __prod_ret__345))) 0 + ((({|
        key:real, value:int | let __sum_ret__187 =
        (let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0}) +
          delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
        {key:__sum_ret__187, value:1}|} @ { Collection }).combine (({|
        key:real, value:int | let __map_ret__220 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__220, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__140} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__140 * -1};
         _accmap)))) empty { key:real, value:int } @ { Collection })).fold
        ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__sum_ret__188} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__sum_ret__188 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_113 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__347} in __accv_113 + __prod_ret__347))) 0) in
      {key:__prod_ret__348, value:1}|} @ { Collection }).combine (({| key:int,
      value:int | let __prod_ret__350 =
      (({| key:real, value:int | let __map_ret__221 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__221, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__142} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__142 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_114 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__349} in __accv_114 + __prod_ret__349))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s8_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__350, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__143} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__143 * -1};
       _accmap)))) empty { key:int, value:int } @ { Collection })).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__sum_ret__190} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__190 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_115 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__352} in __accv_115 + __prod_ret__352))) 0 * let
      wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind __x in
        (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:real } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) +
      (((({| key:int, value:int | let __prod_ret__355 =
      (({| key:real, value:int | let __map_ret__224 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__224, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__144} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__144 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_116 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__354} in __accv_116 + __prod_ret__354))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s8_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__355, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__145} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__145 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_117 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__356} in __accv_117 + __prod_ret__356))) 0 + ((let
      __val_ret__255 = delta_O_ORDERKEY in
      if __val_ret__255 == ORDERS_ORDERKEY then 1 else 0) * ((({| key:int,
      value:int | let __prod_ret__360 =
      (let wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s8_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) *
        ((({| key:real, value:int | let __map_ret__227 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__227, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__147} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__147 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_118 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__357} in __accv_118 + __prod_ret__357))) 0 + ((({|
        key:real, value:int | let __sum_ret__191 =
        (let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0}) +
          delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
        {key:__sum_ret__191, value:1}|} @ { Collection }).combine (({|
        key:real, value:int | let __map_ret__229 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__229, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__149} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__149 * -1};
         _accmap)))) empty { key:real, value:int } @ { Collection })).fold
        ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__sum_ret__192} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__sum_ret__192 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_119 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__359} in __accv_119 + __prod_ret__359))) 0) in
      {key:__prod_ret__360, value:1}|} @ { Collection }).combine (({| key:int,
      value:int | let __prod_ret__362 =
      (({| key:real, value:int | let __map_ret__230 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__230, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__151} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__151 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_120 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__361} in __accv_120 + __prod_ret__361))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s8_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__362, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__152} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__152 * -1};
       _accmap)))) empty { key:int, value:int } @ { Collection })).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__sum_ret__194} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__194 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_121 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__364} in __accv_121 + __prod_ret__364))) 0)) *
      delta_QUERY18_mCUSTOMER1_L1_1_L1_1)) in
    {| key:int, value:real | {key:ORDERS_CUSTKEY,
      value:__prod_ret__368}|} @ { Collection })))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare insert_ORDERS_do_corrective_s8_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { key:int, value:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_O_ORDERKEY,
    value:delta_QUERY18_mCUSTOMER1_L1_2} in _accext.combine (let
    __prod_ret__434 =
    (((if ORDERS_ORDERKEY == delta_O_ORDERKEY then 1 else 0) * ((({| key:int,
      value:int | let __prod_ret__427 =
      (({| key:real, value:int | let __map_ret__267 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__267, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__183} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__183 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_142 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__426} in __accv_142 + __prod_ret__426))) 0 * ((let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s8_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) +
        delta_QUERY18_mCUSTOMER1_L1_2) in
      {key:__prod_ret__427, value:1}|} @ { Collection }).combine (({| key:int,
      value:int | let __prod_ret__429 =
      (({| key:real, value:int | let __map_ret__269 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__269, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__185} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__185 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_143 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__428} in __accv_143 + __prod_ret__428))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s8_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__429, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__186} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__186 * -1};
       _accmap)))) empty { key:int, value:int } @ { Collection })).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__sum_ret__218} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__218 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_144 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__431} in __accv_144 + __prod_ret__431))) 0) * let
      wrapped_lookup_value =
      bind map_QUERY18_mORDERS2_s8_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) * let
      wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind __x in
        (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:real } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0} in
    {| key:int, value:real | {key:ORDERS_CUSTKEY,
      value:__prod_ret__434}|} @ { Collection })))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare insert_ORDERS_do_corrective_s8_m_QUERY18_mORDERS2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:int, rh:string, ri:real, rj:int, rk:string, rl:string, rm:int, rn:string,
  ro:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {key:delta_QUERY18_mORDERSORDERS_CUSTKEY,
    value:delta_QUERY18_mORDERS2} in _accext.combine (let __prod_ret__440 =
    (((if ORDERS_CUSTKEY == delta_QUERY18_mORDERSORDERS_CUSTKEY then 1 
      else 0) * (({| key:int, value:int | let __prod_ret__436 =
      (({| key:real, value:int | let __map_ret__273 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__273, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__187} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__187 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_145 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__435} in __accv_145 + __prod_ret__435))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s8_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__436, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__188} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__188 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_146 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__437} in __accv_146 + __prod_ret__437))) 0) * let
      wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind __x in
        (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:real } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) *
      delta_QUERY18_mORDERS2 in
    {| key:int, value:real | {key:ORDERS_CUSTKEY,
      value:__prod_ret__440}|} @ { Collection })))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare insert_ORDERS_do_corrective_s9_m_QUERY18_mORDERS2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:int, rh:string, ri:real, rj:int, rk:string, rl:string, rm:int, rn:string,
  ro:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {key:delta_QUERY18_mORDERSORDERS_CUSTKEY,
    value:delta_QUERY18_mORDERS2} in _accext.combine (let __prod_ret__441 =
    (if ORDERS_CUSTKEY == delta_QUERY18_mORDERSORDERS_CUSTKEY then 1 
      else 0) * delta_QUERY18_mORDERS2 in
    {| ra:int, rb:int, rc:int | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
      rc:__prod_ret__441}|} @ { Collection })))) empty { ra:int, rb:int, rc:int
    } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_int {ra:QUERY18_mLINEITEM2, rb:true, rc:vid,
      rd:new_tuples});
   (nd_QUERY18_mLINEITEM2_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_ORDERS_do_corrective_s11_m_QUERY18_mORDERS2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:int, rh:string, ri:real, rj:int, rk:string, rl:string, rm:int, rn:string,
  ro:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {key:delta_QUERY18_mORDERSORDERS_CUSTKEY,
    value:delta_QUERY18_mORDERS2} in _accext.combine (let __prod_ret__443 =
    ((if ORDERS_CUSTKEY == delta_QUERY18_mORDERSORDERS_CUSTKEY then 1 
      else 0) * let wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s11_buf as ind __x in
        (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:real } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) *
      delta_QUERY18_mORDERS2 in
    {| ra:int, rb:int, rc:real | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
      rc:__prod_ret__443}|} @ { Collection })))) empty { ra:int, rb:int,
    rc:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mLINEITEM5, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare insert_ORDERS_do_corrective_s11_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { key:int, value:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_O_ORDERKEY,
    value:delta_QUERY18_mCUSTOMER1_L1_1_L1_1} in _accext.combine (let
    __prod_ret__370 =
    ((if ORDERS_ORDERKEY == delta_O_ORDERKEY then 1 else 0) * let
      wrapped_lookup_value =
      bind map_QUERY18_mORDERS2_s11_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) *
      delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
    {| ra:int, rb:int, rc:real | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
      rc:__prod_ret__370}|} @ { Collection })))) empty { ra:int, rb:int,
    rc:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mLINEITEM5, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare insert_ORDERS_do_corrective_s12_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { key:int, value:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_O_ORDERKEY,
    value:delta_QUERY18_mCUSTOMER1_L1_1_L1_1} in _accext.combine (let
    __prod_ret__371 =
    (if ORDERS_ORDERKEY == delta_O_ORDERKEY then 1 else 0) *
      delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
    {| ra:int, rb:int, rc:real | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
      rc:__prod_ret__371}|} @ { Collection })))) empty { ra:int, rb:int,
    rc:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mCUSTOMER1, rb:true, rc:vid,
      rd:new_tuples});
   (nd_QUERY18_mCUSTOMER1_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare sw_delete_ORDERS : { ra:int, rb:int, rc:string, rd:real, re:int,
  rf:string, rg:string, rh:int, ri:string } -> () = (\args ->
  (sw_buf_delete_ORDERS.insert args;
   sw_trig_buf_idx.insert {i:3};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_delete_ORDERS_send_fetch : { key:int, value:int } -> () = (\vid ->
  case (sw_buf_delete_ORDERS.peek ()) of
  {Some args ->
    (sw_buf_delete_ORDERS.erase args;
     bind args as
     {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
     in
     ((route_to_int_int {ra:3, rb:Some ORDERS_CUSTKEY, rc:Some ORDERS_ORDERKEY}).iterate
      ((\b1 -> bind b1 as {i:ip} in 
      (nd_delete_ORDERS_do_complete_s15_trig, ip)<- {ra:vid,
      rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
      re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
      rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}));
      ((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_int {key:7, value:Some ORDERS_ORDERKEY}).fold ((\count ->
        (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18
          {ra:Some ORDERS_CUSTKEY, rb:empty { ra:{ key:int, value:int },
          rb:int, rc:real } @ { Collection }, rc:true}).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:13, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_int {key:8, value:Some ORDERS_ORDERKEY}).fold ((\count ->
          (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18 {ra:Some ORDERS_CUSTKEY,
            rb:empty { ra:{ key:int, value:int }, rb:int, rc:int
            } @ { Collection }, rc:true}).fold ((\_accmap -> (\b3 ->
          bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:13, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }).combine (let
          sender_count =
          (route_to_int {key:5, value:Some ORDERS_CUSTKEY}).fold ((\count ->
            (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
          ((shuffle_QUERY18_mORDERS2_to_QUERY18_bind_0t0
              {ra:Some ORDERS_CUSTKEY, rb:empty { ra:{ key:int, value:int },
              rb:int, rc:int } @ { Collection }, rc:true}).fold ((\_accmap ->
            (\b3 -> bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {ra:ip, rb:13, rc:sender_count};_accmap)))) empty {
            ra:address, rb:int, rc:int } @ { Collection }).combine (let
            sender_count =
            (route_to_int {key:5, value:Some ORDERS_CUSTKEY}).fold ((\count ->
              (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
            ((shuffle_QUERY18_mORDERS2_to_QUERY18_mLINEITEM2_bind_0t0
                {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY, rc:empty {
                ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection },
                rd:true}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
              value:tuples} in 
              (_accmap.insert {ra:ip, rb:14, rc:sender_count};_accmap))))
              empty { ra:address, rb:int, rc:int } @ { Collection }).combine
              (let sender_count =
              (route_to_int {key:5, value:Some ORDERS_CUSTKEY}).fold
                ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
              ((shuffle_QUERY18_mORDERS2_to_QUERY18_mLINEITEM5_bind_0t0
                  {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY, rc:empty {
                  ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection },
                  rd:true}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                value:tuples} in 
                (_accmap.insert {ra:ip, rb:16, rc:sender_count};_accmap))))
                empty { ra:address, rb:int, rc:int } @ { Collection }).combine
                (let sender_count =
                (route_to_int {key:7, value:Some ORDERS_ORDERKEY}).fold
                  ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                ((shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18_mLINEITEM5_bind_1t0
                    {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
                    rc:empty { ra:{ key:int, value:int }, rb:int, rc:real
                    } @ { Collection }, rd:true}).fold ((\_accmap -> (\b3 ->
                  bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:16, rc:sender_count};_accmap))))
                  empty { ra:address, rb:int, rc:int
                  } @ { Collection }).combine (let sender_count =
                  (route_to_int {key:7, value:Some ORDERS_ORDERKEY}).fold
                    ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                  (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18_mCUSTOMER1_bind_1t0
                     {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
                     rc:empty { ra:{ key:int, value:int }, rb:int, rc:real
                     } @ { Collection }, rd:true}).fold ((\_accmap -> (\b3 ->
                    bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:17, rc:sender_count};_accmap))))
                    empty { ra:address, rb:int, rc:int } @ { Collection })))))))).groupBy
      ((\b1 -> bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip,
      value:stmt_id})) ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id,
      rc:count} in acc + count))) 0).groupBy ((\b1 -> bind b1 as {key:b2,
      value:count} in bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc ->
      (\b3 -> bind b3 as {key:ip_and_stmt_id, value:count} in bind
      ip_and_stmt_id as {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_delete_ORDERS_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid,
       rd:ORDERS_ORDERKEY, re:ORDERS_CUSTKEY, rf:ORDERS_ORDERSTATUS,
       rg:ORDERS_TOTALPRICE, rh:ORDERS_ORDERDATE, ri:ORDERS_ORDERPRIORITY,
       rj:ORDERS_CLERK, rk:ORDERS_SHIPPRIORITY, rl:ORDERS_COMMENT};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_int {key:7, value:Some ORDERS_ORDERKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:17, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:7, value:Some ORDERS_ORDERKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:16, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:5, value:Some ORDERS_CUSTKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:16, rb:5, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:5, value:Some ORDERS_CUSTKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:14, rb:5, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:5, value:Some ORDERS_CUSTKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:13, rb:5, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:8, value:Some ORDERS_ORDERKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:13, rb:8, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:7, value:Some ORDERS_ORDERKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:13, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine empty { ra:int, rb:int, rc:address
      } @ { Collection }))))))).groupBy ((\b1 -> bind b1 as {ra:stmt_id,
      rb:map_id, rc:ip} in ip)) ((\acc -> (\b3 -> bind b3 as {ra:stmt_id,
      rb:map_id, rc:ip} in (acc.insert {key:stmt_id, value:map_id};acc))))
      empty { key:int, value:int } @ { Collection }).iterate ((\b1 ->
      bind b1 as {key:ip, value:stmt_map_ids} in 
      (nd_delete_ORDERS_rcv_fetch, ip)<- {ra:stmt_map_ids, rb:vid,
      rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
      rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
      ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))}
  {None ->
    error (print "unexpected missing arguments in sw_buf_delete_ORDERS")})


declare nd_delete_ORDERS_do_complete_s13 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let __prod_ret__23 =
  (((({| key:int, value:int | let __prod_ret__19 =
    (({| key:real, value:int | let __map_ret__19 =
      let wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind __x in
          (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:real } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__map_ret__19, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__7} in 
      (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__7 *
       if 100 < __sql_inline_agg_1 then 1 else 0};
       _accmap)))) empty { key:real, value:int } @ { Collection }).fold
      ((\__accv_7 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
      value:__prod_ret__18} in __accv_7 + __prod_ret__18))) 0 * let
      wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_L1_2_s13_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0} in
    {key:__prod_ret__19, value:1}|} @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__8} in 
    (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__8 *
     if 1 <= __sql_inline_agg_2 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\__accv_8 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
    value:__prod_ret__20} in __accv_8 + __prod_ret__20))) 0 * let
    wrapped_lookup_value =
    bind map_QUERY18_mORDERS2_s13_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * let
    wrapped_lookup_value =
    bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind __x in
      (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:real } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * -1 in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:false, rc:vid, rd:{| key:int,
      value:real | {key:ORDERS_CUSTKEY,
      value:__prod_ret__23}|} @ { Collection }});
   (nd_complete_stmt_cntr_check {key:vid, value:13})))


declare nd_delete_ORDERS_do_complete_s14 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let __prod_ret__24 =
  (let wrapped_lookup_value =
    bind map_QUERY18_mORDERS2_s14_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * -1 in
  ((nd_add_delta_to_int_int_int {ra:QUERY18_mLINEITEM2, rb:false, rc:vid, rd:{|
      ra:int, rb:int, rc:int | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
      rc:__prod_ret__24}|} @ { Collection }});
   let sent_msgs =
   nd_QUERY18_mLINEITEM2_send_correctives {ra:me, rb:14, rc:vid, rd:1, re:vid,
     rf:{| ra:int, rb:int, rc:int | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
     rc:__prod_ret__24}|} @ { Collection }} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:14}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:14, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_ORDERS_do_complete_s16 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let __prod_ret__26 =
  ((let wrapped_lookup_value =
    bind map_QUERY18_mORDERS2_s16_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {ra:ra,
         rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 ->
        bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * let
    wrapped_lookup_value =
    bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s16_buf as ind __x in
      (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:real } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * -1 in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mLINEITEM5, rb:false, rc:vid,
      rd:{| ra:int, rb:int, rc:real | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
      rc:__prod_ret__26}|} @ { Collection }});
   let sent_msgs =
   nd_QUERY18_mLINEITEM5_send_correctives {ra:me, rb:16, rc:vid, rd:1, re:vid,
     rf:{| ra:int, rb:int, rc:real | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
     rc:__prod_ret__26}|} @ { Collection }} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:16}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:16, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_ORDERS_do_complete_s17 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let __prod_ret__27 =
  (let wrapped_lookup_value =
    bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s17_buf as ind __x in
      (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:real } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * -1 in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mCUSTOMER1, rb:false, rc:vid,
      rd:{| ra:int, rb:int, rc:real | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
      rc:__prod_ret__27}|} @ { Collection }});
   let sent_msgs =
   nd_QUERY18_mCUSTOMER1_send_correctives {ra:me, rb:17, rc:vid, rd:1, re:vid,
     rf:{| ra:int, rb:int, rc:real | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
     rc:__prod_ret__27}|} @ { Collection }} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:17}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:17, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_ORDERS_do_complete_s15 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let __val_ret__9 = -1 in
  ((nd_add_delta_to_int_int_int {ra:QUERY18_mLINEITEM2_mCUSTOMER1, rb:false,
      rc:vid, rd:{| ra:int, rb:int, rc:int | {ra:ORDERS_CUSTKEY,
      rb:ORDERS_ORDERKEY, rc:__val_ret__9}|} @ { Collection }});
   let sent_msgs =
   nd_QUERY18_mLINEITEM2_mCUSTOMER1_send_correctives {ra:me, rb:15, rc:vid,
     rd:1, re:vid, rf:{| ra:int, rb:int, rc:int | {ra:ORDERS_CUSTKEY,
     rb:ORDERS_ORDERKEY, rc:__val_ret__9}|} @ { Collection }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:15, rc:1, rd:sent_msgs,
         re:true, rf:true}))


declare delete_ORDERS_do_corrective_s13_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { key:int, value:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_O_ORDERKEY,
    value:delta_QUERY18_mCUSTOMER1_L1_1_L1_1} in _accext.combine (let
    __prod_ret__486 =
    (((if ORDERS_ORDERKEY == delta_O_ORDERKEY then 1 else 0) * let
      wrapped_lookup_value =
      bind map_QUERY18_mORDERS2_s13_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) *
      ((((({| key:int, value:int | let __prod_ret__465 =
      (let wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s13_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) *
        ((({| key:real, value:int | let __map_ret__287 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__287, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__193} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__193 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_151 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__462} in __accv_151 + __prod_ret__462))) 0 + ((({|
        key:real, value:int | let __sum_ret__219 =
        (let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0}) +
          delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
        {key:__sum_ret__219, value:1}|} @ { Collection }).combine (({|
        key:real, value:int | let __map_ret__289 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__289, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__195} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__195 * -1};
         _accmap)))) empty { key:real, value:int } @ { Collection })).fold
        ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__sum_ret__220} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__sum_ret__220 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_152 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__464} in __accv_152 + __prod_ret__464))) 0) in
      {key:__prod_ret__465, value:1}|} @ { Collection }).combine (({| key:int,
      value:int | let __prod_ret__467 =
      (({| key:real, value:int | let __map_ret__290 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__290, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__197} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__197 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_153 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__466} in __accv_153 + __prod_ret__466))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s13_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__467, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__198} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__198 * -1};
       _accmap)))) empty { key:int, value:int } @ { Collection })).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__sum_ret__222} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__222 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_154 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__469} in __accv_154 + __prod_ret__469))) 0 * let
      wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind __x in
        (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:real } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) +
      (((({| key:int, value:int | let __prod_ret__472 =
      (({| key:real, value:int | let __map_ret__293 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__293, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__199} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__199 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_155 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__471} in __accv_155 + __prod_ret__471))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s13_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__472, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__200} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__200 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_156 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__473} in __accv_156 + __prod_ret__473))) 0 + ((let
      __val_ret__296 = delta_O_ORDERKEY in
      if __val_ret__296 == ORDERS_ORDERKEY then 1 else 0) * ((({| key:int,
      value:int | let __prod_ret__477 =
      (let wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s13_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) *
        ((({| key:real, value:int | let __map_ret__296 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__296, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__202} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__202 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_157 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__474} in __accv_157 + __prod_ret__474))) 0 + ((({|
        key:real, value:int | let __sum_ret__223 =
        (let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0}) +
          delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
        {key:__sum_ret__223, value:1}|} @ { Collection }).combine (({|
        key:real, value:int | let __map_ret__298 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__298, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__204} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__204 * -1};
         _accmap)))) empty { key:real, value:int } @ { Collection })).fold
        ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__sum_ret__224} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__sum_ret__224 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_158 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__476} in __accv_158 + __prod_ret__476))) 0) in
      {key:__prod_ret__477, value:1}|} @ { Collection }).combine (({| key:int,
      value:int | let __prod_ret__479 =
      (({| key:real, value:int | let __map_ret__299 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__299, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__206} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__206 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_159 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__478} in __accv_159 + __prod_ret__478))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s13_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__479, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__207} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__207 * -1};
       _accmap)))) empty { key:int, value:int } @ { Collection })).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__sum_ret__226} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__226 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_160 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__481} in __accv_160 + __prod_ret__481))) 0)) *
      delta_QUERY18_mCUSTOMER1_L1_1_L1_1))) * -1 in
    {| key:int, value:real | {key:ORDERS_CUSTKEY,
      value:__prod_ret__486}|} @ { Collection })))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare delete_ORDERS_do_corrective_s13_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { key:int, value:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_O_ORDERKEY,
    value:delta_QUERY18_mCUSTOMER1_L1_2} in _accext.combine (let
    __prod_ret__561 =
    ((((if ORDERS_ORDERKEY == delta_O_ORDERKEY then 1 else 0) * ((({| key:int,
      value:int | let __prod_ret__553 =
      (({| key:real, value:int | let __map_ret__336 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__336, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__238} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__238 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_181 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__552} in __accv_181 + __prod_ret__552))) 0 * ((let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s13_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) +
        delta_QUERY18_mCUSTOMER1_L1_2) in
      {key:__prod_ret__553, value:1}|} @ { Collection }).combine (({| key:int,
      value:int | let __prod_ret__555 =
      (({| key:real, value:int | let __map_ret__338 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__338, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__240} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__240 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_182 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__554} in __accv_182 + __prod_ret__554))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s13_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__555, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__241} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__241 * -1};
       _accmap)))) empty { key:int, value:int } @ { Collection })).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__sum_ret__250} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__250 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_183 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__557} in __accv_183 + __prod_ret__557))) 0) * let
      wrapped_lookup_value =
      bind map_QUERY18_mORDERS2_s13_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) * let
      wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind __x in
        (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:real } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) * -1
    in
    {| key:int, value:real | {key:ORDERS_CUSTKEY,
      value:__prod_ret__561}|} @ { Collection })))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare delete_ORDERS_do_corrective_s13_m_QUERY18_mORDERS2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:int, rh:string, ri:real, rj:int, rk:string, rl:string, rm:int, rn:string,
  ro:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {key:delta_QUERY18_mORDERSORDERS_CUSTKEY,
    value:delta_QUERY18_mORDERS2} in _accext.combine (let __prod_ret__568 =
    (((if ORDERS_CUSTKEY == delta_QUERY18_mORDERSORDERS_CUSTKEY then 1 
      else 0) * (({| key:int, value:int | let __prod_ret__563 =
      (({| key:real, value:int | let __map_ret__342 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__342, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__242} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__242 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_184 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__562} in __accv_184 + __prod_ret__562))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s13_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__563, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__243} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__243 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_185 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__564} in __accv_185 + __prod_ret__564))) 0) * let
      wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind __x in
        (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:real } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) *
      -delta_QUERY18_mORDERS2 in
    {| key:int, value:real | {key:ORDERS_CUSTKEY,
      value:__prod_ret__568}|} @ { Collection })))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare delete_ORDERS_do_corrective_s14_m_QUERY18_mORDERS2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:int, rh:string, ri:real, rj:int, rk:string, rl:string, rm:int, rn:string,
  ro:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {key:delta_QUERY18_mORDERSORDERS_CUSTKEY,
    value:delta_QUERY18_mORDERS2} in _accext.combine (let __prod_ret__570 =
    (if ORDERS_CUSTKEY == delta_QUERY18_mORDERSORDERS_CUSTKEY then 1 
      else 0) * -delta_QUERY18_mORDERS2 in
    {| ra:int, rb:int, rc:int | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
      rc:__prod_ret__570}|} @ { Collection })))) empty { ra:int, rb:int, rc:int
    } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_int {ra:QUERY18_mLINEITEM2, rb:true, rc:vid,
      rd:new_tuples});
   (nd_QUERY18_mLINEITEM2_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_ORDERS_do_corrective_s16_m_QUERY18_mORDERS2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:int, rh:string, ri:real, rj:int, rk:string, rl:string, rm:int, rn:string,
  ro:collection { key:int, value:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {key:delta_QUERY18_mORDERSORDERS_CUSTKEY,
    value:delta_QUERY18_mORDERS2} in _accext.combine (let __prod_ret__573 =
    ((if ORDERS_CUSTKEY == delta_QUERY18_mORDERSORDERS_CUSTKEY then 1 
      else 0) * let wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s16_buf as ind __x in
        (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:real } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) *
      -delta_QUERY18_mORDERS2 in
    {| ra:int, rb:int, rc:real | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
      rc:__prod_ret__573}|} @ { Collection })))) empty { ra:int, rb:int,
    rc:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mLINEITEM5, rb:true, rc:vid,
      rd:new_tuples});
   (nd_QUERY18_mLINEITEM5_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_ORDERS_do_corrective_s16_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { key:int, value:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_O_ORDERKEY,
    value:delta_QUERY18_mCUSTOMER1_L1_1_L1_1} in _accext.combine (let
    __prod_ret__489 =
    ((if ORDERS_ORDERKEY == delta_O_ORDERKEY then 1 else 0) * let
      wrapped_lookup_value =
      bind map_QUERY18_mORDERS2_s16_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) *
      -delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
    {| ra:int, rb:int, rc:real | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
      rc:__prod_ret__489}|} @ { Collection })))) empty { ra:int, rb:int,
    rc:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mLINEITEM5, rb:true, rc:vid,
      rd:new_tuples});
   (nd_QUERY18_mLINEITEM5_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_ORDERS_do_corrective_s17_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { key:int, value:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_O_ORDERKEY,
    value:delta_QUERY18_mCUSTOMER1_L1_1_L1_1} in _accext.combine (let
    __prod_ret__491 =
    (if ORDERS_ORDERKEY == delta_O_ORDERKEY then 1 else 0) *
      -delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
    {| ra:int, rb:int, rc:real | {ra:ORDERS_CUSTKEY, rb:ORDERS_ORDERKEY,
      rc:__prod_ret__491}|} @ { Collection })))) empty { ra:int, rb:int,
    rc:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mCUSTOMER1, rb:true, rc:vid,
      rd:new_tuples});
   (nd_QUERY18_mCUSTOMER1_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare sw_insert_LINEITEM : { ra:int, rb:int, rc:int, rd:int, re:real,
  rf:real, rg:real, rh:real, ri:string, rj:string, rk:int, rl:int, rm:int,
  rn:string, ro:string, rp:string } -> () = (\args ->
  (sw_buf_insert_LINEITEM.insert args;
   sw_trig_buf_idx.insert {i:4};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_insert_LINEITEM_send_fetch : { key:int, value:int } -> () = (\vid ->
  case (sw_buf_insert_LINEITEM.peek ()) of
  {Some args ->
    (sw_buf_insert_LINEITEM.erase args;
     bind args as
     {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
     in
     ((route_to_int {key:7, value:Some LINEITEM_ORDERKEY}).iterate ((\b1 ->
      bind b1 as {i:ip} in 
      (nd_insert_LINEITEM_do_complete_s21_trig, ip)<- {ra:vid,
      rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
      re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
      rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
      rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
      rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
      rq:LINEITEM_COMMENT}));
      (route_to_int {key:8, value:Some LINEITEM_ORDERKEY}).iterate ((\b1 ->
      bind b1 as {i:ip} in 
      (nd_insert_LINEITEM_do_complete_s22_trig, ip)<- {ra:vid,
      rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
      re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
      rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
      rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
      rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
      rq:LINEITEM_COMMENT}));
      ((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_int_int {ra:2, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
        ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_QUERY18_mLINEITEM2_to_QUERY18_bind_0t0 {ra:None immut,
          rb:empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
          } @ { Collection }, rc:true}).fold ((\_accmap -> (\b3 ->
        bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:18, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_int {key:7, value:Some LINEITEM_ORDERKEY}).fold ((\count ->
          (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18 {ra:None immut,
            rb:empty { ra:{ key:int, value:int }, rb:int, rc:real
            } @ { Collection }, rc:true}).fold ((\_accmap -> (\b3 ->
          bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:18, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }).combine (let
          sender_count =
          (route_to_int {key:8, value:Some LINEITEM_ORDERKEY}).fold ((\count ->
            (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
          ((shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18 {ra:None immut,
              rb:empty { ra:{ key:int, value:int }, rb:int, rc:int
              } @ { Collection }, rc:true}).fold ((\_accmap -> (\b3 ->
            bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {ra:ip, rb:18, rc:sender_count};_accmap)))) empty {
            ra:address, rb:int, rc:int } @ { Collection }).combine (let
            sender_count =
            (route_to_int_int {ra:2, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
              ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
            ((shuffle_QUERY18_mLINEITEM2_to_QUERY18_mLINEITEM5_bind_0t0_1t1
                {ra:None immut, rb:Some LINEITEM_ORDERKEY, rc:empty { ra:{
                key:int, value:int }, rb:int, rc:int, rd:int
                } @ { Collection }, rd:true}).fold ((\_accmap -> (\b3 ->
              bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:19, rc:sender_count};_accmap))))
              empty { ra:address, rb:int, rc:int } @ { Collection }).combine
              (let sender_count =
              (route_to_int_int {ra:3, rb:None immut,
                 rc:Some LINEITEM_ORDERKEY}).fold ((\count -> (\b3 ->
                bind b3 as {i:ip} in count + 1))) 0 in
              (shuffle_QUERY18_mLINEITEM2_mCUSTOMER1_to_QUERY18_mCUSTOMER1_bind_0t0_1t1
                 {ra:None immut, rb:Some LINEITEM_ORDERKEY, rc:empty { ra:{
                 key:int, value:int }, rb:int, rc:int, rd:int
                 } @ { Collection }, rd:true}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:20, rc:sender_count};_accmap))))
                empty { ra:address, rb:int, rc:int } @ { Collection })))))).groupBy
      ((\b1 -> bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip,
      value:stmt_id})) ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id,
      rc:count} in acc + count))) 0).groupBy ((\b1 -> bind b1 as {key:b2,
      value:count} in bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc ->
      (\b3 -> bind b3 as {key:ip_and_stmt_id, value:count} in bind
      ip_and_stmt_id as {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_insert_LINEITEM_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid,
       rd:LINEITEM_ORDERKEY, re:LINEITEM_PARTKEY, rf:LINEITEM_SUPPKEY,
       rg:LINEITEM_LINENUMBER, rh:LINEITEM_QUANTITY, ri:LINEITEM_EXTENDEDPRICE,
       rj:LINEITEM_DISCOUNT, rk:LINEITEM_TAX, rl:LINEITEM_RETURNFLAG,
       rm:LINEITEM_LINESTATUS, rn:LINEITEM_SHIPDATE, ro:LINEITEM_COMMITDATE,
       rp:LINEITEM_RECEIPTDATE, rq:LINEITEM_SHIPINSTRUCT, rr:LINEITEM_SHIPMODE,
       rs:LINEITEM_COMMENT};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_int_int {ra:3, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:20, rb:3, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:2, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:19, rb:2, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:8, value:Some LINEITEM_ORDERKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:18, rb:8, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:7, value:Some LINEITEM_ORDERKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:18, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:2, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:18, rb:2, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine empty { ra:int, rb:int, rc:address
      } @ { Collection }))))).groupBy ((\b1 -> bind b1 as {ra:stmt_id,
      rb:map_id, rc:ip} in ip)) ((\acc -> (\b3 -> bind b3 as {ra:stmt_id,
      rb:map_id, rc:ip} in (acc.insert {key:stmt_id, value:map_id};acc))))
      empty { key:int, value:int } @ { Collection }).iterate ((\b1 ->
      bind b1 as {key:ip, value:stmt_map_ids} in 
      (nd_insert_LINEITEM_rcv_fetch, ip)<- {ra:stmt_map_ids, rb:vid,
      rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
      rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
      ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
      rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
      ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
      rr:LINEITEM_COMMENT}))))}{None ->
                                 error
                                   (print
                                      "unexpected missing arguments in sw_buf_insert_LINEITEM")})


declare nd_insert_LINEITEM_do_complete_s18 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((bind map_QUERY18_mLINEITEM2_s18_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:C_CUSTKEY, rb:LINEITEM_ORDERKEY, rc:__map_ret__27} in 
    (_accmap.insert {key:C_CUSTKEY, value:__map_ret__27};_accmap)))) empty {
    key:int, value:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:C_CUSTKEY, value:__map_ret__27} in 
    (_accmap.insert {key:C_CUSTKEY, value:__map_ret__27 * (((({| key:int,
     value:int | let __sum_ret__5 =
     ((({| key:real, value:int | let __map_ret__28 =
       let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
           (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:real } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0} in
       {key:__map_ret__28, value:1}|} @ { Collection }).fold ((\_accmap ->
       (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__9} in 
       (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__9 *
        if 100 < __sql_inline_agg_1 then 1 else 0};
        _accmap)))) empty { key:real, value:int } @ { Collection }).fold
       ((\__accv_9 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
       value:__prod_ret__28} in __accv_9 + __prod_ret__28))) 0 * (((((let
       wrapped_lookup_value =
       bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
         (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
            bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
           ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
           (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
           value:int } @ { Collection } in
       case (wrapped_lookup_value.peek ()) of
         {Some unwrapped_value -> bind unwrapped_value as
           {key:_, value:projected_field} in projected_field}{None -> 0}) + 1)
       * -1) + let wrapped_lookup_value =
       bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
         (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
            bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
           ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
           (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
           value:int } @ { Collection } in
       case (wrapped_lookup_value.peek ()) of
         {Some unwrapped_value -> bind unwrapped_value as
           {key:_, value:projected_field} in projected_field}{None -> 0}) + 1))
       + ((({| key:real, value:int | let __sum_ret__3 =
       (let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
           (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:real } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         LINEITEM_QUANTITY in
       {key:__sum_ret__3, value:1}|} @ { Collection }).fold ((\_accmap ->
       (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__10} in 
       (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__10 *
        if 100 < __sql_inline_agg_1 then 1 else 0};
        _accmap)))) empty { key:real, value:int } @ { Collection }).fold
       ((\__accv_10 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
       value:__prod_ret__31} in __accv_10 + __prod_ret__31))) 0 * ((let
       wrapped_lookup_value =
       bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
         (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
            bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
           ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
           (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
           value:int } @ { Collection } in
       case (wrapped_lookup_value.peek ()) of
         {Some unwrapped_value -> bind unwrapped_value as
           {key:_, value:projected_field} in projected_field}{None -> 0}) + 1))
     in {key:__sum_ret__5, value:1}|} @ { Collection }).fold ((\_accmap ->
     (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__11} in 
     (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__11 *
      if 1 <= __sql_inline_agg_2 then 1 else 0};
      _accmap)))) empty { key:int, value:int } @ { Collection }).fold
     ((\__accv_11 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
     value:__prod_ret__33} in __accv_11 + __prod_ret__33))) 0 *
     LINEITEM_QUANTITY) + ((let wrapped_lookup_value =
     bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
       (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
          bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
         ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
         (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
         value:real } @ { Collection } in
     case (wrapped_lookup_value.peek ()) of
       {Some unwrapped_value -> bind unwrapped_value as
         {key:_, value:projected_field} in projected_field}{None -> 0}) * ((({|
     key:int, value:int | let __sum_ret__10 =
     ((({| key:real, value:int | let __map_ret__34 =
       let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
           (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:real } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0} in
       {key:__map_ret__34, value:1}|} @ { Collection }).fold ((\_accmap ->
       (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__12} in 
       (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__12 *
        if 100 < __sql_inline_agg_1 then 1 else 0};
        _accmap)))) empty { key:real, value:int } @ { Collection }).fold
       ((\__accv_12 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
       value:__prod_ret__35} in __accv_12 + __prod_ret__35))) 0 * (((((let
       wrapped_lookup_value =
       bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
         (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
            bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
           ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
           (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
           value:int } @ { Collection } in
       case (wrapped_lookup_value.peek ()) of
         {Some unwrapped_value -> bind unwrapped_value as
           {key:_, value:projected_field} in projected_field}{None -> 0}) + 1)
       * -1) + let wrapped_lookup_value =
       bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
         (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
            bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
           ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
           (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
           value:int } @ { Collection } in
       case (wrapped_lookup_value.peek ()) of
         {Some unwrapped_value -> bind unwrapped_value as
           {key:_, value:projected_field} in projected_field}{None -> 0}) + 1))
       + ((({| key:real, value:int | let __sum_ret__8 =
       (let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
           (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:real } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         LINEITEM_QUANTITY in
       {key:__sum_ret__8, value:1}|} @ { Collection }).fold ((\_accmap ->
       (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__13} in 
       (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__13 *
        if 100 < __sql_inline_agg_1 then 1 else 0};
        _accmap)))) empty { key:real, value:int } @ { Collection }).fold
       ((\__accv_13 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
       value:__prod_ret__38} in __accv_13 + __prod_ret__38))) 0 * ((let
       wrapped_lookup_value =
       bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
         (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
            bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
           ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
           (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
           value:int } @ { Collection } in
       case (wrapped_lookup_value.peek ()) of
         {Some unwrapped_value -> bind unwrapped_value as
           {key:_, value:projected_field} in projected_field}{None -> 0}) + 1))
     in {key:__sum_ret__10, value:1}|} @ { Collection }).fold ((\_accmap ->
     (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__14} in 
     (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__14 *
      if 1 <= __sql_inline_agg_2 then 1 else 0};
      _accmap)))) empty { key:int, value:int } @ { Collection }).fold
     ((\__accv_14 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
     value:__prod_ret__40} in __accv_14 + __prod_ret__40))) 0 + ((({| key:int,
     value:int | let __prod_ret__42 =
     (({| key:real, value:int | let __map_ret__39 =
       let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
           (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:real } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0} in
       {key:__map_ret__39, value:1}|} @ { Collection }).fold ((\_accmap ->
       (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__15} in 
       (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__15 *
        if 100 < __sql_inline_agg_1 then 1 else 0};
        _accmap)))) empty { key:real, value:int } @ { Collection }).fold
       ((\__accv_15 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
       value:__prod_ret__41} in __accv_15 + __prod_ret__41))) 0 * let
       wrapped_lookup_value =
       bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
         (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
            bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
           ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
           (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
           value:int } @ { Collection } in
       case (wrapped_lookup_value.peek ()) of
         {Some unwrapped_value -> bind unwrapped_value as
           {key:_, value:projected_field} in projected_field}{None -> 0} in
     {key:__prod_ret__42, value:1}|} @ { Collection }).fold ((\_accmap ->
     (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__16} in 
     (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__16 *
      if 1 <= __sql_inline_agg_2 then 1 else 0};
      _accmap)))) empty { key:int, value:int } @ { Collection }).fold
     ((\__accv_16 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
     value:__prod_ret__43} in __accv_16 + __prod_ret__43))) 0 * -1))))};
     _accmap)))) empty { key:int, value:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY, value:__prod_ret__46} in 
    (_accmap.insert {key:C_CUSTKEY, value:__prod_ret__46};_accmap)))) empty {
    key:int, value:real } @ { Collection } in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:false, rc:vid, rd:delta_values});
   (nd_complete_stmt_cntr_check {key:vid, value:18})))


declare nd_insert_LINEITEM_do_complete_s19 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((bind map_QUERY18_mLINEITEM2_s19_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:C_CUSTKEY, rb:LINEITEM_ORDERKEY, rc:__map_ret__41} in 
    (_accmap.insert {key:C_CUSTKEY, value:__map_ret__41};_accmap)))) empty {
    key:int, value:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:C_CUSTKEY, value:__map_ret__41} in 
    (_accmap.insert {key:C_CUSTKEY, value:__map_ret__41 * LINEITEM_QUANTITY};
     _accmap)))) empty { key:int, value:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY, value:__prod_ret__47} in 
    (_accmap.insert {ra:C_CUSTKEY, rb:LINEITEM_ORDERKEY, rc:__prod_ret__47};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection } in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mLINEITEM5, rb:false, rc:vid,
      rd:delta_values});
   (nd_complete_stmt_cntr_check {key:vid, value:19})))


declare nd_insert_LINEITEM_do_complete_s20 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((bind map_QUERY18_mLINEITEM2_mCUSTOMER1_s20_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:QUERY18_mCUSTOMERCUSTOMER_CUSTKEY, rb:LINEITEM_ORDERKEY,
    rc:__map_ret__42} in 
    (_accmap.insert {key:QUERY18_mCUSTOMERCUSTOMER_CUSTKEY,
     value:__map_ret__42};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:QUERY18_mCUSTOMERCUSTOMER_CUSTKEY,
    value:__map_ret__42} in 
    (_accmap.insert {key:QUERY18_mCUSTOMERCUSTOMER_CUSTKEY, value:__map_ret__42
     * LINEITEM_QUANTITY};
     _accmap)))) empty { key:int, value:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:QUERY18_mCUSTOMERCUSTOMER_CUSTKEY,
    value:__prod_ret__48} in 
    (_accmap.insert {ra:QUERY18_mCUSTOMERCUSTOMER_CUSTKEY,
     rb:LINEITEM_ORDERKEY, rc:__prod_ret__48};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection } in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mCUSTOMER1, rb:false, rc:vid,
      rd:delta_values});
   let sent_msgs =
   nd_QUERY18_mCUSTOMER1_send_correctives {ra:me, rb:20, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:20}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:20, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_LINEITEM_do_complete_s21 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  __val_ret__26 = LINEITEM_QUANTITY in
  ((nd_add_delta_to_int_float {ra:QUERY18_mCUSTOMER1_L1_1_L1_1, rb:false,
      rc:vid, rd:{| key:int, value:real | {key:LINEITEM_ORDERKEY,
      value:__val_ret__26}|} @ { Collection }});
   let sent_msgs =
   nd_QUERY18_mCUSTOMER1_L1_1_L1_1_send_correctives {ra:me, rb:21, rc:vid,
     rd:1, re:vid, rf:{| key:int, value:real | {key:LINEITEM_ORDERKEY,
     value:__val_ret__26}|} @ { Collection }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:21, rc:1, rd:sent_msgs,
         re:true, rf:true}))


declare nd_insert_LINEITEM_do_complete_s22 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  __val_ret__27 = 1 in
  ((nd_add_delta_to_int_int {ra:QUERY18_mCUSTOMER1_L1_2, rb:false, rc:vid,
      rd:{| key:int, value:int | {key:LINEITEM_ORDERKEY,
      value:__val_ret__27}|} @ { Collection }});
   let sent_msgs =
   nd_QUERY18_mCUSTOMER1_L1_2_send_correctives {ra:me, rb:22, rc:vid, rd:1,
     re:vid, rf:{| key:int, value:int | {key:LINEITEM_ORDERKEY,
     value:__val_ret__27}|} @ { Collection }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:22, rc:1, rd:sent_msgs,
         re:true, rf:true}))


declare insert_LINEITEM_do_corrective_s18_m_QUERY18_mLINEITEM2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:int, rh:int, ri:int, rj:real, rk:real, rl:real, rm:real, rn:string,
  ro:string, rp:int, rq:int, rr:int, rs:string, rt:string, ru:string,
  rv:collection { ra:int, rb:int, rc:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY,
  ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE,
  rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG,
  ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
  rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE,
  ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {ra:delta_C_CUSTKEY,
    rb:delta_QUERY18_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_QUERY18_mLINEITEM2} in _accext.combine (let __prod_ret__94 =
    ((if LINEITEM_ORDERKEY == delta_QUERY18_mLINEITEMLINEITEM_ORDERKEY 
      then 1 else 0) * (((({| key:int, value:int | let __sum_ret__26 =
      ((({| key:real, value:int | let __map_ret__57 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__57, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__26} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__26 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_24 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__75} in __accv_24 + __prod_ret__75))) 0 * (((((let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) + 1)
        * -1) + let wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) +
        1)) + ((({| key:real, value:int | let __sum_ret__24 =
        (let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0}) +
          LINEITEM_QUANTITY in
        {key:__sum_ret__24, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__27} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__27 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_25 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__78} in __accv_25 + __prod_ret__78))) 0 * ((let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) +
        1)) in {key:__sum_ret__26, value:1}|} @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__lift_ret__28} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__28 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_26 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__80} in __accv_26 + __prod_ret__80))) 0 *
      LINEITEM_QUANTITY) + ((let wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
        (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:real } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) *
      ((({| key:int, value:int | let __sum_ret__31 =
      ((({| key:real, value:int | let __map_ret__63 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__63, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__29} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__29 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_27 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__82} in __accv_27 + __prod_ret__82))) 0 * (((((let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) + 1)
        * -1) + let wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) +
        1)) + ((({| key:real, value:int | let __sum_ret__29 =
        (let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0}) +
          LINEITEM_QUANTITY in
        {key:__sum_ret__29, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__30} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__30 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_28 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__85} in __accv_28 + __prod_ret__85))) 0 * ((let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) +
        1)) in {key:__sum_ret__31, value:1}|} @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__lift_ret__31} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__31 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_29 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__87} in __accv_29 + __prod_ret__87))) 0 + ((({| key:int,
      value:int | let __prod_ret__89 =
      (({| key:real, value:int | let __map_ret__68 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__68, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__32} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__32 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_30 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__88} in __accv_30 + __prod_ret__88))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__89, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__33} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__33 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_31 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__90} in __accv_31 + __prod_ret__90))) 0 * -1))))) *
      delta_QUERY18_mLINEITEM2 in
    {| key:int, value:real | {key:delta_C_CUSTKEY,
      value:__prod_ret__94}|} @ { Collection })))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare insert_LINEITEM_do_corrective_s18_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { key:int, value:real } @ { Collection } } -> int =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY,
  ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE,
  rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG,
  ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
  rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE,
  ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_O_ORDERKEY,
    value:delta_QUERY18_mCUSTOMER1_L1_1_L1_1} in _accext.combine (let
    delta_values =
    ((((((bind map_QUERY18_mLINEITEM2_s18_buf as ind __x in
      (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
        rd:map_val} in (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc))))
        empty { ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:C_CUSTKEY, rb:LINEITEM_ORDERKEY,
      rc:__map_ret__83} in 
      (_accmap.insert {key:C_CUSTKEY, value:__map_ret__83};_accmap)))) empty {
      key:int, value:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {key:C_CUSTKEY, value:__map_ret__83} in 
      (_accmap.insert {key:C_CUSTKEY, value:__map_ret__83 *
       if LINEITEM_ORDERKEY == delta_O_ORDERKEY then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY,
      value:__prod_ret__174} in 
      (_accmap.insert {key:C_CUSTKEY, value:__prod_ret__174 * (((((({| key:int,
       value:int | let __sum_ret__57 =
       (((let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * ((({| key:real, value:int | let __sum_ret__47 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           LINEITEM_QUANTITY in
         {key:__sum_ret__47, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__42} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__42 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_40 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__119} in __accv_40 + __prod_ret__119))) 0 + ((({|
         key:real, value:int | let __sum_ret__48 =
         ((let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           LINEITEM_QUANTITY) + delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
         {key:__sum_ret__48, value:1}|} @ { Collection }).combine (({|
         key:real, value:int | let __sum_ret__49 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           LINEITEM_QUANTITY in
         {key:__sum_ret__49, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__44} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__44 * -1};
          _accmap)))) empty { key:real, value:int } @ { Collection })).fold
         ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__sum_ret__50} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__sum_ret__50 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_41 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__121} in __accv_41 + __prod_ret__121))) 0)) +
         ((((((let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * -1) + let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * ((({| key:real, value:int | let __map_ret__90 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__90, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__45} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__45 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_42 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__124} in __accv_42 + __prod_ret__124))) 0 + ((({|
         key:real, value:int | let __sum_ret__54 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
         {key:__sum_ret__54, value:1}|} @ { Collection }).combine (({|
         key:real, value:int | let __map_ret__92 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__92, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__47} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__47 * -1};
          _accmap)))) empty { key:real, value:int } @ { Collection })).fold
         ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__sum_ret__55} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__sum_ret__55 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_43 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__126} in __accv_43 + __prod_ret__126))) 0)) in
       {key:__sum_ret__57, value:1}|} @ { Collection }).combine (({| key:int,
       value:int | let __sum_ret__62 =
       ((({| key:real, value:int | let __map_ret__93 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__93, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__49} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__49 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_44 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__128} in __accv_44 + __prod_ret__128))) 0 * (((((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * -1) + let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1)) + ((({| key:real, value:int | let __sum_ret__60 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           LINEITEM_QUANTITY in
         {key:__sum_ret__60, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__50} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__50 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_45 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__131} in __accv_45 + __prod_ret__131))) 0 * ((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1)) in {key:__sum_ret__62, value:1}|} @ { Collection }).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__lift_ret__51} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__51 * -1};
        _accmap)))) empty { key:int, value:int } @ { Collection })).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__sum_ret__63} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__63 *
        if 1 <= __sql_inline_agg_2 then 1 else 0};
        _accmap)))) empty { key:int, value:int } @ { Collection }).fold
       ((\__accv_46 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__prod_ret__134} in __accv_46 + __prod_ret__134))) 0 *
       LINEITEM_QUANTITY) + (((({| key:int, value:int | let __sum_ret__68 =
       ((({| key:real, value:int | let __map_ret__98 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__98, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__52} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__52 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_47 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__136} in __accv_47 + __prod_ret__136))) 0 * (((((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * -1) + let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1)) + ((({| key:real, value:int | let __sum_ret__66 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           LINEITEM_QUANTITY in
         {key:__sum_ret__66, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__53} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__53 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_48 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__139} in __accv_48 + __prod_ret__139))) 0 * ((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1)) in {key:__sum_ret__68, value:1}|} @ { Collection }).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__lift_ret__54} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__54 *
        if 1 <= __sql_inline_agg_2 then 1 else 0};
        _accmap)))) empty { key:int, value:int } @ { Collection }).fold
       ((\__accv_49 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__prod_ret__141} in __accv_49 + __prod_ret__141))) 0 + ((({|
       key:int, value:int | let __prod_ret__143 =
       (({| key:real, value:int | let __map_ret__103 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__103, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__55} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__55 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_50 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__142} in __accv_50 + __prod_ret__142))) 0 * let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0} in
       {key:__prod_ret__143, value:1}|} @ { Collection }).fold ((\_accmap ->
       (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__56} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__56 *
        if 1 <= __sql_inline_agg_2 then 1 else 0};
        _accmap)))) empty { key:int, value:int } @ { Collection }).fold
       ((\__accv_51 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__prod_ret__144} in __accv_51 + __prod_ret__144))) 0 * -1)) *
       delta_QUERY18_mCUSTOMER1_L1_1_L1_1)) + (((let wrapped_lookup_value =
       bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
         (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
            bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
           ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
           (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
           value:real } @ { Collection } in
       case (wrapped_lookup_value.peek ()) of
         {Some unwrapped_value -> bind unwrapped_value as
           {key:_, value:projected_field} in projected_field}{None -> 0}) +
       ((let __val_ret__103 = delta_O_ORDERKEY in
       if __val_ret__103 == LINEITEM_ORDERKEY then 1 else 0) *
       delta_QUERY18_mCUSTOMER1_L1_1_L1_1)) * (((({| key:int, value:int | let
       __sum_ret__82 =
       (((let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * ((({| key:real, value:int | let __sum_ret__72 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           LINEITEM_QUANTITY in
         {key:__sum_ret__72, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__58} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__58 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_52 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__148} in __accv_52 + __prod_ret__148))) 0 + ((({|
         key:real, value:int | let __sum_ret__73 =
         ((let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           LINEITEM_QUANTITY) + delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
         {key:__sum_ret__73, value:1}|} @ { Collection }).combine (({|
         key:real, value:int | let __sum_ret__74 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           LINEITEM_QUANTITY in
         {key:__sum_ret__74, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__60} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__60 * -1};
          _accmap)))) empty { key:real, value:int } @ { Collection })).fold
         ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__sum_ret__75} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__sum_ret__75 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_53 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__150} in __accv_53 + __prod_ret__150))) 0)) +
         ((((((let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * -1) + let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * ((({| key:real, value:int | let __map_ret__112 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__112, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__61} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__61 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_54 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__153} in __accv_54 + __prod_ret__153))) 0 + ((({|
         key:real, value:int | let __sum_ret__79 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
         {key:__sum_ret__79, value:1}|} @ { Collection }).combine (({|
         key:real, value:int | let __map_ret__114 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__114, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__63} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__63 * -1};
          _accmap)))) empty { key:real, value:int } @ { Collection })).fold
         ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__sum_ret__80} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__sum_ret__80 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_55 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__155} in __accv_55 + __prod_ret__155))) 0)) in
       {key:__sum_ret__82, value:1}|} @ { Collection }).combine (({| key:int,
       value:int | let __sum_ret__87 =
       ((({| key:real, value:int | let __map_ret__115 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__115, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__65} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__65 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_56 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__157} in __accv_56 + __prod_ret__157))) 0 * (((((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * -1) + let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1)) + ((({| key:real, value:int | let __sum_ret__85 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           LINEITEM_QUANTITY in
         {key:__sum_ret__85, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__66} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__66 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_57 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__160} in __accv_57 + __prod_ret__160))) 0 * ((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1)) in {key:__sum_ret__87, value:1}|} @ { Collection }).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__lift_ret__67} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__67 * -1};
        _accmap)))) empty { key:int, value:int } @ { Collection })).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__sum_ret__88} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__88 *
        if 1 <= __sql_inline_agg_2 then 1 else 0};
        _accmap)))) empty { key:int, value:int } @ { Collection }).fold
       ((\__accv_58 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__prod_ret__163} in __accv_58 + __prod_ret__163))) 0 + (((({|
       key:int, value:int | let __prod_ret__167 =
       (let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) *
         ((({| key:real, value:int | let __map_ret__121 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__121, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__68} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__68 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_59 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__164} in __accv_59 + __prod_ret__164))) 0 + ((({|
         key:real, value:int | let __sum_ret__89 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
         {key:__sum_ret__89, value:1}|} @ { Collection }).combine (({|
         key:real, value:int | let __map_ret__123 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__123, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__70} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__70 * -1};
          _accmap)))) empty { key:real, value:int } @ { Collection })).fold
         ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__sum_ret__90} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__sum_ret__90 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_60 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__166} in __accv_60 + __prod_ret__166))) 0) in
       {key:__prod_ret__167, value:1}|} @ { Collection }).combine (({| key:int,
       value:int | let __prod_ret__169 =
       (({| key:real, value:int | let __map_ret__124 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__124, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__72} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__72 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_61 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__168} in __accv_61 + __prod_ret__168))) 0 * let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0} in
       {key:__prod_ret__169, value:1}|} @ { Collection }).fold ((\_accmap ->
       (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__73} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__73 * -1};
        _accmap)))) empty { key:int, value:int } @ { Collection })).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__sum_ret__92} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__92 *
        if 1 <= __sql_inline_agg_2 then 1 else 0};
        _accmap)))) empty { key:int, value:int } @ { Collection }).fold
       ((\__accv_62 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__prod_ret__171} in __accv_62 + __prod_ret__171))) 0 * -1))))};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY,
      value:__prod_ret__175} in 
      (_accmap.insert {key:C_CUSTKEY, value:__prod_ret__175};_accmap))))
      empty { key:int, value:real } @ { Collection }).groupBy ((\b1 ->
      bind b1 as {key:map_0, value:map_val} in map_0)) ((\acc -> (\b3 ->
      bind b3 as {key:map_0, value:map_val} in acc + map_val))) 0).fold
      ((\acc -> (\b3 -> bind b3 as {key:g, value:val} in 
      (acc.insert {key:g, value:val};acc)))) empty { key:int, value:real
      } @ { Collection } in delta_values)))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare insert_LINEITEM_do_corrective_s18_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { key:int, value:int } @ { Collection } } -> int =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY,
  ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE,
  rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG,
  ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
  rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE,
  ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_O_ORDERKEY,
    value:delta_QUERY18_mCUSTOMER1_L1_2} in _accext.combine (let delta_values =
    ((((((bind map_QUERY18_mLINEITEM2_s18_buf as ind __x in
      (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
        rd:map_val} in (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc))))
        empty { ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:C_CUSTKEY, rb:LINEITEM_ORDERKEY,
      rc:__map_ret__126} in 
      (_accmap.insert {key:C_CUSTKEY, value:__map_ret__126};_accmap)))) empty {
      key:int, value:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {key:C_CUSTKEY, value:__map_ret__126} in 
      (_accmap.insert {key:C_CUSTKEY, value:__map_ret__126 *
       if LINEITEM_ORDERKEY == delta_O_ORDERKEY then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY,
      value:__prod_ret__209} in 
      (_accmap.insert {key:C_CUSTKEY, value:__prod_ret__209 * ((((({| key:int,
       value:int | let __sum_ret__99 =
       ((({| key:real, value:int | let __sum_ret__95 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           LINEITEM_QUANTITY in
         {key:__sum_ret__95, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__74} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__74 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_63 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__176} in __accv_63 + __prod_ret__176))) 0 * ((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         (1 + delta_QUERY18_mCUSTOMER1_L1_2))) + ((({| key:real, value:int |
         let __map_ret__129 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__129, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__75} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__75 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_64 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__178} in __accv_64 + __prod_ret__178))) 0 * (((((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * -1) + let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1)) in {key:__sum_ret__99, value:1}|} @ { Collection }).combine (({|
       key:int, value:int | let __sum_ret__104 =
       ((({| key:real, value:int | let __map_ret__132 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__132, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__77} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__77 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_65 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__181} in __accv_65 + __prod_ret__181))) 0 * (((((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * -1) + let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1)) + ((({| key:real, value:int | let __sum_ret__102 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           LINEITEM_QUANTITY in
         {key:__sum_ret__102, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__78} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__78 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_66 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__184} in __accv_66 + __prod_ret__184))) 0 * ((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1)) in {key:__sum_ret__104, value:1}|} @ { Collection }).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__lift_ret__79} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__79 * -1};
        _accmap)))) empty { key:int, value:int } @ { Collection })).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__sum_ret__105} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__105 *
        if 1 <= __sql_inline_agg_2 then 1 else 0};
        _accmap)))) empty { key:int, value:int } @ { Collection }).fold
       ((\__accv_67 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__prod_ret__187} in __accv_67 + __prod_ret__187))) 0 *
       LINEITEM_QUANTITY) + ((let wrapped_lookup_value =
       bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
         (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
            bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
           ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
           (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
           value:real } @ { Collection } in
       case (wrapped_lookup_value.peek ()) of
         {Some unwrapped_value -> bind unwrapped_value as
           {key:_, value:projected_field} in projected_field}{None -> 0}) *
       (((({| key:int, value:int | let __sum_ret__110 =
       ((({| key:real, value:int | let __sum_ret__106 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           LINEITEM_QUANTITY in
         {key:__sum_ret__106, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__80} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__80 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_68 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__189} in __accv_68 + __prod_ret__189))) 0 * ((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         (1 + delta_QUERY18_mCUSTOMER1_L1_2))) + ((({| key:real, value:int |
         let __map_ret__140 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__140, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__81} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__81 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_69 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__191} in __accv_69 + __prod_ret__191))) 0 * (((((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * -1) + let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1)) in {key:__sum_ret__110, value:1}|} @ { Collection }).combine (({|
       key:int, value:int | let __sum_ret__115 =
       ((({| key:real, value:int | let __map_ret__143 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__143, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__83} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__83 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_70 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__194} in __accv_70 + __prod_ret__194))) 0 * (((((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * -1) + let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1)) + ((({| key:real, value:int | let __sum_ret__113 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           LINEITEM_QUANTITY in
         {key:__sum_ret__113, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__84} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__84 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_71 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__197} in __accv_71 + __prod_ret__197))) 0 * ((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1)) in {key:__sum_ret__115, value:1}|} @ { Collection }).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__lift_ret__85} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__85 * -1};
        _accmap)))) empty { key:int, value:int } @ { Collection })).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__sum_ret__116} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__116 *
        if 1 <= __sql_inline_agg_2 then 1 else 0};
        _accmap)))) empty { key:int, value:int } @ { Collection }).fold
       ((\__accv_72 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__prod_ret__200} in __accv_72 + __prod_ret__200))) 0 + (((({|
       key:int, value:int | let __prod_ret__202 =
       (({| key:real, value:int | let __map_ret__148 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__148, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__86} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__86 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_73 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__201} in __accv_73 + __prod_ret__201))) 0 * ((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         delta_QUERY18_mCUSTOMER1_L1_2) in
       {key:__prod_ret__202, value:1}|} @ { Collection }).combine (({| key:int,
       value:int | let __prod_ret__204 =
       (({| key:real, value:int | let __map_ret__150 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__150, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__88} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__88 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_74 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__203} in __accv_74 + __prod_ret__203))) 0 * let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0} in
       {key:__prod_ret__204, value:1}|} @ { Collection }).fold ((\_accmap ->
       (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__89} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__89 * -1};
        _accmap)))) empty { key:int, value:int } @ { Collection })).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__sum_ret__118} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__118 *
        if 1 <= __sql_inline_agg_2 then 1 else 0};
        _accmap)))) empty { key:int, value:int } @ { Collection }).fold
       ((\__accv_75 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__prod_ret__206} in __accv_75 + __prod_ret__206))) 0 * -1))))};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY,
      value:__prod_ret__210} in 
      (_accmap.insert {key:C_CUSTKEY, value:__prod_ret__210};_accmap))))
      empty { key:int, value:real } @ { Collection }).groupBy ((\b1 ->
      bind b1 as {key:map_0, value:map_val} in map_0)) ((\acc -> (\b3 ->
      bind b3 as {key:map_0, value:map_val} in acc + map_val))) 0).fold
      ((\acc -> (\b3 -> bind b3 as {key:g, value:val} in 
      (acc.insert {key:g, value:val};acc)))) empty { key:int, value:real
      } @ { Collection } in delta_values)))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare insert_LINEITEM_do_corrective_s19_m_QUERY18_mLINEITEM2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:int, rh:int, ri:int, rj:real, rk:real, rl:real, rm:real, rn:string,
  ro:string, rp:int, rq:int, rr:int, rs:string, rt:string, ru:string,
  rv:collection { ra:int, rb:int, rc:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY,
  ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE,
  rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG,
  ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
  rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE,
  ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {ra:delta_C_CUSTKEY,
    rb:delta_QUERY18_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_QUERY18_mLINEITEM2} in _accext.combine (let __prod_ret__96 =
    ((if LINEITEM_ORDERKEY == delta_QUERY18_mLINEITEMLINEITEM_ORDERKEY 
      then 1 else 0) * delta_QUERY18_mLINEITEM2) * LINEITEM_QUANTITY in
    {| ra:int, rb:int, rc:real | {ra:delta_C_CUSTKEY, rb:LINEITEM_ORDERKEY,
      rc:__prod_ret__96}|} @ { Collection })))) empty { ra:int, rb:int, rc:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mLINEITEM5, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare insert_LINEITEM_do_corrective_s20_m_QUERY18_mLINEITEM2_mCUSTOMER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:int, rb:int, rc:int } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
  rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
  rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
  rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE,
  rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
  rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_QUERY18_mLINEITEM2_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_QUERY18_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_QUERY18_mLINEITEM2_mCUSTOMER1} in _accext.combine (let
    __prod_ret__212 =
    ((if LINEITEM_ORDERKEY == delta_QUERY18_mLINEITEMLINEITEM_ORDERKEY 
      then 1 else 0) * delta_QUERY18_mLINEITEM2_mCUSTOMER1) * LINEITEM_QUANTITY
    in
    {| ra:int, rb:int, rc:real |
      {ra:delta_QUERY18_mLINEITEM2_mCUSTOMERCUSTOMER_CUSTKEY,
      rb:LINEITEM_ORDERKEY, rc:__prod_ret__212}|} @ { Collection })))) empty {
    ra:int, rb:int, rc:real } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mCUSTOMER1, rb:true, rc:vid,
      rd:new_tuples});
   (nd_QUERY18_mCUSTOMER1_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare sw_delete_LINEITEM : { ra:int, rb:int, rc:int, rd:int, re:real,
  rf:real, rg:real, rh:real, ri:string, rj:string, rk:int, rl:int, rm:int,
  rn:string, ro:string, rp:string } -> () = (\args ->
  (sw_buf_delete_LINEITEM.insert args;
   sw_trig_buf_idx.insert {i:5};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_delete_LINEITEM_send_fetch : { key:int, value:int } -> () = (\vid ->
  case (sw_buf_delete_LINEITEM.peek ()) of
  {Some args ->
    (sw_buf_delete_LINEITEM.erase args;
     bind args as
     {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
     in
     ((route_to_int {key:7, value:Some LINEITEM_ORDERKEY}).iterate ((\b1 ->
      bind b1 as {i:ip} in 
      (nd_delete_LINEITEM_do_complete_s26_trig, ip)<- {ra:vid,
      rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
      re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
      rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
      rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
      rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
      rq:LINEITEM_COMMENT}));
      (route_to_int {key:8, value:Some LINEITEM_ORDERKEY}).iterate ((\b1 ->
      bind b1 as {i:ip} in 
      (nd_delete_LINEITEM_do_complete_s27_trig, ip)<- {ra:vid,
      rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
      re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
      rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
      rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
      rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
      rq:LINEITEM_COMMENT}));
      ((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_int_int {ra:2, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
        ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_QUERY18_mLINEITEM2_to_QUERY18_bind_0t0 {ra:None immut,
          rb:empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
          } @ { Collection }, rc:true}).fold ((\_accmap -> (\b3 ->
        bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:23, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_int {key:7, value:Some LINEITEM_ORDERKEY}).fold ((\count ->
          (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18 {ra:None immut,
            rb:empty { ra:{ key:int, value:int }, rb:int, rc:real
            } @ { Collection }, rc:true}).fold ((\_accmap -> (\b3 ->
          bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:23, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }).combine (let
          sender_count =
          (route_to_int {key:8, value:Some LINEITEM_ORDERKEY}).fold ((\count ->
            (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
          ((shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18 {ra:None immut,
              rb:empty { ra:{ key:int, value:int }, rb:int, rc:int
              } @ { Collection }, rc:true}).fold ((\_accmap -> (\b3 ->
            bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {ra:ip, rb:23, rc:sender_count};_accmap)))) empty {
            ra:address, rb:int, rc:int } @ { Collection }).combine (let
            sender_count =
            (route_to_int_int {ra:4, rb:None immut, rc:None immut}).fold
              ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
            ((shuffle_QUERY18_mLINEITEM5_to_QUERY18_bind_0t0 {ra:None immut,
                rb:empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real
                } @ { Collection }, rc:true}).fold ((\_accmap -> (\b3 ->
              bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:23, rc:sender_count};_accmap))))
              empty { ra:address, rb:int, rc:int } @ { Collection }).combine
              (let sender_count =
              (route_to_int_int {ra:2, rb:None immut,
                 rc:Some LINEITEM_ORDERKEY}).fold ((\count -> (\b3 ->
                bind b3 as {i:ip} in count + 1))) 0 in
              ((shuffle_QUERY18_mLINEITEM2_to_QUERY18_mLINEITEM5_bind_0t0_1t1
                  {ra:None immut, rb:Some LINEITEM_ORDERKEY, rc:empty { ra:{
                  key:int, value:int }, rb:int, rc:int, rd:int
                  } @ { Collection }, rd:true}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:24, rc:sender_count};_accmap))))
                empty { ra:address, rb:int, rc:int } @ { Collection }).combine
                (let sender_count =
                (route_to_int_int {ra:3, rb:None immut,
                   rc:Some LINEITEM_ORDERKEY}).fold ((\count -> (\b3 ->
                  bind b3 as {i:ip} in count + 1))) 0 in
                (shuffle_QUERY18_mLINEITEM2_mCUSTOMER1_to_QUERY18_mCUSTOMER1_bind_0t0_1t1
                   {ra:None immut, rb:Some LINEITEM_ORDERKEY, rc:empty { ra:{
                   key:int, value:int }, rb:int, rc:int, rd:int
                   } @ { Collection }, rd:true}).fold ((\_accmap -> (\b3 ->
                  bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:25, rc:sender_count};_accmap))))
                  empty { ra:address, rb:int, rc:int } @ { Collection }))))))).groupBy
      ((\b1 -> bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip,
      value:stmt_id})) ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id,
      rc:count} in acc + count))) 0).groupBy ((\b1 -> bind b1 as {key:b2,
      value:count} in bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc ->
      (\b3 -> bind b3 as {key:ip_and_stmt_id, value:count} in bind
      ip_and_stmt_id as {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_delete_LINEITEM_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid,
       rd:LINEITEM_ORDERKEY, re:LINEITEM_PARTKEY, rf:LINEITEM_SUPPKEY,
       rg:LINEITEM_LINENUMBER, rh:LINEITEM_QUANTITY, ri:LINEITEM_EXTENDEDPRICE,
       rj:LINEITEM_DISCOUNT, rk:LINEITEM_TAX, rl:LINEITEM_RETURNFLAG,
       rm:LINEITEM_LINESTATUS, rn:LINEITEM_SHIPDATE, ro:LINEITEM_COMMITDATE,
       rp:LINEITEM_RECEIPTDATE, rq:LINEITEM_SHIPINSTRUCT, rr:LINEITEM_SHIPMODE,
       rs:LINEITEM_COMMENT};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_int_int {ra:3, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:25, rb:3, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:2, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:24, rb:2, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:4, rb:None immut, rc:None immut}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:23, rb:4, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:8, value:Some LINEITEM_ORDERKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:23, rb:8, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int {key:7, value:Some LINEITEM_ORDERKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:23, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:2, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:23, rb:2, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine empty { ra:int, rb:int, rc:address
      } @ { Collection })))))).groupBy ((\b1 -> bind b1 as {ra:stmt_id,
      rb:map_id, rc:ip} in ip)) ((\acc -> (\b3 -> bind b3 as {ra:stmt_id,
      rb:map_id, rc:ip} in (acc.insert {key:stmt_id, value:map_id};acc))))
      empty { key:int, value:int } @ { Collection }).iterate ((\b1 ->
      bind b1 as {key:ip, value:stmt_map_ids} in 
      (nd_delete_LINEITEM_rcv_fetch, ip)<- {ra:stmt_map_ids, rb:vid,
      rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
      rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
      ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
      rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
      ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
      rr:LINEITEM_COMMENT}))))}{None ->
                                 error
                                   (print
                                      "unexpected missing arguments in sw_buf_delete_LINEITEM")})


declare nd_delete_LINEITEM_do_complete_s23 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((((((((bind map_QUERY18_mLINEITEM2_s23_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:C_CUSTKEY, rb:LINEITEM_ORDERKEY, rc:__map_ret__43} in 
    (_accmap.insert {key:C_CUSTKEY, value:__map_ret__43};_accmap)))) empty {
    key:int, value:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:C_CUSTKEY, value:__map_ret__43} in 
    (_accmap.insert {key:C_CUSTKEY, value:__map_ret__43 * (({| key:int,
     value:int | let __sum_ret__17 =
     ((({| key:real, value:int | let __map_ret__44 =
       let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
           (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:real } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0} in
       {key:__map_ret__44, value:1}|} @ { Collection }).fold ((\_accmap ->
       (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__17} in 
       (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__17 *
        if 100 < __sql_inline_agg_1 then 1 else 0};
        _accmap)))) empty { key:real, value:int } @ { Collection }).fold
       ((\__accv_17 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
       value:__prod_ret__49} in __accv_17 + __prod_ret__49))) 0 * (((((let
       wrapped_lookup_value =
       bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
         (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
            bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
           ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
           (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
           value:int } @ { Collection } in
       case (wrapped_lookup_value.peek ()) of
         {Some unwrapped_value -> bind unwrapped_value as
           {key:_, value:projected_field} in projected_field}{None -> 0}) + 1)
       * -1) + let wrapped_lookup_value =
       bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
         (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
            bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
           ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
           (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
           value:int } @ { Collection } in
       case (wrapped_lookup_value.peek ()) of
         {Some unwrapped_value -> bind unwrapped_value as
           {key:_, value:projected_field} in projected_field}{None -> 0}) + 1))
       + ((({| key:real, value:int | let __sum_ret__15 =
       (let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
           (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:real } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) -
         LINEITEM_QUANTITY in
       {key:__sum_ret__15, value:1}|} @ { Collection }).fold ((\_accmap ->
       (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__18} in 
       (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__18 *
        if 100 < __sql_inline_agg_1 then 1 else 0};
        _accmap)))) empty { key:real, value:int } @ { Collection }).fold
       ((\__accv_18 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
       value:__prod_ret__53} in __accv_18 + __prod_ret__53))) 0 * ((let
       wrapped_lookup_value =
       bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
         (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
            bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
           ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
           (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
           value:int } @ { Collection } in
       case (wrapped_lookup_value.peek ()) of
         {Some unwrapped_value -> bind unwrapped_value as
           {key:_, value:projected_field} in projected_field}{None -> 0}) - 1))
     in {key:__sum_ret__17, value:1}|} @ { Collection }).fold ((\_accmap ->
     (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__19} in 
     (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__19 *
      if 1 <= __sql_inline_agg_2 then 1 else 0};
      _accmap)))) empty { key:int, value:int } @ { Collection }).fold
     ((\__accv_19 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
     value:__prod_ret__55} in __accv_19 + __prod_ret__55))) 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY, value:__prod_ret__56} in 
    (_accmap.insert {key:C_CUSTKEY, value:__prod_ret__56 * LINEITEM_QUANTITY};
     _accmap)))) empty { key:int, value:real } @ { Collection }).combine
    (((((bind map_QUERY18_mLINEITEM5_s23_buf as ind __x in
    (frontier_int_int_float {key:vid, value:__x}).fold ((\acc -> (\b3 ->
      bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:real } @ { Collection }).fold ((\_accext -> (\b3 ->
    bind b3 as {ra:C_CUSTKEY, rb:O_ORDERKEY, rc:__map_ret__49} in 
    _accext.combine (({| key:int, value:int | let __prod_ret__59 =
    (({| key:real, value:int | let __map_ret__50 =
      let wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
          (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == O_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:real } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__map_ret__50, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__20} in 
      (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__20 *
       if 100 < __sql_inline_agg_1 then 1 else 0};
       _accmap)))) empty { key:real, value:int } @ { Collection }).fold
      ((\__accv_20 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
      value:__prod_ret__58} in __accv_20 + __prod_ret__58))) 0 * let
      wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == O_ORDERKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0} in
    {key:__prod_ret__59, value:1}|} @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__21} in 
    (_accmap.insert {ra:C_CUSTKEY, rb:O_ORDERKEY, rc:__sql_inline_agg_2,
     rd:__map_ret__49 * __lift_ret__21};
     _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection }))))
    empty { ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:C_CUSTKEY, rb:O_ORDERKEY,
    rc:__sql_inline_agg_2, rd:__prod_ret__60} in 
    (_accmap.insert {ra:C_CUSTKEY, rb:O_ORDERKEY, rc:__sql_inline_agg_2,
     rd:__prod_ret__60 * if 1 <= __sql_inline_agg_2 then 1 else 0};
     _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
    } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:C_CUSTKEY,
    rb:O_ORDERKEY, rc:__sql_inline_agg_2, rd:__prod_ret__61} in C_CUSTKEY))
    ((\__accv_21 -> (\b3 -> bind b3 as {ra:C_CUSTKEY, rb:O_ORDERKEY,
    rc:__sql_inline_agg_2, rd:__prod_ret__61} in __accv_21 + __prod_ret__61)))
    0).fold ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY,
    value:__prod_ret__61} in 
    (_accmap.insert {key:C_CUSTKEY, value:__prod_ret__61};_accmap)))) empty {
    key:int, value:real } @ { Collection })).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:C_CUSTKEY, value:__sum_ret__18} in 
    (_accmap.insert {key:C_CUSTKEY, value:__sum_ret__18 * -1};_accmap))))
    empty { key:int, value:real } @ { Collection }).combine (((((bind
    map_QUERY18_mLINEITEM5_s23_buf as ind __x in
    (frontier_int_int_float {key:vid, value:__x}).fold ((\acc -> (\b3 ->
      bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:real } @ { Collection }).fold ((\_accext -> (\b3 ->
    bind b3 as {ra:C_CUSTKEY, rb:O_ORDERKEY, rc:__map_ret__52} in 
    _accext.combine (({| key:int, value:int | let __prod_ret__67 =
    (({| key:real, value:int | let __sum_ret__19 =
      (let wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
          (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == O_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:real } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) +
        ((let __val_ret__36 = LINEITEM_ORDERKEY in
        if __val_ret__36 == O_ORDERKEY then 1 else 0) * -LINEITEM_QUANTITY) in
      {key:__sum_ret__19, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__23} in 
      (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__23 *
       if 100 < __sql_inline_agg_1 then 1 else 0};
       _accmap)))) empty { key:real, value:int } @ { Collection }).fold
      ((\__accv_22 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
      value:__prod_ret__65} in __accv_22 + __prod_ret__65))) 0 * ((let
      wrapped_lookup_value =
      bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == O_ORDERKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) +
      ((let __val_ret__39 = LINEITEM_ORDERKEY in
      if __val_ret__39 == O_ORDERKEY then 1 else 0) * -1)) in
    {key:__prod_ret__67, value:1}|} @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__25} in 
    (_accmap.insert {ra:C_CUSTKEY, rb:O_ORDERKEY, rc:__sql_inline_agg_2,
     rd:__map_ret__52 * __lift_ret__25};
     _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection }))))
    empty { ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:C_CUSTKEY, rb:O_ORDERKEY,
    rc:__sql_inline_agg_2, rd:__prod_ret__68} in 
    (_accmap.insert {ra:C_CUSTKEY, rb:O_ORDERKEY, rc:__sql_inline_agg_2,
     rd:__prod_ret__68 * if 1 <= __sql_inline_agg_2 then 1 else 0};
     _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
    } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:C_CUSTKEY,
    rb:O_ORDERKEY, rc:__sql_inline_agg_2, rd:__prod_ret__69} in C_CUSTKEY))
    ((\__accv_23 -> (\b3 -> bind b3 as {ra:C_CUSTKEY, rb:O_ORDERKEY,
    rc:__sql_inline_agg_2, rd:__prod_ret__69} in __accv_23 + __prod_ret__69)))
    0).fold ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY,
    value:__prod_ret__69} in 
    (_accmap.insert {key:C_CUSTKEY, value:__prod_ret__69};_accmap)))) empty {
    key:int, value:real } @ { Collection })).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:C_CUSTKEY, value:__sum_ret__21} in 
    (_accmap.insert {key:C_CUSTKEY, value:__sum_ret__21};_accmap)))) empty {
    key:int, value:real } @ { Collection }).groupBy ((\b1 ->
    bind b1 as {key:map_0, value:map_val} in map_0)) ((\acc -> (\b3 ->
    bind b3 as {key:map_0, value:map_val} in acc + map_val))) 0).fold ((\acc ->
    (\b3 -> bind b3 as {key:g, value:val} in 
    (acc.insert {key:g, value:val};acc)))) empty { key:int, value:real
    } @ { Collection } in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:false, rc:vid, rd:delta_values});
   (nd_complete_stmt_cntr_check {key:vid, value:23})))


declare nd_delete_LINEITEM_do_complete_s24 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((bind map_QUERY18_mLINEITEM2_s24_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:C_CUSTKEY, rb:LINEITEM_ORDERKEY, rc:__map_ret__55} in 
    (_accmap.insert {key:C_CUSTKEY, value:__map_ret__55};_accmap)))) empty {
    key:int, value:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:C_CUSTKEY, value:__map_ret__55} in 
    (_accmap.insert {key:C_CUSTKEY, value:__map_ret__55 * -LINEITEM_QUANTITY};
     _accmap)))) empty { key:int, value:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY, value:__prod_ret__71} in 
    (_accmap.insert {ra:C_CUSTKEY, rb:LINEITEM_ORDERKEY, rc:__prod_ret__71};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection } in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mLINEITEM5, rb:false, rc:vid,
      rd:delta_values});
   let sent_msgs =
   nd_QUERY18_mLINEITEM5_send_correctives {ra:me, rb:24, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:24}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:24, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_LINEITEM_do_complete_s25 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((bind map_QUERY18_mLINEITEM2_mCUSTOMER1_s25_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:QUERY18_mCUSTOMERCUSTOMER_CUSTKEY, rb:LINEITEM_ORDERKEY,
    rc:__map_ret__56} in 
    (_accmap.insert {key:QUERY18_mCUSTOMERCUSTOMER_CUSTKEY,
     value:__map_ret__56};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:QUERY18_mCUSTOMERCUSTOMER_CUSTKEY,
    value:__map_ret__56} in 
    (_accmap.insert {key:QUERY18_mCUSTOMERCUSTOMER_CUSTKEY, value:__map_ret__56
     * -LINEITEM_QUANTITY};
     _accmap)))) empty { key:int, value:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:QUERY18_mCUSTOMERCUSTOMER_CUSTKEY,
    value:__prod_ret__73} in 
    (_accmap.insert {ra:QUERY18_mCUSTOMERCUSTOMER_CUSTKEY,
     rb:LINEITEM_ORDERKEY, rc:__prod_ret__73};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection } in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mCUSTOMER1, rb:false, rc:vid,
      rd:delta_values});
   let sent_msgs =
   nd_QUERY18_mCUSTOMER1_send_correctives {ra:me, rb:25, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:25}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:25, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_LINEITEM_do_complete_s26 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  __prod_ret__74 = -LINEITEM_QUANTITY in
  ((nd_add_delta_to_int_float {ra:QUERY18_mCUSTOMER1_L1_1_L1_1, rb:false,
      rc:vid, rd:{| key:int, value:real | {key:LINEITEM_ORDERKEY,
      value:__prod_ret__74}|} @ { Collection }});
   let sent_msgs =
   nd_QUERY18_mCUSTOMER1_L1_1_L1_1_send_correctives {ra:me, rb:26, rc:vid,
     rd:1, re:vid, rf:{| key:int, value:real | {key:LINEITEM_ORDERKEY,
     value:__prod_ret__74}|} @ { Collection }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:26, rc:1, rd:sent_msgs,
         re:true, rf:true}))


declare nd_delete_LINEITEM_do_complete_s27 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  __val_ret__47 = -1 in
  ((nd_add_delta_to_int_int {ra:QUERY18_mCUSTOMER1_L1_2, rb:false, rc:vid,
      rd:{| key:int, value:int | {key:LINEITEM_ORDERKEY,
      value:__val_ret__47}|} @ { Collection }});
   let sent_msgs =
   nd_QUERY18_mCUSTOMER1_L1_2_send_correctives {ra:me, rb:27, rc:vid, rd:1,
     re:vid, rf:{| key:int, value:int | {key:LINEITEM_ORDERKEY,
     value:__val_ret__47}|} @ { Collection }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:27, rc:1, rd:sent_msgs,
         re:true, rf:true}))


declare delete_LINEITEM_do_corrective_s23_m_QUERY18_mLINEITEM2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:int, rh:int, ri:int, rj:real, rk:real, rl:real, rm:real, rn:string,
  ro:string, rp:int, rq:int, rr:int, rs:string, rt:string, ru:string,
  rv:collection { ra:int, rb:int, rc:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY,
  ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE,
  rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG,
  ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
  rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE,
  ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {ra:delta_C_CUSTKEY,
    rb:delta_QUERY18_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_QUERY18_mLINEITEM2} in _accext.combine (let __prod_ret__223 =
    ((if LINEITEM_ORDERKEY == delta_QUERY18_mLINEITEMLINEITEM_ORDERKEY 
      then 1 else 0) * (({| key:int, value:int | let __sum_ret__125 =
      ((({| key:real, value:int | let __map_ret__152 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__152, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__90} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__90 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_76 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__213} in __accv_76 + __prod_ret__213))) 0 * (((((let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) + 1)
        * -1) + let wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) +
        1)) + ((({| key:real, value:int | let __sum_ret__123 =
        (let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0}) -
          LINEITEM_QUANTITY in
        {key:__sum_ret__123, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__91} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__91 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_77 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__217} in __accv_77 + __prod_ret__217))) 0 * ((let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) -
        1)) in {key:__sum_ret__125, value:1}|} @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__lift_ret__92} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__92 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_78 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__219} in __accv_78 + __prod_ret__219))) 0) *
      (-delta_QUERY18_mLINEITEM2 * LINEITEM_QUANTITY) in
    {| key:int, value:real | {key:delta_C_CUSTKEY,
      value:__prod_ret__223}|} @ { Collection })))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare delete_LINEITEM_do_corrective_s23_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { key:int, value:real } @ { Collection } } -> int =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY,
  ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE,
  rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG,
  ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
  rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE,
  ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_O_ORDERKEY,
    value:delta_QUERY18_mCUSTOMER1_L1_1_L1_1} in _accext.combine (let
    delta_values =
    ((((((((((bind map_QUERY18_mLINEITEM2_s23_buf as ind __x in
      (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
        rd:map_val} in (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc))))
        empty { ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:C_CUSTKEY, rb:LINEITEM_ORDERKEY,
      rc:__map_ret__162} in 
      (_accmap.insert {key:C_CUSTKEY, value:__map_ret__162};_accmap)))) empty {
      key:int, value:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {key:C_CUSTKEY, value:__map_ret__162} in 
      (_accmap.insert {key:C_CUSTKEY, value:__map_ret__162 * let __val_ret__178
       = delta_O_ORDERKEY in
       if __val_ret__178 == LINEITEM_ORDERKEY then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY,
      value:__prod_ret__261} in 
      (_accmap.insert {key:C_CUSTKEY, value:__prod_ret__261 * ((({| key:int,
       value:int | let __sum_ret__142 =
       (((let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) -
         1) * ((({| key:real, value:int | let __sum_ret__132 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) -
           LINEITEM_QUANTITY in
         {key:__sum_ret__132, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__97} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__97 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_82 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__242} in __accv_82 + __prod_ret__242))) 0 + ((({|
         key:real, value:int | let __sum_ret__133 =
         ((let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) -
           LINEITEM_QUANTITY) + delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
         {key:__sum_ret__133, value:1}|} @ { Collection }).combine (({|
         key:real, value:int | let __sum_ret__134 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) -
           LINEITEM_QUANTITY in
         {key:__sum_ret__134, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__99} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__99 * -1};
          _accmap)))) empty { key:real, value:int } @ { Collection })).fold
         ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__sum_ret__135} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__sum_ret__135 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_83 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__246} in __accv_83 + __prod_ret__246))) 0)) +
         ((((((let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * -1) + let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * ((({| key:real, value:int | let __map_ret__169 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__169, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__100} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__100 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_84 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__249} in __accv_84 + __prod_ret__249))) 0 + ((({|
         key:real, value:int | let __sum_ret__139 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
         {key:__sum_ret__139, value:1}|} @ { Collection }).combine (({|
         key:real, value:int | let __map_ret__171 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__171, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__102} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__102 * -1};
          _accmap)))) empty { key:real, value:int } @ { Collection })).fold
         ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__sum_ret__140} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__sum_ret__140 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_85 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__251} in __accv_85 + __prod_ret__251))) 0)) in
       {key:__sum_ret__142, value:1}|} @ { Collection }).combine (({| key:int,
       value:int | let __sum_ret__147 =
       ((({| key:real, value:int | let __map_ret__172 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__172, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__104} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__104 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_86 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__253} in __accv_86 + __prod_ret__253))) 0 * (((((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * -1) + let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1)) + ((({| key:real, value:int | let __sum_ret__145 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) -
           LINEITEM_QUANTITY in
         {key:__sum_ret__145, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__105} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__105 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_87 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__257} in __accv_87 + __prod_ret__257))) 0 * ((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) -
         1)) in {key:__sum_ret__147, value:1}|} @ { Collection }).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__lift_ret__106} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__106 * -1};
        _accmap)))) empty { key:int, value:int } @ { Collection })).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__sum_ret__148} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__148 *
        if 1 <= __sql_inline_agg_2 then 1 else 0};
        _accmap)))) empty { key:int, value:int } @ { Collection }).fold
       ((\__accv_88 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__prod_ret__260} in __accv_88 + __prod_ret__260))) 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY,
      value:__prod_ret__262} in 
      (_accmap.insert {key:C_CUSTKEY, value:__prod_ret__262 *
       LINEITEM_QUANTITY};
       _accmap)))) empty { key:int, value:real } @ { Collection }).combine
      (((bind map_QUERY18_mLINEITEM5_s23_buf as ind __x in
      (frontier_int_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == delta_O_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
        rd:map_val} in (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc))))
        empty { ra:int, rb:int, rc:real } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:C_CUSTKEY, rb:delta_O_ORDERKEY,
      rc:__map_ret__177} in 
      (_accmap.insert {key:C_CUSTKEY, value:__map_ret__177};_accmap)))) empty {
      key:int, value:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {key:C_CUSTKEY, value:__map_ret__177} in 
      (_accmap.insert {key:C_CUSTKEY, value:__map_ret__177 * ((({| key:int,
       value:int | let __prod_ret__267 =
       (let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) *
         ((({| key:real, value:int | let __map_ret__179 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__179, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__107} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__107 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_89 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__264} in __accv_89 + __prod_ret__264))) 0 + ((({|
         key:real, value:int | let __sum_ret__149 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
         {key:__sum_ret__149, value:1}|} @ { Collection }).combine (({|
         key:real, value:int | let __map_ret__181 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__181, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__109} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__109 * -1};
          _accmap)))) empty { key:real, value:int } @ { Collection })).fold
         ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__sum_ret__150} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__sum_ret__150 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_90 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__266} in __accv_90 + __prod_ret__266))) 0) in
       {key:__prod_ret__267, value:1}|} @ { Collection }).combine (({| key:int,
       value:int | let __prod_ret__269 =
       (({| key:real, value:int | let __map_ret__182 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__182, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__111} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__111 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_91 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__268} in __accv_91 + __prod_ret__268))) 0 * let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0} in
       {key:__prod_ret__269, value:1}|} @ { Collection }).fold ((\_accmap ->
       (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__112} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__112 * -1};
        _accmap)))) empty { key:int, value:int } @ { Collection })).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__sum_ret__152} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__152 *
        if 1 <= __sql_inline_agg_2 then 1 else 0};
        _accmap)))) empty { key:int, value:int } @ { Collection }).fold
       ((\__accv_92 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__prod_ret__271} in __accv_92 + __prod_ret__271))) 0};
       _accmap)))) empty { key:int, value:real } @ { Collection })).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY,
      value:__sum_ret__153} in 
      (_accmap.insert {key:C_CUSTKEY, value:__sum_ret__153 * -1};_accmap))))
      empty { key:int, value:real } @ { Collection }).combine (((bind
      map_QUERY18_mLINEITEM5_s23_buf as ind __x in
      (frontier_int_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == delta_O_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
        rd:map_val} in (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc))))
        empty { ra:int, rb:int, rc:real } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:C_CUSTKEY, rb:delta_O_ORDERKEY,
      rc:__map_ret__184} in 
      (_accmap.insert {key:C_CUSTKEY, value:__map_ret__184};_accmap)))) empty {
      key:int, value:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {key:C_CUSTKEY, value:__map_ret__184} in 
      (_accmap.insert {key:C_CUSTKEY, value:__map_ret__184 * ((({| key:int,
       value:int | let __prod_ret__284 =
       ((let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         ((if LINEITEM_ORDERKEY == delta_O_ORDERKEY then 1 else 0) * -1)) *
         ((({| key:real, value:int | let __sum_ret__155 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           ((if LINEITEM_ORDERKEY == delta_O_ORDERKEY then 1 else 0) *
           -LINEITEM_QUANTITY) in
         {key:__sum_ret__155, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__113} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__113 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_93 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__277} in __accv_93 + __prod_ret__277))) 0 + ((({|
         key:real, value:int | let __sum_ret__156 =
         ((let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           ((if LINEITEM_ORDERKEY == delta_O_ORDERKEY then 1 else 0) *
           -LINEITEM_QUANTITY)) + delta_QUERY18_mCUSTOMER1_L1_1_L1_1 in
         {key:__sum_ret__156, value:1}|} @ { Collection }).combine (({|
         key:real, value:int | let __sum_ret__157 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           ((if LINEITEM_ORDERKEY == delta_O_ORDERKEY then 1 else 0) *
           -LINEITEM_QUANTITY) in
         {key:__sum_ret__157, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__115} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__115 * -1};
          _accmap)))) empty { key:real, value:int } @ { Collection })).fold
         ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__sum_ret__158} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__sum_ret__158 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_94 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__283} in __accv_94 + __prod_ret__283))) 0) in
       {key:__prod_ret__284, value:1}|} @ { Collection }).combine (({| key:int,
       value:int | let __prod_ret__289 =
       (({| key:real, value:int | let __sum_ret__160 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           ((if LINEITEM_ORDERKEY == delta_O_ORDERKEY then 1 else 0) *
           -LINEITEM_QUANTITY) in
         {key:__sum_ret__160, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__117} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__117 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_95 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__287} in __accv_95 + __prod_ret__287))) 0 * ((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         ((if LINEITEM_ORDERKEY == delta_O_ORDERKEY then 1 else 0) * -1)) in
       {key:__prod_ret__289, value:1}|} @ { Collection }).fold ((\_accmap ->
       (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__118} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__118 * -1};
        _accmap)))) empty { key:int, value:int } @ { Collection })).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__sum_ret__162} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__162 *
        if 1 <= __sql_inline_agg_2 then 1 else 0};
        _accmap)))) empty { key:int, value:int } @ { Collection }).fold
       ((\__accv_96 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__prod_ret__291} in __accv_96 + __prod_ret__291))) 0};
       _accmap)))) empty { key:int, value:real } @ { Collection })).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY,
      value:__sum_ret__163} in 
      (_accmap.insert {key:C_CUSTKEY, value:__sum_ret__163};_accmap)))) empty {
      key:int, value:real } @ { Collection }).groupBy ((\b1 ->
      bind b1 as {key:map_0, value:map_val} in map_0)) ((\acc -> (\b3 ->
      bind b3 as {key:map_0, value:map_val} in acc + map_val))) 0).fold
      ((\acc -> (\b3 -> bind b3 as {key:g, value:val} in 
      (acc.insert {key:g, value:val};acc)))) empty { key:int, value:real
      } @ { Collection } in delta_values)))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare delete_LINEITEM_do_corrective_s23_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { key:int, value:int } @ { Collection } } -> int =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY,
  ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE,
  rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG,
  ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
  rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE,
  ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {key:delta_O_ORDERKEY,
    value:delta_QUERY18_mCUSTOMER1_L1_2} in _accext.combine (let delta_values =
    ((((((((((bind map_QUERY18_mLINEITEM2_s23_buf as ind __x in
      (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
        rd:map_val} in (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc))))
        empty { ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:C_CUSTKEY, rb:LINEITEM_ORDERKEY,
      rc:__map_ret__191} in 
      (_accmap.insert {key:C_CUSTKEY, value:__map_ret__191};_accmap)))) empty {
      key:int, value:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {key:C_CUSTKEY, value:__map_ret__191} in 
      (_accmap.insert {key:C_CUSTKEY, value:__map_ret__191 * let __val_ret__218
       = delta_O_ORDERKEY in
       if __val_ret__218 == LINEITEM_ORDERKEY then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY,
      value:__prod_ret__307} in 
      (_accmap.insert {key:C_CUSTKEY, value:__prod_ret__307 * ((({| key:int,
       value:int | let __sum_ret__168 =
       ((({| key:real, value:int | let __sum_ret__164 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) -
           LINEITEM_QUANTITY in
         {key:__sum_ret__164, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__120} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__120 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_97 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__294} in __accv_97 + __prod_ret__294))) 0 * ((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         (-1 + delta_QUERY18_mCUSTOMER1_L1_2))) + ((({| key:real, value:int |
         let __map_ret__194 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__194, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__121} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__121 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_98 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__296} in __accv_98 + __prod_ret__296))) 0 * (((((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * -1) + let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1)) in {key:__sum_ret__168, value:1}|} @ { Collection }).combine (({|
       key:int, value:int | let __sum_ret__173 =
       ((({| key:real, value:int | let __map_ret__197 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__197, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__123} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__123 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_99 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__299} in __accv_99 + __prod_ret__299))) 0 * (((((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1) * -1) + let wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         1)) + ((({| key:real, value:int | let __sum_ret__171 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) -
           LINEITEM_QUANTITY in
         {key:__sum_ret__171, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__124} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__124 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_100 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__303} in __accv_100 + __prod_ret__303))) 0 * ((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) -
         1)) in {key:__sum_ret__173, value:1}|} @ { Collection }).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__lift_ret__125} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__125 * -1};
        _accmap)))) empty { key:int, value:int } @ { Collection })).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__sum_ret__174} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__174 *
        if 1 <= __sql_inline_agg_2 then 1 else 0};
        _accmap)))) empty { key:int, value:int } @ { Collection }).fold
       ((\__accv_101 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__prod_ret__306} in __accv_101 + __prod_ret__306))) 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY,
      value:__prod_ret__308} in 
      (_accmap.insert {key:C_CUSTKEY, value:__prod_ret__308 *
       LINEITEM_QUANTITY};
       _accmap)))) empty { key:int, value:real } @ { Collection }).combine
      (((bind map_QUERY18_mLINEITEM5_s23_buf as ind __x in
      (frontier_int_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == delta_O_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
        rd:map_val} in (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc))))
        empty { ra:int, rb:int, rc:real } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:C_CUSTKEY, rb:delta_O_ORDERKEY,
      rc:__map_ret__202} in 
      (_accmap.insert {key:C_CUSTKEY, value:__map_ret__202};_accmap)))) empty {
      key:int, value:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {key:C_CUSTKEY, value:__map_ret__202} in 
      (_accmap.insert {key:C_CUSTKEY, value:__map_ret__202 * ((({| key:int,
       value:int | let __prod_ret__311 =
       (({| key:real, value:int | let __map_ret__203 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__203, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__126} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__126 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_102 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__310} in __accv_102 + __prod_ret__310))) 0 * ((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         delta_QUERY18_mCUSTOMER1_L1_2) in
       {key:__prod_ret__311, value:1}|} @ { Collection }).combine (({| key:int,
       value:int | let __prod_ret__313 =
       (({| key:real, value:int | let __map_ret__205 =
         let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0} in
         {key:__map_ret__205, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__128} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__128 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_103 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__312} in __accv_103 + __prod_ret__312))) 0 * let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0} in
       {key:__prod_ret__313, value:1}|} @ { Collection }).fold ((\_accmap ->
       (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__129} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__129 * -1};
        _accmap)))) empty { key:int, value:int } @ { Collection })).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__sum_ret__176} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__176 *
        if 1 <= __sql_inline_agg_2 then 1 else 0};
        _accmap)))) empty { key:int, value:int } @ { Collection }).fold
       ((\__accv_104 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__prod_ret__315} in __accv_104 + __prod_ret__315))) 0};
       _accmap)))) empty { key:int, value:real } @ { Collection })).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY,
      value:__sum_ret__177} in 
      (_accmap.insert {key:C_CUSTKEY, value:__sum_ret__177 * -1};_accmap))))
      empty { key:int, value:real } @ { Collection }).combine (((bind
      map_QUERY18_mLINEITEM5_s23_buf as ind __x in
      (frontier_int_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == delta_O_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
        rd:map_val} in (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc))))
        empty { ra:int, rb:int, rc:real } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:C_CUSTKEY, rb:delta_O_ORDERKEY,
      rc:__map_ret__207} in 
      (_accmap.insert {key:C_CUSTKEY, value:__map_ret__207};_accmap)))) empty {
      key:int, value:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {key:C_CUSTKEY, value:__map_ret__207} in 
      (_accmap.insert {key:C_CUSTKEY, value:__map_ret__207 * ((({| key:int,
       value:int | let __prod_ret__322 =
       (({| key:real, value:int | let __sum_ret__178 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           ((if LINEITEM_ORDERKEY == delta_O_ORDERKEY then 1 else 0) *
           -LINEITEM_QUANTITY) in
         {key:__sum_ret__178, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__130} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__130 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_105 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__320} in __accv_105 + __prod_ret__320))) 0 * (((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         ((if LINEITEM_ORDERKEY == delta_O_ORDERKEY then 1 else 0) * -1)) +
         delta_QUERY18_mCUSTOMER1_L1_2) in
       {key:__prod_ret__322, value:1}|} @ { Collection }).combine (({| key:int,
       value:int | let __prod_ret__327 =
       (({| key:real, value:int | let __sum_ret__180 =
         (let wrapped_lookup_value =
           bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
             (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
                bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
               ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
               (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
               value:real } @ { Collection } in
           case (wrapped_lookup_value.peek ()) of
             {Some unwrapped_value -> bind unwrapped_value as
               {key:_, value:projected_field} in projected_field}{None -> 0}) +
           ((if LINEITEM_ORDERKEY == delta_O_ORDERKEY then 1 else 0) *
           -LINEITEM_QUANTITY) in
         {key:__sum_ret__180, value:1}|} @ { Collection }).fold ((\_accmap ->
         (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__132} in 
         (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__132 *
          if 100 < __sql_inline_agg_1 then 1 else 0};
          _accmap)))) empty { key:real, value:int } @ { Collection }).fold
         ((\__accv_106 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
         value:__prod_ret__325} in __accv_106 + __prod_ret__325))) 0 * ((let
         wrapped_lookup_value =
         bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
           (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
              bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
             ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
             (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
             value:int } @ { Collection } in
         case (wrapped_lookup_value.peek ()) of
           {Some unwrapped_value -> bind unwrapped_value as
             {key:_, value:projected_field} in projected_field}{None -> 0}) +
         ((if LINEITEM_ORDERKEY == delta_O_ORDERKEY then 1 else 0) * -1)) in
       {key:__prod_ret__327, value:1}|} @ { Collection }).fold ((\_accmap ->
       (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__133} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__133 * -1};
        _accmap)))) empty { key:int, value:int } @ { Collection })).fold
       ((\_accmap -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__sum_ret__182} in 
       (_accmap.insert {key:__sql_inline_agg_2, value:__sum_ret__182 *
        if 1 <= __sql_inline_agg_2 then 1 else 0};
        _accmap)))) empty { key:int, value:int } @ { Collection }).fold
       ((\__accv_107 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
       value:__prod_ret__329} in __accv_107 + __prod_ret__329))) 0};
       _accmap)))) empty { key:int, value:real } @ { Collection })).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:C_CUSTKEY,
      value:__sum_ret__183} in 
      (_accmap.insert {key:C_CUSTKEY, value:__sum_ret__183};_accmap)))) empty {
      key:int, value:real } @ { Collection }).groupBy ((\b1 ->
      bind b1 as {key:map_0, value:map_val} in map_0)) ((\acc -> (\b3 ->
      bind b3 as {key:map_0, value:map_val} in acc + map_val))) 0).fold
      ((\acc -> (\b3 -> bind b3 as {key:g, value:val} in 
      (acc.insert {key:g, value:val};acc)))) empty { key:int, value:real
      } @ { Collection } in delta_values)))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare delete_LINEITEM_do_corrective_s23_m_QUERY18_mLINEITEM5 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:int, rh:int, ri:int, rj:real, rk:real, rl:real, rm:real, rn:string,
  ro:string, rp:int, rq:int, rr:int, rs:string, rt:string, ru:string,
  rv:collection { ra:int, rb:int, rc:real } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY,
  ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE,
  rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG,
  ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
  rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE,
  ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {ra:delta_C_CUSTKEY,
    rb:delta_O_ORDERKEY, rc:delta_QUERY18_mLINEITEM5} in _accext.combine (let
    __prod_ret__341 =
    (((({| key:int, value:int | let __prod_ret__332 =
      (({| key:real, value:int | let __map_ret__212 =
        let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0} in
        {key:__map_ret__212, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__134} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__134 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_108 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__331} in __accv_108 + __prod_ret__331))) 0 * let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0} in
      {key:__prod_ret__332, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__135} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__135 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_109 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__333} in __accv_109 + __prod_ret__333))) 0 * -1) + (({|
      key:int, value:int | let __prod_ret__339 =
      (({| key:real, value:int | let __sum_ret__184 =
        (let wrapped_lookup_value =
          bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind __x in
            (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
               bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
              ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
              (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
              value:real } @ { Collection } in
          case (wrapped_lookup_value.peek ()) of
            {Some unwrapped_value -> bind unwrapped_value as
              {key:_, value:projected_field} in projected_field}{None -> 0}) +
          ((if LINEITEM_ORDERKEY == delta_O_ORDERKEY then 1 else 0) *
          -LINEITEM_QUANTITY) in
        {key:__sum_ret__184, value:1}|} @ { Collection }).fold ((\_accmap ->
        (\b3 -> bind b3 as {key:__sql_inline_agg_1, value:__lift_ret__136} in 
        (_accmap.insert {key:__sql_inline_agg_1, value:__lift_ret__136 *
         if 100 < __sql_inline_agg_1 then 1 else 0};
         _accmap)))) empty { key:real, value:int } @ { Collection }).fold
        ((\__accv_110 -> (\b3 -> bind b3 as {key:__sql_inline_agg_1,
        value:__prod_ret__337} in __accv_110 + __prod_ret__337))) 0 * ((let
        wrapped_lookup_value =
        bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind __x in
          (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
             bind b1 as {ra:ra, rb:rb, rc:rc} in rb == delta_O_ORDERKEY))}).fold
            ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_val} in 
            (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
            value:int } @ { Collection } in
        case (wrapped_lookup_value.peek ()) of
          {Some unwrapped_value -> bind unwrapped_value as
            {key:_, value:projected_field} in projected_field}{None -> 0}) +
        ((if LINEITEM_ORDERKEY == delta_O_ORDERKEY then 1 else 0) * -1)) in
      {key:__prod_ret__339, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:__sql_inline_agg_2, value:__lift_ret__137} in 
      (_accmap.insert {key:__sql_inline_agg_2, value:__lift_ret__137 *
       if 1 <= __sql_inline_agg_2 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\__accv_111 -> (\b3 -> bind b3 as {key:__sql_inline_agg_2,
      value:__prod_ret__340} in __accv_111 + __prod_ret__340))) 0) *
      delta_QUERY18_mLINEITEM5 in
    {| key:int, value:real | {key:delta_C_CUSTKEY,
      value:__prod_ret__341}|} @ { Collection })))) empty { key:int, value:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {key:map_0,
    value:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_float {ra:QUERY18, rb:true, rc:vid, rd:new_tuples});0))


declare delete_LINEITEM_do_corrective_s24_m_QUERY18_mLINEITEM2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:int, rh:int, ri:int, rj:real, rk:real, rl:real, rm:real, rn:string,
  ro:string, rp:int, rq:int, rr:int, rs:string, rt:string, ru:string,
  rv:collection { ra:int, rb:int, rc:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY,
  ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE,
  rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG,
  ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
  rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE,
  ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 -> bind b3 as {ra:delta_C_CUSTKEY,
    rb:delta_QUERY18_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_QUERY18_mLINEITEM2} in _accext.combine (let __prod_ret__226 =
    (if LINEITEM_ORDERKEY == delta_QUERY18_mLINEITEMLINEITEM_ORDERKEY 
      then 1 else 0) * (-delta_QUERY18_mLINEITEM2 * LINEITEM_QUANTITY) in
    {| ra:int, rb:int, rc:real | {ra:delta_C_CUSTKEY, rb:LINEITEM_ORDERKEY,
      rc:__prod_ret__226}|} @ { Collection })))) empty { ra:int, rb:int,
    rc:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mLINEITEM5, rb:true, rc:vid,
      rd:new_tuples});
   (nd_QUERY18_mLINEITEM5_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_LINEITEM_do_corrective_s25_m_QUERY18_mLINEITEM2_mCUSTOMER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:int, rb:int, rc:int } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
  rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
  rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
  rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE,
  rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
  rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_QUERY18_mLINEITEM2_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_QUERY18_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_QUERY18_mLINEITEM2_mCUSTOMER1} in _accext.combine (let
    __prod_ret__344 =
    (if LINEITEM_ORDERKEY == delta_QUERY18_mLINEITEMLINEITEM_ORDERKEY 
      then 1 else 0) * (-delta_QUERY18_mLINEITEM2_mCUSTOMER1 *
      LINEITEM_QUANTITY) in
    {| ra:int, rb:int, rc:real |
      {ra:delta_QUERY18_mLINEITEM2_mCUSTOMERCUSTOMER_CUSTKEY,
      rb:LINEITEM_ORDERKEY, rc:__prod_ret__344}|} @ { Collection })))) empty {
    ra:int, rb:int, rc:real } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_float {ra:QUERY18_mCUSTOMER1, rb:true, rc:vid,
      rd:new_tuples});
   (nd_QUERY18_mCUSTOMER1_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


trigger ms_rcv_sw_init_ack : () = (\_u ->
  (ms_rcv_sw_init_ack_cnt = ms_rcv_sw_init_ack_cnt + 1;
   (if ms_rcv_sw_init_ack_cnt == num_switches
   then
     (ms_start_time = now_int ();
      (sw_rcv_token, sw_next_switch_addr)<- g_start_vid;
      (tm_insert_timer, timer_addr)<- {ra:ms_gc_interval, rb:0, rc:me})
   else ())))
trigger sw_rcv_init : () = (\_u ->
  (sw_init = true;
   (sw_driver_trig, me)<- ();
   (ms_rcv_sw_init_ack, master_addr)<- ()))
trigger ms_rcv_jobs_ack : () = (\_u ->
  (ms_rcv_jobs_ack_cnt = ms_rcv_jobs_ack_cnt + 1;
   (if ms_rcv_jobs_ack_cnt == num_peers
   then
     (switches.iterate ((\b1 -> bind b1 as {i:addr} in 
      (sw_rcv_init, addr)<- ()))) else ())))
trigger rcv_jobs : collection { key:address, value:int } @ { Map } =
  (\jobs_in ->
  (jobs = jobs_in;
   timer_addr = case ((jobs.filter ((\b1 -> bind b1 as {key:addr,
   value:job} in job == job_timer))).peek ()) of
   {Some timer -> timer.key}{None -> error (print "no timer peer found")};
   nodes = (jobs.filter ((\b1 -> bind b1 as {key:addr, value:job} in job ==
   job_node))).fold ((\_accmap -> (\x ->
   (_accmap.insert ({i:x.key});_accmap)))) empty {i:address} @ { Collection };
   num_nodes = nodes.size ();
   switches = (jobs.filter ((\b1 -> bind b1 as {key:addr, value:job} in job ==
   job_switch))).fold ((\_accmap -> (\x ->
   (_accmap.insert ({i:x.key});_accmap)))) empty {i:address} @ { Collection };
   num_switches = switches.size ();
   (if job <= job_switch
   then sw_next_switch_addr = let addr_list =
     (switches.fold ((\acc_conv -> (\b3 -> bind b3 as {i:x} in 
       (acc_conv.insert {i:x};acc_conv)))) empty {i:address} @ { Seq }).sort
       ((\b2 -> (\b3 -> bind b2 as {i:addr1} in bind b3 as {i:addr2} in 
       if addr1 < addr2 then -1 else 1))) in
     case (addr_list.peek ()) of
       {Some first_addr -> (addr_list.fold ((\b2 -> (\b5 ->
         bind b2 as {key:take, value:result} in bind b5 as {i:x} in if take
         then {key:false, value:x}
         else if x == me then {key:true, value:result}
           else {key:take, value:result}))) {key:false,
         value:first_addr.i}).value}{None ->
                                      error (print "no addresses in addr_list")}
   else ());
   nodes.iterate ((\b1 -> bind b1 as {i:addr} in add_node addr));
   (ms_rcv_jobs_ack, master_addr)<- ()))
trigger ms_rcv_job : { key:address, value:int } = (\b1 -> bind b1 as {key:addr,
  value:job} in 
  (jobs.insert {key:addr, value:job};
   ms_rcv_job_cnt = ms_rcv_job_cnt + 1;
   (if ms_rcv_job_cnt == num_peers
   then my_peers.iterate ((\b1 -> bind b1 as {i:addr} in 
     (rcv_jobs, addr)<- jobs)) else ())))
trigger rcv_master_addr : address = (\addr ->
  (master_addr = addr;(ms_rcv_job, addr)<- {key:me, value:job}))
trigger ms_send_addr_self : () = (\_u -> my_peers.iterate ((\b1 ->
  bind b1 as {i:addr} in (rcv_master_addr, addr)<- me)))
trigger shutdown_trig : () = (\_u -> haltEngine ())
trigger ms_shutdown : () = (\_u -> if ms_rcv_node_done_cnt == num_nodes
  then my_peers.iterate ((\b1 -> bind b1 as {i:addr} in 
    (shutdown_trig, addr)<- ())) else ())
trigger ms_rcv_node_done : bool = (\done -> if done
  then
    (ms_rcv_node_done_cnt = ms_rcv_node_done_cnt + 1;
     (if ms_rcv_node_done_cnt == num_nodes
     then (ms_end_time = now_int ();(ms_shutdown, me)<- ()) else ()))
  else ms_rcv_node_done_cnt = ms_rcv_node_done_cnt - 1)
trigger nd_rcv_done : () = (\_u ->
  (nd_rcvd_sys_done = true;
   (if not nd_sent_done and nd_stmt_cntrs.size () == 0
   then ((ms_rcv_node_done, master_addr)<- true;nd_sent_done = true) 
   else ())))
trigger ms_rcv_switch_done : () = (\_u ->
  (ms_rcv_switch_done_cnt = ms_rcv_switch_done_cnt + 1;
   (if ms_rcv_switch_done_cnt == num_switches
   then nodes.iterate ((\b1 -> bind b1 as {i:addr} in 
     (nd_rcv_done, addr)<- ())) else ())))
trigger sw_ack_rcv : { key:address, value:{ key:int, value:int } } = (\b1 ->
  bind b1 as {key:addr, value:vid} in 
  (sw_num_ack = sw_num_ack + 1;
   (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key, value:value} in key
   == vid))).peek ()) of
   {Some x -> if x.value == 0 then sw_ack_log.erase x
     else sw_ack_log.update x {key:vid, value:x.value - 1}}{None -> ()});
   (if not sw_sent_done and (sw_trig_buf_idx.size () == 0 and (sw_num_ack ==
      sw_num_sent and sw_seen_sentry == true))
   then ((ms_rcv_switch_done, master_addr)<- ();sw_sent_done = true) 
   else ())))
trigger ms_rcv_gc_vid : { key:address, value:{ key:int, value:int } } =
  (\data ->
  (ms_gc_vid_map.insert data;
   ms_gc_vid_ctr = ms_gc_vid_ctr + 1;
   (if ms_gc_vid_ctr >= ms_num_gc_expected
   then let min_vid =
     ms_gc_vid_map.fold ((\min_vid -> (\b3 -> bind b3 as {key:addr,
       value:vid} in if min_vid < vid then min_vid else vid))) g_min_vid in
     (ms_gc_vid_ctr = 0;
      ms_gc_vid_map = empty { key:address, value:{ key:int, value:int }
      } @ { Map };
      my_peers.iterate ((\b1 -> bind b1 as {i:addr} in 
      (do_gc, addr)<- min_vid));
      (tm_insert_timer, timer_addr)<- {ra:ms_gc_interval, rb:0, rc:me})
   else ())))
trigger rcv_req_gc_vid : () = (\_u -> if job == job_switch or job == job_master
  then (ms_rcv_gc_vid, master_addr)<- {key:me, value:sw_ack_log.fold
    ((\min_vid -> (\b3 -> bind b3 as {key:vid, value:count} in if min_vid < vid
    then min_vid else vid))) sw_highest_vid}
  else if job == job_node
    then (ms_rcv_gc_vid, master_addr)<- {key:me, value:nd_stmt_cntrs.fold
      ((\min_vid -> (\b3 -> bind b3 as {key:vid_stmt_id, value:ctr_corrs} in 
      if min_vid < vid_stmt_id.key then min_vid else vid_stmt_id.key)))
      g_max_vid} else ())
trigger ms_send_gc_req : () = (\_u -> my_peers.iterate ((\b1 ->
  bind b1 as {i:addr} in (rcv_req_gc_vid, addr)<- ())))
trigger do_gc : { key:int, value:int } = (\min_gc_vid ->
  (let temp = empty { key:{ key:int, value:int }, value:int } @ { Set } in
   (nd_log_master.iterate ((\b1 -> bind b1 as {key:vid, value:stmt_id} in 
    if vid < min_gc_vid then temp.insert {key:vid, value:stmt_id} else ()));
    temp.iterate ((\val -> nd_log_master.erase val)));
   let temp =
   empty { key:{ key:int, value:int }, value:{ ra:int, rb:string, rc:string,
     rd:int, re:string, rf:real, rg:string, rh:string } } @ { Map } in
   (nd_log_insert_CUSTOMER.iterate ((\b1 -> bind b1 as {key:vid,
    value:args} in if vid < min_gc_vid then temp.insert {key:vid, value:args}
    else ()));
    temp.iterate ((\val -> nd_log_insert_CUSTOMER.erase val)));
   let temp =
   empty { key:{ key:int, value:int }, value:{ ra:int, rb:string, rc:string,
     rd:int, re:string, rf:real, rg:string, rh:string } } @ { Map } in
   (nd_log_delete_CUSTOMER.iterate ((\b1 -> bind b1 as {key:vid,
    value:args} in if vid < min_gc_vid then temp.insert {key:vid, value:args}
    else ()));
    temp.iterate ((\val -> nd_log_delete_CUSTOMER.erase val)));
   let temp =
   empty { key:{ key:int, value:int }, value:{ ra:int, rb:int, rc:string,
     rd:real, re:int, rf:string, rg:string, rh:int, ri:string } } @ { Map } in
   (nd_log_insert_ORDERS.iterate ((\b1 -> bind b1 as {key:vid, value:args} in 
    if vid < min_gc_vid then temp.insert {key:vid, value:args} else ()));
    temp.iterate ((\val -> nd_log_insert_ORDERS.erase val)));
   let temp =
   empty { key:{ key:int, value:int }, value:{ ra:int, rb:int, rc:string,
     rd:real, re:int, rf:string, rg:string, rh:int, ri:string } } @ { Map } in
   (nd_log_delete_ORDERS.iterate ((\b1 -> bind b1 as {key:vid, value:args} in 
    if vid < min_gc_vid then temp.insert {key:vid, value:args} else ()));
    temp.iterate ((\val -> nd_log_delete_ORDERS.erase val)));
   let temp =
   empty { key:{ key:int, value:int }, value:{ ra:int, rb:int, rc:int, rd:int,
     re:real, rf:real, rg:real, rh:real, ri:string, rj:string, rk:int, rl:int,
     rm:int, rn:string, ro:string, rp:string } } @ { Map } in
   (nd_log_insert_LINEITEM.iterate ((\b1 -> bind b1 as {key:vid,
    value:args} in if vid < min_gc_vid then temp.insert {key:vid, value:args}
    else ()));
    temp.iterate ((\val -> nd_log_insert_LINEITEM.erase val)));
   let temp =
   empty { key:{ key:int, value:int }, value:{ ra:int, rb:int, rc:int, rd:int,
     re:real, rf:real, rg:real, rh:real, ri:string, rj:string, rk:int, rl:int,
     rm:int, rn:string, ro:string, rp:string } } @ { Map } in
   (nd_log_delete_LINEITEM.iterate ((\b1 -> bind b1 as {key:vid,
    value:args} in if vid < min_gc_vid then temp.insert {key:vid, value:args}
    else ()));
    temp.iterate ((\val -> nd_log_delete_LINEITEM.erase val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_s0_buf as ind
     map_QUERY18_mCUSTOMER1_s0_buf_unwrap in
     let frontier =
       frontier_int_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_s0_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_s0_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_s0_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mCUSTOMER1_s0_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s0_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s0_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s0_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s0_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s0_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s0_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_QUERY18_mLINEITEM2_mCUSTOMER1_s1_buf as ind
     map_QUERY18_mLINEITEM2_mCUSTOMER1_s1_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_QUERY18_mLINEITEM2_mCUSTOMER1_s1_buf_unwrap} in
       (map_QUERY18_mLINEITEM2_mCUSTOMER1_s1_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mLINEITEM2_mCUSTOMER1_s1_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mLINEITEM2_mCUSTOMER1_s1_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_s2_buf as ind
     map_QUERY18_mCUSTOMER1_s2_buf_unwrap in
     let frontier =
       frontier_int_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_s2_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_s2_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_s2_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mCUSTOMER1_s2_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_s4_buf as ind
     map_QUERY18_mCUSTOMER1_s4_buf_unwrap in
     let frontier =
       frontier_int_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_s4_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_s4_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_s4_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mCUSTOMER1_s4_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s4_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s4_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s4_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s4_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s4_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s4_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_QUERY18_mLINEITEM2_mCUSTOMER1_s5_buf as ind
     map_QUERY18_mLINEITEM2_mCUSTOMER1_s5_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_QUERY18_mLINEITEM2_mCUSTOMER1_s5_buf_unwrap} in
       (map_QUERY18_mLINEITEM2_mCUSTOMER1_s5_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mLINEITEM2_mCUSTOMER1_s5_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mLINEITEM2_mCUSTOMER1_s5_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_s6_buf as ind
     map_QUERY18_mCUSTOMER1_s6_buf_unwrap in
     let frontier =
       frontier_int_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_s6_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_s6_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_s6_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mCUSTOMER1_s6_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s8_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s8_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s8_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s8_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s8_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s8_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s8_buf as ind map_QUERY18_mORDERS2_s8_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s8_buf_unwrap} in
       (map_QUERY18_mORDERS2_s8_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
        rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s8_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s8_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s9_buf as ind map_QUERY18_mORDERS2_s9_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s9_buf_unwrap} in
       (map_QUERY18_mORDERS2_s9_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
        rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s9_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s9_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s11_buf as ind map_QUERY18_mORDERS2_s11_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s11_buf_unwrap} in
       (map_QUERY18_mORDERS2_s11_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s11_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s11_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s11_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s11_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s11_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s11_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s11_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s11_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s12_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s12_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s12_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s12_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s12_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s12_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s13_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s13_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s13_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s13_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s13_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s13_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s13_buf as ind map_QUERY18_mORDERS2_s13_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s13_buf_unwrap} in
       (map_QUERY18_mORDERS2_s13_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s13_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s13_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s14_buf as ind map_QUERY18_mORDERS2_s14_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s14_buf_unwrap} in
       (map_QUERY18_mORDERS2_s14_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s14_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s14_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s16_buf as ind map_QUERY18_mORDERS2_s16_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s16_buf_unwrap} in
       (map_QUERY18_mORDERS2_s16_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s16_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s16_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s16_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s16_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s16_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s16_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s16_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s16_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s17_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s17_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s17_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s17_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s17_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s17_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_QUERY18_mLINEITEM2_s18_buf as ind
     map_QUERY18_mLINEITEM2_s18_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_QUERY18_mLINEITEM2_s18_buf_unwrap} in
       (map_QUERY18_mLINEITEM2_s18_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mLINEITEM2_s18_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_QUERY18_mLINEITEM2_s18_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s18_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s18_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s18_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s18_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s18_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_QUERY18_mLINEITEM2_s19_buf as ind
     map_QUERY18_mLINEITEM2_s19_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_QUERY18_mLINEITEM2_s19_buf_unwrap} in
       (map_QUERY18_mLINEITEM2_s19_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mLINEITEM2_s19_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_QUERY18_mLINEITEM2_s19_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_QUERY18_mLINEITEM2_mCUSTOMER1_s20_buf as ind
     map_QUERY18_mLINEITEM2_mCUSTOMER1_s20_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_QUERY18_mLINEITEM2_mCUSTOMER1_s20_buf_unwrap} in
       (map_QUERY18_mLINEITEM2_mCUSTOMER1_s20_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mLINEITEM2_mCUSTOMER1_s20_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mLINEITEM2_mCUSTOMER1_s20_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_QUERY18_mLINEITEM2_s23_buf as ind
     map_QUERY18_mLINEITEM2_s23_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_QUERY18_mLINEITEM2_s23_buf_unwrap} in
       (map_QUERY18_mLINEITEM2_s23_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mLINEITEM2_s23_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_QUERY18_mLINEITEM2_s23_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s23_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s23_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s23_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s23_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s23_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Set } in
   bind map_QUERY18_mLINEITEM5_s23_buf as ind
     map_QUERY18_mLINEITEM5_s23_buf_unwrap in
     let frontier =
       frontier_int_int_float {key:min_gc_vid,
         value:map_QUERY18_mLINEITEM5_s23_buf_unwrap} in
       (map_QUERY18_mLINEITEM5_s23_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mLINEITEM5_s23_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_QUERY18_mLINEITEM5_s23_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_QUERY18_mLINEITEM2_s24_buf as ind
     map_QUERY18_mLINEITEM2_s24_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_QUERY18_mLINEITEM2_s24_buf_unwrap} in
       (map_QUERY18_mLINEITEM2_s24_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mLINEITEM2_s24_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_QUERY18_mLINEITEM2_s24_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_QUERY18_mLINEITEM2_mCUSTOMER1_s25_buf as ind
     map_QUERY18_mLINEITEM2_mCUSTOMER1_s25_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_QUERY18_mLINEITEM2_mCUSTOMER1_s25_buf_unwrap} in
       (map_QUERY18_mLINEITEM2_mCUSTOMER1_s25_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mLINEITEM2_mCUSTOMER1_s25_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mLINEITEM2_mCUSTOMER1_s25_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s28_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s28_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s28_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s28_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s28_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s28_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s28_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s28_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s28_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s28_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s28_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s28_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s30_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s30_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s30_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s30_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s30_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s30_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s30_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s30_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s30_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s30_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s30_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s30_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_QUERY18_mLINEITEM2_s32_buf as ind
     map_QUERY18_mLINEITEM2_s32_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_QUERY18_mLINEITEM2_s32_buf_unwrap} in
       (map_QUERY18_mLINEITEM2_s32_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mLINEITEM2_s32_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_QUERY18_mLINEITEM2_s32_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s32_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s32_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s32_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s32_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s32_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s32_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s32_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s32_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s32_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s32_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s32_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s32_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_QUERY18_mLINEITEM2_s33_buf as ind
     map_QUERY18_mLINEITEM2_s33_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_QUERY18_mLINEITEM2_s33_buf_unwrap} in
       (map_QUERY18_mLINEITEM2_s33_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mLINEITEM2_s33_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_QUERY18_mLINEITEM2_s33_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s33_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s33_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s33_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s33_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s33_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s33_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s33_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s33_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s33_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s33_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s33_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s33_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s35_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s35_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s35_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s35_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s35_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s35_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s35_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s35_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s35_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s35_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s35_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s35_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s37_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s37_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s37_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s37_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s37_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s37_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s37_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s37_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s37_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s37_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s37_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s37_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_QUERY18_mLINEITEM2_s39_buf as ind
     map_QUERY18_mLINEITEM2_s39_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_QUERY18_mLINEITEM2_s39_buf_unwrap} in
       (map_QUERY18_mLINEITEM2_s39_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mLINEITEM2_s39_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_QUERY18_mLINEITEM2_s39_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s39_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s39_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s39_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s39_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s39_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s39_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s39_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s39_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s39_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s39_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s39_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s39_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Set } in
   bind map_QUERY18_mLINEITEM5_s39_buf as ind
     map_QUERY18_mLINEITEM5_s39_buf_unwrap in
     let frontier =
       frontier_int_int_float {key:min_gc_vid,
         value:map_QUERY18_mLINEITEM5_s39_buf_unwrap} in
       (map_QUERY18_mLINEITEM5_s39_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mLINEITEM5_s39_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_QUERY18_mLINEITEM5_s39_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_QUERY18_mLINEITEM2_s40_buf as ind
     map_QUERY18_mLINEITEM2_s40_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_QUERY18_mLINEITEM2_s40_buf_unwrap} in
       (map_QUERY18_mLINEITEM2_s40_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mLINEITEM2_s40_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_QUERY18_mLINEITEM2_s40_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s40_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s40_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s40_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s40_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s40_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s40_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s40_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s40_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s40_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s40_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s40_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s40_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Set } in
   bind map_QUERY18_mLINEITEM5_s40_buf as ind
     map_QUERY18_mLINEITEM5_s40_buf_unwrap in
     let frontier =
       frontier_int_int_float {key:min_gc_vid,
         value:map_QUERY18_mLINEITEM5_s40_buf_unwrap} in
       (map_QUERY18_mLINEITEM5_s40_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mLINEITEM5_s40_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_QUERY18_mLINEITEM5_s40_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s41_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s41_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s41_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s41_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s41_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s41_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s41_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s41_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s41_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s41_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s41_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s41_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s43_buf as ind map_QUERY18_mORDERS2_s43_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s43_buf_unwrap} in
       (map_QUERY18_mORDERS2_s43_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s43_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s43_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s43_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s43_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s43_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s43_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s43_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s43_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s43_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s43_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s43_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s43_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s43_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s43_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s44_buf as ind map_QUERY18_mORDERS2_s44_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s44_buf_unwrap} in
       (map_QUERY18_mORDERS2_s44_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s44_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s44_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s46_buf as ind map_QUERY18_mORDERS2_s46_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s46_buf_unwrap} in
       (map_QUERY18_mORDERS2_s46_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s46_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s46_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s46_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s46_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s46_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s46_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s46_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s46_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s46_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s46_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s46_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s46_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s46_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s46_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s47_buf as ind map_QUERY18_mORDERS2_s47_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s47_buf_unwrap} in
       (map_QUERY18_mORDERS2_s47_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s47_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s47_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s49_buf as ind map_QUERY18_mORDERS2_s49_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s49_buf_unwrap} in
       (map_QUERY18_mORDERS2_s49_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s49_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s49_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s49_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s49_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s49_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s49_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s49_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s49_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s49_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s49_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s49_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s49_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s49_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s49_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s50_buf as ind map_QUERY18_mORDERS2_s50_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s50_buf_unwrap} in
       (map_QUERY18_mORDERS2_s50_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s50_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s50_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s52_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s52_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s52_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s52_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s52_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s52_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s52_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s52_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s52_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s52_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s52_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s52_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s52_buf as ind map_QUERY18_mORDERS2_s52_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s52_buf_unwrap} in
       (map_QUERY18_mORDERS2_s52_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s52_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s52_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s53_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s53_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s53_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s53_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s53_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s53_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s53_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s53_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s53_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s53_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s53_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s53_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s55_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s55_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s55_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s55_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s55_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s55_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s56_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s56_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s56_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s56_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s56_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s56_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s56_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s56_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s56_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s56_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s56_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s56_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s58_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s58_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s58_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s58_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s58_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s58_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s59_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s59_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s59_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s59_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s59_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s59_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s59_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s59_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s59_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s59_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s59_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s59_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s61_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s61_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s61_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s61_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s61_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s61_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s62_buf as ind map_QUERY18_mORDERS2_s62_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s62_buf_unwrap} in
       (map_QUERY18_mORDERS2_s62_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s62_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s62_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s62_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s62_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s62_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s62_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s62_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s62_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s62_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s62_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s62_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s62_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s62_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s62_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s63_buf as ind map_QUERY18_mORDERS2_s63_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s63_buf_unwrap} in
       (map_QUERY18_mORDERS2_s63_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s63_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s63_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s65_buf as ind map_QUERY18_mORDERS2_s65_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s65_buf_unwrap} in
       (map_QUERY18_mORDERS2_s65_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s65_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s65_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s65_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s65_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s65_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s65_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s65_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s65_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s65_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s65_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s65_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s65_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s65_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s65_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s66_buf as ind map_QUERY18_mORDERS2_s66_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s66_buf_unwrap} in
       (map_QUERY18_mORDERS2_s66_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s66_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s66_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s68_buf as ind map_QUERY18_mORDERS2_s68_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s68_buf_unwrap} in
       (map_QUERY18_mORDERS2_s68_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s68_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s68_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s68_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s68_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s68_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s68_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s68_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s68_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s68_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s68_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s68_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s68_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s68_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s68_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s69_buf as ind map_QUERY18_mORDERS2_s69_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s69_buf_unwrap} in
       (map_QUERY18_mORDERS2_s69_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s69_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s69_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s71_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s71_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s71_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s71_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s71_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s71_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s71_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s71_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s71_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s71_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s71_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s71_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mORDERS2_s71_buf as ind map_QUERY18_mORDERS2_s71_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mORDERS2_s71_buf_unwrap} in
       (map_QUERY18_mORDERS2_s71_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mORDERS2_s71_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY18_mORDERS2_s71_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s72_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s72_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s72_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s72_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s72_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s72_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s72_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s72_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s72_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s72_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s72_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s72_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s74_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s74_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s74_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s74_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s74_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s74_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s75_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s75_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s75_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s75_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s75_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s75_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s75_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s75_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s75_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s75_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s75_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s75_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s77_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s77_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s77_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s77_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s77_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s77_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s78_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s78_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s78_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s78_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s78_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s78_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s78_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s78_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s78_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s78_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s78_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s78_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s80_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s80_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s80_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s80_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s80_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s80_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s81_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s81_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s81_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s81_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s81_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s81_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s81_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s81_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s81_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s81_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s81_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s81_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s83_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s83_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s83_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s83_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s83_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s83_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s83_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s83_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s83_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s83_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s83_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s83_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_s85_buf as ind
     map_QUERY18_mCUSTOMER1_s85_buf_unwrap in
     let frontier =
       frontier_int_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_s85_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_s85_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_s85_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_QUERY18_mCUSTOMER1_s85_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s85_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s85_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s85_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s85_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s85_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s85_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s85_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s85_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s85_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s85_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s85_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s85_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_s86_buf as ind
     map_QUERY18_mCUSTOMER1_s86_buf_unwrap in
     let frontier =
       frontier_int_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_s86_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_s86_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_s86_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_QUERY18_mCUSTOMER1_s86_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s86_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s86_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s86_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s86_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s86_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s86_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s86_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s86_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s86_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s86_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s86_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s86_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s88_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s88_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s88_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s88_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s88_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s88_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s88_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s88_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s88_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s88_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s88_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s88_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s90_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s90_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s90_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s90_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s90_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s90_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s90_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s90_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s90_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s90_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s90_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s90_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_s92_buf as ind
     map_QUERY18_mCUSTOMER1_s92_buf_unwrap in
     let frontier =
       frontier_int_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_s92_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_s92_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_s92_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_QUERY18_mCUSTOMER1_s92_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s92_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s92_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s92_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s92_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s92_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s92_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s92_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s92_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s92_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s92_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s92_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s92_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_s93_buf as ind
     map_QUERY18_mCUSTOMER1_s93_buf_unwrap in
     let frontier =
       frontier_int_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_s93_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_s93_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_s93_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_QUERY18_mCUSTOMER1_s93_buf_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s93_buf as ind
     map_QUERY18_mCUSTOMER1_L1_1_L1_1_s93_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s93_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_1_L1_1_s93_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s93_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_1_L1_1_s93_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind map_QUERY18_mCUSTOMER1_L1_2_s93_buf as ind
     map_QUERY18_mCUSTOMER1_L1_2_s93_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY18_mCUSTOMER1_L1_2_s93_buf_unwrap} in
       (map_QUERY18_mCUSTOMER1_L1_2_s93_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> map_QUERY18_mCUSTOMER1_L1_2_s93_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_QUERY18_mCUSTOMER1_L1_2_s93_buf_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind QUERY18 as ind QUERY18_unwrap in
     let frontier = frontier_int_float {key:min_gc_vid, value:QUERY18_unwrap}
       in
       (QUERY18_unwrap.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0,
        rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> QUERY18_unwrap.erase val));
        frontier.iterate ((\val -> QUERY18_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind QUERY18_mLINEITEM2 as ind QUERY18_mLINEITEM2_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid, value:QUERY18_mLINEITEM2_unwrap}
       in
       (QUERY18_mLINEITEM2_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> QUERY18_mLINEITEM2_unwrap.erase val));
        frontier.iterate ((\val -> QUERY18_mLINEITEM2_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind QUERY18_mLINEITEM2_mCUSTOMER1 as ind
     QUERY18_mLINEITEM2_mCUSTOMER1_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:QUERY18_mLINEITEM2_mCUSTOMER1_unwrap} in
       (QUERY18_mLINEITEM2_mCUSTOMER1_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> QUERY18_mLINEITEM2_mCUSTOMER1_unwrap.erase val));
        frontier.iterate ((\val -> QUERY18_mLINEITEM2_mCUSTOMER1_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Set } in
   bind QUERY18_mLINEITEM5 as ind QUERY18_mLINEITEM5_unwrap in
     let frontier =
       frontier_int_int_float {key:min_gc_vid, value:QUERY18_mLINEITEM5_unwrap}
       in
       (QUERY18_mLINEITEM5_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> QUERY18_mLINEITEM5_unwrap.erase val));
        frontier.iterate ((\val -> QUERY18_mLINEITEM5_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind QUERY18_mORDERS2 as ind QUERY18_mORDERS2_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid, value:QUERY18_mORDERS2_unwrap} in
       (QUERY18_mORDERS2_unwrap.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0,
        rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> QUERY18_mORDERS2_unwrap.erase val));
        frontier.iterate ((\val -> QUERY18_mORDERS2_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Set } in
   bind QUERY18_mCUSTOMER1 as ind QUERY18_mCUSTOMER1_unwrap in
     let frontier =
       frontier_int_int_float {key:min_gc_vid, value:QUERY18_mCUSTOMER1_unwrap}
       in
       (QUERY18_mCUSTOMER1_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> QUERY18_mCUSTOMER1_unwrap.erase val));
        frontier.iterate ((\val -> QUERY18_mCUSTOMER1_unwrap.insert val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:real } @ { Set } in
   bind QUERY18_mCUSTOMER1_L1_1_L1_1 as ind QUERY18_mCUSTOMER1_L1_1_L1_1_unwrap
     in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:QUERY18_mCUSTOMER1_L1_1_L1_1_unwrap} in
       (QUERY18_mCUSTOMER1_L1_1_L1_1_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> QUERY18_mCUSTOMER1_L1_1_L1_1_unwrap.erase val));
        frontier.iterate ((\val -> QUERY18_mCUSTOMER1_L1_1_L1_1_unwrap.insert
        val)));
   let temp = empty { ra:{ key:int, value:int }, rb:int, rc:int } @ { Set } in
   bind QUERY18_mCUSTOMER1_L1_2 as ind QUERY18_mCUSTOMER1_L1_2_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid, value:QUERY18_mCUSTOMER1_L1_2_unwrap}
       in
       (QUERY18_mCUSTOMER1_L1_2_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
        rb:map_0, rc:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_val} else ()));
        temp.iterate ((\val -> QUERY18_mCUSTOMER1_L1_2_unwrap.erase val));
        frontier.iterate ((\val -> QUERY18_mCUSTOMER1_L1_2_unwrap.insert val)))))
  
trigger sw_rcv_token : { key:int, value:int } = (\vid ->
  if sw_need_vid_cntr > 0
  then let next_vid = {key:vid.key, value:vid.value + sw_need_vid_cntr} in
    ((sw_rcv_token, sw_next_switch_addr)<- next_vid;
     sw_token_vid_list.insert {key:vid, value:sw_need_vid_cntr};
     sw_need_vid_cntr = 0;
     sw_highest_vid = next_vid;
     (if not sw_sent_done and (sw_trig_buf_idx.size () == 0 and (sw_num_ack ==
        sw_num_sent and sw_seen_sentry == true))
     then ((ms_rcv_switch_done, master_addr)<- ();sw_sent_done = true) 
     else ());
     (sw_driver_trig, me)<- ()) else (sw_rcv_token, sw_next_switch_addr)<- vid)
trigger tm_insert_timer : { ra:int, rb:int, rc:address } = (\b1 ->
  bind b1 as {ra:time, rb:trig_id, rc:addr} in 
  (tm_timer_list.insert {ra:time + now_int (), rb:trig_id, rc:addr};
   tm_timer_list = tm_timer_list.sort ((\b2 -> (\b6 -> bind b2 as {ra:time1,
   rb:trig_id1, rc:addr1} in bind b6 as {ra:time2, rb:trig_id2, rc:addr2} in 
   if time1 < time2 then -1 else 1)));
   (tm_check_time, me)<- ()))
trigger tm_check_time : () = (\_u -> case (tm_timer_list.peek ()) of
  {Some timer -> if now_int () >= timer.ra
    then
      (tm_timer_list.erase timer;
       bind timer as {ra:time, rb:trig_id, rc:addr} in
       if trig_id == 0 then (ms_send_gc_req, addr)<- () else ();
       (tm_check_time, me)<- ()) else ((tm_check_time, me)<- ();(sleep 1000))}
  {None -> ()})
trigger sw_demux : { ra:string, rb:int, rc:real, rd:string, re:int, rf:string,
  rg:string, rh:string, ri:string, rj:string, rk:int, rl:real, rm:real, rn:int,
  ro:string, rp:string, rq:string, rr:string, rs:int, rt:string, ru:int,
  rv:string, rw:string, rx:int, ry:string, rz:real, rza:string, rzb:int,
  rzc:real, rzd:string, rze:string, rzf:string, rzg:string, rzh:int, rzi:int,
  rzj:int, rzk:real, rzl:real, rzm:real, rzn:string } = (\args ->
  if args.ra == "ORDERS"
  then if args.rb == 1
    then
      sw_insert_ORDERS {ra:args.ru, rb:args.rk, rc:args.rw, rd:args.rzm,
        re:tpch_date (args.rt), rf:args.rv, rg:args.rg, rh:args.rzh,
        ri:args.rh}
    else
      sw_delete_ORDERS {ra:args.ru, rb:args.rk, rc:args.rw, rd:args.rzm,
        re:tpch_date (args.rt), rf:args.rv, rg:args.rg, rh:args.rzh,
        ri:args.rh}
  else if args.ra == "LINEITEM"
    then if args.rb == 1
      then
        sw_insert_LINEITEM {ra:args.ru, rb:args.rx, rc:args.rzj, rd:args.rn,
          re:args.rz, rf:args.rm, rg:args.rl, rh:args.rzl, ri:args.rzd,
          rj:args.ro, rk:tpch_date (args.rze), rl:tpch_date (args.ri),
          rm:tpch_date (args.rza), rn:args.rzf, ro:args.rzg, rp:args.rh}
      else
        sw_delete_LINEITEM {ra:args.ru, rb:args.rx, rc:args.rzj, rd:args.rn,
          re:args.rz, rf:args.rm, rg:args.rl, rh:args.rzl, ri:args.rzd,
          rj:args.ro, rk:tpch_date (args.rze), rl:tpch_date (args.ri),
          rm:tpch_date (args.rza), rn:args.rzf, ro:args.rzg, rp:args.rh}
    else if args.ra == "CUSTOMER"
      then if args.rb == 1
        then
          sw_insert_CUSTOMER {ra:args.rk, rb:args.rr, rc:args.rd, rd:args.rs,
            re:args.ry, rf:args.rc, rg:args.rq, rh:args.rh}
        else
          sw_delete_CUSTOMER {ra:args.rk, rb:args.rr, rc:args.rd, rd:args.rs,
            re:args.ry, rf:args.rc, rg:args.rq, rh:args.rh}
      else if args.ra == ""
        then
          (sw_trig_buf_idx.insert ({i:-1});
           sw_need_vid_cntr = sw_need_vid_cntr + 1)
        else error (print "unidentified trig id"))
trigger sw_driver_trig : () = (\_u ->
  if sw_init and sw_trig_buf_idx.size () > 0
  then case sw_gen_vid () of
    {Some vid -> case (sw_trig_buf_idx.peek ()) of
      {Some trig_id ->
        (sw_trig_buf_idx.erase {i:trig_id.i};
         (if trig_id.i == -1
         then
           (sw_seen_sentry = true;
            (if not sw_sent_done and (sw_trig_buf_idx.size () == 0 and
               (sw_num_ack == sw_num_sent and sw_seen_sentry == true))
            then ((ms_rcv_switch_done, master_addr)<- ();sw_sent_done = true)
            else ()))
         else
           ((if trig_id.i == 5 then sw_delete_LINEITEM_send_fetch vid
            else if trig_id.i == 4 then sw_insert_LINEITEM_send_fetch vid
              else if trig_id.i == 3 then sw_delete_ORDERS_send_fetch vid
                else if trig_id.i == 2 then sw_insert_ORDERS_send_fetch vid
                  else if trig_id.i == 1 then sw_delete_CUSTOMER_send_fetch vid
                    else if trig_id.i == 0
                      then sw_insert_CUSTOMER_send_fetch vid
                      else error (print "mismatch on trigger id"));
            (sw_driver_trig, me)<- ())))}{None -> ()}}{None -> ()} else ())
trigger nd_rcv_corr_done : { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } = (\b1 -> bind b1 as {ra:vid, rb:stmt_id, rc:hop, rd:count} in 
  ((nd_update_stmt_cntr_corr_map {ra:vid, rb:stmt_id, rc:hop, rd:count,
      re:false, rf:false});
   (case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
   key == {key:vid, value:stmt_id}))).peek ()) of
   {Some lkup -> if 0 == ((lkup.value).value).size ()
     then
       (nd_stmt_cntrs.erase lkup;
        (if nd_rcvd_sys_done
        then if not nd_sent_done and nd_stmt_cntrs.size () == 0
          then ((ms_rcv_node_done, master_addr)<- true;nd_sent_done = true)
          else () else ())) else ()}{None ->
                                      error
                                        (print
                                           "nd_rcv_corr_done: expected stmt_cntr value")})))
  
trigger nd_insert_CUSTOMER_rcv_put : { ra:address, rb:collection { key:int,
  value:int } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:string,
  rf:string, rg:int, rh:string, ri:real, rj:string, rk:string } = (\b1 ->
  bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid, rd:CUSTOMER_CUSTKEY,
  re:CUSTOMER_NAME, rf:CUSTOMER_ADDRESS, rg:CUSTOMER_NATIONKEY,
  rh:CUSTOMER_PHONE, ri:CUSTOMER_ACCTBAL, rj:CUSTOMER_MKTSEGMENT,
  rk:CUSTOMER_COMMENT} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 3
     then
       nd_insert_CUSTOMER_do_complete_s3 {ra:vid, rb:CUSTOMER_CUSTKEY,
         rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
         rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
         ri:CUSTOMER_COMMENT}
     else if stmt_id == 2
       then
         nd_insert_CUSTOMER_do_complete_s2 {ra:vid, rb:CUSTOMER_CUSTKEY,
           rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
           rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
           ri:CUSTOMER_COMMENT}
       else if stmt_id == 1
         then
           nd_insert_CUSTOMER_do_complete_s1 {ra:vid, rb:CUSTOMER_CUSTKEY,
             rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
             rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
             ri:CUSTOMER_COMMENT}
         else if stmt_id == 0
           then
             nd_insert_CUSTOMER_do_complete_s0 {ra:vid, rb:CUSTOMER_CUSTKEY,
               rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
               rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
               ri:CUSTOMER_COMMENT} else () else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_insert_CUSTOMER_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string, rj:string } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 0
   then if map_id == 6
     then (nd_insert_CUSTOMER_send_push_s0_m_QUERY18_mCUSTOMER1, me)<- {ra:vid,
       rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
       re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
       rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
     else if map_id == 7
       then
         (nd_insert_CUSTOMER_send_push_s0_m_QUERY18_mCUSTOMER1_L1_1_L1_1, me)<- {ra:vid,
         rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
         re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
         rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
       else if map_id == 8
         then
           (nd_insert_CUSTOMER_send_push_s0_m_QUERY18_mCUSTOMER1_L1_2, me)<- {ra:vid,
           rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
           re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
           rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 1
     then if map_id == 3
       then
         (nd_insert_CUSTOMER_send_push_s1_m_QUERY18_mLINEITEM2_mCUSTOMER1, me)<- {ra:vid,
         rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
         re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
         rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 2
       then if map_id == 6
         then
           (nd_insert_CUSTOMER_send_push_s2_m_QUERY18_mCUSTOMER1, me)<- {ra:vid,
           rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
           re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
           rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
       else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_insert_CUSTOMER_send_push_s0_m_QUERY18_mCUSTOMER1 : { ra:{ key:int,
  value:int }, rb:int, rc:string, rd:string, re:int, rf:string, rg:real,
  rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in bind QUERY18_mCUSTOMER1 as ind
  QUERY18_mCUSTOMER1_deref in
  ((nd_log_master_write {key:vid, value:0});
   (shuffle_QUERY18_mCUSTOMER1_to_QUERY18_bind_0t0 {ra:Some CUSTOMER_CUSTKEY,
      rb:frontier_int_int_float {key:vid, value:QUERY18_mCUSTOMER1_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb ==
           CUSTOMER_CUSTKEY))}, rc:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s0_m_QUERY18_mCUSTOMER1, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s0_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : { ra:{
  key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  QUERY18_mCUSTOMER1_L1_1_L1_1 as ind QUERY18_mCUSTOMER1_L1_1_L1_1_deref in
  ((nd_log_master_write {key:vid, value:0});
   (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18 {ra:Some CUSTOMER_CUSTKEY,
      rb:frontier_int_float {key:vid, value:QUERY18_mCUSTOMER1_L1_1_L1_1_deref},
      rc:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s0_m_QUERY18_mCUSTOMER1_L1_1_L1_1, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s0_m_QUERY18_mCUSTOMER1_L1_2 : { ra:{
  key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind QUERY18_mCUSTOMER1_L1_2
  as ind QUERY18_mCUSTOMER1_L1_2_deref in
  ((nd_log_master_write {key:vid, value:0});
   (shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18 {ra:Some CUSTOMER_CUSTKEY,
      rb:frontier_int_int {key:vid, value:QUERY18_mCUSTOMER1_L1_2_deref},
      rc:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s0_m_QUERY18_mCUSTOMER1_L1_2, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s1_m_QUERY18_mLINEITEM2_mCUSTOMER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  QUERY18_mLINEITEM2_mCUSTOMER1 as ind QUERY18_mLINEITEM2_mCUSTOMER1_deref in
  ((nd_log_master_write {key:vid, value:1});
   (shuffle_QUERY18_mLINEITEM2_mCUSTOMER1_to_QUERY18_mLINEITEM2_bind_0t0_1t1
      {ra:Some CUSTOMER_CUSTKEY, rb:None immut,
      rc:frontier_int_int_int {key:vid,
           value:QUERY18_mLINEITEM2_mCUSTOMER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))},
      rd:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s1_m_QUERY18_mLINEITEM2_mCUSTOMER1, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s2_m_QUERY18_mCUSTOMER1 : { ra:{ key:int,
  value:int }, rb:int, rc:string, rd:string, re:int, rf:string, rg:real,
  rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in bind QUERY18_mCUSTOMER1 as ind
  QUERY18_mCUSTOMER1_deref in
  ((nd_log_master_write {key:vid, value:2});
   (shuffle_QUERY18_mCUSTOMER1_to_QUERY18_mLINEITEM5_bind_0t0_1t1
      {ra:Some CUSTOMER_CUSTKEY, rb:None immut,
      rc:frontier_int_int_float {key:vid, value:QUERY18_mCUSTOMER1_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb ==
           CUSTOMER_CUSTKEY))}, rd:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s2_m_QUERY18_mCUSTOMER1, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_rcv_push_s0_m_QUERY18_mCUSTOMER1 : { ra:collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Collection }, rb:{
  key:int, value:int }, rc:int, rd:string, re:string, rf:int, rg:string,
  rh:real, ri:string, rj:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
  rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
  ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_s0_buf as ind
   map_QUERY18_mCUSTOMER1_s0_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_QUERY18_mCUSTOMER1_s0_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_s0_buf_d.update vals tuple}
       {None -> map_QUERY18_mCUSTOMER1_s0_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:0, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s0 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s0_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string, rj:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf as
   ind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek
       ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf_d.update vals
         tuple}{None -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:0, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s0 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s0_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection },
  rb:{ key:int, value:int }, rc:int, rd:string, re:string, rf:int, rg:string,
  rh:real, ri:string, rj:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
  rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
  ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_L1_2_s0_buf as ind
   map_QUERY18_mCUSTOMER1_L1_2_s0_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mCUSTOMER1_L1_2_s0_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek
       ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_L1_2_s0_buf_d.update vals tuple}
       {None -> map_QUERY18_mCUSTOMER1_L1_2_s0_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:0, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s0 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s1_m_QUERY18_mLINEITEM2_mCUSTOMER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string, rj:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mLINEITEM2_mCUSTOMER1_s1_buf as
   ind map_QUERY18_mLINEITEM2_mCUSTOMER1_s1_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_QUERY18_mLINEITEM2_mCUSTOMER1_s1_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2)
       and rb == _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mLINEITEM2_mCUSTOMER1_s1_buf_d.update vals
         tuple}{None -> map_QUERY18_mLINEITEM2_mCUSTOMER1_s1_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:1, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s1 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s2_m_QUERY18_mCUSTOMER1 : { ra:collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Collection }, rb:{
  key:int, value:int }, rc:int, rd:string, re:string, rf:int, rg:string,
  rh:real, ri:string, rj:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
  rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
  ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_s2_buf as ind
   map_QUERY18_mCUSTOMER1_s2_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_QUERY18_mCUSTOMER1_s2_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_s2_buf_d.update vals tuple}
       {None -> map_QUERY18_mCUSTOMER1_s2_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:2, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s2 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_do_complete_s3_trig : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in 
  nd_insert_CUSTOMER_do_complete_s3 {ra:vid, rb:CUSTOMER_CUSTKEY,
    rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
    rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
    ri:CUSTOMER_COMMENT})
trigger insert_CUSTOMER_rcv_corrective_s0_m_QUERY18_mCUSTOMER1 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { ra:int,
  rb:int, rc:real } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_float {ra:map_QUERY18_mCUSTOMER1_s0_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:0}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s0_m_QUERY18_mCUSTOMER1 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid,
             rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS,
             ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL,
             rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT, rn:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_CUSTOMER_rcv_corrective_s0_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  key:int, value:real } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_float {ra:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s0_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:0}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s0_m_QUERY18_mCUSTOMER1_L1_1_L1_1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_CUSTOMER_rcv_corrective_s0_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  key:int, value:int } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_QUERY18_mCUSTOMER1_L1_2_s0_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:0}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s0_m_QUERY18_mCUSTOMER1_L1_2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_CUSTOMER_rcv_corrective_s1_m_QUERY18_mLINEITEM2_mCUSTOMER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_QUERY18_mLINEITEM2_mCUSTOMER1_s1_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:1}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s1_m_QUERY18_mLINEITEM2_mCUSTOMER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_CUSTOMER_rcv_corrective_s2_m_QUERY18_mCUSTOMER1 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { ra:int,
  rb:int, rc:real } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_float {ra:map_QUERY18_mCUSTOMER1_s2_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:2}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s2_m_QUERY18_mCUSTOMER1 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid,
             rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS,
             ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL,
             rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT, rn:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger nd_delete_CUSTOMER_rcv_put : { ra:address, rb:collection { key:int,
  value:int } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:string,
  rf:string, rg:int, rh:string, ri:real, rj:string, rk:string } = (\b1 ->
  bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid, rd:CUSTOMER_CUSTKEY,
  re:CUSTOMER_NAME, rf:CUSTOMER_ADDRESS, rg:CUSTOMER_NATIONKEY,
  rh:CUSTOMER_PHONE, ri:CUSTOMER_ACCTBAL, rj:CUSTOMER_MKTSEGMENT,
  rk:CUSTOMER_COMMENT} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 7
     then
       nd_delete_CUSTOMER_do_complete_s7 {ra:vid, rb:CUSTOMER_CUSTKEY,
         rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
         rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
         ri:CUSTOMER_COMMENT}
     else if stmt_id == 6
       then
         nd_delete_CUSTOMER_do_complete_s6 {ra:vid, rb:CUSTOMER_CUSTKEY,
           rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
           rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
           ri:CUSTOMER_COMMENT}
       else if stmt_id == 5
         then
           nd_delete_CUSTOMER_do_complete_s5 {ra:vid, rb:CUSTOMER_CUSTKEY,
             rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
             rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
             ri:CUSTOMER_COMMENT}
         else if stmt_id == 4
           then
             nd_delete_CUSTOMER_do_complete_s4 {ra:vid, rb:CUSTOMER_CUSTKEY,
               rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
               rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
               ri:CUSTOMER_COMMENT} else () else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_delete_CUSTOMER_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string, rj:string } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 4
   then if map_id == 6
     then (nd_delete_CUSTOMER_send_push_s4_m_QUERY18_mCUSTOMER1, me)<- {ra:vid,
       rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
       re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
       rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
     else if map_id == 7
       then
         (nd_delete_CUSTOMER_send_push_s4_m_QUERY18_mCUSTOMER1_L1_1_L1_1, me)<- {ra:vid,
         rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
         re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
         rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
       else if map_id == 8
         then
           (nd_delete_CUSTOMER_send_push_s4_m_QUERY18_mCUSTOMER1_L1_2, me)<- {ra:vid,
           rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
           re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
           rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 5
     then if map_id == 3
       then
         (nd_delete_CUSTOMER_send_push_s5_m_QUERY18_mLINEITEM2_mCUSTOMER1, me)<- {ra:vid,
         rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
         re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
         rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 6
       then if map_id == 6
         then
           (nd_delete_CUSTOMER_send_push_s6_m_QUERY18_mCUSTOMER1, me)<- {ra:vid,
           rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
           re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
           rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
       else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_delete_CUSTOMER_send_push_s4_m_QUERY18_mCUSTOMER1 : { ra:{ key:int,
  value:int }, rb:int, rc:string, rd:string, re:int, rf:string, rg:real,
  rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in bind QUERY18_mCUSTOMER1 as ind
  QUERY18_mCUSTOMER1_deref in
  ((nd_log_master_write {key:vid, value:4});
   (shuffle_QUERY18_mCUSTOMER1_to_QUERY18_bind_0t0 {ra:Some CUSTOMER_CUSTKEY,
      rb:frontier_int_int_float {key:vid, value:QUERY18_mCUSTOMER1_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb ==
           CUSTOMER_CUSTKEY))}, rc:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s4_m_QUERY18_mCUSTOMER1, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_send_push_s4_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : { ra:{
  key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  QUERY18_mCUSTOMER1_L1_1_L1_1 as ind QUERY18_mCUSTOMER1_L1_1_L1_1_deref in
  ((nd_log_master_write {key:vid, value:4});
   (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18 {ra:Some CUSTOMER_CUSTKEY,
      rb:frontier_int_float {key:vid, value:QUERY18_mCUSTOMER1_L1_1_L1_1_deref},
      rc:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s4_m_QUERY18_mCUSTOMER1_L1_1_L1_1, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_send_push_s4_m_QUERY18_mCUSTOMER1_L1_2 : { ra:{
  key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind QUERY18_mCUSTOMER1_L1_2
  as ind QUERY18_mCUSTOMER1_L1_2_deref in
  ((nd_log_master_write {key:vid, value:4});
   (shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18 {ra:Some CUSTOMER_CUSTKEY,
      rb:frontier_int_int {key:vid, value:QUERY18_mCUSTOMER1_L1_2_deref},
      rc:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s4_m_QUERY18_mCUSTOMER1_L1_2, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_send_push_s5_m_QUERY18_mLINEITEM2_mCUSTOMER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  QUERY18_mLINEITEM2_mCUSTOMER1 as ind QUERY18_mLINEITEM2_mCUSTOMER1_deref in
  ((nd_log_master_write {key:vid, value:5});
   (shuffle_QUERY18_mLINEITEM2_mCUSTOMER1_to_QUERY18_mLINEITEM2_bind_0t0_1t1
      {ra:Some CUSTOMER_CUSTKEY, rb:None immut,
      rc:frontier_int_int_int {key:vid,
           value:QUERY18_mLINEITEM2_mCUSTOMER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))},
      rd:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s5_m_QUERY18_mLINEITEM2_mCUSTOMER1, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_send_push_s6_m_QUERY18_mCUSTOMER1 : { ra:{ key:int,
  value:int }, rb:int, rc:string, rd:string, re:int, rf:string, rg:real,
  rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in bind QUERY18_mCUSTOMER1 as ind
  QUERY18_mCUSTOMER1_deref in
  ((nd_log_master_write {key:vid, value:6});
   (shuffle_QUERY18_mCUSTOMER1_to_QUERY18_mLINEITEM5_bind_0t0_1t1
      {ra:Some CUSTOMER_CUSTKEY, rb:None immut,
      rc:frontier_int_int_float {key:vid, value:QUERY18_mCUSTOMER1_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb ==
           CUSTOMER_CUSTKEY))}, rd:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s6_m_QUERY18_mCUSTOMER1, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_rcv_push_s4_m_QUERY18_mCUSTOMER1 : { ra:collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Collection }, rb:{
  key:int, value:int }, rc:int, rd:string, re:string, rf:int, rg:string,
  rh:real, ri:string, rj:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
  rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
  ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_s4_buf as ind
   map_QUERY18_mCUSTOMER1_s4_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_QUERY18_mCUSTOMER1_s4_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_s4_buf_d.update vals tuple}
       {None -> map_QUERY18_mCUSTOMER1_s4_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:4, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s4 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_rcv_push_s4_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string, rj:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf as
   ind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek
       ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf_d.update vals
         tuple}{None -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:4, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s4 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_rcv_push_s4_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection },
  rb:{ key:int, value:int }, rc:int, rd:string, re:string, rf:int, rg:string,
  rh:real, ri:string, rj:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
  rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
  ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_L1_2_s4_buf as ind
   map_QUERY18_mCUSTOMER1_L1_2_s4_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mCUSTOMER1_L1_2_s4_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek
       ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_L1_2_s4_buf_d.update vals tuple}
       {None -> map_QUERY18_mCUSTOMER1_L1_2_s4_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:4, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s4 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_rcv_push_s5_m_QUERY18_mLINEITEM2_mCUSTOMER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string, rj:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mLINEITEM2_mCUSTOMER1_s5_buf as
   ind map_QUERY18_mLINEITEM2_mCUSTOMER1_s5_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_QUERY18_mLINEITEM2_mCUSTOMER1_s5_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2)
       and rb == _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mLINEITEM2_mCUSTOMER1_s5_buf_d.update vals
         tuple}{None -> map_QUERY18_mLINEITEM2_mCUSTOMER1_s5_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:5, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s5 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_rcv_push_s6_m_QUERY18_mCUSTOMER1 : { ra:collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:real } @ { Collection }, rb:{
  key:int, value:int }, rc:int, rd:string, re:string, rf:int, rg:string,
  rh:real, ri:string, rj:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
  rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
  ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_s6_buf as ind
   map_QUERY18_mCUSTOMER1_s6_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_QUERY18_mCUSTOMER1_s6_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_s6_buf_d.update vals tuple}
       {None -> map_QUERY18_mCUSTOMER1_s6_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:6, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s6 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_do_complete_s7_trig : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in 
  nd_delete_CUSTOMER_do_complete_s7 {ra:vid, rb:CUSTOMER_CUSTKEY,
    rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
    rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
    ri:CUSTOMER_COMMENT})
trigger delete_CUSTOMER_rcv_corrective_s4_m_QUERY18_mCUSTOMER1 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { ra:int,
  rb:int, rc:real } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_float {ra:map_QUERY18_mCUSTOMER1_s4_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:4}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           delete_CUSTOMER_do_corrective_s4_m_QUERY18_mCUSTOMER1 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid,
             rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS,
             ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL,
             rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT, rn:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_CUSTOMER_rcv_corrective_s4_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  key:int, value:real } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_float {ra:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s4_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:4}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           delete_CUSTOMER_do_corrective_s4_m_QUERY18_mCUSTOMER1_L1_1_L1_1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_CUSTOMER_rcv_corrective_s4_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  key:int, value:int } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_QUERY18_mCUSTOMER1_L1_2_s4_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:4}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           delete_CUSTOMER_do_corrective_s4_m_QUERY18_mCUSTOMER1_L1_2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_CUSTOMER_rcv_corrective_s5_m_QUERY18_mLINEITEM2_mCUSTOMER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_QUERY18_mLINEITEM2_mCUSTOMER1_s5_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:5}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           delete_CUSTOMER_do_corrective_s5_m_QUERY18_mLINEITEM2_mCUSTOMER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_CUSTOMER_rcv_corrective_s6_m_QUERY18_mCUSTOMER1 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { ra:int,
  rb:int, rc:real } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_float {ra:map_QUERY18_mCUSTOMER1_s6_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:6}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           delete_CUSTOMER_do_corrective_s6_m_QUERY18_mCUSTOMER1 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid,
             rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS,
             ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL,
             rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT, rn:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger nd_insert_ORDERS_rcv_put : { ra:address, rb:collection { key:int,
  value:int } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:int,
  rf:string, rg:real, rh:int, ri:string, rj:string, rk:int, rl:string } =
  (\b1 -> bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid,
  rd:ORDERS_ORDERKEY, re:ORDERS_CUSTKEY, rf:ORDERS_ORDERSTATUS,
  rg:ORDERS_TOTALPRICE, rh:ORDERS_ORDERDATE, ri:ORDERS_ORDERPRIORITY,
  rj:ORDERS_CLERK, rk:ORDERS_SHIPPRIORITY, rl:ORDERS_COMMENT} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 12
     then
       nd_insert_ORDERS_do_complete_s12 {ra:vid, rb:ORDERS_ORDERKEY,
         rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
         rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
         ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
     else if stmt_id == 11
       then
         nd_insert_ORDERS_do_complete_s11 {ra:vid, rb:ORDERS_ORDERKEY,
           rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
           rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
           ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
       else if stmt_id == 10
         then
           nd_insert_ORDERS_do_complete_s10 {ra:vid, rb:ORDERS_ORDERKEY,
             rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
             rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
             ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
         else if stmt_id == 9
           then
             nd_insert_ORDERS_do_complete_s9 {ra:vid, rb:ORDERS_ORDERKEY,
               rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
               rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
               ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
           else if stmt_id == 8
             then
               nd_insert_ORDERS_do_complete_s8 {ra:vid, rb:ORDERS_ORDERKEY,
                 rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
                 re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
                 rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
                 ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else () else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_insert_ORDERS_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 8
   then if map_id == 7
     then
       (nd_insert_ORDERS_send_push_s8_m_QUERY18_mCUSTOMER1_L1_1_L1_1, me)<- {ra:vid,
       rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
       re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
       rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
     else if map_id == 8
       then
         (nd_insert_ORDERS_send_push_s8_m_QUERY18_mCUSTOMER1_L1_2, me)<- {ra:vid,
         rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
         re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
         rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
       else if map_id == 5
         then (nd_insert_ORDERS_send_push_s8_m_QUERY18_mORDERS2, me)<- {ra:vid,
           rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
           re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
           rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 9
     then if map_id == 5
       then (nd_insert_ORDERS_send_push_s9_m_QUERY18_mORDERS2, me)<- {ra:vid,
         rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
         re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
         rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 11
       then if map_id == 5
         then
           (nd_insert_ORDERS_send_push_s11_m_QUERY18_mORDERS2, me)<- {ra:vid,
           rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
           re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
           rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
         else if map_id == 7
           then
             (nd_insert_ORDERS_send_push_s11_m_QUERY18_mCUSTOMER1_L1_1_L1_1,
               me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
             rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
             rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
             rj:ORDERS_COMMENT}
           else error (print "nd_rcv_fetch: invalid map id")
       else if stmt_id == 12
         then if map_id == 7
           then
             (nd_insert_ORDERS_send_push_s12_m_QUERY18_mCUSTOMER1_L1_1_L1_1,
               me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
             rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
             rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
             rj:ORDERS_COMMENT}
           else error (print "nd_rcv_fetch: invalid map id")
         else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_insert_ORDERS_send_push_s8_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  QUERY18_mCUSTOMER1_L1_1_L1_1 as ind QUERY18_mCUSTOMER1_L1_1_L1_1_deref in
  ((nd_log_master_write {key:vid, value:8});
   (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18 {ra:Some ORDERS_CUSTKEY,
      rb:frontier_int_float {key:vid,
           value:QUERY18_mCUSTOMER1_L1_1_L1_1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))},
      rc:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s8_m_QUERY18_mCUSTOMER1_L1_1_L1_1, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s8_m_QUERY18_mCUSTOMER1_L1_2 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  QUERY18_mCUSTOMER1_L1_2 as ind QUERY18_mCUSTOMER1_L1_2_deref in
  ((nd_log_master_write {key:vid, value:8});
   (shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18 {ra:Some ORDERS_CUSTKEY,
      rb:frontier_int_int {key:vid, value:QUERY18_mCUSTOMER1_L1_2_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc} in rb ==
           ORDERS_ORDERKEY))}, rc:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s8_m_QUERY18_mCUSTOMER1_L1_2, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s8_m_QUERY18_mORDERS2 : { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  QUERY18_mORDERS2 as ind QUERY18_mORDERS2_deref in
  ((nd_log_master_write {key:vid, value:8});
   (shuffle_QUERY18_mORDERS2_to_QUERY18_bind_0t0 {ra:Some ORDERS_CUSTKEY,
      rb:frontier_int_int {key:vid, value:QUERY18_mORDERS2_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))},
      rc:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s8_m_QUERY18_mORDERS2, ip)<- {ra:tuples, rb:vid,
   rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s9_m_QUERY18_mORDERS2 : { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  QUERY18_mORDERS2 as ind QUERY18_mORDERS2_deref in
  ((nd_log_master_write {key:vid, value:9});
   (shuffle_QUERY18_mORDERS2_to_QUERY18_mLINEITEM2_bind_0t0
      {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
      rc:frontier_int_int {key:vid, value:QUERY18_mORDERS2_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))},
      rd:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s9_m_QUERY18_mORDERS2, ip)<- {ra:tuples, rb:vid,
   rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s11_m_QUERY18_mORDERS2 : { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  QUERY18_mORDERS2 as ind QUERY18_mORDERS2_deref in
  ((nd_log_master_write {key:vid, value:11});
   (shuffle_QUERY18_mORDERS2_to_QUERY18_mLINEITEM5_bind_0t0
      {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
      rc:frontier_int_int {key:vid, value:QUERY18_mORDERS2_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))},
      rd:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s11_m_QUERY18_mORDERS2, ip)<- {ra:tuples, rb:vid,
   rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s11_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  QUERY18_mCUSTOMER1_L1_1_L1_1 as ind QUERY18_mCUSTOMER1_L1_1_L1_1_deref in
  ((nd_log_master_write {key:vid, value:11});
   (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18_mLINEITEM5_bind_1t0
      {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
      rc:frontier_int_float {key:vid,
           value:QUERY18_mCUSTOMER1_L1_1_L1_1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))},
      rd:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s11_m_QUERY18_mCUSTOMER1_L1_1_L1_1, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s12_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  QUERY18_mCUSTOMER1_L1_1_L1_1 as ind QUERY18_mCUSTOMER1_L1_1_L1_1_deref in
  ((nd_log_master_write {key:vid, value:12});
   (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18_mCUSTOMER1_bind_1t0
      {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
      rc:frontier_int_float {key:vid,
           value:QUERY18_mCUSTOMER1_L1_1_L1_1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))},
      rd:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s12_m_QUERY18_mCUSTOMER1_L1_1_L1_1, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_rcv_push_s8_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf as
   ind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek
       ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf_d.update vals
         tuple}{None -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:8, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s8 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s8_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection },
  rb:{ key:int, value:int }, rc:int, rd:int, re:string, rf:real, rg:int,
  rh:string, ri:string, rj:int, rk:string } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
  rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
  ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_L1_2_s8_buf as ind
   map_QUERY18_mCUSTOMER1_L1_2_s8_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mCUSTOMER1_L1_2_s8_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek
       ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_L1_2_s8_buf_d.update vals tuple}
       {None -> map_QUERY18_mCUSTOMER1_L1_2_s8_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:8, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s8 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s8_m_QUERY18_mORDERS2 : { ra:collection {
  ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int,
  value:int }, rc:int, rd:int, re:string, rf:real, rg:int, rh:string,
  ri:string, rj:int, rk:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
  rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
  ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mORDERS2_s8_buf as ind
   map_QUERY18_mORDERS2_s8_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mORDERS2_s8_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mORDERS2_s8_buf_d.update vals tuple}
       {None -> map_QUERY18_mORDERS2_s8_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:8, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s8 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s9_m_QUERY18_mORDERS2 : { ra:collection {
  ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int,
  value:int }, rc:int, rd:int, re:string, rf:real, rg:int, rh:string,
  ri:string, rj:int, rk:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
  rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
  ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mORDERS2_s9_buf as ind
   map_QUERY18_mORDERS2_s9_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mORDERS2_s9_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mORDERS2_s9_buf_d.update vals tuple}
       {None -> map_QUERY18_mORDERS2_s9_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:9, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s9 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s11_m_QUERY18_mORDERS2 : { ra:collection {
  ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int,
  value:int }, rc:int, rd:int, re:string, rf:real, rg:int, rh:string,
  ri:string, rj:int, rk:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
  rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
  ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mORDERS2_s11_buf as ind
   map_QUERY18_mORDERS2_s11_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mORDERS2_s11_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mORDERS2_s11_buf_d.update vals tuple}
       {None -> map_QUERY18_mORDERS2_s11_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:11, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s11 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s11_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s11_buf as
   ind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s11_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mCUSTOMER1_L1_1_L1_1_s11_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek
       ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s11_buf_d.update vals
         tuple}{None -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s11_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:11, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s11 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s12_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s12_buf as
   ind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s12_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mCUSTOMER1_L1_1_L1_1_s12_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek
       ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s12_buf_d.update vals
         tuple}{None -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s12_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:12, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s12 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_do_complete_s10_trig : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int,
  rj:string } = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY,
  rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
  rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
  ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in 
  nd_insert_ORDERS_do_complete_s10 {ra:vid, rb:ORDERS_ORDERKEY,
    rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
    rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
    ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT})
trigger insert_ORDERS_rcv_corrective_s8_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  key:int, value:real } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_float {ra:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s8_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:8}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s8_m_QUERY18_mCUSTOMER1_L1_1_L1_1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s8_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  key:int, value:int } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_QUERY18_mCUSTOMER1_L1_2_s8_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:8}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s8_m_QUERY18_mCUSTOMER1_L1_2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s8_m_QUERY18_mORDERS2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { key:int,
  value:int } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_QUERY18_mORDERS2_s8_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:8}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s8_m_QUERY18_mORDERS2 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid,
             rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
             ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s9_m_QUERY18_mORDERS2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { key:int,
  value:int } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_QUERY18_mORDERS2_s9_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:9}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s9_m_QUERY18_mORDERS2 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid,
             rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
             ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s11_m_QUERY18_mORDERS2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { key:int,
  value:int } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_QUERY18_mORDERS2_s11_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:11}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s11_m_QUERY18_mORDERS2 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid,
             rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
             ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s11_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  key:int, value:real } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_float {ra:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s11_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:11}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s11_m_QUERY18_mCUSTOMER1_L1_1_L1_1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s12_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  key:int, value:real } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_float {ra:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s12_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:12}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s12_m_QUERY18_mCUSTOMER1_L1_1_L1_1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger nd_delete_ORDERS_rcv_put : { ra:address, rb:collection { key:int,
  value:int } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:int,
  rf:string, rg:real, rh:int, ri:string, rj:string, rk:int, rl:string } =
  (\b1 -> bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid,
  rd:ORDERS_ORDERKEY, re:ORDERS_CUSTKEY, rf:ORDERS_ORDERSTATUS,
  rg:ORDERS_TOTALPRICE, rh:ORDERS_ORDERDATE, ri:ORDERS_ORDERPRIORITY,
  rj:ORDERS_CLERK, rk:ORDERS_SHIPPRIORITY, rl:ORDERS_COMMENT} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 17
     then
       nd_delete_ORDERS_do_complete_s17 {ra:vid, rb:ORDERS_ORDERKEY,
         rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
         rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
         ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
     else if stmt_id == 16
       then
         nd_delete_ORDERS_do_complete_s16 {ra:vid, rb:ORDERS_ORDERKEY,
           rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
           rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
           ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
       else if stmt_id == 15
         then
           nd_delete_ORDERS_do_complete_s15 {ra:vid, rb:ORDERS_ORDERKEY,
             rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
             rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
             ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
         else if stmt_id == 14
           then
             nd_delete_ORDERS_do_complete_s14 {ra:vid, rb:ORDERS_ORDERKEY,
               rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
               rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
               ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
           else if stmt_id == 13
             then
               nd_delete_ORDERS_do_complete_s13 {ra:vid, rb:ORDERS_ORDERKEY,
                 rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
                 re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
                 rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
                 ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else () else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_delete_ORDERS_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 13
   then if map_id == 7
     then
       (nd_delete_ORDERS_send_push_s13_m_QUERY18_mCUSTOMER1_L1_1_L1_1, me)<- {ra:vid,
       rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
       re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
       rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
     else if map_id == 8
       then
         (nd_delete_ORDERS_send_push_s13_m_QUERY18_mCUSTOMER1_L1_2, me)<- {ra:vid,
         rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
         re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
         rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
       else if map_id == 5
         then
           (nd_delete_ORDERS_send_push_s13_m_QUERY18_mORDERS2, me)<- {ra:vid,
           rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
           re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
           rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 14
     then if map_id == 5
       then (nd_delete_ORDERS_send_push_s14_m_QUERY18_mORDERS2, me)<- {ra:vid,
         rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
         re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
         rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 16
       then if map_id == 5
         then
           (nd_delete_ORDERS_send_push_s16_m_QUERY18_mORDERS2, me)<- {ra:vid,
           rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
           re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
           rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
         else if map_id == 7
           then
             (nd_delete_ORDERS_send_push_s16_m_QUERY18_mCUSTOMER1_L1_1_L1_1,
               me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
             rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
             rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
             rj:ORDERS_COMMENT}
           else error (print "nd_rcv_fetch: invalid map id")
       else if stmt_id == 17
         then if map_id == 7
           then
             (nd_delete_ORDERS_send_push_s17_m_QUERY18_mCUSTOMER1_L1_1_L1_1,
               me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
             rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
             rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
             rj:ORDERS_COMMENT}
           else error (print "nd_rcv_fetch: invalid map id")
         else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_delete_ORDERS_send_push_s13_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  QUERY18_mCUSTOMER1_L1_1_L1_1 as ind QUERY18_mCUSTOMER1_L1_1_L1_1_deref in
  ((nd_log_master_write {key:vid, value:13});
   (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18 {ra:Some ORDERS_CUSTKEY,
      rb:frontier_int_float {key:vid,
           value:QUERY18_mCUSTOMER1_L1_1_L1_1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))},
      rc:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s13_m_QUERY18_mCUSTOMER1_L1_1_L1_1, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_send_push_s13_m_QUERY18_mCUSTOMER1_L1_2 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  QUERY18_mCUSTOMER1_L1_2 as ind QUERY18_mCUSTOMER1_L1_2_deref in
  ((nd_log_master_write {key:vid, value:13});
   (shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18 {ra:Some ORDERS_CUSTKEY,
      rb:frontier_int_int {key:vid, value:QUERY18_mCUSTOMER1_L1_2_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc} in rb ==
           ORDERS_ORDERKEY))}, rc:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s13_m_QUERY18_mCUSTOMER1_L1_2, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_send_push_s13_m_QUERY18_mORDERS2 : { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  QUERY18_mORDERS2 as ind QUERY18_mORDERS2_deref in
  ((nd_log_master_write {key:vid, value:13});
   (shuffle_QUERY18_mORDERS2_to_QUERY18_bind_0t0 {ra:Some ORDERS_CUSTKEY,
      rb:frontier_int_int {key:vid, value:QUERY18_mORDERS2_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))},
      rc:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s13_m_QUERY18_mORDERS2, ip)<- {ra:tuples, rb:vid,
   rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_send_push_s14_m_QUERY18_mORDERS2 : { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  QUERY18_mORDERS2 as ind QUERY18_mORDERS2_deref in
  ((nd_log_master_write {key:vid, value:14});
   (shuffle_QUERY18_mORDERS2_to_QUERY18_mLINEITEM2_bind_0t0
      {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
      rc:frontier_int_int {key:vid, value:QUERY18_mORDERS2_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))},
      rd:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s14_m_QUERY18_mORDERS2, ip)<- {ra:tuples, rb:vid,
   rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_send_push_s16_m_QUERY18_mORDERS2 : { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  QUERY18_mORDERS2 as ind QUERY18_mORDERS2_deref in
  ((nd_log_master_write {key:vid, value:16});
   (shuffle_QUERY18_mORDERS2_to_QUERY18_mLINEITEM5_bind_0t0
      {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
      rc:frontier_int_int {key:vid, value:QUERY18_mORDERS2_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_CUSTKEY))},
      rd:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s16_m_QUERY18_mORDERS2, ip)<- {ra:tuples, rb:vid,
   rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_send_push_s16_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  QUERY18_mCUSTOMER1_L1_1_L1_1 as ind QUERY18_mCUSTOMER1_L1_1_L1_1_deref in
  ((nd_log_master_write {key:vid, value:16});
   (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18_mLINEITEM5_bind_1t0
      {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
      rc:frontier_int_float {key:vid,
           value:QUERY18_mCUSTOMER1_L1_1_L1_1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))},
      rd:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s16_m_QUERY18_mCUSTOMER1_L1_1_L1_1, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_send_push_s17_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  QUERY18_mCUSTOMER1_L1_1_L1_1 as ind QUERY18_mCUSTOMER1_L1_1_L1_1_deref in
  ((nd_log_master_write {key:vid, value:17});
   (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18_mCUSTOMER1_bind_1t0
      {ra:Some ORDERS_CUSTKEY, rb:Some ORDERS_ORDERKEY,
      rc:frontier_int_float {key:vid,
           value:QUERY18_mCUSTOMER1_L1_1_L1_1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == ORDERS_ORDERKEY))},
      rd:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s17_m_QUERY18_mCUSTOMER1_L1_1_L1_1, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_rcv_push_s13_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf as
   ind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek
       ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf_d.update vals
         tuple}{None -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:13, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s13 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_rcv_push_s13_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection },
  rb:{ key:int, value:int }, rc:int, rd:int, re:string, rf:real, rg:int,
  rh:string, ri:string, rj:int, rk:string } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
  rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
  ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_L1_2_s13_buf as ind
   map_QUERY18_mCUSTOMER1_L1_2_s13_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mCUSTOMER1_L1_2_s13_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek
       ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_L1_2_s13_buf_d.update vals tuple}
       {None -> map_QUERY18_mCUSTOMER1_L1_2_s13_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:13, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s13 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_rcv_push_s13_m_QUERY18_mORDERS2 : { ra:collection {
  ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int,
  value:int }, rc:int, rd:int, re:string, rf:real, rg:int, rh:string,
  ri:string, rj:int, rk:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
  rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
  ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mORDERS2_s13_buf as ind
   map_QUERY18_mORDERS2_s13_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mORDERS2_s13_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mORDERS2_s13_buf_d.update vals tuple}
       {None -> map_QUERY18_mORDERS2_s13_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:13, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s13 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_rcv_push_s14_m_QUERY18_mORDERS2 : { ra:collection {
  ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int,
  value:int }, rc:int, rd:int, re:string, rf:real, rg:int, rh:string,
  ri:string, rj:int, rk:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
  rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
  ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mORDERS2_s14_buf as ind
   map_QUERY18_mORDERS2_s14_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mORDERS2_s14_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mORDERS2_s14_buf_d.update vals tuple}
       {None -> map_QUERY18_mORDERS2_s14_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:14, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s14 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_rcv_push_s16_m_QUERY18_mORDERS2 : { ra:collection {
  ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection }, rb:{ key:int,
  value:int }, rc:int, rd:int, re:string, rf:real, rg:int, rh:string,
  ri:string, rj:int, rk:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
  rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
  ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mORDERS2_s16_buf as ind
   map_QUERY18_mORDERS2_s16_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mORDERS2_s16_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mORDERS2_s16_buf_d.update vals tuple}
       {None -> map_QUERY18_mORDERS2_s16_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:16, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s16 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_rcv_push_s16_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s16_buf as
   ind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s16_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mCUSTOMER1_L1_1_L1_1_s16_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek
       ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s16_buf_d.update vals
         tuple}{None -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s16_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:16, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s16 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_rcv_push_s17_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s17_buf as
   ind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s17_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mCUSTOMER1_L1_1_L1_1_s17_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek
       ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s17_buf_d.update vals
         tuple}{None -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s17_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:17, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s17 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_do_complete_s15_trig : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int,
  rj:string } = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY,
  rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
  rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
  ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in 
  nd_delete_ORDERS_do_complete_s15 {ra:vid, rb:ORDERS_ORDERKEY,
    rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
    rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
    ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT})
trigger delete_ORDERS_rcv_corrective_s13_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  key:int, value:real } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_float {ra:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s13_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:13}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s13_m_QUERY18_mCUSTOMER1_L1_1_L1_1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_ORDERS_rcv_corrective_s13_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  key:int, value:int } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_QUERY18_mCUSTOMER1_L1_2_s13_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:13}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s13_m_QUERY18_mCUSTOMER1_L1_2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_ORDERS_rcv_corrective_s13_m_QUERY18_mORDERS2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { key:int,
  value:int } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_QUERY18_mORDERS2_s13_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:13}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s13_m_QUERY18_mORDERS2 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid,
             rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
             ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_ORDERS_rcv_corrective_s14_m_QUERY18_mORDERS2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { key:int,
  value:int } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_QUERY18_mORDERS2_s14_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:14}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s14_m_QUERY18_mORDERS2 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid,
             rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
             ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_ORDERS_rcv_corrective_s16_m_QUERY18_mORDERS2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { key:int,
  value:int } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_QUERY18_mORDERS2_s16_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:16}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s16_m_QUERY18_mORDERS2 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid,
             rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
             ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_ORDERS_rcv_corrective_s16_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  key:int, value:real } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_float {ra:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s16_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:16}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s16_m_QUERY18_mCUSTOMER1_L1_1_L1_1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_ORDERS_rcv_corrective_s17_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  key:int, value:real } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_float {ra:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s17_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:17}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s17_m_QUERY18_mCUSTOMER1_L1_1_L1_1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger nd_insert_LINEITEM_rcv_put : { ra:address, rb:collection { key:int,
  value:int } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:int,
  rf:int, rg:int, rh:real, ri:real, rj:real, rk:real, rl:string, rm:string,
  rn:int, ro:int, rp:int, rq:string, rr:string, rs:string } = (\b1 ->
  bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid, rd:LINEITEM_ORDERKEY,
  re:LINEITEM_PARTKEY, rf:LINEITEM_SUPPKEY, rg:LINEITEM_LINENUMBER,
  rh:LINEITEM_QUANTITY, ri:LINEITEM_EXTENDEDPRICE, rj:LINEITEM_DISCOUNT,
  rk:LINEITEM_TAX, rl:LINEITEM_RETURNFLAG, rm:LINEITEM_LINESTATUS,
  rn:LINEITEM_SHIPDATE, ro:LINEITEM_COMMITDATE, rp:LINEITEM_RECEIPTDATE,
  rq:LINEITEM_SHIPINSTRUCT, rr:LINEITEM_SHIPMODE, rs:LINEITEM_COMMENT} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 22
     then
       nd_insert_LINEITEM_do_complete_s22 {ra:vid, rb:LINEITEM_ORDERKEY,
         rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
         rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
         ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
         rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
         ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
     else if stmt_id == 21
       then
         nd_insert_LINEITEM_do_complete_s21 {ra:vid, rb:LINEITEM_ORDERKEY,
           rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
           rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
           rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
           rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
           rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
           ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
       else if stmt_id == 20
         then
           nd_insert_LINEITEM_do_complete_s20 {ra:vid, rb:LINEITEM_ORDERKEY,
             rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
             rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
             rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
             rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
             rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
             ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
             rq:LINEITEM_COMMENT}
         else if stmt_id == 19
           then
             nd_insert_LINEITEM_do_complete_s19 {ra:vid, rb:LINEITEM_ORDERKEY,
               rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
               re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
               rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
               ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
               rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
               rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
               rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
           else if stmt_id == 18
             then
               nd_insert_LINEITEM_do_complete_s18 {ra:vid,
                 rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                 rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                 rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                 rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
                 rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                 rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
                 ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                 rq:LINEITEM_COMMENT} else () else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_insert_LINEITEM_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:LINEITEM_ORDERKEY,
  rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER,
  rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT,
  rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS,
  rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE,
  rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 18
   then if map_id == 2
     then
       (nd_insert_LINEITEM_send_push_s18_m_QUERY18_mLINEITEM2, me)<- {ra:vid,
       rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
       re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
       rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
       rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
       rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
       rq:LINEITEM_COMMENT}
     else if map_id == 7
       then
         (nd_insert_LINEITEM_send_push_s18_m_QUERY18_mCUSTOMER1_L1_1_L1_1, me)<- {ra:vid,
         rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
         re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
         rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
         rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
         rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
         ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
       else if map_id == 8
         then
           (nd_insert_LINEITEM_send_push_s18_m_QUERY18_mCUSTOMER1_L1_2, me)<- {ra:vid,
           rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
           re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
           rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
           rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
           rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
           rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
           rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 19
     then if map_id == 2
       then
         (nd_insert_LINEITEM_send_push_s19_m_QUERY18_mLINEITEM2, me)<- {ra:vid,
         rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
         re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
         rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
         rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
         rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
         ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 20
       then if map_id == 3
         then
           (nd_insert_LINEITEM_send_push_s20_m_QUERY18_mLINEITEM2_mCUSTOMER1,
             me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
           rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
           rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
           rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
           rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
           rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
           rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
       else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_insert_LINEITEM_send_push_s18_m_QUERY18_mLINEITEM2 : { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real,
  ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string,
  rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  QUERY18_mLINEITEM2 as ind QUERY18_mLINEITEM2_deref in
  ((nd_log_master_write {key:vid, value:18});
   (shuffle_QUERY18_mLINEITEM2_to_QUERY18_bind_0t0 {ra:None immut,
      rb:frontier_int_int_int {key:vid, value:QUERY18_mLINEITEM2_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc ==
           LINEITEM_ORDERKEY))}, rc:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s18_m_QUERY18_mLINEITEM2, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s18_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  QUERY18_mCUSTOMER1_L1_1_L1_1 as ind QUERY18_mCUSTOMER1_L1_1_L1_1_deref in
  ((nd_log_master_write {key:vid, value:18});
   (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18 {ra:None immut,
      rb:frontier_int_float {key:vid,
           value:QUERY18_mCUSTOMER1_L1_1_L1_1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))},
      rc:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s18_m_QUERY18_mCUSTOMER1_L1_1_L1_1, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s18_m_QUERY18_mCUSTOMER1_L1_2 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  QUERY18_mCUSTOMER1_L1_2 as ind QUERY18_mCUSTOMER1_L1_2_deref in
  ((nd_log_master_write {key:vid, value:18});
   (shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18 {ra:None immut,
      rb:frontier_int_int {key:vid, value:QUERY18_mCUSTOMER1_L1_2_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc} in rb ==
           LINEITEM_ORDERKEY))}, rc:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s18_m_QUERY18_mCUSTOMER1_L1_2, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s19_m_QUERY18_mLINEITEM2 : { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real,
  ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string,
  rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  QUERY18_mLINEITEM2 as ind QUERY18_mLINEITEM2_deref in
  ((nd_log_master_write {key:vid, value:19});
   (shuffle_QUERY18_mLINEITEM2_to_QUERY18_mLINEITEM5_bind_0t0_1t1
      {ra:None immut, rb:Some LINEITEM_ORDERKEY,
      rc:frontier_int_int_int {key:vid, value:QUERY18_mLINEITEM2_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc ==
           LINEITEM_ORDERKEY))}, rd:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s19_m_QUERY18_mLINEITEM2, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s20_m_QUERY18_mLINEITEM2_mCUSTOMER1 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  QUERY18_mLINEITEM2_mCUSTOMER1 as ind QUERY18_mLINEITEM2_mCUSTOMER1_deref in
  ((nd_log_master_write {key:vid, value:20});
   (shuffle_QUERY18_mLINEITEM2_mCUSTOMER1_to_QUERY18_mCUSTOMER1_bind_0t0_1t1
      {ra:None immut, rb:Some LINEITEM_ORDERKEY,
      rc:frontier_int_int_int {key:vid,
           value:QUERY18_mLINEITEM2_mCUSTOMER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc ==
           LINEITEM_ORDERKEY))}, rd:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s20_m_QUERY18_mLINEITEM2_mCUSTOMER1, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_rcv_push_s18_m_QUERY18_mLINEITEM2 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mLINEITEM2_s18_buf as ind
   map_QUERY18_mLINEITEM2_s18_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_QUERY18_mLINEITEM2_s18_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mLINEITEM2_s18_buf_d.update vals tuple}
       {None -> map_QUERY18_mLINEITEM2_s18_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:18, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s18 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_rcv_push_s18_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf as
   ind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek
       ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf_d.update vals
         tuple}{None -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:18, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s18 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_rcv_push_s18_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection },
  rb:{ key:int, value:int }, rc:int, rd:int, re:int, rf:int, rg:real, rh:real,
  ri:real, rj:real, rk:string, rl:string, rm:int, rn:int, ro:int, rp:string,
  rq:string, rr:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
  rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
  ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
  rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
  ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
  rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_L1_2_s18_buf as ind
   map_QUERY18_mCUSTOMER1_L1_2_s18_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mCUSTOMER1_L1_2_s18_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek
       ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_L1_2_s18_buf_d.update vals tuple}
       {None -> map_QUERY18_mCUSTOMER1_L1_2_s18_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:18, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s18 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_rcv_push_s19_m_QUERY18_mLINEITEM2 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mLINEITEM2_s19_buf as ind
   map_QUERY18_mLINEITEM2_s19_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_QUERY18_mLINEITEM2_s19_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mLINEITEM2_s19_buf_d.update vals tuple}
       {None -> map_QUERY18_mLINEITEM2_s19_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:19, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s19 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_rcv_push_s20_m_QUERY18_mLINEITEM2_mCUSTOMER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mLINEITEM2_mCUSTOMER1_s20_buf as
   ind map_QUERY18_mLINEITEM2_mCUSTOMER1_s20_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_QUERY18_mLINEITEM2_mCUSTOMER1_s20_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2)
       and rb == _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mLINEITEM2_mCUSTOMER1_s20_buf_d.update vals
         tuple}{None -> map_QUERY18_mLINEITEM2_mCUSTOMER1_s20_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:20, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s20 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_do_complete_s21_trig : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
  rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
  rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
  rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
  rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
  rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in 
  nd_insert_LINEITEM_do_complete_s21 {ra:vid, rb:LINEITEM_ORDERKEY,
    rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
    rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
    ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
    rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
    ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT})
trigger nd_insert_LINEITEM_do_complete_s22_trig : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
  rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
  rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
  rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
  rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
  rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in 
  nd_insert_LINEITEM_do_complete_s22 {ra:vid, rb:LINEITEM_ORDERKEY,
    rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
    rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
    ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
    rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
    ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT})
trigger insert_LINEITEM_rcv_corrective_s18_m_QUERY18_mLINEITEM2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { ra:int,
  rb:int, rc:int } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_QUERY18_mLINEITEM2_s18_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:18}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s18_m_QUERY18_mLINEITEM2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s18_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  key:int, value:real } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_float {ra:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s18_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:18}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s18_m_QUERY18_mCUSTOMER1_L1_1_L1_1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s18_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  key:int, value:int } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_QUERY18_mCUSTOMER1_L1_2_s18_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:18}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s18_m_QUERY18_mCUSTOMER1_L1_2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s19_m_QUERY18_mLINEITEM2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { ra:int,
  rb:int, rc:int } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_QUERY18_mLINEITEM2_s19_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:19}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s19_m_QUERY18_mLINEITEM2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s20_m_QUERY18_mLINEITEM2_mCUSTOMER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_QUERY18_mLINEITEM2_mCUSTOMER1_s20_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:20}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s20_m_QUERY18_mLINEITEM2_mCUSTOMER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger nd_delete_LINEITEM_rcv_put : { ra:address, rb:collection { key:int,
  value:int } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:int,
  rf:int, rg:int, rh:real, ri:real, rj:real, rk:real, rl:string, rm:string,
  rn:int, ro:int, rp:int, rq:string, rr:string, rs:string } = (\b1 ->
  bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid, rd:LINEITEM_ORDERKEY,
  re:LINEITEM_PARTKEY, rf:LINEITEM_SUPPKEY, rg:LINEITEM_LINENUMBER,
  rh:LINEITEM_QUANTITY, ri:LINEITEM_EXTENDEDPRICE, rj:LINEITEM_DISCOUNT,
  rk:LINEITEM_TAX, rl:LINEITEM_RETURNFLAG, rm:LINEITEM_LINESTATUS,
  rn:LINEITEM_SHIPDATE, ro:LINEITEM_COMMITDATE, rp:LINEITEM_RECEIPTDATE,
  rq:LINEITEM_SHIPINSTRUCT, rr:LINEITEM_SHIPMODE, rs:LINEITEM_COMMENT} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 27
     then
       nd_delete_LINEITEM_do_complete_s27 {ra:vid, rb:LINEITEM_ORDERKEY,
         rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
         rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
         ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
         rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
         ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
     else if stmt_id == 26
       then
         nd_delete_LINEITEM_do_complete_s26 {ra:vid, rb:LINEITEM_ORDERKEY,
           rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
           rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
           rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
           rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
           rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
           ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
       else if stmt_id == 25
         then
           nd_delete_LINEITEM_do_complete_s25 {ra:vid, rb:LINEITEM_ORDERKEY,
             rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
             rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
             rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
             rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
             rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
             ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
             rq:LINEITEM_COMMENT}
         else if stmt_id == 24
           then
             nd_delete_LINEITEM_do_complete_s24 {ra:vid, rb:LINEITEM_ORDERKEY,
               rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
               re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
               rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
               ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
               rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
               rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
               rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
           else if stmt_id == 23
             then
               nd_delete_LINEITEM_do_complete_s23 {ra:vid,
                 rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                 rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                 rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                 rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
                 rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                 rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
                 ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                 rq:LINEITEM_COMMENT} else () else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_delete_LINEITEM_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:LINEITEM_ORDERKEY,
  rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER,
  rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT,
  rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS,
  rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE,
  rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 23
   then if map_id == 2
     then
       (nd_delete_LINEITEM_send_push_s23_m_QUERY18_mLINEITEM2, me)<- {ra:vid,
       rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
       re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
       rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
       rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
       rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
       rq:LINEITEM_COMMENT}
     else if map_id == 7
       then
         (nd_delete_LINEITEM_send_push_s23_m_QUERY18_mCUSTOMER1_L1_1_L1_1, me)<- {ra:vid,
         rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
         re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
         rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
         rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
         rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
         ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
       else if map_id == 8
         then
           (nd_delete_LINEITEM_send_push_s23_m_QUERY18_mCUSTOMER1_L1_2, me)<- {ra:vid,
           rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
           re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
           rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
           rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
           rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
           rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
           rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
         else if map_id == 4
           then
             (nd_delete_LINEITEM_send_push_s23_m_QUERY18_mLINEITEM5, me)<- {ra:vid,
             rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
             re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
             rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
             rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
             rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
             rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
             rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
           else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 24
     then if map_id == 2
       then
         (nd_delete_LINEITEM_send_push_s24_m_QUERY18_mLINEITEM2, me)<- {ra:vid,
         rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
         re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
         rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
         rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
         rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
         ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 25
       then if map_id == 3
         then
           (nd_delete_LINEITEM_send_push_s25_m_QUERY18_mLINEITEM2_mCUSTOMER1,
             me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
           rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
           rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
           rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
           rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
           rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
           rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
       else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_delete_LINEITEM_send_push_s23_m_QUERY18_mLINEITEM2 : { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real,
  ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string,
  rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  QUERY18_mLINEITEM2 as ind QUERY18_mLINEITEM2_deref in
  ((nd_log_master_write {key:vid, value:23});
   (shuffle_QUERY18_mLINEITEM2_to_QUERY18_bind_0t0 {ra:None immut,
      rb:frontier_int_int_int {key:vid, value:QUERY18_mLINEITEM2_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc ==
           LINEITEM_ORDERKEY))}, rc:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s23_m_QUERY18_mLINEITEM2, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_send_push_s23_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  QUERY18_mCUSTOMER1_L1_1_L1_1 as ind QUERY18_mCUSTOMER1_L1_1_L1_1_deref in
  ((nd_log_master_write {key:vid, value:23});
   (shuffle_QUERY18_mCUSTOMER1_L1_1_L1_1_to_QUERY18 {ra:None immut,
      rb:frontier_int_float {key:vid,
           value:QUERY18_mCUSTOMER1_L1_1_L1_1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc} in rb == LINEITEM_ORDERKEY))},
      rc:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s23_m_QUERY18_mCUSTOMER1_L1_1_L1_1, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_send_push_s23_m_QUERY18_mCUSTOMER1_L1_2 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  QUERY18_mCUSTOMER1_L1_2 as ind QUERY18_mCUSTOMER1_L1_2_deref in
  ((nd_log_master_write {key:vid, value:23});
   (shuffle_QUERY18_mCUSTOMER1_L1_2_to_QUERY18 {ra:None immut,
      rb:frontier_int_int {key:vid, value:QUERY18_mCUSTOMER1_L1_2_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc} in rb ==
           LINEITEM_ORDERKEY))}, rc:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s23_m_QUERY18_mCUSTOMER1_L1_2, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_send_push_s23_m_QUERY18_mLINEITEM5 : { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real,
  ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string,
  rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  QUERY18_mLINEITEM5 as ind QUERY18_mLINEITEM5_deref in
  ((nd_log_master_write {key:vid, value:23});
   (shuffle_QUERY18_mLINEITEM5_to_QUERY18_bind_0t0 {ra:None immut,
      rb:frontier_int_int_float {key:vid, value:QUERY18_mLINEITEM5_deref},
      rc:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s23_m_QUERY18_mLINEITEM5, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_send_push_s24_m_QUERY18_mLINEITEM2 : { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real,
  ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string,
  rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  QUERY18_mLINEITEM2 as ind QUERY18_mLINEITEM2_deref in
  ((nd_log_master_write {key:vid, value:24});
   (shuffle_QUERY18_mLINEITEM2_to_QUERY18_mLINEITEM5_bind_0t0_1t1
      {ra:None immut, rb:Some LINEITEM_ORDERKEY,
      rc:frontier_int_int_int {key:vid, value:QUERY18_mLINEITEM2_deref.filter
           ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc ==
           LINEITEM_ORDERKEY))}, rd:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s24_m_QUERY18_mLINEITEM2, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_send_push_s25_m_QUERY18_mLINEITEM2_mCUSTOMER1 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  QUERY18_mLINEITEM2_mCUSTOMER1 as ind QUERY18_mLINEITEM2_mCUSTOMER1_deref in
  ((nd_log_master_write {key:vid, value:25});
   (shuffle_QUERY18_mLINEITEM2_mCUSTOMER1_to_QUERY18_mCUSTOMER1_bind_0t0_1t1
      {ra:None immut, rb:Some LINEITEM_ORDERKEY,
      rc:frontier_int_int_int {key:vid,
           value:QUERY18_mLINEITEM2_mCUSTOMER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc ==
           LINEITEM_ORDERKEY))}, rd:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s25_m_QUERY18_mLINEITEM2_mCUSTOMER1, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_rcv_push_s23_m_QUERY18_mLINEITEM2 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mLINEITEM2_s23_buf as ind
   map_QUERY18_mLINEITEM2_s23_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_QUERY18_mLINEITEM2_s23_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mLINEITEM2_s23_buf_d.update vals tuple}
       {None -> map_QUERY18_mLINEITEM2_s23_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:23, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s23 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_rcv_push_s23_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf as
   ind map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek
       ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf_d.update vals
         tuple}{None -> map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:23, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s23 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_rcv_push_s23_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int } @ { Collection },
  rb:{ key:int, value:int }, rc:int, rd:int, re:int, rf:int, rg:real, rh:real,
  ri:real, rj:real, rk:string, rl:string, rm:int, rn:int, ro:int, rp:string,
  rq:string, rr:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid,
  rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
  rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
  ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
  rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
  ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
  rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mCUSTOMER1_L1_2_s23_buf as ind
   map_QUERY18_mCUSTOMER1_L1_2_s23_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2} in
     case ((map_QUERY18_mCUSTOMER1_L1_2_s23_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc} in ra == _tup0 and rb == _tup1))).peek
       ()) of
       {Some vals -> map_QUERY18_mCUSTOMER1_L1_2_s23_buf_d.update vals tuple}
       {None -> map_QUERY18_mCUSTOMER1_L1_2_s23_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:23, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s23 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_rcv_push_s23_m_QUERY18_mLINEITEM5 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mLINEITEM5_s23_buf as ind
   map_QUERY18_mLINEITEM5_s23_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_QUERY18_mLINEITEM5_s23_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mLINEITEM5_s23_buf_d.update vals tuple}
       {None -> map_QUERY18_mLINEITEM5_s23_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:23, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s23 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_rcv_push_s24_m_QUERY18_mLINEITEM2 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mLINEITEM2_s24_buf as ind
   map_QUERY18_mLINEITEM2_s24_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_QUERY18_mLINEITEM2_s24_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mLINEITEM2_s24_buf_d.update vals tuple}
       {None -> map_QUERY18_mLINEITEM2_s24_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:24, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s24 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_rcv_push_s25_m_QUERY18_mLINEITEM2_mCUSTOMER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY18_mLINEITEM2_mCUSTOMER1_s25_buf as
   ind map_QUERY18_mLINEITEM2_mCUSTOMER1_s25_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_QUERY18_mLINEITEM2_mCUSTOMER1_s25_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2)
       and rb == _tup1))).peek ()) of
       {Some vals -> map_QUERY18_mLINEITEM2_mCUSTOMER1_s25_buf_d.update vals
         tuple}{None -> map_QUERY18_mLINEITEM2_mCUSTOMER1_s25_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:25, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s25 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_do_complete_s26_trig : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
  rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
  rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
  rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
  rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
  rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in 
  nd_delete_LINEITEM_do_complete_s26 {ra:vid, rb:LINEITEM_ORDERKEY,
    rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
    rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
    ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
    rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
    ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT})
trigger nd_delete_LINEITEM_do_complete_s27_trig : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
  rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
  rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
  rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
  rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
  rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in 
  nd_delete_LINEITEM_do_complete_s27 {ra:vid, rb:LINEITEM_ORDERKEY,
    rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
    rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
    ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
    rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
    ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT})
trigger delete_LINEITEM_rcv_corrective_s23_m_QUERY18_mLINEITEM2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { ra:int,
  rb:int, rc:int } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_QUERY18_mLINEITEM2_s23_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:23}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s23_m_QUERY18_mLINEITEM2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_LINEITEM_rcv_corrective_s23_m_QUERY18_mCUSTOMER1_L1_1_L1_1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  key:int, value:real } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_float {ra:map_QUERY18_mCUSTOMER1_L1_1_L1_1_s23_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:23}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s23_m_QUERY18_mCUSTOMER1_L1_1_L1_1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_LINEITEM_rcv_corrective_s23_m_QUERY18_mCUSTOMER1_L1_2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  key:int, value:int } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int {ra:map_QUERY18_mCUSTOMER1_L1_2_s23_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:23}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s23_m_QUERY18_mCUSTOMER1_L1_2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_LINEITEM_rcv_corrective_s23_m_QUERY18_mLINEITEM5 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { ra:int,
  rb:int, rc:real } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_float {ra:map_QUERY18_mLINEITEM5_s23_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:23}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s23_m_QUERY18_mLINEITEM5
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_LINEITEM_rcv_corrective_s24_m_QUERY18_mLINEITEM2 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { ra:int,
  rb:int, rc:int } @ { Collection } } = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:compute_vids,
  rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_QUERY18_mLINEITEM2_s24_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:24}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s24_m_QUERY18_mLINEITEM2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_LINEITEM_rcv_corrective_s25_m_QUERY18_mLINEITEM2_mCUSTOMER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_QUERY18_mLINEITEM2_mCUSTOMER1_s25_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:25}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s25_m_QUERY18_mLINEITEM2_mCUSTOMER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))


source master : () = value(())feed master |> ms_send_addr_self


source switch : { ra:string, rb:int, rc:real, rd:string, re:int, rf:string,
rg:string, rh:string, ri:string, rj:string, rk:int, rl:real, rm:real, rn:int,
ro:string, rp:string, rq:string, rr:string, rs:int, rt:string, ru:int,
rv:string, rw:string, rx:int, ry:string, rz:real, rza:string, rzb:int,
rzc:real, rzd:string, rze:string, rzf:string, rzg:string, rzh:int, rzi:int,
rzj:int, rzk:real, rzl:real, rzm:real, rzn:string
} = file "/k3/K3/temp/tpch18a.csv" psvfeed switch |> sw_demux








