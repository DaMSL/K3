include "Core/Builtins.k3"
include "Annotation/Map.k3"
include "Annotation/Set.k3"
include "Annotation/Seq.k3"
declare my_peers : collection { i:address } @ {Collection} =
  peers.fold (\acc -> (\x -> (acc.insert {i:x.addr}; acc))) empty { i:address} @ Collection
declare ms_rcv_sw_init_ack_cnt : mut int = 0


declare ms_rcv_jobs_ack_cnt : mut int = 0


declare ms_rcv_job_cnt : mut int = 0


declare ms_rcv_node_done_cnt : mut int = 0


declare ms_rcv_switch_done_cnt : mut int = 0


declare g_init_vid : { key:int, value:int } = {key:0, value:0}


declare g_min_vid : { key:int, value:int } = {key:0, value:0}


declare g_max_vid : { key:int, value:int } = {key:get_max_int (),
  value:get_max_int ()}


declare g_start_vid : { key:int, value:int } = {key:0, value:1}


declare job_master : int = 0


declare job_switch : int = 1


declare job_node : int = 2


declare job_timer : int = 3


declare job : mut int = if role == "master" then job_master
  else if role == "switch" then job_switch
    else if role == "node" then job_node
      else if role == "timer" then job_timer
        else error (print "failed to find proper role")


declare jobs : mut collection { key:address, value:int } @ { Map }


declare master_addr : mut address


declare timer_addr : mut address


declare nodes : mut collection {i:address} @ { Collection }


declare switches : mut collection {i:address} @ { Collection }


declare num_peers : mut int = my_peers.size ()


declare num_switches : mut int


declare num_nodes : mut int


declare map_ids : collection { r1:int, r2:string, r3:int } @ { Collection } =
  {| r1:int, r2:string, r3:int | {r1:1, r2:"QUERY3", r3:4}, {r1:2,
  r2:"QUERY3_mLINEITEM1", r3:4}, {r1:3, r2:"QUERY3_mLINEITEM1_mCUSTOMER2",
  r3:5}, {r1:4, r2:"QUERY3_mORDERS1", r3:2}, {r1:5, r2:"QUERY3_mORDERS3",
  r3:2}, {r1:6, r2:"QUERY3_mORDERS6", r3:2}, {r1:7, r2:"QUERY3_mCUSTOMER2",
  r3:5}, {r1:8, r2:"QUERY3_mCUSTOMER4", r3:5}|} @ { Collection }


declare trig_ids : collection { r1:int, r2:string,
  r3:collection {i:int} @ { Seq } } @ { Collection } = {| r1:int, r2:string,
  r3:collection {i:int} @ { Seq } | {r1:0, r2:"sw_insert_CUSTOMER", r3:{|i:int|
  1, 2, 3, 4, 5, 6, 7, 8|} @ { Seq }}, {r1:4, r2:"sw_insert_LINEITEM",
  r3:{|i:int| 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
  24|} @ { Seq }}, {r1:2, r2:"sw_insert_ORDERS", r3:{|i:int| 25, 26, 27, 28,
  29, 30, 31, 32, 33|} @ { Seq }}|} @ { Collection }


declare nd_stmt_cntrs : collection { key:{ key:{ key:int, value:int },
  value:int }, value:{ key:int, value:collection { key:int, value:int
  } @ { Map } } } @ { Map }


declare nd_log_master : collection { key:{ key:int, value:int }, value:int
  } @ { Set }


declare nd_state_normal : int = 0


declare nd_state_done : int = 1


declare nd_state : mut int = nd_state_normal


declare sw_state_pre_init : int = 0


declare sw_state_idle : int = 1


declare sw_state_sending : int = 2


declare sw_state_wait_vid : int = 3


declare sw_state_done : int = 4


declare sw_state : mut int = sw_state_pre_init


declare sw_trig_buf_idx : collection {i:int} @ { Seq }


declare ms_start_time : mut int


declare ms_end_time : mut int


declare sw_buf_insert_CUSTOMER : collection { r1:int, r2:string, r3:string,
  r4:int, r5:string, r6:real, r7:string, r8:string } @ { Seq }


declare sw_buf_insert_ORDERS : collection { r1:int, r2:int, r3:string, r4:real,
  r5:int, r6:string, r7:string, r8:int, r9:string } @ { Seq }


declare sw_buf_insert_LINEITEM : collection { r1:int, r2:int, r3:int, r4:int,
  r5:real, r6:real, r7:real, r8:real, r9:string, r10:string, r11:int, r12:int,
  r13:int, r14:string, r15:string, r16:string } @ { Seq }


declare nd_log_insert_CUSTOMER : collection { key:{ key:int, value:int },
  value:{ r1:int, r2:string, r3:string, r4:int, r5:string, r6:real, r7:string,
  r8:string } } @ { Map }


declare nd_log_insert_ORDERS : collection { key:{ key:int, value:int }, value:{
  r1:int, r2:int, r3:string, r4:real, r5:int, r6:string, r7:string, r8:int,
  r9:string } } @ { Map }


declare nd_log_insert_LINEITEM : collection { key:{ key:int, value:int },
  value:{ r1:int, r2:int, r3:int, r4:int, r5:real, r6:real, r7:real, r8:real,
  r9:string, r10:string, r11:int, r12:int, r13:int, r14:string, r15:string,
  r16:string } } @ { Map }


declare QUERY3 : ind collection { r1:{ key:int, value:int }, r2:int, r3:int,
  r4:int, r5:real } @ { Set } = ind empty { r1:{ key:int, value:int }, r2:int,
  r3:int, r4:int, r5:real } @ { Set }


declare QUERY3_mLINEITEM1 : ind collection { r1:{ key:int, value:int }, r2:int,
  r3:int, r4:int, r5:int } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:int } @ { Set }


declare QUERY3_mLINEITEM1_mCUSTOMER2 : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set } = ind empty { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set }


declare QUERY3_mORDERS1 : ind collection { r1:{ key:int, value:int }, r2:int,
  r3:int } @ { Set } = ind empty { r1:{ key:int, value:int }, r2:int, r3:int
  } @ { Set }


declare QUERY3_mORDERS3 : ind collection { r1:{ key:int, value:int }, r2:int,
  r3:real } @ { Set } = ind empty { r1:{ key:int, value:int }, r2:int, r3:real
  } @ { Set }


declare QUERY3_mORDERS6 : ind collection { r1:{ key:int, value:int }, r2:int,
  r3:real } @ { Set } = ind empty { r1:{ key:int, value:int }, r2:int, r3:real
  } @ { Set }


declare QUERY3_mCUSTOMER2 : ind collection { r1:{ key:int, value:int }, r2:int,
  r3:int, r4:int, r5:int, r6:real } @ { Set } = ind empty { r1:{ key:int,
  value:int }, r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set }


declare QUERY3_mCUSTOMER4 : ind collection { r1:{ key:int, value:int }, r2:int,
  r3:int, r4:int, r5:int, r6:real } @ { Set } = ind empty { r1:{ key:int,
  value:int }, r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set }


declare map_QUERY3_mCUSTOMER2_s0_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set } = ind empty { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set }


declare map_QUERY3_mCUSTOMER4_s0_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set } = ind empty { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set }


declare map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf : ind collection { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set } =
  ind empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int
  } @ { Set }


declare map_QUERY3_mCUSTOMER2_s3_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set } = ind empty { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set }


declare map_QUERY3_mCUSTOMER4_s3_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set } = ind empty { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set }


declare map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf : ind collection { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set } =
  ind empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int
  } @ { Set }


declare map_QUERY3_mORDERS1_s6_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:int } @ { Set }


declare map_QUERY3_mORDERS3_s6_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:real } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }


declare map_QUERY3_mORDERS6_s6_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:real } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }


declare map_QUERY3_mORDERS1_s7_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:int } @ { Set }


declare map_QUERY3_mORDERS3_s9_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:real } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }


declare map_QUERY3_mORDERS6_s10_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:real } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }


declare map_QUERY3_mORDERS1_s11_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:int } @ { Set }


declare map_QUERY3_mORDERS3_s11_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:real } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }


declare map_QUERY3_mORDERS6_s11_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:real } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }


declare map_QUERY3_mORDERS1_s12_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:int } @ { Set }


declare map_QUERY3_mORDERS3_s14_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:real } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }


declare map_QUERY3_mORDERS6_s15_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:real } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }


declare map_QUERY3_mLINEITEM1_s16_buf : ind collection { r1:{ key:int,
  value:int }, r2:int, r3:int, r4:int, r5:int } @ { Set } = ind empty { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:int } @ { Set }


declare map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf : ind collection { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set } =
  ind empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int
  } @ { Set }


declare map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf : ind collection { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set } =
  ind empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int
  } @ { Set }


declare map_QUERY3_mLINEITEM1_s21_buf : ind collection { r1:{ key:int,
  value:int }, r2:int, r3:int, r4:int, r5:int } @ { Set } = ind empty { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:int } @ { Set }


declare map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf : ind collection { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set } =
  ind empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int
  } @ { Set }


declare map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf : ind collection { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set } =
  ind empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int
  } @ { Set }


declare map_QUERY3_mORDERS3_s36_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:real } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }


declare map_QUERY3_mORDERS6_s36_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:real } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }


declare map_QUERY3_mORDERS3_s38_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:real } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }


declare map_QUERY3_mORDERS6_s38_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:real } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }


declare map_QUERY3_mORDERS1_s40_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:int } @ { Set }


declare map_QUERY3_mORDERS1_s42_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:int } @ { Set }


declare map_QUERY3_mORDERS1_s44_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:int } @ { Set }


declare map_QUERY3_mORDERS1_s46_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:int } @ { Set }


declare map_QUERY3_mORDERS3_s48_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:real } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }


declare map_QUERY3_mORDERS6_s48_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:real } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }


declare map_QUERY3_mORDERS3_s50_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:real } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }


declare map_QUERY3_mORDERS6_s50_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:real } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }


declare map_QUERY3_mORDERS1_s52_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:int } @ { Set }


declare map_QUERY3_mORDERS1_s54_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:int } @ { Set }


declare map_QUERY3_mORDERS1_s56_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:int } @ { Set }


declare map_QUERY3_mORDERS1_s58_buf : ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int } @ { Set } = ind empty { r1:{ key:int, value:int },
  r2:int, r3:int } @ { Set }


declare tm_timer_list : mut collection { r1:int, r2:int, r3:address } @ { Seq }


declare sw_next_switch_addr : mut address


declare sw_need_vid_cntr : mut int = 0


declare sw_token_vid_list : collection { key:{ key:int, value:int }, value:int
  } @ { Seq }


declare sw_highest_vid : mut { key:int, value:int }


declare node_ring : mut collection { key:address, value:int } @ { Seq }


declare replicas : mut int = 8


declare pmap_input : collection { key:string, value:collection { key:int,
  value:int } @ { Seq } } @ { Seq } = {| key:string, value:collection {
  key:int, value:int } @ { Seq } | {key:"QUERY3", value:{| key:int, value:int |
  {key:0, value:4}, {key:1, value:2}, {key:2, value:2}|} @ { Seq }},
  {key:"QUERY3_mLINEITEM1", value:{| key:int, value:int | {key:0, value:4},
  {key:1, value:2}, {key:2, value:2}|} @ { Seq }},
  {key:"QUERY3_mLINEITEM1_mCUSTOMER2", value:{| key:int, value:int | {key:0,
  value:2}, {key:1, value:2}, {key:2, value:2}, {key:3, value:2}|} @ { Seq }},
  {key:"QUERY3_mORDERS1", value:{| key:int, value:int | {key:0,
  value:16}|} @ { Seq }}, {key:"QUERY3_mORDERS3", value:{| key:int, value:int |
  {key:0, value:16}|} @ { Seq }}, {key:"QUERY3_mORDERS6", value:{| key:int,
  value:int | {key:0, value:16}|} @ { Seq }}, {key:"QUERY3_mCUSTOMER2",
  value:{| key:int, value:int | {key:0, value:2}, {key:1, value:2}, {key:2,
  value:2}, {key:3, value:2}|} @ { Seq }}, {key:"QUERY3_mCUSTOMER4", value:{|
  key:int, value:int | {key:0, value:2}, {key:1, value:2}, {key:2, value:2},
  {key:3, value:2}|} @ { Seq }}|} @ { Seq }


declare pmap_data : collection { key:int, value:collection { key:int, value:int
  } @ { Seq } } @ { Seq } = pmap_input.fold ((\_accmap -> (\b3 ->
  bind b3 as {key:map_name, value:map_types} in 
  (_accmap.insert {key:(case ((map_ids.filter ((\b1 -> bind b1 as {r1:r1,
   r2:r2, r3:r3} in r2 == map_name))).peek ()) of
   {Some x -> x}{None -> error (print "can't find map in map_ids")}).r1,
   value:map_types};
   _accmap)))) empty { key:int, value:collection { key:int, value:int
  } @ { Seq } } @ { Seq }


declare sw_max_ack_vid : mut { key:int, value:int } = g_min_vid


declare sw_ack_log : collection { key:{ key:int, value:int },
  value:collection {i:address} @ { Set } } @ { Map }


declare ms_gc_interval : mut int = 20000


declare ms_gc_vid_map : mut collection { key:address, value:{ key:int,
  value:int } } @ { Map }


declare ms_gc_vid_ctr : mut int = 0


declare ms_num_gc_expected : mut int = my_peers.size ()


declare nd_log_master_write : { key:{ key:int, value:int }, value:int } -> () =
  (\b1 -> bind b1 as {key:vid, value:stmt_id} in nd_log_master.insert {key:vid,
  value:stmt_id})


declare nd_log_write_insert_CUSTOMER : { r1:{ key:int, value:int }, r2:int,
  r3:string, r4:string, r5:int, r6:string, r7:real, r8:string, r9:string
  } -> () = (\b1 -> bind b1 as {r1:vid, r2:CUSTOMER_CUSTKEY, r3:CUSTOMER_NAME,
  r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY, r6:CUSTOMER_PHONE,
  r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT, r9:CUSTOMER_COMMENT} in 
  nd_log_insert_CUSTOMER.insert {key:vid, value:{r1:CUSTOMER_CUSTKEY,
  r2:CUSTOMER_NAME, r3:CUSTOMER_ADDRESS, r4:CUSTOMER_NATIONKEY,
  r5:CUSTOMER_PHONE, r6:CUSTOMER_ACCTBAL, r7:CUSTOMER_MKTSEGMENT,
  r8:CUSTOMER_COMMENT}})


declare nd_log_write_insert_ORDERS : { r1:{ key:int, value:int }, r2:int,
  r3:int, r4:string, r5:real, r6:int, r7:string, r8:string, r9:int, r10:string
  } -> () = (\b1 -> bind b1 as {r1:vid, r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY,
  r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE,
  r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY,
  r10:ORDERS_COMMENT} in nd_log_insert_ORDERS.insert {key:vid,
  value:{r1:ORDERS_ORDERKEY, r2:ORDERS_CUSTKEY, r3:ORDERS_ORDERSTATUS,
  r4:ORDERS_TOTALPRICE, r5:ORDERS_ORDERDATE, r6:ORDERS_ORDERPRIORITY,
  r7:ORDERS_CLERK, r8:ORDERS_SHIPPRIORITY, r9:ORDERS_COMMENT}})


declare nd_log_write_insert_LINEITEM : { r1:{ key:int, value:int }, r2:int,
  r3:int, r4:int, r5:int, r6:real, r7:real, r8:real, r9:real, r10:string,
  r11:string, r12:int, r13:int, r14:int, r15:string, r16:string, r17:string
  } -> () = (\b1 -> bind b1 as {r1:vid, r2:LINEITEM_ORDERKEY,
  r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
  r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
  r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
  r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
  r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT} in 
  nd_log_insert_LINEITEM.insert {key:vid, value:{r1:LINEITEM_ORDERKEY,
  r2:LINEITEM_PARTKEY, r3:LINEITEM_SUPPKEY, r4:LINEITEM_LINENUMBER,
  r5:LINEITEM_QUANTITY, r6:LINEITEM_EXTENDEDPRICE, r7:LINEITEM_DISCOUNT,
  r8:LINEITEM_TAX, r9:LINEITEM_RETURNFLAG, r10:LINEITEM_LINESTATUS,
  r11:LINEITEM_SHIPDATE, r12:LINEITEM_COMMITDATE, r13:LINEITEM_RECEIPTDATE,
  r14:LINEITEM_SHIPINSTRUCT, r15:LINEITEM_SHIPMODE, r16:LINEITEM_COMMENT}})


declare nd_log_get_bound_insert_CUSTOMER : { key:int, value:int } -> { r1:int,
  r2:string, r3:string, r4:int, r5:string, r6:real, r7:string, r8:string } =
  (\vid -> (case ((nd_log_insert_CUSTOMER.filter ((\b1 -> bind b1 as {key:key,
  value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_insert_ORDERS : { key:int, value:int } -> { r1:int,
  r2:int, r3:string, r4:real, r5:int, r6:string, r7:string, r8:int, r9:string
  } = (\vid -> (case ((nd_log_insert_ORDERS.filter ((\b1 ->
  bind b1 as {key:key, value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_insert_LINEITEM : { key:int, value:int } -> { r1:int,
  r2:int, r3:int, r4:int, r5:real, r6:real, r7:real, r8:real, r9:string,
  r10:string, r11:int, r12:int, r13:int, r14:string, r15:string, r16:string } =
  (\vid -> (case ((nd_log_insert_LINEITEM.filter ((\b1 -> bind b1 as {key:key,
  value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_read_geq : { key:int, value:int } -> collection { key:{ key:int,
  value:int }, value:int } @ { Set } = (\vid2 -> nd_log_master.filter ((\b1 ->
  bind b1 as {key:vid, value:stmt_id} in vid >= vid2)))


declare nd_check_stmt_cntr_index : { r1:{ key:int, value:int }, r2:int, r3:int
  } -> bool = (\b1 -> bind b1 as {r1:vid, r2:stmt_id, r3:add_to_count} in case
  ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
  {key:vid, value:stmt_id}))).peek ()) of
  {Some lookup_value -> let new_count = add_to_count + (lookup_value.value).key
    in
    (nd_stmt_cntrs.update lookup_value {key:{key:vid, value:stmt_id},
     value:{key:new_count, value:(lookup_value.value).value}};
     0 == new_count)}{None ->
                       (nd_stmt_cntrs.insert {key:{key:vid, value:stmt_id},
                        value:{key:add_to_count, value:empty { key:int,
                        value:int } @ { Map }}};
                        false)})


declare nd_complete_stmt_cntr_check : { key:{ key:int, value:int }, value:int
  } -> () = (\b1 -> bind b1 as {key:vid, value:stmt_id} in 
  ((case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
   key == {key:vid, value:stmt_id}))).peek ()) of
   {Some lookup_data -> nd_stmt_cntrs.erase lookup_data}{None -> ()});
   (if nd_state == nd_state_done
   then if 0 == nd_stmt_cntrs.size ()
     then (ms_rcv_node_done, master_addr)<- true else () else ())))


declare nd_update_stmt_cntr_corr_map : { r1:{ key:int, value:int }, r2:int,
  r3:int, r4:int, r5:bool, r6:bool } -> () = (\b1 -> bind b1 as {r1:vid,
  r2:stmt_id, r3:hop, r4:count, r5:root, r6:create} in 
  ((if create
   then nd_stmt_cntrs.insert {key:{key:vid, value:stmt_id}, value:{key:0,
     value:empty { key:int, value:int } @ { Map }}} else ());
   (case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
   key == {key:vid, value:stmt_id}))).peek ()) of
   {Some lkup -> nd_stmt_cntrs.update lkup {key:{key:vid, value:stmt_id},
     value:let sc_corr_map = (lkup.value).value in
     ((case ((sc_corr_map.filter ((\b1 -> bind b1 as {key:key, value:value} in 
      key == hop))).peek ()) of
      {Some lkup2 -> sc_corr_map.update lkup2 {key:hop, value:lkup2.value +
        count}}{None -> sc_corr_map.insert {key:hop, value:count}});
      (if root then ()
      else case ((sc_corr_map.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == hop))).peek ()) of
        {Some lkup2 -> let new_corr_cnt = lkup2.value - 1 in
          if new_corr_cnt == 0 then sc_corr_map.erase lkup2
            else sc_corr_map.update lkup2 {key:hop, value:new_corr_cnt}}
        {None -> sc_corr_map.insert {key:hop, value:-1}});
      {key:(lkup.value).key, value:sc_corr_map})}}{None ->
                                                    error
                                                      (print
                                                         "nd_update_stmt_cntr_corr_map: missing stmt_cntrs value")})))


declare nd_filter_corrective_list : { key:{ key:int, value:int },
  value:collection { key:int, value:int } @ { Collection } } -> collection {
  key:int, value:collection { key:int, value:int } @ { Seq }
  } @ { Collection } = (\b1 -> bind b1 as {key:request_vid,
  value:trig_stmt_list} in ((((nd_log_read_geq request_vid).fold ((\acc_conv ->
  (\x -> (acc_conv.insert x;acc_conv)))) empty { key:{ key:int, value:int },
  value:int } @ { Seq }).sort ((\b2 -> (\b5 -> bind b2 as {key:vid1,
  value:stmt1} in bind b5 as {key:vid2, value:stmt2} in if vid1 < vid2 
  then -1 else 1)))).groupBy ((\b1 -> bind b1 as {value:stmt_id} in stmt_id))
  ((\vid_list -> (\b3 -> bind b3 as {key:vid} in 
  (vid_list.insert vid;vid_list)))) empty { key:int, value:int
  } @ { Seq }).fold ((\acc_conv -> (\x -> (acc_conv.insert x;acc_conv))))
  empty { key:int, value:collection { key:int, value:int } @ { Seq }
  } @ { Collection })


declare add_node : address -> () = (\addr -> let rng = range replicas in
  let new_elems =
    rng.fold ((\_accmap -> (\b3 -> bind b3 as {i:i} in 
      (_accmap.insert {key:addr, value:abs (hash ((i * 2683) + hash addr))};
       _accmap)))) empty { key:address, value:int } @ { Seq } in
    (node_ring = node_ring.combine new_elems;
     node_ring = node_ring.sort ((\b2 -> (\b5 -> bind b2 as {key:addr,
     value:hash1} in bind b5 as {key:addr, value:hash2} in if hash1 < hash2
     then -1 else 1)))))


declare get_ring_node : { key:int, value:int } -> address = (\b1 ->
  bind b1 as {key:data, value:max_val} in let scaled =
  truncate (real_of_int (get_max_int ()) * (real_of_int data /
    real_of_int max_val)) in
  let results =
    node_ring.filter ((\b1 -> bind b1 as {key:addr, value:hash} in hash >=
      scaled)) in
    bind
      case (results.peek ()) of
        {Some x -> x}{None -> case (node_ring.peek ()) of
                       {Some x -> x}{None -> error (print "empty node ring")}}
      as {key:addr, value:_} in addr)


declare frontier_int_int : { key:{ key:int, value:int }, value:collection {
  r1:{ key:int, value:int }, r2:int, r3:int } @ { Set } } -> collection { r1:{
  key:int, value:int }, r2:int, r3:int } @ { Set } = (\b1 ->
  bind b1 as {key:vid, value:input_map} in (input_map.groupBy ((\b1 ->
  bind b1 as {r1:map_vid, r2:map_0, r3:map_val} in map_0)) ((\b2 -> (\b5 ->
  bind b2 as {key:acc, value:max_vid} in bind b5 as {r1:map_vid, r2:map_0,
  r3:map_val} in if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {r1:map_vid, r2:map_0, r3:map_val};{key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| r1:{ key:int, value:int }, r2:int, r3:int | {r1:map_vid,
        r2:map_0, r3:map_val}|} @ { Set }, value:map_vid}
      else {key:acc, value:max_vid} else {key:acc, value:max_vid})))
  {key:empty { r1:{ key:int, value:int }, r2:int, r3:int } @ { Set },
  value:g_min_vid}).fold ((\_accext -> (\b3 -> bind b3 as {value:b4} in 
  bind b4 as {key:project} in _accext.combine project))) empty { r1:{ key:int,
  value:int }, r2:int, r3:int } @ { Set })


declare frontier_int_date_int_float : { key:{ key:int, value:int },
  value:collection { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:real
  } @ { Set } } -> collection { r1:{ key:int, value:int }, r2:int, r3:int,
  r4:int, r5:real } @ { Set } = (\b1 -> bind b1 as {key:vid,
  value:input_map} in (input_map.groupBy ((\b1 -> bind b1 as {r1:map_vid,
  r2:map_0, r3:map_1, r4:map_2, r5:map_val} in {r1:map_0, r2:map_1, r3:map_2}))
  ((\b2 -> (\b5 -> bind b2 as {key:acc, value:max_vid} in 
  bind b5 as {r1:map_vid, r2:map_0, r3:map_1, r4:map_2, r5:map_val} in 
  if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {r1:map_vid, r2:map_0, r3:map_1, r4:map_2, r5:map_val};
       {key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:real |
        {r1:map_vid, r2:map_0, r3:map_1, r4:map_2, r5:map_val}|} @ { Set },
        value:map_vid} else {key:acc, value:max_vid}
  else {key:acc, value:max_vid}))) {key:empty { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:real } @ { Set }, value:g_min_vid}).fold
  ((\_accext -> (\b3 -> bind b3 as {value:b4} in bind b4 as {key:project} in 
  _accext.combine project))) empty { r1:{ key:int, value:int }, r2:int, r3:int,
  r4:int, r5:real } @ { Set })


declare frontier_int_date_int_int : { key:{ key:int, value:int },
  value:collection { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int
  } @ { Set } } -> collection { r1:{ key:int, value:int }, r2:int, r3:int,
  r4:int, r5:int } @ { Set } = (\b1 -> bind b1 as {key:vid,
  value:input_map} in (input_map.groupBy ((\b1 -> bind b1 as {r1:map_vid,
  r2:map_0, r3:map_1, r4:map_2, r5:map_val} in {r1:map_0, r2:map_1, r3:map_2}))
  ((\b2 -> (\b5 -> bind b2 as {key:acc, value:max_vid} in 
  bind b5 as {r1:map_vid, r2:map_0, r3:map_1, r4:map_2, r5:map_val} in 
  if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {r1:map_vid, r2:map_0, r3:map_1, r4:map_2, r5:map_val};
       {key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int |
        {r1:map_vid, r2:map_0, r3:map_1, r4:map_2, r5:map_val}|} @ { Set },
        value:map_vid} else {key:acc, value:max_vid}
  else {key:acc, value:max_vid}))) {key:empty { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:int } @ { Set }, value:g_min_vid}).fold
  ((\_accext -> (\b3 -> bind b3 as {value:b4} in bind b4 as {key:project} in 
  _accext.combine project))) empty { r1:{ key:int, value:int }, r2:int, r3:int,
  r4:int, r5:int } @ { Set })


declare frontier_int_float : { key:{ key:int, value:int }, value:collection {
  r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } } -> collection { r1:{
  key:int, value:int }, r2:int, r3:real } @ { Set } = (\b1 ->
  bind b1 as {key:vid, value:input_map} in (input_map.groupBy ((\b1 ->
  bind b1 as {r1:map_vid, r2:map_0, r3:map_val} in map_0)) ((\b2 -> (\b5 ->
  bind b2 as {key:acc, value:max_vid} in bind b5 as {r1:map_vid, r2:map_0,
  r3:map_val} in if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {r1:map_vid, r2:map_0, r3:map_val};{key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| r1:{ key:int, value:int }, r2:int, r3:real | {r1:map_vid,
        r2:map_0, r3:map_val}|} @ { Set }, value:map_vid}
      else {key:acc, value:max_vid} else {key:acc, value:max_vid})))
  {key:empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set },
  value:g_min_vid}).fold ((\_accext -> (\b3 -> bind b3 as {value:b4} in 
  bind b4 as {key:project} in _accext.combine project))) empty { r1:{ key:int,
  value:int }, r2:int, r3:real } @ { Set })


declare frontier_int_date_int_int_int : { key:{ key:int, value:int },
  value:collection { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int,
  r6:int } @ { Set } } -> collection { r1:{ key:int, value:int }, r2:int,
  r3:int, r4:int, r5:int, r6:int } @ { Set } = (\b1 -> bind b1 as {key:vid,
  value:input_map} in (input_map.groupBy ((\b1 -> bind b1 as {r1:map_vid,
  r2:map_0, r3:map_1, r4:map_2, r5:map_3, r6:map_val} in {r1:map_0, r2:map_1,
  r3:map_2, r4:map_3})) ((\b2 -> (\b5 -> bind b2 as {key:acc,
  value:max_vid} in bind b5 as {r1:map_vid, r2:map_0, r3:map_1, r4:map_2,
  r5:map_3, r6:map_val} in if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {r1:map_vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
       r6:map_val};
       {key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int,
        r6:int | {r1:map_vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
        r6:map_val}|} @ { Set }, value:map_vid} else {key:acc, value:max_vid}
  else {key:acc, value:max_vid}))) {key:empty { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set }, value:g_min_vid}).fold
  ((\_accext -> (\b3 -> bind b3 as {value:b4} in bind b4 as {key:project} in 
  _accext.combine project))) empty { r1:{ key:int, value:int }, r2:int, r3:int,
  r4:int, r5:int, r6:int } @ { Set })


declare frontier_int_date_int_int_float : { key:{ key:int, value:int },
  value:collection { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int,
  r6:real } @ { Set } } -> collection { r1:{ key:int, value:int }, r2:int,
  r3:int, r4:int, r5:int, r6:real } @ { Set } = (\b1 -> bind b1 as {key:vid,
  value:input_map} in (input_map.groupBy ((\b1 -> bind b1 as {r1:map_vid,
  r2:map_0, r3:map_1, r4:map_2, r5:map_3, r6:map_val} in {r1:map_0, r2:map_1,
  r3:map_2, r4:map_3})) ((\b2 -> (\b5 -> bind b2 as {key:acc,
  value:max_vid} in bind b5 as {r1:map_vid, r2:map_0, r3:map_1, r4:map_2,
  r5:map_3, r6:map_val} in if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {r1:map_vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
       r6:map_val};
       {key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int,
        r6:real | {r1:map_vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
        r6:map_val}|} @ { Set }, value:map_vid} else {key:acc, value:max_vid}
  else {key:acc, value:max_vid}))) {key:empty { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set }, value:g_min_vid}).fold
  ((\_accext -> (\b3 -> bind b3 as {value:b4} in bind b4 as {key:project} in 
  _accext.combine project))) empty { r1:{ key:int, value:int }, r2:int, r3:int,
  r4:int, r5:int, r6:real } @ { Set })


declare nd_add_delta_to_int_int : { r1:ind collection { r1:{ key:int, value:int
  }, r2:int, r3:int } @ { Set }, r2:bool, r3:{ key:int, value:int },
  r4:collection { key:int, value:int } @ { Set } } -> () = (\b1 ->
  bind b1 as {r1:target_map, r2:corrective, r3:min_vid, r4:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {key:map_0, value:map_val} in bind
   target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {r1:r1, r2:r2, r3:r3} in r1
         == min_vid and r2 == map_0))
       else empty { r1:{ key:int, value:int }, r2:int, r3:int } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.r3 in
         target_map_d.update val {r1:min_vid, r2:map_0, r3:update_value}}
       {None -> let lookup_value =
         frontier_int_int {key:min_vid, value:target_map_d.filter ((\b1 ->
           bind b1 as {r1:r1, r2:r2, r3:r3} in r2 == map_0))} in
         let update_value =
           map_val + case (lookup_value.peek ()) of
             {Some val -> val.r3}{None -> 0} in
           target_map_d.insert {r1:min_vid, r2:map_0, r3:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {key:map_0_delta,
   value:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {r1:r1, r2:r2, r3:r3} in r2 ==
       map_0_delta))).filter ((\b1 -> bind b1 as {r1:vid, r2:map_0,
       r3:map_val} in vid > min_vid)) in
   filtered.iterate ((\b1 -> bind b1 as {r1:vid, r2:map_0, r3:map_val} in bind
     target_map as ind target_map_d in
     target_map_d.update {r1:vid, r2:map_0, r3:map_val} {r1:vid, r2:map_0,
       r3:map_val + map_val_delta}))))))


declare nd_add_delta_to_int_date_int_float : { r1:ind collection { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:real } @ { Set }, r2:bool,
  r3:{ key:int, value:int }, r4:collection { r1:int, r2:int, r3:int, r4:real
  } @ { Set } } -> () = (\b1 -> bind b1 as {r1:target_map, r2:corrective,
  r3:min_vid, r4:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {r1:map_0, r2:map_1, r3:map_2,
   r4:map_val} in bind target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {r1:r1, r2:r2, r3:r3,
         r4:r4, r5:r5} in ((r1 == min_vid and r4 == map_2) and r3 == map_1) and
         r2 == map_0))
       else empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:real
         } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.r5 in
         target_map_d.update val {r1:min_vid, r2:map_0, r3:map_1, r4:map_2,
           r5:update_value}}{None -> let lookup_value =
                              frontier_int_date_int_float {key:min_vid,
                                value:target_map_d.filter ((\b1 ->
                                bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4,
                                r5:r5} in (r2 == map_0 and r4 == map_2) and r3
                                == map_1))} in
                              let update_value =
                                map_val + case (lookup_value.peek ()) of
                                  {Some val -> val.r5}{None -> 0} in
                                target_map_d.insert {r1:min_vid, r2:map_0,
                                  r3:map_1, r4:map_2, r5:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {r1:map_0_delta, r2:map_1_delta,
   r3:map_2_delta, r4:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4,
       r5:r5} in (r2 == map_0_delta and r4 == map_2_delta) and r3 ==
       map_1_delta))).filter ((\b1 -> bind b1 as {r1:vid, r2:map_0, r3:map_1,
       r4:map_2, r5:map_val} in vid > min_vid)) in
   filtered.iterate ((\b1 -> bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2,
     r5:map_val} in bind target_map as ind target_map_d in
     target_map_d.update {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_val}
       {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_val + map_val_delta}))))))


declare nd_add_delta_to_int_date_int_int : { r1:ind collection { r1:{ key:int,
  value:int }, r2:int, r3:int, r4:int, r5:int } @ { Set }, r2:bool, r3:{
  key:int, value:int }, r4:collection { r1:int, r2:int, r3:int, r4:int
  } @ { Set } } -> () = (\b1 -> bind b1 as {r1:target_map, r2:corrective,
  r3:min_vid, r4:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {r1:map_0, r2:map_1, r3:map_2,
   r4:map_val} in bind target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {r1:r1, r2:r2, r3:r3,
         r4:r4, r5:r5} in ((r1 == min_vid and r4 == map_2) and r3 == map_1) and
         r2 == map_0))
       else empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int
         } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.r5 in
         target_map_d.update val {r1:min_vid, r2:map_0, r3:map_1, r4:map_2,
           r5:update_value}}{None -> let lookup_value =
                              frontier_int_date_int_int {key:min_vid,
                                value:target_map_d.filter ((\b1 ->
                                bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4,
                                r5:r5} in (r2 == map_0 and r4 == map_2) and r3
                                == map_1))} in
                              let update_value =
                                map_val + case (lookup_value.peek ()) of
                                  {Some val -> val.r5}{None -> 0} in
                                target_map_d.insert {r1:min_vid, r2:map_0,
                                  r3:map_1, r4:map_2, r5:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {r1:map_0_delta, r2:map_1_delta,
   r3:map_2_delta, r4:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4,
       r5:r5} in (r2 == map_0_delta and r4 == map_2_delta) and r3 ==
       map_1_delta))).filter ((\b1 -> bind b1 as {r1:vid, r2:map_0, r3:map_1,
       r4:map_2, r5:map_val} in vid > min_vid)) in
   filtered.iterate ((\b1 -> bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2,
     r5:map_val} in bind target_map as ind target_map_d in
     target_map_d.update {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_val}
       {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_val + map_val_delta}))))))


declare nd_add_delta_to_int_float : { r1:ind collection { r1:{ key:int,
  value:int }, r2:int, r3:real } @ { Set }, r2:bool, r3:{ key:int, value:int },
  r4:collection { key:int, value:real } @ { Set } } -> () = (\b1 ->
  bind b1 as {r1:target_map, r2:corrective, r3:min_vid, r4:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {key:map_0, value:map_val} in bind
   target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {r1:r1, r2:r2, r3:r3} in r1
         == min_vid and r2 == map_0))
       else empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.r3 in
         target_map_d.update val {r1:min_vid, r2:map_0, r3:update_value}}
       {None -> let lookup_value =
         frontier_int_float {key:min_vid, value:target_map_d.filter ((\b1 ->
           bind b1 as {r1:r1, r2:r2, r3:r3} in r2 == map_0))} in
         let update_value =
           map_val + case (lookup_value.peek ()) of
             {Some val -> val.r3}{None -> 0} in
           target_map_d.insert {r1:min_vid, r2:map_0, r3:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {key:map_0_delta,
   value:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {r1:r1, r2:r2, r3:r3} in r2 ==
       map_0_delta))).filter ((\b1 -> bind b1 as {r1:vid, r2:map_0,
       r3:map_val} in vid > min_vid)) in
   filtered.iterate ((\b1 -> bind b1 as {r1:vid, r2:map_0, r3:map_val} in bind
     target_map as ind target_map_d in
     target_map_d.update {r1:vid, r2:map_0, r3:map_val} {r1:vid, r2:map_0,
       r3:map_val + map_val_delta}))))))


declare nd_add_delta_to_int_date_int_int_int : { r1:ind collection { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set },
  r2:bool, r3:{ key:int, value:int }, r4:collection { r1:int, r2:int, r3:int,
  r4:int, r5:int } @ { Set } } -> () = (\b1 -> bind b1 as {r1:target_map,
  r2:corrective, r3:min_vid, r4:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {r1:map_0, r2:map_1, r3:map_2,
   r4:map_3, r5:map_val} in bind target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {r1:r1, r2:r2, r3:r3,
         r4:r4, r5:r5, r6:r6} in (((r1 == min_vid and r5 == map_3) and r4 ==
         map_2) and r3 == map_1) and r2 == map_0))
       else empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int,
         r6:int } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.r6 in
         target_map_d.update val {r1:min_vid, r2:map_0, r3:map_1, r4:map_2,
           r5:map_3, r6:update_value}}{None -> let lookup_value =
                                        frontier_int_date_int_int_int
                                          {key:min_vid,
                                          value:target_map_d.filter ((\b1 ->
                                          bind b1 as {r1:r1, r2:r2, r3:r3,
                                          r4:r4, r5:r5, r6:r6} in ((r2 == map_0
                                          and r5 == map_3) and r4 == map_2) and
                                          r3 == map_1))} in
                                        let update_value =
                                          map_val + case (lookup_value.peek ())
                                            of {Some val -> val.r6}{None -> 0}
                                          in
                                          target_map_d.insert {r1:min_vid,
                                            r2:map_0, r3:map_1, r4:map_2,
                                            r5:map_3, r6:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {r1:map_0_delta, r2:map_1_delta,
   r3:map_2_delta, r4:map_3_delta, r5:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4,
       r5:r5, r6:r6} in ((r2 == map_0_delta and r5 == map_3_delta) and r4 ==
       map_2_delta) and r3 == map_1_delta))).filter ((\b1 ->
       bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
       r6:map_val} in vid > min_vid)) in
   filtered.iterate ((\b1 -> bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2,
     r5:map_3, r6:map_val} in bind target_map as ind target_map_d in
     target_map_d.update {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
       r6:map_val} {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3, r6:map_val
       + map_val_delta}))))))


declare nd_add_delta_to_int_date_int_int_float : { r1:ind collection { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set },
  r2:bool, r3:{ key:int, value:int }, r4:collection { r1:int, r2:int, r3:int,
  r4:int, r5:real } @ { Set } } -> () = (\b1 -> bind b1 as {r1:target_map,
  r2:corrective, r3:min_vid, r4:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {r1:map_0, r2:map_1, r3:map_2,
   r4:map_3, r5:map_val} in bind target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {r1:r1, r2:r2, r3:r3,
         r4:r4, r5:r5, r6:r6} in (((r1 == min_vid and r5 == map_3) and r4 ==
         map_2) and r3 == map_1) and r2 == map_0))
       else empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int,
         r6:real } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.r6 in
         target_map_d.update val {r1:min_vid, r2:map_0, r3:map_1, r4:map_2,
           r5:map_3, r6:update_value}}{None -> let lookup_value =
                                        frontier_int_date_int_int_float
                                          {key:min_vid,
                                          value:target_map_d.filter ((\b1 ->
                                          bind b1 as {r1:r1, r2:r2, r3:r3,
                                          r4:r4, r5:r5, r6:r6} in ((r2 == map_0
                                          and r5 == map_3) and r4 == map_2) and
                                          r3 == map_1))} in
                                        let update_value =
                                          map_val + case (lookup_value.peek ())
                                            of {Some val -> val.r6}{None -> 0}
                                          in
                                          target_map_d.insert {r1:min_vid,
                                            r2:map_0, r3:map_1, r4:map_2,
                                            r5:map_3, r6:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {r1:map_0_delta, r2:map_1_delta,
   r3:map_2_delta, r4:map_3_delta, r5:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4,
       r5:r5, r6:r6} in ((r2 == map_0_delta and r5 == map_3_delta) and r4 ==
       map_2_delta) and r3 == map_1_delta))).filter ((\b1 ->
       bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
       r6:map_val} in vid > min_vid)) in
   filtered.iterate ((\b1 -> bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2,
     r5:map_3, r6:map_val} in bind target_map as ind target_map_d in
     target_map_d.update {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
       r6:map_val} {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3, r6:map_val
       + map_val_delta}))))))


declare sw_gen_vid : () -> option { key:int, value:int } = (\_ -> case
  (sw_token_vid_list.peek ()) of
  {Some vid_num -> let num_new = vid_num.value - 1 in
    let vid_new = {key:(vid_num.key).key, value:(vid_num.key).value + 1} in
      ((if num_new <= 0 then sw_token_vid_list.erase vid_num
       else sw_token_vid_list.update vid_num {key:vid_new, value:num_new});
       Some (vid_num.key))}{None -> None immut})


declare calc_dim_bounds : collection { key:int, value:int } @ { Seq } -> {
  key:collection { key:int, value:int } @ { Seq }, value:int } = (\pmap ->
  pmap.fold ((\b2 -> (\b5 -> bind b2 as {key:xs, value:acc_size} in 
  bind b5 as {key:pos, value:bin_size} in {key:xs.combine ({| key:int,
  value:int | {key:pos, value:acc_size}|} @ { Seq }), value:bin_size *
  acc_size}))) {key:empty { key:int, value:int } @ { Seq }, value:1})


declare route_to_int_date_int_int : { r1:int, r2:option int, r3:option int,
  r4:option int, r5:option int } -> collection {i:address} @ { Collection } =
  (\b1 -> bind b1 as {r1:map_id, r2:key_0, r3:key_1, r4:key_2, r5:key_3} in let
  pmap =
  (case ((pmap_data.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
    map_id))).peek ()) of
    {Some x -> x}{None -> error (print "can't find map_id in pmap_data")}).value
  in
  case (pmap.peek ()) of
    {Some _ -> bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in
      let bound_bucket =
        case key_3 of
          {Some key_3_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              3)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_3_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 3))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 3 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_2 of
          {Some key_2_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              2)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_2_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 2))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 2 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_1 of
          {Some key_1_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              1)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_1_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 1))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 1 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_0 of
          {Some key_0_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              0)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_0_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 0))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 0 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + 0))) in
        let free_dims =
          (if key_3 != None immut then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 3))).combine ((if key_2 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 2))).combine ((if key_1 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 1))).combine ((if key_0 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 0))).combine empty { key:int, value:int } @ { Seq }))) in
          let free_domains =
            free_dims.fold ((\_accmap -> (\b3 -> bind b3 as {key:i,
              value:b_i} in 
              (_accmap.insert {key:i, value:range b_i};_accmap)))) empty {
              key:int, value:collection {i:int} @ { Seq } } @ { Seq } in
            let free_cart_prod =
              free_domains.fold ((\prev_cart_prod -> (\b3 -> bind b3 as {key:i,
                value:domain} in domain.fold ((\_accext -> (\b3 ->
                bind b3 as {i:domain_element} in _accext.combine
                (if 0 == prev_cart_prod.size ()
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int | {key:i,
                  value:domain_element}|} @ { Seq }|} @ { Seq }
                else prev_cart_prod.fold ((\_accmap -> (\b3 ->
                  bind b3 as {i:rest_tup} in 
                  (_accmap.insert ({i:rest_tup.combine ({| key:int, value:int |
                   {key:i, value:domain_element}|} @ { Seq })});
                   _accmap)))) empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq })))) empty {i:collection { key:int,
                value:int } @ { Seq }} @ { Seq }))) empty {i:collection {
                key:int, value:int } @ { Seq }} @ { Seq } in
              let sorted_ip_list =
                (free_cart_prod.fold ((\acc_ips -> (\b3 ->
                  bind b3 as {i:free_bucket} in acc_ips.combine ({|i:address|
                  get_ring_node {key:free_bucket.fold ((\acc -> (\b3 ->
                    bind b3 as {key:i, value:val} in acc + (val * (case
                    ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                    value:value} in key == i))).peek ()) of
                    {Some x -> x}{None ->
                                   error (print "can't find i in dim_bounds")}).value))))
                    bound_bucket, value:max_val}|} @ { Collection }))))
                  empty {i:address} @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {i:ip} in ip)) ((\_ -> (\_ -> ()))) () in
                if 0 == sorted_ip_list.size ()
                  then {|i:address|
                    get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
                  else sorted_ip_list.fold ((\_accmap -> (\x ->
                    (_accmap.insert ({i:x.key});_accmap))))
                    empty {i:address} @ { Collection }}{None -> nodes})


declare route_to_int : { key:int, value:option int
  } -> collection {i:address} @ { Collection } = (\b1 ->
  bind b1 as {key:map_id, value:key_0} in let pmap =
  (case ((pmap_data.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
    map_id))).peek ()) of
    {Some x -> x}{None -> error (print "can't find map_id in pmap_data")}).value
  in
  case (pmap.peek ()) of
    {Some _ -> bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in
      let bound_bucket =
        case key_0 of
          {Some key_0_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              0)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_0_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 0))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 0 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + 0 in
        let free_dims =
          (if key_0 != None immut then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 0))).combine empty { key:int, value:int } @ { Seq } in
          let free_domains =
            free_dims.fold ((\_accmap -> (\b3 -> bind b3 as {key:i,
              value:b_i} in 
              (_accmap.insert {key:i, value:range b_i};_accmap)))) empty {
              key:int, value:collection {i:int} @ { Seq } } @ { Seq } in
            let free_cart_prod =
              free_domains.fold ((\prev_cart_prod -> (\b3 -> bind b3 as {key:i,
                value:domain} in domain.fold ((\_accext -> (\b3 ->
                bind b3 as {i:domain_element} in _accext.combine
                (if 0 == prev_cart_prod.size ()
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int | {key:i,
                  value:domain_element}|} @ { Seq }|} @ { Seq }
                else prev_cart_prod.fold ((\_accmap -> (\b3 ->
                  bind b3 as {i:rest_tup} in 
                  (_accmap.insert ({i:rest_tup.combine ({| key:int, value:int |
                   {key:i, value:domain_element}|} @ { Seq })});
                   _accmap)))) empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq })))) empty {i:collection { key:int,
                value:int } @ { Seq }} @ { Seq }))) empty {i:collection {
                key:int, value:int } @ { Seq }} @ { Seq } in
              let sorted_ip_list =
                (free_cart_prod.fold ((\acc_ips -> (\b3 ->
                  bind b3 as {i:free_bucket} in acc_ips.combine ({|i:address|
                  get_ring_node {key:free_bucket.fold ((\acc -> (\b3 ->
                    bind b3 as {key:i, value:val} in acc + (val * (case
                    ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                    value:value} in key == i))).peek ()) of
                    {Some x -> x}{None ->
                                   error (print "can't find i in dim_bounds")}).value))))
                    bound_bucket, value:max_val}|} @ { Collection }))))
                  empty {i:address} @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {i:ip} in ip)) ((\_ -> (\_ -> ()))) () in
                if 0 == sorted_ip_list.size ()
                  then {|i:address|
                    get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
                  else sorted_ip_list.fold ((\_accmap -> (\x ->
                    (_accmap.insert ({i:x.key});_accmap))))
                    empty {i:address} @ { Collection }}{None -> nodes})


declare route_to_int_date_int : { r1:int, r2:option int, r3:option int,
  r4:option int } -> collection {i:address} @ { Collection } = (\b1 ->
  bind b1 as {r1:map_id, r2:key_0, r3:key_1, r4:key_2} in let pmap =
  (case ((pmap_data.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
    map_id))).peek ()) of
    {Some x -> x}{None -> error (print "can't find map_id in pmap_data")}).value
  in
  case (pmap.peek ()) of
    {Some _ -> bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in
      let bound_bucket =
        case key_2 of
          {Some key_2_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              2)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_2_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 2))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 2 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_1 of
          {Some key_1_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              1)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_1_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 1))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 1 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_0 of
          {Some key_0_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              0)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_0_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 0))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 0 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + 0)) in
        let free_dims =
          (if key_2 != None immut then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 2))).combine ((if key_1 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 1))).combine ((if key_0 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 0))).combine empty { key:int, value:int } @ { Seq })) in
          let free_domains =
            free_dims.fold ((\_accmap -> (\b3 -> bind b3 as {key:i,
              value:b_i} in 
              (_accmap.insert {key:i, value:range b_i};_accmap)))) empty {
              key:int, value:collection {i:int} @ { Seq } } @ { Seq } in
            let free_cart_prod =
              free_domains.fold ((\prev_cart_prod -> (\b3 -> bind b3 as {key:i,
                value:domain} in domain.fold ((\_accext -> (\b3 ->
                bind b3 as {i:domain_element} in _accext.combine
                (if 0 == prev_cart_prod.size ()
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int | {key:i,
                  value:domain_element}|} @ { Seq }|} @ { Seq }
                else prev_cart_prod.fold ((\_accmap -> (\b3 ->
                  bind b3 as {i:rest_tup} in 
                  (_accmap.insert ({i:rest_tup.combine ({| key:int, value:int |
                   {key:i, value:domain_element}|} @ { Seq })});
                   _accmap)))) empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq })))) empty {i:collection { key:int,
                value:int } @ { Seq }} @ { Seq }))) empty {i:collection {
                key:int, value:int } @ { Seq }} @ { Seq } in
              let sorted_ip_list =
                (free_cart_prod.fold ((\acc_ips -> (\b3 ->
                  bind b3 as {i:free_bucket} in acc_ips.combine ({|i:address|
                  get_ring_node {key:free_bucket.fold ((\acc -> (\b3 ->
                    bind b3 as {key:i, value:val} in acc + (val * (case
                    ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                    value:value} in key == i))).peek ()) of
                    {Some x -> x}{None ->
                                   error (print "can't find i in dim_bounds")}).value))))
                    bound_bucket, value:max_val}|} @ { Collection }))))
                  empty {i:address} @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {i:ip} in ip)) ((\_ -> (\_ -> ()))) () in
                if 0 == sorted_ip_list.size ()
                  then {|i:address|
                    get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
                  else sorted_ip_list.fold ((\_accmap -> (\x ->
                    (_accmap.insert ({i:x.key});_accmap))))
                    empty {i:address} @ { Collection }}{None -> nodes})


declare shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_to_QUERY3_mCUSTOMER4_bind_0t0_1t1_2t2_3t3 :
  { r1:option int, r2:option int, r3:option int, r4:option int, r5:collection {
  r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int
  } @ { Set }, r6:bool } -> collection { key:address, value:collection { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set }
  } @ { Collection } = (\b1 -> bind b1 as {r1:lkey_0, r2:lkey_1, r3:lkey_2,
  r4:lkey_3, r5:tuples, r6:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_int_date_int_int {r1:8, r2:lkey_0, r3:lkey_1, r4:lkey_2,
         r5:lkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { r1:{ key:int, value:int }, r2:int,
       r3:int, r4:int, r5:int, r6:int } @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set }
      } @ { Collection }
    else empty { key:address, value:collection { r1:{ key:int, value:int },
      r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {r1:rkey_0, r2:rkey_1, r3:rkey_2, r4:rkey_3, r5:rkey_4, r6:rkey_5} in
    (route_to_int_date_int_int {r1:8, r2:Some rkey_1, r3:Some rkey_2,
       r4:Some rkey_3, r5:Some rkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| r1:{ key:int, value:int }, r2:int,
       r3:int, r4:int, r5:int, r6:int | r_tuple|} @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set }
      } @ { Collection })))) empty { key:address, value:collection { r1:{
    key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int,
    r6:int } @ { Set })


declare shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_to_QUERY3_mCUSTOMER2_bind_0t0_1t1_2t2_3t3 :
  { r1:option int, r2:option int, r3:option int, r4:option int, r5:collection {
  r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int
  } @ { Set }, r6:bool } -> collection { key:address, value:collection { r1:{
  key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set }
  } @ { Collection } = (\b1 -> bind b1 as {r1:lkey_0, r2:lkey_1, r3:lkey_2,
  r4:lkey_3, r5:tuples, r6:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_int_date_int_int {r1:7, r2:lkey_0, r3:lkey_1, r4:lkey_2,
         r5:lkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { r1:{ key:int, value:int }, r2:int,
       r3:int, r4:int, r5:int, r6:int } @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set }
      } @ { Collection }
    else empty { key:address, value:collection { r1:{ key:int, value:int },
      r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {r1:rkey_0, r2:rkey_1, r3:rkey_2, r4:rkey_3, r5:rkey_4, r6:rkey_5} in
    (route_to_int_date_int_int {r1:7, r2:Some rkey_1, r3:Some rkey_2,
       r4:Some rkey_3, r5:Some rkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| r1:{ key:int, value:int }, r2:int,
       r3:int, r4:int, r5:int, r6:int | r_tuple|} @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set }
      } @ { Collection })))) empty { key:address, value:collection { r1:{
    key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int,
    r6:int } @ { Set })


declare shuffle_QUERY3_mLINEITEM1_to_QUERY3_bind_0t0_1t1_2t2 : { r1:option int,
  r2:option int, r3:option int, r4:collection { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:int } @ { Set }, r5:bool } -> collection {
  key:address, value:collection { r1:{ key:int, value:int }, r2:int, r3:int,
  r4:int, r5:int } @ { Set } } @ { Collection } = (\b1 ->
  bind b1 as {r1:lkey_0, r2:lkey_1, r3:lkey_2, r4:tuples,
  r5:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_date_int {r1:1, r2:lkey_0, r3:lkey_1, r4:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { r1:{ key:int, value:int }, r2:int,
       r3:int, r4:int, r5:int } @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:int, r4:int, r5:int } @ { Set }
      } @ { Collection }
    else empty { key:address, value:collection { r1:{ key:int, value:int },
      r2:int, r3:int, r4:int, r5:int } @ { Set } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {r1:rkey_0, r2:rkey_1, r3:rkey_2, r4:rkey_3, r5:rkey_4} in
    (route_to_int_date_int {r1:1, r2:Some rkey_1, r3:Some rkey_2,
       r4:Some rkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| r1:{ key:int, value:int }, r2:int,
       r3:int, r4:int, r5:int | r_tuple|} @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:int, r4:int, r5:int } @ { Set }
      } @ { Collection })))) empty { key:address, value:collection { r1:{
    key:int, value:int }, r2:int, r3:int, r4:int, r5:int } @ { Set }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int
    } @ { Set })


declare shuffle_QUERY3_mORDERS6_to_QUERY3_mCUSTOMER4_bind_0t0 : {
  r1:option int, r2:option int, r3:option int, r4:option int, r5:collection {
  r1:{ key:int, value:int }, r2:int, r3:real } @ { Set }, r6:bool
  } -> collection { key:address, value:collection { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set } } @ { Collection } = (\b1 ->
  bind b1 as {r1:lkey_0, r2:lkey_1, r3:lkey_2, r4:lkey_3, r5:tuples,
  r6:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_int_date_int_int {r1:8, r2:lkey_0, r3:lkey_1, r4:lkey_2,
         r5:lkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { r1:{ key:int, value:int }, r2:int,
       r3:real } @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:real } @ { Set } } @ { Collection }
    else empty { key:address, value:collection { r1:{ key:int, value:int },
      r2:int, r3:real } @ { Set } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {r1:rkey_0, r2:rkey_1, r3:rkey_2} in
    (route_to_int_date_int_int {r1:8, r2:Some rkey_1, r3:lkey_1, r4:lkey_2,
       r5:lkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| r1:{ key:int, value:int }, r2:int,
       r3:real | r_tuple|} @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:real } @ { Set } } @ { Collection })))) empty {
    key:address, value:collection { r1:{ key:int, value:int }, r2:int, r3:real
    } @ { Set } } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip,
    value:tuple} in ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in 
    tuple.combine acc))) empty { r1:{ key:int, value:int }, r2:int, r3:real
    } @ { Set })


declare shuffle_QUERY3_mORDERS3_to_QUERY3_mCUSTOMER2_bind_0t0 : {
  r1:option int, r2:option int, r3:option int, r4:option int, r5:collection {
  r1:{ key:int, value:int }, r2:int, r3:real } @ { Set }, r6:bool
  } -> collection { key:address, value:collection { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set } } @ { Collection } = (\b1 ->
  bind b1 as {r1:lkey_0, r2:lkey_1, r3:lkey_2, r4:lkey_3, r5:tuples,
  r6:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_int_date_int_int {r1:7, r2:lkey_0, r3:lkey_1, r4:lkey_2,
         r5:lkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { r1:{ key:int, value:int }, r2:int,
       r3:real } @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:real } @ { Set } } @ { Collection }
    else empty { key:address, value:collection { r1:{ key:int, value:int },
      r2:int, r3:real } @ { Set } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {r1:rkey_0, r2:rkey_1, r3:rkey_2} in
    (route_to_int_date_int_int {r1:7, r2:Some rkey_1, r3:lkey_1, r4:lkey_2,
       r5:lkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| r1:{ key:int, value:int }, r2:int,
       r3:real | r_tuple|} @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:real } @ { Set } } @ { Collection })))) empty {
    key:address, value:collection { r1:{ key:int, value:int }, r2:int, r3:real
    } @ { Set } } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip,
    value:tuple} in ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in 
    tuple.combine acc))) empty { r1:{ key:int, value:int }, r2:int, r3:real
    } @ { Set })


declare shuffle_QUERY3_mORDERS1_to_QUERY3_mLINEITEM1 : { r1:option int,
  r2:option int, r3:option int, r4:collection { r1:{ key:int, value:int },
  r2:int, r3:int } @ { Set }, r5:bool } -> collection { key:address,
  value:collection { r1:{ key:int, value:int }, r2:int, r3:int } @ { Set }
  } @ { Collection } = (\b1 -> bind b1 as {r1:lkey_0, r2:lkey_1, r3:lkey_2,
  r4:tuples, r5:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_date_int {r1:2, r2:lkey_0, r3:lkey_1, r4:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { r1:{ key:int, value:int }, r2:int,
       r3:int } @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:int } @ { Set } } @ { Collection }
    else empty { key:address, value:collection { r1:{ key:int, value:int },
      r2:int, r3:int } @ { Set } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {r1:rkey_0, r2:rkey_1, r3:rkey_2} in
    (route_to_int_date_int {r1:2, r2:lkey_0, r3:lkey_1, r4:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| r1:{ key:int, value:int }, r2:int,
       r3:int | r_tuple|} @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:int } @ { Set } } @ { Collection })))) empty {
    key:address, value:collection { r1:{ key:int, value:int }, r2:int, r3:int
    } @ { Set } } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip,
    value:tuple} in ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in 
    tuple.combine acc))) empty { r1:{ key:int, value:int }, r2:int, r3:int
    } @ { Set })


declare shuffle_QUERY3_mORDERS6_to_QUERY3_bind_0t0 : { r1:option int,
  r2:option int, r3:option int, r4:collection { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }, r5:bool } -> collection { key:address,
  value:collection { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set }
  } @ { Collection } = (\b1 -> bind b1 as {r1:lkey_0, r2:lkey_1, r3:lkey_2,
  r4:tuples, r5:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_date_int {r1:1, r2:lkey_0, r3:lkey_1, r4:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { r1:{ key:int, value:int }, r2:int,
       r3:real } @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:real } @ { Set } } @ { Collection }
    else empty { key:address, value:collection { r1:{ key:int, value:int },
      r2:int, r3:real } @ { Set } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {r1:rkey_0, r2:rkey_1, r3:rkey_2} in
    (route_to_int_date_int {r1:1, r2:Some rkey_1, r3:lkey_1, r4:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| r1:{ key:int, value:int }, r2:int,
       r3:real | r_tuple|} @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:real } @ { Set } } @ { Collection })))) empty {
    key:address, value:collection { r1:{ key:int, value:int }, r2:int, r3:real
    } @ { Set } } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip,
    value:tuple} in ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in 
    tuple.combine acc))) empty { r1:{ key:int, value:int }, r2:int, r3:real
    } @ { Set })


declare shuffle_QUERY3_mORDERS3_to_QUERY3_bind_0t0 : { r1:option int,
  r2:option int, r3:option int, r4:collection { r1:{ key:int, value:int },
  r2:int, r3:real } @ { Set }, r5:bool } -> collection { key:address,
  value:collection { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set }
  } @ { Collection } = (\b1 -> bind b1 as {r1:lkey_0, r2:lkey_1, r3:lkey_2,
  r4:tuples, r5:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_date_int {r1:1, r2:lkey_0, r3:lkey_1, r4:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { r1:{ key:int, value:int }, r2:int,
       r3:real } @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:real } @ { Set } } @ { Collection }
    else empty { key:address, value:collection { r1:{ key:int, value:int },
      r2:int, r3:real } @ { Set } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {r1:rkey_0, r2:rkey_1, r3:rkey_2} in
    (route_to_int_date_int {r1:1, r2:Some rkey_1, r3:lkey_1, r4:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| r1:{ key:int, value:int }, r2:int,
       r3:real | r_tuple|} @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:real } @ { Set } } @ { Collection })))) empty {
    key:address, value:collection { r1:{ key:int, value:int }, r2:int, r3:real
    } @ { Set } } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip,
    value:tuple} in ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in 
    tuple.combine acc))) empty { r1:{ key:int, value:int }, r2:int, r3:real
    } @ { Set })


declare shuffle_QUERY3_mORDERS1_to_QUERY3 : { r1:option int, r2:option int,
  r3:option int, r4:collection { r1:{ key:int, value:int }, r2:int, r3:int
  } @ { Set }, r5:bool } -> collection { key:address, value:collection { r1:{
  key:int, value:int }, r2:int, r3:int } @ { Set } } @ { Collection } = (\b1 ->
  bind b1 as {r1:lkey_0, r2:lkey_1, r3:lkey_2, r4:tuples,
  r5:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_date_int {r1:1, r2:lkey_0, r3:lkey_1, r4:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { r1:{ key:int, value:int }, r2:int,
       r3:int } @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:int } @ { Set } } @ { Collection }
    else empty { key:address, value:collection { r1:{ key:int, value:int },
      r2:int, r3:int } @ { Set } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {r1:rkey_0, r2:rkey_1, r3:rkey_2} in
    (route_to_int_date_int {r1:1, r2:lkey_0, r3:lkey_1, r4:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| r1:{ key:int, value:int }, r2:int,
       r3:int | r_tuple|} @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:int } @ { Set } } @ { Collection })))) empty {
    key:address, value:collection { r1:{ key:int, value:int }, r2:int, r3:int
    } @ { Set } } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip,
    value:tuple} in ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in 
    tuple.combine acc))) empty { r1:{ key:int, value:int }, r2:int, r3:int
    } @ { Set })


declare shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_to_QUERY3_mLINEITEM1_bind_0t0_1t1_2t2 :
  { r1:option int, r2:option int, r3:option int, r4:collection { r1:{ key:int,
  value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set }, r5:bool
  } -> collection { key:address, value:collection { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set } } @ { Collection } =
  (\b1 -> bind b1 as {r1:lkey_0, r2:lkey_1, r3:lkey_2, r4:tuples,
  r5:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_date_int {r1:2, r2:lkey_0, r3:lkey_1, r4:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { r1:{ key:int, value:int }, r2:int,
       r3:int, r4:int, r5:int, r6:int } @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set }
      } @ { Collection }
    else empty { key:address, value:collection { r1:{ key:int, value:int },
      r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {r1:rkey_0, r2:rkey_1, r3:rkey_2, r4:rkey_3, r5:rkey_4, r6:rkey_5} in
    (route_to_int_date_int {r1:2, r2:Some rkey_1, r3:Some rkey_2,
       r4:Some rkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| r1:{ key:int, value:int }, r2:int,
       r3:int, r4:int, r5:int, r6:int | r_tuple|} @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set }
      } @ { Collection })))) empty { key:address, value:collection { r1:{
    key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int } @ { Set }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int,
    r6:int } @ { Set })


declare shuffle_QUERY3_mCUSTOMER4_to_QUERY3_bind_0t0_1t1_2t2 : { r1:option int,
  r2:option int, r3:option int, r4:collection { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set }, r5:bool
  } -> collection { key:address, value:collection { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set } } @ { Collection } =
  (\b1 -> bind b1 as {r1:lkey_0, r2:lkey_1, r3:lkey_2, r4:tuples,
  r5:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_date_int {r1:1, r2:lkey_0, r3:lkey_1, r4:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { r1:{ key:int, value:int }, r2:int,
       r3:int, r4:int, r5:int, r6:real } @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set }
      } @ { Collection }
    else empty { key:address, value:collection { r1:{ key:int, value:int },
      r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {r1:rkey_0, r2:rkey_1, r3:rkey_2, r4:rkey_3, r5:rkey_4, r6:rkey_5} in
    (route_to_int_date_int {r1:1, r2:Some rkey_1, r3:Some rkey_2,
       r4:Some rkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| r1:{ key:int, value:int }, r2:int,
       r3:int, r4:int, r5:int, r6:real | r_tuple|} @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set }
      } @ { Collection })))) empty { key:address, value:collection { r1:{
    key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int,
    r6:real } @ { Set })


declare shuffle_QUERY3_mCUSTOMER2_to_QUERY3_bind_0t0_1t1_2t2 : { r1:option int,
  r2:option int, r3:option int, r4:collection { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set }, r5:bool
  } -> collection { key:address, value:collection { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set } } @ { Collection } =
  (\b1 -> bind b1 as {r1:lkey_0, r2:lkey_1, r3:lkey_2, r4:tuples,
  r5:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_date_int {r1:1, r2:lkey_0, r3:lkey_1, r4:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { r1:{ key:int, value:int }, r2:int,
       r3:int, r4:int, r5:int, r6:real } @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set }
      } @ { Collection }
    else empty { key:address, value:collection { r1:{ key:int, value:int },
      r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {r1:rkey_0, r2:rkey_1, r3:rkey_2, r4:rkey_3, r5:rkey_4, r6:rkey_5} in
    (route_to_int_date_int {r1:1, r2:Some rkey_1, r3:Some rkey_2,
       r4:Some rkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| r1:{ key:int, value:int }, r2:int,
       r3:int, r4:int, r5:int, r6:real | r_tuple|} @ { Set }};
       _accmap)))) empty { key:address, value:collection { r1:{ key:int,
      value:int }, r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set }
      } @ { Collection })))) empty { key:address, value:collection { r1:{
    key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int,
    r6:real } @ { Set })


declare nd_QUERY3_mORDERS6_send_correctives : { r1:address, r2:int, r3:{
  key:int, value:int }, r4:int, r5:{ key:int, value:int }, r6:collection {
  key:int, value:real } @ { Set } } -> int = (\b1 -> bind b1 as {r1:orig_addr,
  r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:corrective_vid, r6:delta_tuples} in 
  let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:2, value:6}, {key:2, value:10}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {key:map_0,
        value:map_val} in 
        (_accmap.insert {r1:g_min_vid, r2:map_0, r3:map_val};_accmap))))
        empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 10
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_insert_ORDERS vid as
            {r1:ORDERS_ORDERKEY, r2:ORDERS_CUSTKEY, r3:ORDERS_ORDERSTATUS, r4:ORDERS_TOTALPRICE, r5:ORDERS_ORDERDATE, r6:ORDERS_ORDERPRIORITY, r7:ORDERS_CLERK, r8:ORDERS_SHIPPRIORITY, r9:ORDERS_COMMENT}
            in
            (shuffle_QUERY3_mORDERS6_to_QUERY3_mCUSTOMER4_bind_0t0
               {r1:Some ORDERS_ORDERKEY, r2:Some ORDERS_ORDERDATE,
               r3:Some ORDERS_SHIPPRIORITY, r4:Some ORDERS_CUSTKEY,
               r5:delta_tuples2, r6:false}).fold ((\_accmap -> (\b3 ->
              bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {r1:ip, r2:vid, r3:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_val} in 
               (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
               key:int, value:real } @ { Set }};
               _accmap)))) empty { r1:address, r2:{ key:int, value:int },
              r3:collection { key:int, value:real } @ { Set }
              } @ { Collection })))) empty { r1:address, r2:{ key:int,
            value:int }, r3:collection { key:int, value:real } @ { Set }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {r1:ip, r2:vid,
            r3:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {r1:ip, r2:vid, r3:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
             value:real } @ { Set }})))) {key:empty { key:int, value:int
            } @ { Seq }, value:empty { key:int, value:real } @ { Set }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((insert_ORDERS_rcv_corrective_s10_m_QUERY3_mORDERS6, ip)<- {r1:orig_addr,
             r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:corrective_vid,
             r6:vid_send_list_tup.key, r7:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 6
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_ORDERS vid as
              {r1:ORDERS_ORDERKEY, r2:ORDERS_CUSTKEY, r3:ORDERS_ORDERSTATUS, r4:ORDERS_TOTALPRICE, r5:ORDERS_ORDERDATE, r6:ORDERS_ORDERPRIORITY, r7:ORDERS_CLERK, r8:ORDERS_SHIPPRIORITY, r9:ORDERS_COMMENT}
              in
              (shuffle_QUERY3_mORDERS6_to_QUERY3_bind_0t0
                 {r1:Some ORDERS_ORDERKEY, r2:Some ORDERS_ORDERDATE,
                 r3:Some ORDERS_SHIPPRIORITY, r4:delta_tuples2, r5:false}).fold
                ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {r1:ip, r2:vid, r3:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_val} in 
                 (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
                 key:int, value:real } @ { Set }};
                 _accmap)))) empty { r1:address, r2:{ key:int, value:int },
                r3:collection { key:int, value:real } @ { Set }
                } @ { Collection })))) empty { r1:address, r2:{ key:int,
              value:int }, r3:collection { key:int, value:real } @ { Set }
              } @ { Collection }).groupBy ((\b1 -> bind b1 as {r1:ip, r2:vid,
              r3:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
              value:acc_tuples} in bind b5 as {r1:ip, r2:vid, r3:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
               value:real } @ { Set }})))) {key:empty { key:int, value:int
              } @ { Seq }, value:empty { key:int, value:real } @ { Set }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_ORDERS_rcv_corrective_s6_m_QUERY3_mORDERS6, ip)<- {r1:orig_addr,
               r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:corrective_vid,
               r6:vid_send_list_tup.key, r7:vid_send_list_tup.value};
               acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_QUERY3_mORDERS3_send_correctives : { r1:address, r2:int, r3:{
  key:int, value:int }, r4:int, r5:{ key:int, value:int }, r6:collection {
  key:int, value:real } @ { Set } } -> int = (\b1 -> bind b1 as {r1:orig_addr,
  r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:corrective_vid, r6:delta_tuples} in 
  let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:2, value:6}, {key:2, value:9}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {key:map_0,
        value:map_val} in 
        (_accmap.insert {r1:g_min_vid, r2:map_0, r3:map_val};_accmap))))
        empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 9
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_insert_ORDERS vid as
            {r1:ORDERS_ORDERKEY, r2:ORDERS_CUSTKEY, r3:ORDERS_ORDERSTATUS, r4:ORDERS_TOTALPRICE, r5:ORDERS_ORDERDATE, r6:ORDERS_ORDERPRIORITY, r7:ORDERS_CLERK, r8:ORDERS_SHIPPRIORITY, r9:ORDERS_COMMENT}
            in
            (shuffle_QUERY3_mORDERS3_to_QUERY3_mCUSTOMER2_bind_0t0
               {r1:Some ORDERS_ORDERKEY, r2:Some ORDERS_ORDERDATE,
               r3:Some ORDERS_SHIPPRIORITY, r4:Some ORDERS_CUSTKEY,
               r5:delta_tuples2, r6:false}).fold ((\_accmap -> (\b3 ->
              bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {r1:ip, r2:vid, r3:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_val} in 
               (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
               key:int, value:real } @ { Set }};
               _accmap)))) empty { r1:address, r2:{ key:int, value:int },
              r3:collection { key:int, value:real } @ { Set }
              } @ { Collection })))) empty { r1:address, r2:{ key:int,
            value:int }, r3:collection { key:int, value:real } @ { Set }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {r1:ip, r2:vid,
            r3:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {r1:ip, r2:vid, r3:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
             value:real } @ { Set }})))) {key:empty { key:int, value:int
            } @ { Seq }, value:empty { key:int, value:real } @ { Set }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((insert_ORDERS_rcv_corrective_s9_m_QUERY3_mORDERS3, ip)<- {r1:orig_addr,
             r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:corrective_vid,
             r6:vid_send_list_tup.key, r7:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 6
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_ORDERS vid as
              {r1:ORDERS_ORDERKEY, r2:ORDERS_CUSTKEY, r3:ORDERS_ORDERSTATUS, r4:ORDERS_TOTALPRICE, r5:ORDERS_ORDERDATE, r6:ORDERS_ORDERPRIORITY, r7:ORDERS_CLERK, r8:ORDERS_SHIPPRIORITY, r9:ORDERS_COMMENT}
              in
              (shuffle_QUERY3_mORDERS3_to_QUERY3_bind_0t0
                 {r1:Some ORDERS_ORDERKEY, r2:Some ORDERS_ORDERDATE,
                 r3:Some ORDERS_SHIPPRIORITY, r4:delta_tuples2, r5:false}).fold
                ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {r1:ip, r2:vid, r3:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_val} in 
                 (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
                 key:int, value:real } @ { Set }};
                 _accmap)))) empty { r1:address, r2:{ key:int, value:int },
                r3:collection { key:int, value:real } @ { Set }
                } @ { Collection })))) empty { r1:address, r2:{ key:int,
              value:int }, r3:collection { key:int, value:real } @ { Set }
              } @ { Collection }).groupBy ((\b1 -> bind b1 as {r1:ip, r2:vid,
              r3:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
              value:acc_tuples} in bind b5 as {r1:ip, r2:vid, r3:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
               value:real } @ { Set }})))) {key:empty { key:int, value:int
              } @ { Seq }, value:empty { key:int, value:real } @ { Set }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_ORDERS_rcv_corrective_s6_m_QUERY3_mORDERS3, ip)<- {r1:orig_addr,
               r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:corrective_vid,
               r6:vid_send_list_tup.key, r7:vid_send_list_tup.value};
               acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_QUERY3_mCUSTOMER4_send_correctives : { r1:address, r2:int, r3:{
  key:int, value:int }, r4:int, r5:{ key:int, value:int }, r6:collection {
  r1:int, r2:int, r3:int, r4:int, r5:real } @ { Set } } -> int = (\b1 ->
  bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop,
  r5:corrective_vid, r6:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:0, value:0}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {r1:map_0, r2:map_1,
        r3:map_2, r4:map_3, r5:map_val} in 
        (_accmap.insert {r1:g_min_vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
         r6:map_val};
         _accmap)))) empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int,
        r5:int, r6:real } @ { Set } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 0
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_insert_CUSTOMER vid as
            {r1:CUSTOMER_CUSTKEY, r2:CUSTOMER_NAME, r3:CUSTOMER_ADDRESS, r4:CUSTOMER_NATIONKEY, r5:CUSTOMER_PHONE, r6:CUSTOMER_ACCTBAL, r7:CUSTOMER_MKTSEGMENT, r8:CUSTOMER_COMMENT}
            in
            (shuffle_QUERY3_mCUSTOMER4_to_QUERY3_bind_0t0_1t1_2t2
               {r1:None immut, r2:None immut, r3:None immut, r4:delta_tuples2,
               r5:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
              value:tuples} in 
              (_accmap.insert {r1:ip, r2:vid, r3:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_1, r4:map_2,
               r5:map_3, r6:map_val} in 
               (_accmap.insert {r1:map_0, r2:map_1, r3:map_2, r4:map_3,
                r5:map_val};
                _accmap)))) empty { r1:int, r2:int, r3:int, r4:int, r5:real
               } @ { Set }};
               _accmap)))) empty { r1:address, r2:{ key:int, value:int },
              r3:collection { r1:int, r2:int, r3:int, r4:int, r5:real
              } @ { Set } } @ { Collection })))) empty { r1:address, r2:{
            key:int, value:int }, r3:collection { r1:int, r2:int, r3:int,
            r4:int, r5:real } @ { Set } } @ { Collection }).groupBy ((\b1 ->
            bind b1 as {r1:ip, r2:vid, r3:tuples} in ip)) ((\b2 -> (\b5 ->
            bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {r1:ip,
            r2:vid, r3:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { r1:int, r2:int,
             r3:int, r4:int, r5:real } @ { Set }})))) {key:empty { key:int,
            value:int } @ { Seq }, value:empty { r1:int, r2:int, r3:int,
            r4:int, r5:real } @ { Set }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((insert_CUSTOMER_rcv_corrective_s0_m_QUERY3_mCUSTOMER4, ip)<- {r1:orig_addr,
             r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:corrective_vid,
             r6:vid_send_list_tup.key, r7:vid_send_list_tup.value};
             acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_QUERY3_mCUSTOMER2_send_correctives : { r1:address, r2:int, r3:{
  key:int, value:int }, r4:int, r5:{ key:int, value:int }, r6:collection {
  r1:int, r2:int, r3:int, r4:int, r5:real } @ { Set } } -> int = (\b1 ->
  bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop,
  r5:corrective_vid, r6:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:0, value:0}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {r1:map_0, r2:map_1,
        r3:map_2, r4:map_3, r5:map_val} in 
        (_accmap.insert {r1:g_min_vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
         r6:map_val};
         _accmap)))) empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int,
        r5:int, r6:real } @ { Set } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 0
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_insert_CUSTOMER vid as
            {r1:CUSTOMER_CUSTKEY, r2:CUSTOMER_NAME, r3:CUSTOMER_ADDRESS, r4:CUSTOMER_NATIONKEY, r5:CUSTOMER_PHONE, r6:CUSTOMER_ACCTBAL, r7:CUSTOMER_MKTSEGMENT, r8:CUSTOMER_COMMENT}
            in
            (shuffle_QUERY3_mCUSTOMER2_to_QUERY3_bind_0t0_1t1_2t2
               {r1:None immut, r2:None immut, r3:None immut, r4:delta_tuples2,
               r5:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
              value:tuples} in 
              (_accmap.insert {r1:ip, r2:vid, r3:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_1, r4:map_2,
               r5:map_3, r6:map_val} in 
               (_accmap.insert {r1:map_0, r2:map_1, r3:map_2, r4:map_3,
                r5:map_val};
                _accmap)))) empty { r1:int, r2:int, r3:int, r4:int, r5:real
               } @ { Set }};
               _accmap)))) empty { r1:address, r2:{ key:int, value:int },
              r3:collection { r1:int, r2:int, r3:int, r4:int, r5:real
              } @ { Set } } @ { Collection })))) empty { r1:address, r2:{
            key:int, value:int }, r3:collection { r1:int, r2:int, r3:int,
            r4:int, r5:real } @ { Set } } @ { Collection }).groupBy ((\b1 ->
            bind b1 as {r1:ip, r2:vid, r3:tuples} in ip)) ((\b2 -> (\b5 ->
            bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {r1:ip,
            r2:vid, r3:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { r1:int, r2:int,
             r3:int, r4:int, r5:real } @ { Set }})))) {key:empty { key:int,
            value:int } @ { Seq }, value:empty { r1:int, r2:int, r3:int,
            r4:int, r5:real } @ { Set }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((insert_CUSTOMER_rcv_corrective_s0_m_QUERY3_mCUSTOMER2, ip)<- {r1:orig_addr,
             r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:corrective_vid,
             r6:vid_send_list_tup.key, r7:vid_send_list_tup.value};
             acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_QUERY3_mLINEITEM1_mCUSTOMER2_send_correctives : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int },
  r6:collection { r1:int, r2:int, r3:int, r4:int, r5:int } @ { Set } } -> int =
  (\b1 -> bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop,
  r5:corrective_vid, r6:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:0, value:1}, {key:4, value:19}, {key:4, value:20}|} @ { Collection }}
  in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {r1:map_0, r2:map_1,
        r3:map_2, r4:map_3, r5:map_val} in 
        (_accmap.insert {r1:g_min_vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
         r6:map_val};
         _accmap)))) empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int,
        r5:int, r6:int } @ { Set } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 20
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_insert_LINEITEM vid as
            {r1:LINEITEM_ORDERKEY, r2:LINEITEM_PARTKEY, r3:LINEITEM_SUPPKEY, r4:LINEITEM_LINENUMBER, r5:LINEITEM_QUANTITY, r6:LINEITEM_EXTENDEDPRICE, r7:LINEITEM_DISCOUNT, r8:LINEITEM_TAX, r9:LINEITEM_RETURNFLAG, r10:LINEITEM_LINESTATUS, r11:LINEITEM_SHIPDATE, r12:LINEITEM_COMMITDATE, r13:LINEITEM_RECEIPTDATE, r14:LINEITEM_SHIPINSTRUCT, r15:LINEITEM_SHIPMODE, r16:LINEITEM_COMMENT}
            in
            (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_to_QUERY3_mCUSTOMER4_bind_0t0_1t1_2t2_3t3
               {r1:Some LINEITEM_ORDERKEY, r2:None immut, r3:None immut,
               r4:None immut, r5:delta_tuples2, r6:false}).fold ((\_accmap ->
              (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {r1:ip, r2:vid, r3:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_1, r4:map_2,
               r5:map_3, r6:map_val} in 
               (_accmap.insert {r1:map_0, r2:map_1, r3:map_2, r4:map_3,
                r5:map_val};
                _accmap)))) empty { r1:int, r2:int, r3:int, r4:int, r5:int
               } @ { Set }};
               _accmap)))) empty { r1:address, r2:{ key:int, value:int },
              r3:collection { r1:int, r2:int, r3:int, r4:int, r5:int
              } @ { Set } } @ { Collection })))) empty { r1:address, r2:{
            key:int, value:int }, r3:collection { r1:int, r2:int, r3:int,
            r4:int, r5:int } @ { Set } } @ { Collection }).groupBy ((\b1 ->
            bind b1 as {r1:ip, r2:vid, r3:tuples} in ip)) ((\b2 -> (\b5 ->
            bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {r1:ip,
            r2:vid, r3:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { r1:int, r2:int,
             r3:int, r4:int, r5:int } @ { Set }})))) {key:empty { key:int,
            value:int } @ { Seq }, value:empty { r1:int, r2:int, r3:int,
            r4:int, r5:int } @ { Set }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((insert_LINEITEM_rcv_corrective_s20_m_QUERY3_mLINEITEM1_mCUSTOMER2,
               ip)<- {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop,
             r5:corrective_vid, r6:vid_send_list_tup.key,
             r7:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 19
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_LINEITEM vid as
              {r1:LINEITEM_ORDERKEY, r2:LINEITEM_PARTKEY, r3:LINEITEM_SUPPKEY, r4:LINEITEM_LINENUMBER, r5:LINEITEM_QUANTITY, r6:LINEITEM_EXTENDEDPRICE, r7:LINEITEM_DISCOUNT, r8:LINEITEM_TAX, r9:LINEITEM_RETURNFLAG, r10:LINEITEM_LINESTATUS, r11:LINEITEM_SHIPDATE, r12:LINEITEM_COMMITDATE, r13:LINEITEM_RECEIPTDATE, r14:LINEITEM_SHIPINSTRUCT, r15:LINEITEM_SHIPMODE, r16:LINEITEM_COMMENT}
              in
              (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_to_QUERY3_mCUSTOMER2_bind_0t0_1t1_2t2_3t3
                 {r1:Some LINEITEM_ORDERKEY, r2:None immut, r3:None immut,
                 r4:None immut, r5:delta_tuples2, r6:false}).fold ((\_accmap ->
                (\b3 -> bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {r1:ip, r2:vid, r3:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_1, r4:map_2,
                 r5:map_3, r6:map_val} in 
                 (_accmap.insert {r1:map_0, r2:map_1, r3:map_2, r4:map_3,
                  r5:map_val};
                  _accmap)))) empty { r1:int, r2:int, r3:int, r4:int, r5:int
                 } @ { Set }};
                 _accmap)))) empty { r1:address, r2:{ key:int, value:int },
                r3:collection { r1:int, r2:int, r3:int, r4:int, r5:int
                } @ { Set } } @ { Collection })))) empty { r1:address, r2:{
              key:int, value:int }, r3:collection { r1:int, r2:int, r3:int,
              r4:int, r5:int } @ { Set } } @ { Collection }).groupBy ((\b1 ->
              bind b1 as {r1:ip, r2:vid, r3:tuples} in ip)) ((\b2 -> (\b5 ->
              bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {r1:ip,
              r2:vid, r3:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { r1:int,
               r2:int, r3:int, r4:int, r5:int } @ { Set }})))) {key:empty {
              key:int, value:int } @ { Seq }, value:empty { r1:int, r2:int,
              r3:int, r4:int, r5:int } @ { Set }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_LINEITEM_rcv_corrective_s19_m_QUERY3_mLINEITEM1_mCUSTOMER2,
                 ip)<- {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop,
               r5:corrective_vid, r6:vid_send_list_tup.key,
               r7:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 1
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_insert_CUSTOMER vid as
                {r1:CUSTOMER_CUSTKEY, r2:CUSTOMER_NAME, r3:CUSTOMER_ADDRESS, r4:CUSTOMER_NATIONKEY, r5:CUSTOMER_PHONE, r6:CUSTOMER_ACCTBAL, r7:CUSTOMER_MKTSEGMENT, r8:CUSTOMER_COMMENT}
                in
                (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_to_QUERY3_mLINEITEM1_bind_0t0_1t1_2t2
                   {r1:None immut, r2:None immut, r3:None immut,
                   r4:delta_tuples2, r5:false}).fold ((\_accmap -> (\b3 ->
                  bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {r1:ip, r2:vid, r3:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_1, r4:map_2,
                   r5:map_3, r6:map_val} in 
                   (_accmap.insert {r1:map_0, r2:map_1, r3:map_2, r4:map_3,
                    r5:map_val};
                    _accmap)))) empty { r1:int, r2:int, r3:int, r4:int, r5:int
                   } @ { Set }};
                   _accmap)))) empty { r1:address, r2:{ key:int, value:int },
                  r3:collection { r1:int, r2:int, r3:int, r4:int, r5:int
                  } @ { Set } } @ { Collection })))) empty { r1:address, r2:{
                key:int, value:int }, r3:collection { r1:int, r2:int, r3:int,
                r4:int, r5:int } @ { Set } } @ { Collection }).groupBy ((\b1 ->
                bind b1 as {r1:ip, r2:vid, r3:tuples} in ip)) ((\b2 -> (\b5 ->
                bind b2 as {key:acc_vid, value:acc_tuples} in 
                bind b5 as {r1:ip, r2:vid, r3:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { r1:int, r2:int, r3:int, r4:int, r5:int } @ { Set }}))))
                {key:empty { key:int, value:int } @ { Seq }, value:empty {
                r1:int, r2:int, r3:int, r4:int, r5:int } @ { Set }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((insert_CUSTOMER_rcv_corrective_s1_m_QUERY3_mLINEITEM1_mCUSTOMER2,
                   ip)<- {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop,
                 r5:corrective_vid, r6:vid_send_list_tup.key,
                 r7:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_QUERY3_mORDERS1_send_correctives : { r1:address, r2:int, r3:{
  key:int, value:int }, r4:int, r5:{ key:int, value:int }, r6:collection {
  key:int, value:int } @ { Set } } -> int = (\b1 -> bind b1 as {r1:orig_addr,
  r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:corrective_vid, r6:delta_tuples} in 
  let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:2, value:6}, {key:2, value:7}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {key:map_0,
        value:map_val} in 
        (_accmap.insert {r1:g_min_vid, r2:map_0, r3:map_val};_accmap))))
        empty { r1:{ key:int, value:int }, r2:int, r3:int } @ { Set } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 7
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_insert_ORDERS vid as
            {r1:ORDERS_ORDERKEY, r2:ORDERS_CUSTKEY, r3:ORDERS_ORDERSTATUS, r4:ORDERS_TOTALPRICE, r5:ORDERS_ORDERDATE, r6:ORDERS_ORDERPRIORITY, r7:ORDERS_CLERK, r8:ORDERS_SHIPPRIORITY, r9:ORDERS_COMMENT}
            in
            (shuffle_QUERY3_mORDERS1_to_QUERY3_mLINEITEM1
               {r1:Some ORDERS_ORDERKEY, r2:Some ORDERS_ORDERDATE,
               r3:Some ORDERS_SHIPPRIORITY, r4:delta_tuples2, r5:false}).fold
              ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {r1:ip, r2:vid, r3:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_val} in 
               (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
               key:int, value:int } @ { Set }};
               _accmap)))) empty { r1:address, r2:{ key:int, value:int },
              r3:collection { key:int, value:int } @ { Set } } @ { Collection }))))
            empty { r1:address, r2:{ key:int, value:int }, r3:collection {
            key:int, value:int } @ { Set } } @ { Collection }).groupBy ((\b1 ->
            bind b1 as {r1:ip, r2:vid, r3:tuples} in ip)) ((\b2 -> (\b5 ->
            bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {r1:ip,
            r2:vid, r3:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
             value:int } @ { Set }})))) {key:empty { key:int, value:int
            } @ { Seq }, value:empty { key:int, value:int } @ { Set }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((insert_ORDERS_rcv_corrective_s7_m_QUERY3_mORDERS1, ip)<- {r1:orig_addr,
             r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:corrective_vid,
             r6:vid_send_list_tup.key, r7:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 6
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_ORDERS vid as
              {r1:ORDERS_ORDERKEY, r2:ORDERS_CUSTKEY, r3:ORDERS_ORDERSTATUS, r4:ORDERS_TOTALPRICE, r5:ORDERS_ORDERDATE, r6:ORDERS_ORDERPRIORITY, r7:ORDERS_CLERK, r8:ORDERS_SHIPPRIORITY, r9:ORDERS_COMMENT}
              in
              (shuffle_QUERY3_mORDERS1_to_QUERY3 {r1:Some ORDERS_ORDERKEY,
                 r2:Some ORDERS_ORDERDATE, r3:Some ORDERS_SHIPPRIORITY,
                 r4:delta_tuples2, r5:false}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {r1:ip, r2:vid, r3:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_val} in 
                 (_accmap.insert {key:map_0, value:map_val};_accmap)))) empty {
                 key:int, value:int } @ { Set }};
                 _accmap)))) empty { r1:address, r2:{ key:int, value:int },
                r3:collection { key:int, value:int } @ { Set }
                } @ { Collection })))) empty { r1:address, r2:{ key:int,
              value:int }, r3:collection { key:int, value:int } @ { Set }
              } @ { Collection }).groupBy ((\b1 -> bind b1 as {r1:ip, r2:vid,
              r3:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
              value:acc_tuples} in bind b5 as {r1:ip, r2:vid, r3:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { key:int,
               value:int } @ { Set }})))) {key:empty { key:int, value:int
              } @ { Seq }, value:empty { key:int, value:int } @ { Set }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_ORDERS_rcv_corrective_s6_m_QUERY3_mORDERS1, ip)<- {r1:orig_addr,
               r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:corrective_vid,
               r6:vid_send_list_tup.key, r7:vid_send_list_tup.value};
               acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_QUERY3_mLINEITEM1_send_correctives : { r1:address, r2:int, r3:{
  key:int, value:int }, r4:int, r5:{ key:int, value:int }, r6:collection {
  r1:int, r2:int, r3:int, r4:int } @ { Set } } -> int = (\b1 ->
  bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop,
  r5:corrective_vid, r6:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:4, value:16}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {r1:map_0, r2:map_1,
        r3:map_2, r4:map_val} in 
        (_accmap.insert {r1:g_min_vid, r2:map_0, r3:map_1, r4:map_2,
         r5:map_val};
         _accmap)))) empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int,
        r5:int } @ { Set } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 16
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_insert_LINEITEM vid as
            {r1:LINEITEM_ORDERKEY, r2:LINEITEM_PARTKEY, r3:LINEITEM_SUPPKEY, r4:LINEITEM_LINENUMBER, r5:LINEITEM_QUANTITY, r6:LINEITEM_EXTENDEDPRICE, r7:LINEITEM_DISCOUNT, r8:LINEITEM_TAX, r9:LINEITEM_RETURNFLAG, r10:LINEITEM_LINESTATUS, r11:LINEITEM_SHIPDATE, r12:LINEITEM_COMMITDATE, r13:LINEITEM_RECEIPTDATE, r14:LINEITEM_SHIPINSTRUCT, r15:LINEITEM_SHIPMODE, r16:LINEITEM_COMMENT}
            in
            (shuffle_QUERY3_mLINEITEM1_to_QUERY3_bind_0t0_1t1_2t2
               {r1:Some LINEITEM_ORDERKEY, r2:None immut, r3:None immut,
               r4:delta_tuples2, r5:false}).fold ((\_accmap -> (\b3 ->
              bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {r1:ip, r2:vid, r3:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_1, r4:map_2,
               r5:map_val} in 
               (_accmap.insert {r1:map_0, r2:map_1, r3:map_2, r4:map_val};
                _accmap)))) empty { r1:int, r2:int, r3:int, r4:int } @ { Set }};
               _accmap)))) empty { r1:address, r2:{ key:int, value:int },
              r3:collection { r1:int, r2:int, r3:int, r4:int } @ { Set }
              } @ { Collection })))) empty { r1:address, r2:{ key:int,
            value:int }, r3:collection { r1:int, r2:int, r3:int, r4:int
            } @ { Set } } @ { Collection }).groupBy ((\b1 -> bind b1 as {r1:ip,
            r2:vid, r3:tuples} in ip)) ((\b2 -> (\b5 ->
            bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {r1:ip,
            r2:vid, r3:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { r1:int, r2:int,
             r3:int, r4:int } @ { Set }})))) {key:empty { key:int, value:int
            } @ { Seq }, value:empty { r1:int, r2:int, r3:int, r4:int
            } @ { Set }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((insert_LINEITEM_rcv_corrective_s16_m_QUERY3_mLINEITEM1, ip)<- {r1:orig_addr,
             r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:corrective_vid,
             r6:vid_send_list_tup.key, r7:vid_send_list_tup.value};
             acc_count + 1)))) acc_count else acc_count))) 0)


declare sw_insert_CUSTOMER : { r1:int, r2:string, r3:string, r4:int, r5:string,
  r6:real, r7:string, r8:string } -> () = (\args ->
  (sw_buf_insert_CUSTOMER.insert args;
   sw_trig_buf_idx.insert {i:0};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_insert_CUSTOMER_send_fetch : { key:int, value:int } -> () = (\vid ->
  case (sw_buf_insert_CUSTOMER.peek ()) of
  {Some args ->
    (sw_buf_insert_CUSTOMER.erase args;
     bind args as
     {r1:CUSTOMER_CUSTKEY, r2:CUSTOMER_NAME, r3:CUSTOMER_ADDRESS, r4:CUSTOMER_NATIONKEY, r5:CUSTOMER_PHONE, r6:CUSTOMER_ACCTBAL, r7:CUSTOMER_MKTSEGMENT, r8:CUSTOMER_COMMENT}
     in
     ((route_to_int {key:4, value:Some CUSTOMER_CUSTKEY}).iterate ((\b1 ->
      bind b1 as {i:ip} in 
      (nd_insert_CUSTOMER_do_complete_s2_trig, ip)<- {r1:vid,
      r2:CUSTOMER_CUSTKEY, r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS,
      r5:CUSTOMER_NATIONKEY, r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL,
      r8:CUSTOMER_MKTSEGMENT, r9:CUSTOMER_COMMENT}));
      ((((empty { r1:address, r2:int, r3:int } @ { Collection }).combine (let
      sender_count =
      (route_to_int_date_int_int {r1:7, r2:None immut, r3:None immut,
         r4:None immut, r5:Some CUSTOMER_CUSTKEY}).fold ((\count -> (\b3 ->
        bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_QUERY3_mCUSTOMER2_to_QUERY3_bind_0t0_1t1_2t2 {r1:None immut,
          r2:None immut, r3:None immut, r4:empty { r1:{ key:int, value:int },
          r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set }, r5:true}).fold
        ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {r1:ip, r2:0, r3:sender_count};_accmap)))) empty {
        r1:address, r2:int, r3:int } @ { Collection }).combine (let
        sender_count =
        (route_to_int_date_int_int {r1:8, r2:None immut, r3:None immut,
           r4:None immut, r5:Some CUSTOMER_CUSTKEY}).fold ((\count -> (\b3 ->
          bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mCUSTOMER4_to_QUERY3_bind_0t0_1t1_2t2 {r1:None immut,
            r2:None immut, r3:None immut, r4:empty { r1:{ key:int, value:int },
            r2:int, r3:int, r4:int, r5:int, r6:real } @ { Set }, r5:true}).fold
          ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {r1:ip, r2:0, r3:sender_count};_accmap)))) empty {
          r1:address, r2:int, r3:int } @ { Collection }).combine (let
          sender_count =
          (route_to_int_date_int_int {r1:3, r2:None immut, r3:None immut,
             r4:None immut, r5:Some CUSTOMER_CUSTKEY}).fold ((\count -> (\b3 ->
            bind b3 as {i:ip} in count + 1))) 0 in
          (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_to_QUERY3_mLINEITEM1_bind_0t0_1t1_2t2
             {r1:None immut, r2:None immut, r3:None immut, r4:empty { r1:{
             key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int
             } @ { Set }, r5:true}).fold ((\_accmap -> (\b3 ->
            bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {r1:ip, r2:1, r3:sender_count};_accmap)))) empty {
            r1:address, r2:int, r3:int } @ { Collection })))).groupBy ((\b1 ->
      bind b1 as {r1:ip, r2:stmt_id, r3:count} in {key:ip, value:stmt_id}))
      ((\acc -> (\b3 -> bind b3 as {r1:ip, r2:stmt_id, r3:count} in acc +
      count))) 0).groupBy ((\b1 -> bind b1 as {key:b2, value:count} in 
      bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc -> (\b3 ->
      bind b3 as {key:ip_and_stmt_id, value:count} in bind ip_and_stmt_id as
      {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_insert_CUSTOMER_rcv_put, addr)<- {r1:me, r2:stmt_cnt_list, r3:vid,
       r4:CUSTOMER_CUSTKEY, r5:CUSTOMER_NAME, r6:CUSTOMER_ADDRESS,
       r7:CUSTOMER_NATIONKEY, r8:CUSTOMER_PHONE, r9:CUSTOMER_ACCTBAL,
       r10:CUSTOMER_MKTSEGMENT, r11:CUSTOMER_COMMENT};
       (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == vid))).peek ()) of
       {Some old_val -> let old_set = old_val.value in
         (old_set.insert {i:addr};sw_ack_log.insert {key:vid, value:old_set})}
       {None -> sw_ack_log.insert {key:vid, value:{|i:address|
         addr|} @ { Set }}}))));
      ((((route_to_int_date_int_int {r1:3, r2:None immut, r3:None immut,
            r4:None immut, r5:Some CUSTOMER_CUSTKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {r1:1, r2:3, r3:ip};_accmap)))) empty { r1:int, r2:int,
      r3:address } @ { Collection }).combine
      (((route_to_int_date_int_int {r1:8, r2:None immut, r3:None immut,
           r4:None immut, r5:Some CUSTOMER_CUSTKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {r1:0, r2:8, r3:ip};_accmap))))
      empty { r1:int, r2:int, r3:address } @ { Collection }).combine
      (((route_to_int_date_int_int {r1:7, r2:None immut, r3:None immut,
           r4:None immut, r5:Some CUSTOMER_CUSTKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {r1:0, r2:7, r3:ip};_accmap))))
      empty { r1:int, r2:int, r3:address } @ { Collection }).combine empty {
      r1:int, r2:int, r3:address } @ { Collection }))).groupBy ((\b1 ->
      bind b1 as {r1:stmt_id, r2:map_id, r3:ip} in ip)) ((\acc -> (\b3 ->
      bind b3 as {r1:stmt_id, r2:map_id, r3:ip} in 
      (acc.insert {key:stmt_id, value:map_id};acc)))) empty { key:int,
      value:int } @ { Collection }).iterate ((\b1 -> bind b1 as {key:ip,
      value:stmt_map_ids} in 
      (nd_insert_CUSTOMER_rcv_fetch, ip)<- {r1:stmt_map_ids, r2:vid,
      r3:CUSTOMER_CUSTKEY, r4:CUSTOMER_NAME, r5:CUSTOMER_ADDRESS,
      r6:CUSTOMER_NATIONKEY, r7:CUSTOMER_PHONE, r8:CUSTOMER_ACCTBAL,
      r9:CUSTOMER_MKTSEGMENT, r10:CUSTOMER_COMMENT}))))}{None ->
                                                          error
                                                            (print
                                                               "unexpected missing arguments in sw_buf_insert_CUSTOMER")})


declare nd_insert_CUSTOMER_do_complete_s0 : { r1:{ key:int, value:int },
  r2:int, r3:string, r4:string, r5:int, r6:string, r7:real, r8:string,
  r9:string } -> () = (\b1 -> bind b1 as {r1:vid, r2:CUSTOMER_CUSTKEY,
  r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY,
  r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT,
  r9:CUSTOMER_COMMENT} in let delta_values =
  (((((((bind map_QUERY3_mCUSTOMER2_s0_buf as ind __x in
    (frontier_int_date_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4, r5:r5, r6:r6} in r5 ==
       CUSTOMER_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {r1:vid,
      r2:map_0, r3:map_1, r4:map_2, r5:map_3, r6:map_val} in 
      (acc.insert {r1:map_0, r2:map_1, r3:map_2, r4:map_3, r5:map_val};acc))))
      empty { r1:int, r2:int, r3:int, r4:int, r5:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {r1:ORDERS_ORDERKEY, r2:ORDERS_ORDERDATE,
    r3:ORDERS_SHIPPRIORITY, r4:CUSTOMER_CUSTKEY, r5:__map_ret__1} in 
    (_accmap.insert {r1:ORDERS_ORDERKEY, r2:ORDERS_ORDERDATE,
     r3:ORDERS_SHIPPRIORITY, r4:__map_ret__1};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {r1:ORDERS_ORDERKEY, r2:ORDERS_ORDERDATE,
    r3:ORDERS_SHIPPRIORITY, r4:__map_ret__1} in 
    (_accmap.insert {r1:ORDERS_ORDERKEY, r2:ORDERS_ORDERDATE,
     r3:ORDERS_SHIPPRIORITY, r4:__map_ret__1 * -1};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:real
    } @ { Collection }).combine ((bind map_QUERY3_mCUSTOMER4_s0_buf as ind __x
    in
    (frontier_int_date_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4, r5:r5, r6:r6} in r5 ==
       CUSTOMER_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {r1:vid,
      r2:map_0, r3:map_1, r4:map_2, r5:map_3, r6:map_val} in 
      (acc.insert {r1:map_0, r2:map_1, r3:map_2, r4:map_3, r5:map_val};acc))))
      empty { r1:int, r2:int, r3:int, r4:int, r5:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {r1:ORDERS_ORDERKEY, r2:ORDERS_ORDERDATE,
    r3:ORDERS_SHIPPRIORITY, r4:CUSTOMER_CUSTKEY, r5:__map_ret__2} in 
    (_accmap.insert {r1:ORDERS_ORDERKEY, r2:ORDERS_ORDERDATE,
     r3:ORDERS_SHIPPRIORITY, r4:__map_ret__2};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:real
    } @ { Collection })).fold ((\_accmap -> (\b3 ->
    bind b3 as {r1:ORDERS_ORDERKEY, r2:ORDERS_ORDERDATE,
    r3:ORDERS_SHIPPRIORITY, r4:__sum_ret__1} in 
    (_accmap.insert {r1:ORDERS_ORDERKEY, r2:ORDERS_ORDERDATE,
     r3:ORDERS_SHIPPRIORITY, r4:__sum_ret__1 *
     if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {r1:ORDERS_ORDERKEY, r2:ORDERS_ORDERDATE,
    r3:ORDERS_SHIPPRIORITY, r4:__prod_ret__2} in 
    (_accmap.insert {r1:ORDERS_ORDERKEY, r2:ORDERS_ORDERDATE,
     r3:ORDERS_SHIPPRIORITY, r4:__prod_ret__2};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:real
    } @ { Collection }).groupBy ((\b1 -> bind b1 as {r1:map_0, r2:map_1,
    r3:map_2, r4:map_val} in {r1:map_0, r2:map_1, r3:map_2})) ((\acc -> (\b3 ->
    bind b3 as {r1:map_0, r2:map_1, r3:map_2, r4:map_val} in acc + map_val)))
    0).fold ((\acc -> (\b3 -> bind b3 as {key:g, value:val} in 
    (acc.insert {r1:g.r1, r2:g.r2, r3:g.r3, r4:val};acc)))) empty { r1:int,
    r2:int, r3:int, r4:real } @ { Set } in
  ((nd_add_delta_to_int_date_int_float {r1:QUERY3, r2:false, r3:vid,
      r4:delta_values});
   (nd_complete_stmt_cntr_check {key:vid, value:0})))


declare nd_insert_CUSTOMER_do_complete_s1 : { r1:{ key:int, value:int },
  r2:int, r3:string, r4:string, r5:int, r6:string, r7:real, r8:string,
  r9:string } -> () = (\b1 -> bind b1 as {r1:vid, r2:CUSTOMER_CUSTKEY,
  r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY,
  r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT,
  r9:CUSTOMER_COMMENT} in let delta_values =
  ((((bind map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf as ind __x in
    (frontier_int_date_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4, r5:r5, r6:r6} in r5 ==
       CUSTOMER_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {r1:vid,
      r2:map_0, r3:map_1, r4:map_2, r5:map_3, r6:map_val} in 
      (acc.insert {r1:map_0, r2:map_1, r3:map_2, r4:map_3, r5:map_val};acc))))
      empty { r1:int, r2:int, r3:int, r4:int, r5:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {r1:QUERY3_mLINEITEMLINEITEM_ORDERKEY,
    r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY, r4:CUSTOMER_CUSTKEY,
    r5:__map_ret__3} in 
    (_accmap.insert {r1:QUERY3_mLINEITEMLINEITEM_ORDERKEY, r2:ORDERS_ORDERDATE,
     r3:ORDERS_SHIPPRIORITY, r4:__map_ret__3};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {r1:QUERY3_mLINEITEMLINEITEM_ORDERKEY, r2:ORDERS_ORDERDATE,
    r3:ORDERS_SHIPPRIORITY, r4:__map_ret__3} in 
    (_accmap.insert {r1:QUERY3_mLINEITEMLINEITEM_ORDERKEY, r2:ORDERS_ORDERDATE,
     r3:ORDERS_SHIPPRIORITY, r4:__map_ret__3 *
     if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {r1:QUERY3_mLINEITEMLINEITEM_ORDERKEY, r2:ORDERS_ORDERDATE,
    r3:ORDERS_SHIPPRIORITY, r4:__prod_ret__3} in 
    (_accmap.insert {r1:QUERY3_mLINEITEMLINEITEM_ORDERKEY, r2:ORDERS_ORDERDATE,
     r3:ORDERS_SHIPPRIORITY, r4:__prod_ret__3};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:int
    } @ { Collection }).fold ((\acc_conv -> (\x ->
    (acc_conv.insert x;acc_conv)))) empty { r1:int, r2:int, r3:int, r4:int
    } @ { Set } in
  ((nd_add_delta_to_int_date_int_int {r1:QUERY3_mLINEITEM1, r2:false, r3:vid,
      r4:delta_values});
   let sent_msgs =
   nd_QUERY3_mLINEITEM1_send_correctives {r1:me, r2:1, r3:vid, r4:1, r5:vid,
     r6:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:1}
     else
       nd_update_stmt_cntr_corr_map {r1:vid, r2:1, r3:1, r4:sent_msgs, r5:true,
         r6:false}))


declare nd_insert_CUSTOMER_do_complete_s2 : { r1:{ key:int, value:int },
  r2:int, r3:string, r4:string, r5:int, r6:string, r7:real, r8:string,
  r9:string } -> () = (\b1 -> bind b1 as {r1:vid, r2:CUSTOMER_CUSTKEY,
  r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY,
  r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT,
  r9:CUSTOMER_COMMENT} in let __cmp_ret__3 =
  if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0 in
  ((nd_add_delta_to_int_int {r1:QUERY3_mORDERS1, r2:false, r3:vid, r4:{|
      key:int, value:int | {key:CUSTOMER_CUSTKEY,
      value:__cmp_ret__3}|} @ { Set }});
   let sent_msgs =
   nd_QUERY3_mORDERS1_send_correctives {r1:me, r2:2, r3:vid, r4:1, r5:vid,
     r6:{| key:int, value:int | {key:CUSTOMER_CUSTKEY,
     value:__cmp_ret__3}|} @ { Set }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {r1:vid, r2:2, r3:1, r4:sent_msgs, r5:true,
         r6:true}))


declare insert_CUSTOMER_do_corrective_s0_m_QUERY3_mCUSTOMER2 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int }, r6:int,
  r7:string, r8:string, r9:int, r10:string, r11:real, r12:string, r13:string,
  r14:collection { r1:int, r2:int, r3:int, r4:int, r5:real } @ { Set }
  } -> int = (\b1 -> bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid,
  r4:hop, r5:vid, r6:CUSTOMER_CUSTKEY, r7:CUSTOMER_NAME, r8:CUSTOMER_ADDRESS,
  r9:CUSTOMER_NATIONKEY, r10:CUSTOMER_PHONE, r11:CUSTOMER_ACCTBAL,
  r12:CUSTOMER_MKTSEGMENT, r13:CUSTOMER_COMMENT, r14:delta_tuples} in let
  new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {r1:delta_ORDERS_ORDERKEY, r2:delta_ORDERS_ORDERDATE,
    r3:delta_ORDERS_SHIPPRIORITY, r4:delta_QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
    r5:delta_QUERY3_mCUSTOMER2} in _accext.combine (let __prod_ret__169 =
    ((if CUSTOMER_CUSTKEY == delta_QUERY3_mCUSTOMERCUSTOMER_CUSTKEY then 1
      else 0) * if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0) *
      -delta_QUERY3_mCUSTOMER2 in
    {| r1:int, r2:int, r3:int, r4:real | {r1:delta_ORDERS_ORDERKEY,
      r2:delta_ORDERS_ORDERDATE, r3:delta_ORDERS_SHIPPRIORITY,
      r4:__prod_ret__169}|} @ { Set })))) empty { r1:int, r2:int, r3:int,
    r4:real } @ { Set }).filter ((\b1 -> bind b1 as {r1:map_0, r2:map_1,
    r3:map_2, r4:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_date_int_float {r1:QUERY3, r2:true, r3:vid,
      r4:new_tuples});
   0))


declare insert_CUSTOMER_do_corrective_s0_m_QUERY3_mCUSTOMER4 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int }, r6:int,
  r7:string, r8:string, r9:int, r10:string, r11:real, r12:string, r13:string,
  r14:collection { r1:int, r2:int, r3:int, r4:int, r5:real } @ { Set }
  } -> int = (\b1 -> bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid,
  r4:hop, r5:vid, r6:CUSTOMER_CUSTKEY, r7:CUSTOMER_NAME, r8:CUSTOMER_ADDRESS,
  r9:CUSTOMER_NATIONKEY, r10:CUSTOMER_PHONE, r11:CUSTOMER_ACCTBAL,
  r12:CUSTOMER_MKTSEGMENT, r13:CUSTOMER_COMMENT, r14:delta_tuples} in let
  new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {r1:delta_ORDERS_ORDERKEY, r2:delta_ORDERS_ORDERDATE,
    r3:delta_ORDERS_SHIPPRIORITY, r4:delta_QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
    r5:delta_QUERY3_mCUSTOMER4} in _accext.combine (let __prod_ret__171 =
    ((if CUSTOMER_CUSTKEY == delta_QUERY3_mCUSTOMERCUSTOMER_CUSTKEY then 1
      else 0) * if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0) *
      delta_QUERY3_mCUSTOMER4 in
    {| r1:int, r2:int, r3:int, r4:real | {r1:delta_ORDERS_ORDERKEY,
      r2:delta_ORDERS_ORDERDATE, r3:delta_ORDERS_SHIPPRIORITY,
      r4:__prod_ret__171}|} @ { Set })))) empty { r1:int, r2:int, r3:int,
    r4:real } @ { Set }).filter ((\b1 -> bind b1 as {r1:map_0, r2:map_1,
    r3:map_2, r4:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_date_int_float {r1:QUERY3, r2:true, r3:vid,
      r4:new_tuples});
   0))


declare insert_CUSTOMER_do_corrective_s1_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
  r1:address, r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int,
  value:int }, r6:int, r7:string, r8:string, r9:int, r10:string, r11:real,
  r12:string, r13:string, r14:collection { r1:int, r2:int, r3:int, r4:int,
  r5:int } @ { Set } } -> int = (\b1 -> bind b1 as {r1:orig_addr,
  r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:vid, r6:CUSTOMER_CUSTKEY,
  r7:CUSTOMER_NAME, r8:CUSTOMER_ADDRESS, r9:CUSTOMER_NATIONKEY,
  r10:CUSTOMER_PHONE, r11:CUSTOMER_ACCTBAL, r12:CUSTOMER_MKTSEGMENT,
  r13:CUSTOMER_COMMENT, r14:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {r1:delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY,
    r2:delta_ORDERS_ORDERDATE, r3:delta_ORDERS_SHIPPRIORITY,
    r4:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
    r5:delta_QUERY3_mLINEITEM1_mCUSTOMER2} in _accext.combine (let
    __prod_ret__173 =
    ((if CUSTOMER_CUSTKEY == delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY
      then 1 else 0) * if CUSTOMER_MKTSEGMENT == "BUILDING" then 1 else 0) *
      delta_QUERY3_mLINEITEM1_mCUSTOMER2 in
    {| r1:int, r2:int, r3:int, r4:int |
      {r1:delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY, r2:delta_ORDERS_ORDERDATE,
      r3:delta_ORDERS_SHIPPRIORITY, r4:__prod_ret__173}|} @ { Set })))) empty {
    r1:int, r2:int, r3:int, r4:int } @ { Set }).filter ((\b1 ->
    bind b1 as {r1:map_0, r2:map_1, r3:map_2, r4:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_date_int_int {r1:QUERY3_mLINEITEM1, r2:true, r3:vid,
      r4:new_tuples});
   (nd_QUERY3_mLINEITEM1_send_correctives {r1:orig_addr, r2:orig_stmt_id,
      r3:orig_vid, r4:1 + hop, r5:vid, r6:new_tuples})))


declare sw_insert_ORDERS : { r1:int, r2:int, r3:string, r4:real, r5:int,
  r6:string, r7:string, r8:int, r9:string } -> () = (\args ->
  (sw_buf_insert_ORDERS.insert args;
   sw_trig_buf_idx.insert {i:2};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_insert_ORDERS_send_fetch : { key:int, value:int } -> () = (\vid ->
  case (sw_buf_insert_ORDERS.peek ()) of
  {Some args ->
    (sw_buf_insert_ORDERS.erase args;
     bind args as
     {r1:ORDERS_ORDERKEY, r2:ORDERS_CUSTKEY, r3:ORDERS_ORDERSTATUS, r4:ORDERS_TOTALPRICE, r5:ORDERS_ORDERDATE, r6:ORDERS_ORDERPRIORITY, r7:ORDERS_CLERK, r8:ORDERS_SHIPPRIORITY, r9:ORDERS_COMMENT}
     in
     ((route_to_int_date_int_int {r1:3, r2:Some ORDERS_ORDERKEY,
         r3:Some ORDERS_ORDERDATE, r4:Some ORDERS_SHIPPRIORITY,
         r5:Some ORDERS_CUSTKEY}).iterate ((\b1 -> bind b1 as {i:ip} in 
      (nd_insert_ORDERS_do_complete_s8_trig, ip)<- {r1:vid, r2:ORDERS_ORDERKEY,
      r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE,
      r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK,
      r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT}));
      ((((empty { r1:address, r2:int, r3:int } @ { Collection }).combine (let
      sender_count =
      (route_to_int {key:4, value:Some ORDERS_CUSTKEY}).fold ((\count ->
        (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_QUERY3_mORDERS1_to_QUERY3 {r1:Some ORDERS_ORDERKEY,
          r2:Some ORDERS_ORDERDATE, r3:Some ORDERS_SHIPPRIORITY, r4:empty {
          r1:{ key:int, value:int }, r2:int, r3:int } @ { Set }, r5:true}).fold
        ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {r1:ip, r2:6, r3:sender_count};_accmap)))) empty {
        r1:address, r2:int, r3:int } @ { Collection }).combine (let
        sender_count =
        (route_to_int {key:5, value:Some ORDERS_ORDERKEY}).fold ((\count ->
          (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mORDERS3_to_QUERY3_bind_0t0 {r1:Some ORDERS_ORDERKEY,
            r2:Some ORDERS_ORDERDATE, r3:Some ORDERS_SHIPPRIORITY, r4:empty {
            r1:{ key:int, value:int }, r2:int, r3:real } @ { Set }, r5:true}).fold
          ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {r1:ip, r2:6, r3:sender_count};_accmap)))) empty {
          r1:address, r2:int, r3:int } @ { Collection }).combine (let
          sender_count =
          (route_to_int {key:6, value:Some ORDERS_ORDERKEY}).fold ((\count ->
            (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
          ((shuffle_QUERY3_mORDERS6_to_QUERY3_bind_0t0
              {r1:Some ORDERS_ORDERKEY, r2:Some ORDERS_ORDERDATE,
              r3:Some ORDERS_SHIPPRIORITY, r4:empty { r1:{ key:int, value:int
              }, r2:int, r3:real } @ { Set }, r5:true}).fold ((\_accmap ->
            (\b3 -> bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {r1:ip, r2:6, r3:sender_count};_accmap)))) empty {
            r1:address, r2:int, r3:int } @ { Collection }).combine (let
            sender_count =
            (route_to_int {key:4, value:Some ORDERS_CUSTKEY}).fold ((\count ->
              (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
            ((shuffle_QUERY3_mORDERS1_to_QUERY3_mLINEITEM1
                {r1:Some ORDERS_ORDERKEY, r2:Some ORDERS_ORDERDATE,
                r3:Some ORDERS_SHIPPRIORITY, r4:empty { r1:{ key:int, value:int
                }, r2:int, r3:int } @ { Set }, r5:true}).fold ((\_accmap ->
              (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {r1:ip, r2:7, r3:sender_count};_accmap))))
              empty { r1:address, r2:int, r3:int } @ { Collection }).combine
              (let sender_count =
              (route_to_int {key:5, value:Some ORDERS_ORDERKEY}).fold
                ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
              ((shuffle_QUERY3_mORDERS3_to_QUERY3_mCUSTOMER2_bind_0t0
                  {r1:Some ORDERS_ORDERKEY, r2:Some ORDERS_ORDERDATE,
                  r3:Some ORDERS_SHIPPRIORITY, r4:Some ORDERS_CUSTKEY,
                  r5:empty { r1:{ key:int, value:int }, r2:int, r3:real
                  } @ { Set }, r6:true}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {r1:ip, r2:9, r3:sender_count};_accmap))))
                empty { r1:address, r2:int, r3:int } @ { Collection }).combine
                (let sender_count =
                (route_to_int {key:6, value:Some ORDERS_ORDERKEY}).fold
                  ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                (shuffle_QUERY3_mORDERS6_to_QUERY3_mCUSTOMER4_bind_0t0
                   {r1:Some ORDERS_ORDERKEY, r2:Some ORDERS_ORDERDATE,
                   r3:Some ORDERS_SHIPPRIORITY, r4:Some ORDERS_CUSTKEY,
                   r5:empty { r1:{ key:int, value:int }, r2:int, r3:real
                   } @ { Set }, r6:true}).fold ((\_accmap -> (\b3 ->
                  bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {r1:ip, r2:10, r3:sender_count};_accmap))))
                  empty { r1:address, r2:int, r3:int } @ { Collection }))))))).groupBy
      ((\b1 -> bind b1 as {r1:ip, r2:stmt_id, r3:count} in {key:ip,
      value:stmt_id})) ((\acc -> (\b3 -> bind b3 as {r1:ip, r2:stmt_id,
      r3:count} in acc + count))) 0).groupBy ((\b1 -> bind b1 as {key:b2,
      value:count} in bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc ->
      (\b3 -> bind b3 as {key:ip_and_stmt_id, value:count} in bind
      ip_and_stmt_id as {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_insert_ORDERS_rcv_put, addr)<- {r1:me, r2:stmt_cnt_list, r3:vid,
       r4:ORDERS_ORDERKEY, r5:ORDERS_CUSTKEY, r6:ORDERS_ORDERSTATUS,
       r7:ORDERS_TOTALPRICE, r8:ORDERS_ORDERDATE, r9:ORDERS_ORDERPRIORITY,
       r10:ORDERS_CLERK, r11:ORDERS_SHIPPRIORITY, r12:ORDERS_COMMENT};
       (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == vid))).peek ()) of
       {Some old_val -> let old_set = old_val.value in
         (old_set.insert {i:addr};sw_ack_log.insert {key:vid, value:old_set})}
       {None -> sw_ack_log.insert {key:vid, value:{|i:address|
         addr|} @ { Set }}}))));
      ((((route_to_int {key:6, value:Some ORDERS_ORDERKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {r1:10, r2:6, r3:ip};_accmap)))) empty { r1:int, r2:int,
      r3:address } @ { Collection }).combine
      (((route_to_int {key:5, value:Some ORDERS_ORDERKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {r1:9, r2:5, r3:ip};_accmap)))) empty { r1:int, r2:int,
      r3:address } @ { Collection }).combine
      (((route_to_int {key:4, value:Some ORDERS_CUSTKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {r1:7, r2:4, r3:ip};_accmap)))) empty { r1:int, r2:int,
      r3:address } @ { Collection }).combine
      (((route_to_int {key:6, value:Some ORDERS_ORDERKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {r1:6, r2:6, r3:ip};_accmap)))) empty { r1:int, r2:int,
      r3:address } @ { Collection }).combine
      (((route_to_int {key:5, value:Some ORDERS_ORDERKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {r1:6, r2:5, r3:ip};_accmap)))) empty { r1:int, r2:int,
      r3:address } @ { Collection }).combine
      (((route_to_int {key:4, value:Some ORDERS_CUSTKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {r1:6, r2:4, r3:ip};_accmap)))) empty { r1:int, r2:int,
      r3:address } @ { Collection }).combine empty { r1:int, r2:int, r3:address
      } @ { Collection })))))).groupBy ((\b1 -> bind b1 as {r1:stmt_id,
      r2:map_id, r3:ip} in ip)) ((\acc -> (\b3 -> bind b3 as {r1:stmt_id,
      r2:map_id, r3:ip} in (acc.insert {key:stmt_id, value:map_id};acc))))
      empty { key:int, value:int } @ { Collection }).iterate ((\b1 ->
      bind b1 as {key:ip, value:stmt_map_ids} in 
      (nd_insert_ORDERS_rcv_fetch, ip)<- {r1:stmt_map_ids, r2:vid,
      r3:ORDERS_ORDERKEY, r4:ORDERS_CUSTKEY, r5:ORDERS_ORDERSTATUS,
      r6:ORDERS_TOTALPRICE, r7:ORDERS_ORDERDATE, r8:ORDERS_ORDERPRIORITY,
      r9:ORDERS_CLERK, r10:ORDERS_SHIPPRIORITY, r11:ORDERS_COMMENT}))))}
  {None ->
    error (print "unexpected missing arguments in sw_buf_insert_ORDERS")})


declare nd_insert_ORDERS_do_complete_s6 : { r1:{ key:int, value:int }, r2:int,
  r3:int, r4:string, r5:real, r6:int, r7:string, r8:string, r9:int, r10:string
  } -> () = (\b1 -> bind b1 as {r1:vid, r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY,
  r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE,
  r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY,
  r10:ORDERS_COMMENT} in let __prod_ret__11 =
  ((if ORDERS_ORDERDATE < 19950315 then 1 else 0) * let wrapped_lookup_value =
    bind map_QUERY3_mORDERS1_s6_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {r1:r1,
         r2:r2, r3:r3} in r2 == ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 ->
        bind b3 as {r1:vid, r2:map_0, r3:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * (((let
    wrapped_lookup_value =
    bind map_QUERY3_mORDERS3_s6_buf as ind __x in
      (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {r1:r1, r2:r2, r3:r3} in r2 == ORDERS_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:real } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) * -1) +
    let wrapped_lookup_value =
    bind map_QUERY3_mORDERS6_s6_buf as ind __x in
      (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {r1:r1, r2:r2, r3:r3} in r2 == ORDERS_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:real } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) in
  ((nd_add_delta_to_int_date_int_float {r1:QUERY3, r2:false, r3:vid, r4:{|
      r1:int, r2:int, r3:int, r4:real | {r1:ORDERS_ORDERKEY,
      r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY,
      r4:__prod_ret__11}|} @ { Set }});
   (nd_complete_stmt_cntr_check {key:vid, value:6})))


declare nd_insert_ORDERS_do_complete_s7 : { r1:{ key:int, value:int }, r2:int,
  r3:int, r4:string, r5:real, r6:int, r7:string, r8:string, r9:int, r10:string
  } -> () = (\b1 -> bind b1 as {r1:vid, r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY,
  r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE,
  r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY,
  r10:ORDERS_COMMENT} in let __prod_ret__12 =
  (let wrapped_lookup_value =
    bind map_QUERY3_mORDERS1_s7_buf as ind __x in
      (frontier_int_int {key:vid, value:__x.filter ((\b1 -> bind b1 as {r1:r1,
         r2:r2, r3:r3} in r2 == ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 ->
        bind b3 as {r1:vid, r2:map_0, r3:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:int } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0}) *
    if ORDERS_ORDERDATE < 19950315 then 1 else 0 in
  ((nd_add_delta_to_int_date_int_int {r1:QUERY3_mLINEITEM1, r2:false, r3:vid,
      r4:{| r1:int, r2:int, r3:int, r4:int | {r1:ORDERS_ORDERKEY,
      r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY,
      r4:__prod_ret__12}|} @ { Set }});
   let sent_msgs =
   nd_QUERY3_mLINEITEM1_send_correctives {r1:me, r2:7, r3:vid, r4:1, r5:vid,
     r6:{| r1:int, r2:int, r3:int, r4:int | {r1:ORDERS_ORDERKEY,
     r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY,
     r4:__prod_ret__12}|} @ { Set }} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:7}
     else
       nd_update_stmt_cntr_corr_map {r1:vid, r2:7, r3:1, r4:sent_msgs, r5:true,
         r6:false}))


declare nd_insert_ORDERS_do_complete_s9 : { r1:{ key:int, value:int }, r2:int,
  r3:int, r4:string, r5:real, r6:int, r7:string, r8:string, r9:int, r10:string
  } -> () = (\b1 -> bind b1 as {r1:vid, r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY,
  r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE,
  r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY,
  r10:ORDERS_COMMENT} in let __prod_ret__13 =
  (if ORDERS_ORDERDATE < 19950315 then 1 else 0) * let wrapped_lookup_value =
    bind map_QUERY3_mORDERS3_s9_buf as ind __x in
      (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {r1:r1, r2:r2, r3:r3} in r2 == ORDERS_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:real } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0} in
  ((nd_add_delta_to_int_date_int_int_float {r1:QUERY3_mCUSTOMER2, r2:false,
      r3:vid, r4:{| r1:int, r2:int, r3:int, r4:int, r5:real |
      {r1:ORDERS_ORDERKEY, r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY,
      r4:ORDERS_CUSTKEY, r5:__prod_ret__13}|} @ { Set }});
   let sent_msgs =
   nd_QUERY3_mCUSTOMER2_send_correctives {r1:me, r2:9, r3:vid, r4:1, r5:vid,
     r6:{| r1:int, r2:int, r3:int, r4:int, r5:real | {r1:ORDERS_ORDERKEY,
     r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY, r4:ORDERS_CUSTKEY,
     r5:__prod_ret__13}|} @ { Set }} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:9}
     else
       nd_update_stmt_cntr_corr_map {r1:vid, r2:9, r3:1, r4:sent_msgs, r5:true,
         r6:false}))


declare nd_insert_ORDERS_do_complete_s10 : { r1:{ key:int, value:int }, r2:int,
  r3:int, r4:string, r5:real, r6:int, r7:string, r8:string, r9:int, r10:string
  } -> () = (\b1 -> bind b1 as {r1:vid, r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY,
  r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE,
  r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY,
  r10:ORDERS_COMMENT} in let __prod_ret__14 =
  (if ORDERS_ORDERDATE < 19950315 then 1 else 0) * let wrapped_lookup_value =
    bind map_QUERY3_mORDERS6_s10_buf as ind __x in
      (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {r1:r1, r2:r2, r3:r3} in r2 == ORDERS_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_val} in 
        (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
        value:real } @ { Collection } in
    case (wrapped_lookup_value.peek ()) of
      {Some unwrapped_value -> bind unwrapped_value as
        {key:_, value:projected_field} in projected_field}{None -> 0} in
  ((nd_add_delta_to_int_date_int_int_float {r1:QUERY3_mCUSTOMER4, r2:false,
      r3:vid, r4:{| r1:int, r2:int, r3:int, r4:int, r5:real |
      {r1:ORDERS_ORDERKEY, r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY,
      r4:ORDERS_CUSTKEY, r5:__prod_ret__14}|} @ { Set }});
   let sent_msgs =
   nd_QUERY3_mCUSTOMER4_send_correctives {r1:me, r2:10, r3:vid, r4:1, r5:vid,
     r6:{| r1:int, r2:int, r3:int, r4:int, r5:real | {r1:ORDERS_ORDERKEY,
     r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY, r4:ORDERS_CUSTKEY,
     r5:__prod_ret__14}|} @ { Set }} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:10}
     else
       nd_update_stmt_cntr_corr_map {r1:vid, r2:10, r3:1, r4:sent_msgs,
         r5:true, r6:false}))


declare nd_insert_ORDERS_do_complete_s8 : { r1:{ key:int, value:int }, r2:int,
  r3:int, r4:string, r5:real, r6:int, r7:string, r8:string, r9:int, r10:string
  } -> () = (\b1 -> bind b1 as {r1:vid, r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY,
  r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE,
  r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY,
  r10:ORDERS_COMMENT} in let __cmp_ret__9 =
  if ORDERS_ORDERDATE < 19950315 then 1 else 0 in
  ((nd_add_delta_to_int_date_int_int_int {r1:QUERY3_mLINEITEM1_mCUSTOMER2,
      r2:false, r3:vid, r4:{| r1:int, r2:int, r3:int, r4:int, r5:int |
      {r1:ORDERS_ORDERKEY, r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY,
      r4:ORDERS_CUSTKEY, r5:__cmp_ret__9}|} @ { Set }});
   let sent_msgs =
   nd_QUERY3_mLINEITEM1_mCUSTOMER2_send_correctives {r1:me, r2:8, r3:vid, r4:1,
     r5:vid, r6:{| r1:int, r2:int, r3:int, r4:int, r5:int |
     {r1:ORDERS_ORDERKEY, r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY,
     r4:ORDERS_CUSTKEY, r5:__cmp_ret__9}|} @ { Set }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {r1:vid, r2:8, r3:1, r4:sent_msgs, r5:true,
         r6:true}))


declare insert_ORDERS_do_corrective_s6_m_QUERY3_mORDERS1 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int }, r6:int,
  r7:int, r8:string, r9:real, r10:int, r11:string, r12:string, r13:int,
  r14:string, r15:collection { key:int, value:int } @ { Set } } -> int =
  (\b1 -> bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop,
  r5:vid, r6:ORDERS_ORDERKEY, r7:ORDERS_CUSTKEY, r8:ORDERS_ORDERSTATUS,
  r9:ORDERS_TOTALPRICE, r10:ORDERS_ORDERDATE, r11:ORDERS_ORDERPRIORITY,
  r12:ORDERS_CLERK, r13:ORDERS_SHIPPRIORITY, r14:ORDERS_COMMENT,
  r15:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {key:delta_QUERY3_mORDERSORDERS_CUSTKEY,
    value:delta_QUERY3_mORDERS1} in _accext.combine (let __prod_ret__96 =
    (((if ORDERS_CUSTKEY == delta_QUERY3_mORDERSORDERS_CUSTKEY then 1 
      else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) * (((let
      wrapped_lookup_value =
      bind map_QUERY3_mORDERS3_s6_buf as ind __x in
        (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {r1:r1, r2:r2, r3:r3} in r2 == ORDERS_ORDERKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:real } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) * -1)
      + let wrapped_lookup_value =
      bind map_QUERY3_mORDERS6_s6_buf as ind __x in
        (frontier_int_float {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {r1:r1, r2:r2, r3:r3} in r2 == ORDERS_ORDERKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:real } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0})) *
      delta_QUERY3_mORDERS1 in
    {| r1:int, r2:int, r3:int, r4:real | {r1:ORDERS_ORDERKEY,
      r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY,
      r4:__prod_ret__96}|} @ { Set })))) empty { r1:int, r2:int, r3:int,
    r4:real } @ { Set }).filter ((\b1 -> bind b1 as {r1:map_0, r2:map_1,
    r3:map_2, r4:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_date_int_float {r1:QUERY3, r2:true, r3:vid,
      r4:new_tuples});
   0))


declare insert_ORDERS_do_corrective_s6_m_QUERY3_mORDERS3 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int }, r6:int,
  r7:int, r8:string, r9:real, r10:int, r11:string, r12:string, r13:int,
  r14:string, r15:collection { key:int, value:real } @ { Set } } -> int =
  (\b1 -> bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop,
  r5:vid, r6:ORDERS_ORDERKEY, r7:ORDERS_CUSTKEY, r8:ORDERS_ORDERSTATUS,
  r9:ORDERS_TOTALPRICE, r10:ORDERS_ORDERDATE, r11:ORDERS_ORDERPRIORITY,
  r12:ORDERS_CLERK, r13:ORDERS_SHIPPRIORITY, r14:ORDERS_COMMENT,
  r15:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {key:delta_QUERY3_mORDERSORDERS_ORDERKEY,
    value:delta_QUERY3_mORDERS3} in _accext.combine (let __prod_ret__108 =
    (((if ORDERS_ORDERKEY == delta_QUERY3_mORDERSORDERS_ORDERKEY then 1 
      else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) * let
      wrapped_lookup_value =
      bind map_QUERY3_mORDERS1_s6_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {r1:r1, r2:r2, r3:r3} in r2 == ORDERS_CUSTKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) *
      -delta_QUERY3_mORDERS3 in
    {| r1:int, r2:int, r3:int, r4:real | {r1:ORDERS_ORDERKEY,
      r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY,
      r4:__prod_ret__108}|} @ { Set })))) empty { r1:int, r2:int, r3:int,
    r4:real } @ { Set }).filter ((\b1 -> bind b1 as {r1:map_0, r2:map_1,
    r3:map_2, r4:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_date_int_float {r1:QUERY3, r2:true, r3:vid,
      r4:new_tuples});
   0))


declare insert_ORDERS_do_corrective_s6_m_QUERY3_mORDERS6 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int }, r6:int,
  r7:int, r8:string, r9:real, r10:int, r11:string, r12:string, r13:int,
  r14:string, r15:collection { key:int, value:real } @ { Set } } -> int =
  (\b1 -> bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop,
  r5:vid, r6:ORDERS_ORDERKEY, r7:ORDERS_CUSTKEY, r8:ORDERS_ORDERSTATUS,
  r9:ORDERS_TOTALPRICE, r10:ORDERS_ORDERDATE, r11:ORDERS_ORDERPRIORITY,
  r12:ORDERS_CLERK, r13:ORDERS_SHIPPRIORITY, r14:ORDERS_COMMENT,
  r15:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {key:delta_QUERY3_mORDERSORDERS_ORDERKEY,
    value:delta_QUERY3_mORDERS6} in _accext.combine (let __prod_ret__119 =
    (((if ORDERS_ORDERKEY == delta_QUERY3_mORDERSORDERS_ORDERKEY then 1 
      else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) * let
      wrapped_lookup_value =
      bind map_QUERY3_mORDERS1_s6_buf as ind __x in
        (frontier_int_int {key:vid, value:__x.filter ((\b1 ->
           bind b1 as {r1:r1, r2:r2, r3:r3} in r2 == ORDERS_CUSTKEY))}).fold
          ((\acc -> (\b3 -> bind b3 as {r1:vid, r2:map_0, r3:map_val} in 
          (acc.insert {key:map_0, value:map_val};acc)))) empty { key:int,
          value:int } @ { Collection } in
      case (wrapped_lookup_value.peek ()) of
        {Some unwrapped_value -> bind unwrapped_value as
          {key:_, value:projected_field} in projected_field}{None -> 0}) *
      delta_QUERY3_mORDERS6 in
    {| r1:int, r2:int, r3:int, r4:real | {r1:ORDERS_ORDERKEY,
      r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY,
      r4:__prod_ret__119}|} @ { Set })))) empty { r1:int, r2:int, r3:int,
    r4:real } @ { Set }).filter ((\b1 -> bind b1 as {r1:map_0, r2:map_1,
    r3:map_2, r4:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_date_int_float {r1:QUERY3, r2:true, r3:vid,
      r4:new_tuples});
   0))


declare insert_ORDERS_do_corrective_s7_m_QUERY3_mORDERS1 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int }, r6:int,
  r7:int, r8:string, r9:real, r10:int, r11:string, r12:string, r13:int,
  r14:string, r15:collection { key:int, value:int } @ { Set } } -> int =
  (\b1 -> bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop,
  r5:vid, r6:ORDERS_ORDERKEY, r7:ORDERS_CUSTKEY, r8:ORDERS_ORDERSTATUS,
  r9:ORDERS_TOTALPRICE, r10:ORDERS_ORDERDATE, r11:ORDERS_ORDERPRIORITY,
  r12:ORDERS_CLERK, r13:ORDERS_SHIPPRIORITY, r14:ORDERS_COMMENT,
  r15:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {key:delta_QUERY3_mORDERSORDERS_CUSTKEY,
    value:delta_QUERY3_mORDERS1} in _accext.combine (let __prod_ret__98 =
    ((if ORDERS_CUSTKEY == delta_QUERY3_mORDERSORDERS_CUSTKEY then 1 
      else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
      delta_QUERY3_mORDERS1 in
    {| r1:int, r2:int, r3:int, r4:int | {r1:ORDERS_ORDERKEY,
      r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY,
      r4:__prod_ret__98}|} @ { Set })))) empty { r1:int, r2:int, r3:int, r4:int
    } @ { Set }).filter ((\b1 -> bind b1 as {r1:map_0, r2:map_1, r3:map_2,
    r4:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_date_int_int {r1:QUERY3_mLINEITEM1, r2:true, r3:vid,
      r4:new_tuples});
   (nd_QUERY3_mLINEITEM1_send_correctives {r1:orig_addr, r2:orig_stmt_id,
      r3:orig_vid, r4:1 + hop, r5:vid, r6:new_tuples})))


declare insert_ORDERS_do_corrective_s9_m_QUERY3_mORDERS3 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int }, r6:int,
  r7:int, r8:string, r9:real, r10:int, r11:string, r12:string, r13:int,
  r14:string, r15:collection { key:int, value:real } @ { Set } } -> int =
  (\b1 -> bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop,
  r5:vid, r6:ORDERS_ORDERKEY, r7:ORDERS_CUSTKEY, r8:ORDERS_ORDERSTATUS,
  r9:ORDERS_TOTALPRICE, r10:ORDERS_ORDERDATE, r11:ORDERS_ORDERPRIORITY,
  r12:ORDERS_CLERK, r13:ORDERS_SHIPPRIORITY, r14:ORDERS_COMMENT,
  r15:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {key:delta_QUERY3_mORDERSORDERS_ORDERKEY,
    value:delta_QUERY3_mORDERS3} in _accext.combine (let __prod_ret__110 =
    ((if ORDERS_ORDERKEY == delta_QUERY3_mORDERSORDERS_ORDERKEY then 1 
      else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
      delta_QUERY3_mORDERS3 in
    {| r1:int, r2:int, r3:int, r4:int, r5:real | {r1:ORDERS_ORDERKEY,
      r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY, r4:ORDERS_CUSTKEY,
      r5:__prod_ret__110}|} @ { Set })))) empty { r1:int, r2:int, r3:int,
    r4:int, r5:real } @ { Set }).filter ((\b1 -> bind b1 as {r1:map_0,
    r2:map_1, r3:map_2, r4:map_3, r5:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_date_int_int_float {r1:QUERY3_mCUSTOMER2, r2:true,
      r3:vid, r4:new_tuples});
   (nd_QUERY3_mCUSTOMER2_send_correctives {r1:orig_addr, r2:orig_stmt_id,
      r3:orig_vid, r4:1 + hop, r5:vid, r6:new_tuples})))


declare insert_ORDERS_do_corrective_s10_m_QUERY3_mORDERS6 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int }, r6:int,
  r7:int, r8:string, r9:real, r10:int, r11:string, r12:string, r13:int,
  r14:string, r15:collection { key:int, value:real } @ { Set } } -> int =
  (\b1 -> bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop,
  r5:vid, r6:ORDERS_ORDERKEY, r7:ORDERS_CUSTKEY, r8:ORDERS_ORDERSTATUS,
  r9:ORDERS_TOTALPRICE, r10:ORDERS_ORDERDATE, r11:ORDERS_ORDERPRIORITY,
  r12:ORDERS_CLERK, r13:ORDERS_SHIPPRIORITY, r14:ORDERS_COMMENT,
  r15:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {key:delta_QUERY3_mORDERSORDERS_ORDERKEY,
    value:delta_QUERY3_mORDERS6} in _accext.combine (let __prod_ret__121 =
    ((if ORDERS_ORDERKEY == delta_QUERY3_mORDERSORDERS_ORDERKEY then 1 
      else 0) * if ORDERS_ORDERDATE < 19950315 then 1 else 0) *
      delta_QUERY3_mORDERS6 in
    {| r1:int, r2:int, r3:int, r4:int, r5:real | {r1:ORDERS_ORDERKEY,
      r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY, r4:ORDERS_CUSTKEY,
      r5:__prod_ret__121}|} @ { Set })))) empty { r1:int, r2:int, r3:int,
    r4:int, r5:real } @ { Set }).filter ((\b1 -> bind b1 as {r1:map_0,
    r2:map_1, r3:map_2, r4:map_3, r5:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_date_int_int_float {r1:QUERY3_mCUSTOMER4, r2:true,
      r3:vid, r4:new_tuples});
   (nd_QUERY3_mCUSTOMER4_send_correctives {r1:orig_addr, r2:orig_stmt_id,
      r3:orig_vid, r4:1 + hop, r5:vid, r6:new_tuples})))


declare sw_insert_LINEITEM : { r1:int, r2:int, r3:int, r4:int, r5:real,
  r6:real, r7:real, r8:real, r9:string, r10:string, r11:int, r12:int, r13:int,
  r14:string, r15:string, r16:string } -> () = (\args ->
  (sw_buf_insert_LINEITEM.insert args;
   sw_trig_buf_idx.insert {i:4};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_insert_LINEITEM_send_fetch : { key:int, value:int } -> () = (\vid ->
  case (sw_buf_insert_LINEITEM.peek ()) of
  {Some args ->
    (sw_buf_insert_LINEITEM.erase args;
     bind args as
     {r1:LINEITEM_ORDERKEY, r2:LINEITEM_PARTKEY, r3:LINEITEM_SUPPKEY, r4:LINEITEM_LINENUMBER, r5:LINEITEM_QUANTITY, r6:LINEITEM_EXTENDEDPRICE, r7:LINEITEM_DISCOUNT, r8:LINEITEM_TAX, r9:LINEITEM_RETURNFLAG, r10:LINEITEM_LINESTATUS, r11:LINEITEM_SHIPDATE, r12:LINEITEM_COMMITDATE, r13:LINEITEM_RECEIPTDATE, r14:LINEITEM_SHIPINSTRUCT, r15:LINEITEM_SHIPMODE, r16:LINEITEM_COMMENT}
     in
     ((route_to_int {key:5, value:Some LINEITEM_ORDERKEY}).iterate ((\b1 ->
      bind b1 as {i:ip} in 
      (nd_insert_LINEITEM_do_complete_s17_trig, ip)<- {r1:vid,
      r2:LINEITEM_ORDERKEY, r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY,
      r5:LINEITEM_LINENUMBER, r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE,
      r8:LINEITEM_DISCOUNT, r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG,
      r11:LINEITEM_LINESTATUS, r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE,
      r14:LINEITEM_RECEIPTDATE, r15:LINEITEM_SHIPINSTRUCT,
      r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT}));
      (route_to_int {key:6, value:Some LINEITEM_ORDERKEY}).iterate ((\b1 ->
      bind b1 as {i:ip} in 
      (nd_insert_LINEITEM_do_complete_s18_trig, ip)<- {r1:vid,
      r2:LINEITEM_ORDERKEY, r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY,
      r5:LINEITEM_LINENUMBER, r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE,
      r8:LINEITEM_DISCOUNT, r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG,
      r11:LINEITEM_LINESTATUS, r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE,
      r14:LINEITEM_RECEIPTDATE, r15:LINEITEM_SHIPINSTRUCT,
      r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT}));
      ((((empty { r1:address, r2:int, r3:int } @ { Collection }).combine (let
      sender_count =
      (route_to_int_date_int {r1:2, r2:Some LINEITEM_ORDERKEY, r3:None immut,
         r4:None immut}).fold ((\count -> (\b3 -> bind b3 as {i:ip} in count +
        1))) 0 in
      ((shuffle_QUERY3_mLINEITEM1_to_QUERY3_bind_0t0_1t1_2t2
          {r1:Some LINEITEM_ORDERKEY, r2:None immut, r3:None immut, r4:empty {
          r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int
          } @ { Set }, r5:true}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
        value:tuples} in 
        (_accmap.insert {r1:ip, r2:16, r3:sender_count};_accmap)))) empty {
        r1:address, r2:int, r3:int } @ { Collection }).combine (let
        sender_count =
        (route_to_int_date_int_int {r1:3, r2:Some LINEITEM_ORDERKEY,
           r3:None immut, r4:None immut, r5:None immut}).fold ((\count ->
          (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_to_QUERY3_mCUSTOMER2_bind_0t0_1t1_2t2_3t3
            {r1:Some LINEITEM_ORDERKEY, r2:None immut, r3:None immut,
            r4:None immut, r5:empty { r1:{ key:int, value:int }, r2:int,
            r3:int, r4:int, r5:int, r6:int } @ { Set }, r6:true}).fold
          ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {r1:ip, r2:19, r3:sender_count};_accmap)))) empty {
          r1:address, r2:int, r3:int } @ { Collection }).combine (let
          sender_count =
          (route_to_int_date_int_int {r1:3, r2:Some LINEITEM_ORDERKEY,
             r3:None immut, r4:None immut, r5:None immut}).fold ((\count ->
            (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
          (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_to_QUERY3_mCUSTOMER4_bind_0t0_1t1_2t2_3t3
             {r1:Some LINEITEM_ORDERKEY, r2:None immut, r3:None immut,
             r4:None immut, r5:empty { r1:{ key:int, value:int }, r2:int,
             r3:int, r4:int, r5:int, r6:int } @ { Set }, r6:true}).fold
            ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {r1:ip, r2:20, r3:sender_count};_accmap)))) empty {
            r1:address, r2:int, r3:int } @ { Collection })))).groupBy ((\b1 ->
      bind b1 as {r1:ip, r2:stmt_id, r3:count} in {key:ip, value:stmt_id}))
      ((\acc -> (\b3 -> bind b3 as {r1:ip, r2:stmt_id, r3:count} in acc +
      count))) 0).groupBy ((\b1 -> bind b1 as {key:b2, value:count} in 
      bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc -> (\b3 ->
      bind b3 as {key:ip_and_stmt_id, value:count} in bind ip_and_stmt_id as
      {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_insert_LINEITEM_rcv_put, addr)<- {r1:me, r2:stmt_cnt_list, r3:vid,
       r4:LINEITEM_ORDERKEY, r5:LINEITEM_PARTKEY, r6:LINEITEM_SUPPKEY,
       r7:LINEITEM_LINENUMBER, r8:LINEITEM_QUANTITY, r9:LINEITEM_EXTENDEDPRICE,
       r10:LINEITEM_DISCOUNT, r11:LINEITEM_TAX, r12:LINEITEM_RETURNFLAG,
       r13:LINEITEM_LINESTATUS, r14:LINEITEM_SHIPDATE, r15:LINEITEM_COMMITDATE,
       r16:LINEITEM_RECEIPTDATE, r17:LINEITEM_SHIPINSTRUCT,
       r18:LINEITEM_SHIPMODE, r19:LINEITEM_COMMENT};
       (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == vid))).peek ()) of
       {Some old_val -> let old_set = old_val.value in
         (old_set.insert {i:addr};sw_ack_log.insert {key:vid, value:old_set})}
       {None -> sw_ack_log.insert {key:vid, value:{|i:address|
         addr|} @ { Set }}}))));
      ((((route_to_int_date_int_int {r1:3, r2:Some LINEITEM_ORDERKEY,
            r3:None immut, r4:None immut, r5:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {r1:20, r2:3, r3:ip};_accmap)))) empty { r1:int, r2:int,
      r3:address } @ { Collection }).combine
      (((route_to_int_date_int_int {r1:3, r2:Some LINEITEM_ORDERKEY,
           r3:None immut, r4:None immut, r5:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {r1:19, r2:3, r3:ip};_accmap)))) empty { r1:int, r2:int,
      r3:address } @ { Collection }).combine
      (((route_to_int_date_int {r1:2, r2:Some LINEITEM_ORDERKEY, r3:None immut,
           r4:None immut}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {r1:16, r2:2, r3:ip};_accmap)))) empty { r1:int, r2:int,
      r3:address } @ { Collection }).combine empty { r1:int, r2:int, r3:address
      } @ { Collection }))).groupBy ((\b1 -> bind b1 as {r1:stmt_id, r2:map_id,
      r3:ip} in ip)) ((\acc -> (\b3 -> bind b3 as {r1:stmt_id, r2:map_id,
      r3:ip} in (acc.insert {key:stmt_id, value:map_id};acc)))) empty {
      key:int, value:int } @ { Collection }).iterate ((\b1 ->
      bind b1 as {key:ip, value:stmt_map_ids} in 
      (nd_insert_LINEITEM_rcv_fetch, ip)<- {r1:stmt_map_ids, r2:vid,
      r3:LINEITEM_ORDERKEY, r4:LINEITEM_PARTKEY, r5:LINEITEM_SUPPKEY,
      r6:LINEITEM_LINENUMBER, r7:LINEITEM_QUANTITY, r8:LINEITEM_EXTENDEDPRICE,
      r9:LINEITEM_DISCOUNT, r10:LINEITEM_TAX, r11:LINEITEM_RETURNFLAG,
      r12:LINEITEM_LINESTATUS, r13:LINEITEM_SHIPDATE, r14:LINEITEM_COMMITDATE,
      r15:LINEITEM_RECEIPTDATE, r16:LINEITEM_SHIPINSTRUCT,
      r17:LINEITEM_SHIPMODE, r18:LINEITEM_COMMENT}))))}{None ->
                                                         error
                                                           (print
                                                              "unexpected missing arguments in sw_buf_insert_LINEITEM")})


declare nd_insert_LINEITEM_do_complete_s16 : { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:int, r6:real, r7:real, r8:real, r9:real,
  r10:string, r11:string, r12:int, r13:int, r14:int, r15:string, r16:string,
  r17:string } -> () = (\b1 -> bind b1 as {r1:vid, r2:LINEITEM_ORDERKEY,
  r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
  r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
  r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
  r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
  r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT} in 
  let delta_values =
  ((((((bind map_QUERY3_mLINEITEM1_s16_buf as ind __x in
    (frontier_int_date_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4, r5:r5} in r2 ==
       LINEITEM_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {r1:vid,
      r2:map_0, r3:map_1, r4:map_2, r5:map_val} in 
      (acc.insert {r1:map_0, r2:map_1, r3:map_2, r4:map_val};acc)))) empty {
      r1:int, r2:int, r3:int, r4:int } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {r1:LINEITEM_ORDERKEY, r2:ORDERS_ORDERDATE,
    r3:ORDERS_SHIPPRIORITY, r4:__map_ret__19} in 
    (_accmap.insert {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
     r3:__map_ret__19};
     _accmap)))) empty { r1:int, r2:int, r3:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {r1:ORDERS_ORDERDATE,
    r2:ORDERS_SHIPPRIORITY, r3:__map_ret__19} in 
    (_accmap.insert {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
     r3:__map_ret__19 * if 19950315 < LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { r1:int, r2:int, r3:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {r1:ORDERS_ORDERDATE,
    r2:ORDERS_SHIPPRIORITY, r3:__prod_ret__26} in 
    (_accmap.insert {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
     r3:__prod_ret__26 * (-LINEITEM_DISCOUNT + 1)};
     _accmap)))) empty { r1:int, r2:int, r3:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {r1:ORDERS_ORDERDATE,
    r2:ORDERS_SHIPPRIORITY, r3:__prod_ret__27} in 
    (_accmap.insert {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
     r3:__prod_ret__27 * LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { r1:int, r2:int, r3:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {r1:ORDERS_ORDERDATE,
    r2:ORDERS_SHIPPRIORITY, r3:__prod_ret__28} in 
    (_accmap.insert {r1:LINEITEM_ORDERKEY, r2:ORDERS_ORDERDATE,
     r3:ORDERS_SHIPPRIORITY, r4:__prod_ret__28};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:real
    } @ { Collection }).fold ((\acc_conv -> (\x ->
    (acc_conv.insert x;acc_conv)))) empty { r1:int, r2:int, r3:int, r4:real
    } @ { Set } in
  ((nd_add_delta_to_int_date_int_float {r1:QUERY3, r2:false, r3:vid,
      r4:delta_values});
   (nd_complete_stmt_cntr_check {key:vid, value:16})))


declare nd_insert_LINEITEM_do_complete_s19 : { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:int, r6:real, r7:real, r8:real, r9:real,
  r10:string, r11:string, r12:int, r13:int, r14:int, r15:string, r16:string,
  r17:string } -> () = (\b1 -> bind b1 as {r1:vid, r2:LINEITEM_ORDERKEY,
  r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
  r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
  r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
  r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
  r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT} in 
  let delta_values =
  ((((((bind map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf as ind __x in
    (frontier_int_date_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4, r5:r5, r6:r6} in r2 ==
       LINEITEM_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {r1:vid,
      r2:map_0, r3:map_1, r4:map_2, r5:map_3, r6:map_val} in 
      (acc.insert {r1:map_0, r2:map_1, r3:map_2, r4:map_3, r5:map_val};acc))))
      empty { r1:int, r2:int, r3:int, r4:int, r5:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {r1:LINEITEM_ORDERKEY,
    r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY,
    r4:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, r5:__map_ret__20} in 
    (_accmap.insert {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
     r3:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, r4:__map_ret__20};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
    r3:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, r4:__map_ret__20} in 
    (_accmap.insert {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
     r3:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, r4:__map_ret__20 *
     if 19950315 < LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
    r3:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, r4:__prod_ret__32} in 
    (_accmap.insert {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
     r3:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, r4:__prod_ret__32 *
     LINEITEM_DISCOUNT};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
    r3:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, r4:__prod_ret__33} in 
    (_accmap.insert {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
     r3:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, r4:__prod_ret__33 *
     LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
    r3:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, r4:__prod_ret__34} in 
    (_accmap.insert {r1:LINEITEM_ORDERKEY, r2:ORDERS_ORDERDATE,
     r3:ORDERS_SHIPPRIORITY, r4:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
     r5:__prod_ret__34};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:int, r5:real
    } @ { Collection }).fold ((\acc_conv -> (\x ->
    (acc_conv.insert x;acc_conv)))) empty { r1:int, r2:int, r3:int, r4:int,
    r5:real } @ { Set } in
  ((nd_add_delta_to_int_date_int_int_float {r1:QUERY3_mCUSTOMER2, r2:false,
      r3:vid, r4:delta_values});
   let sent_msgs =
   nd_QUERY3_mCUSTOMER2_send_correctives {r1:me, r2:19, r3:vid, r4:1, r5:vid,
     r6:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:19}
     else
       nd_update_stmt_cntr_corr_map {r1:vid, r2:19, r3:1, r4:sent_msgs,
         r5:true, r6:false}))


declare nd_insert_LINEITEM_do_complete_s20 : { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:int, r6:real, r7:real, r8:real, r9:real,
  r10:string, r11:string, r12:int, r13:int, r14:int, r15:string, r16:string,
  r17:string } -> () = (\b1 -> bind b1 as {r1:vid, r2:LINEITEM_ORDERKEY,
  r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
  r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
  r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
  r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
  r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT} in 
  let delta_values =
  (((((bind map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf as ind __x in
    (frontier_int_date_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4, r5:r5, r6:r6} in r2 ==
       LINEITEM_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {r1:vid,
      r2:map_0, r3:map_1, r4:map_2, r5:map_3, r6:map_val} in 
      (acc.insert {r1:map_0, r2:map_1, r3:map_2, r4:map_3, r5:map_val};acc))))
      empty { r1:int, r2:int, r3:int, r4:int, r5:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {r1:LINEITEM_ORDERKEY,
    r2:ORDERS_ORDERDATE, r3:ORDERS_SHIPPRIORITY,
    r4:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, r5:__map_ret__21} in 
    (_accmap.insert {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
     r3:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, r4:__map_ret__21};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
    r3:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, r4:__map_ret__21} in 
    (_accmap.insert {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
     r3:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, r4:__map_ret__21 *
     if 19950315 < LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
    r3:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, r4:__prod_ret__35} in 
    (_accmap.insert {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
     r3:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, r4:__prod_ret__35 *
     LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {r1:ORDERS_ORDERDATE, r2:ORDERS_SHIPPRIORITY,
    r3:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY, r4:__prod_ret__36} in 
    (_accmap.insert {r1:LINEITEM_ORDERKEY, r2:ORDERS_ORDERDATE,
     r3:ORDERS_SHIPPRIORITY, r4:QUERY3_mCUSTOMERCUSTOMER_CUSTKEY,
     r5:__prod_ret__36};
     _accmap)))) empty { r1:int, r2:int, r3:int, r4:int, r5:real
    } @ { Collection }).fold ((\acc_conv -> (\x ->
    (acc_conv.insert x;acc_conv)))) empty { r1:int, r2:int, r3:int, r4:int,
    r5:real } @ { Set } in
  ((nd_add_delta_to_int_date_int_int_float {r1:QUERY3_mCUSTOMER4, r2:false,
      r3:vid, r4:delta_values});
   let sent_msgs =
   nd_QUERY3_mCUSTOMER4_send_correctives {r1:me, r2:20, r3:vid, r4:1, r5:vid,
     r6:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:20}
     else
       nd_update_stmt_cntr_corr_map {r1:vid, r2:20, r3:1, r4:sent_msgs,
         r5:true, r6:false}))


declare nd_insert_LINEITEM_do_complete_s17 : { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:int, r6:real, r7:real, r8:real, r9:real,
  r10:string, r11:string, r12:int, r13:int, r14:int, r15:string, r16:string,
  r17:string } -> () = (\b1 -> bind b1 as {r1:vid, r2:LINEITEM_ORDERKEY,
  r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
  r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
  r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
  r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
  r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT} in 
  let __prod_ret__30 =
  ((if 19950315 < LINEITEM_SHIPDATE then 1 else 0) * LINEITEM_DISCOUNT) *
    LINEITEM_EXTENDEDPRICE in
  ((nd_add_delta_to_int_float {r1:QUERY3_mORDERS3, r2:false, r3:vid, r4:{|
      key:int, value:real | {key:LINEITEM_ORDERKEY,
      value:__prod_ret__30}|} @ { Set }});
   let sent_msgs =
   nd_QUERY3_mORDERS3_send_correctives {r1:me, r2:17, r3:vid, r4:1, r5:vid,
     r6:{| key:int, value:real | {key:LINEITEM_ORDERKEY,
     value:__prod_ret__30}|} @ { Set }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {r1:vid, r2:17, r3:1, r4:sent_msgs,
         r5:true, r6:true}))


declare nd_insert_LINEITEM_do_complete_s18 : { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:int, r6:real, r7:real, r8:real, r9:real,
  r10:string, r11:string, r12:int, r13:int, r14:int, r15:string, r16:string,
  r17:string } -> () = (\b1 -> bind b1 as {r1:vid, r2:LINEITEM_ORDERKEY,
  r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
  r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
  r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
  r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
  r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT} in 
  let __prod_ret__31 =
  (if 19950315 < LINEITEM_SHIPDATE then 1 else 0) * LINEITEM_EXTENDEDPRICE in
  ((nd_add_delta_to_int_float {r1:QUERY3_mORDERS6, r2:false, r3:vid, r4:{|
      key:int, value:real | {key:LINEITEM_ORDERKEY,
      value:__prod_ret__31}|} @ { Set }});
   let sent_msgs =
   nd_QUERY3_mORDERS6_send_correctives {r1:me, r2:18, r3:vid, r4:1, r5:vid,
     r6:{| key:int, value:real | {key:LINEITEM_ORDERKEY,
     value:__prod_ret__31}|} @ { Set }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {r1:vid, r2:18, r3:1, r4:sent_msgs,
         r5:true, r6:true}))


declare insert_LINEITEM_do_corrective_s16_m_QUERY3_mLINEITEM1 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int }, r6:int,
  r7:int, r8:int, r9:int, r10:real, r11:real, r12:real, r13:real, r14:string,
  r15:string, r16:int, r17:int, r18:int, r19:string, r20:string, r21:string,
  r22:collection { r1:int, r2:int, r3:int, r4:int } @ { Set } } -> int =
  (\b1 -> bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop,
  r5:vid, r6:LINEITEM_ORDERKEY, r7:LINEITEM_PARTKEY, r8:LINEITEM_SUPPKEY,
  r9:LINEITEM_LINENUMBER, r10:LINEITEM_QUANTITY, r11:LINEITEM_EXTENDEDPRICE,
  r12:LINEITEM_DISCOUNT, r13:LINEITEM_TAX, r14:LINEITEM_RETURNFLAG,
  r15:LINEITEM_LINESTATUS, r16:LINEITEM_SHIPDATE, r17:LINEITEM_COMMITDATE,
  r18:LINEITEM_RECEIPTDATE, r19:LINEITEM_SHIPINSTRUCT, r20:LINEITEM_SHIPMODE,
  r21:LINEITEM_COMMENT, r22:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {r1:delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY,
    r2:delta_ORDERS_ORDERDATE, r3:delta_ORDERS_SHIPPRIORITY,
    r4:delta_QUERY3_mLINEITEM1} in _accext.combine (let __prod_ret__56 =
    ((((if LINEITEM_ORDERKEY == delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY 
      then 1 else 0) * if 19950315 < LINEITEM_SHIPDATE then 1 else 0) *
      (-LINEITEM_DISCOUNT + 1)) * delta_QUERY3_mLINEITEM1) *
      LINEITEM_EXTENDEDPRICE in
    {| r1:int, r2:int, r3:int, r4:real | {r1:LINEITEM_ORDERKEY,
      r2:delta_ORDERS_ORDERDATE, r3:delta_ORDERS_SHIPPRIORITY,
      r4:__prod_ret__56}|} @ { Set })))) empty { r1:int, r2:int, r3:int,
    r4:real } @ { Set }).filter ((\b1 -> bind b1 as {r1:map_0, r2:map_1,
    r3:map_2, r4:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_date_int_float {r1:QUERY3, r2:true, r3:vid,
      r4:new_tuples});
   0))


declare insert_LINEITEM_do_corrective_s19_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
  r1:address, r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int,
  value:int }, r6:int, r7:int, r8:int, r9:int, r10:real, r11:real, r12:real,
  r13:real, r14:string, r15:string, r16:int, r17:int, r18:int, r19:string,
  r20:string, r21:string, r22:collection { r1:int, r2:int, r3:int, r4:int,
  r5:int } @ { Set } } -> int = (\b1 -> bind b1 as {r1:orig_addr,
  r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:vid, r6:LINEITEM_ORDERKEY,
  r7:LINEITEM_PARTKEY, r8:LINEITEM_SUPPKEY, r9:LINEITEM_LINENUMBER,
  r10:LINEITEM_QUANTITY, r11:LINEITEM_EXTENDEDPRICE, r12:LINEITEM_DISCOUNT,
  r13:LINEITEM_TAX, r14:LINEITEM_RETURNFLAG, r15:LINEITEM_LINESTATUS,
  r16:LINEITEM_SHIPDATE, r17:LINEITEM_COMMITDATE, r18:LINEITEM_RECEIPTDATE,
  r19:LINEITEM_SHIPINSTRUCT, r20:LINEITEM_SHIPMODE, r21:LINEITEM_COMMENT,
  r22:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {r1:delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY,
    r2:delta_ORDERS_ORDERDATE, r3:delta_ORDERS_SHIPPRIORITY,
    r4:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
    r5:delta_QUERY3_mLINEITEM1_mCUSTOMER2} in _accext.combine (let
    __prod_ret__60 =
    ((((if LINEITEM_ORDERKEY == delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY 
      then 1 else 0) * if 19950315 < LINEITEM_SHIPDATE then 1 else 0) *
      delta_QUERY3_mLINEITEM1_mCUSTOMER2) * LINEITEM_DISCOUNT) *
      LINEITEM_EXTENDEDPRICE in
    {| r1:int, r2:int, r3:int, r4:int, r5:real | {r1:LINEITEM_ORDERKEY,
      r2:delta_ORDERS_ORDERDATE, r3:delta_ORDERS_SHIPPRIORITY,
      r4:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
      r5:__prod_ret__60}|} @ { Set })))) empty { r1:int, r2:int, r3:int,
    r4:int, r5:real } @ { Set }).filter ((\b1 -> bind b1 as {r1:map_0,
    r2:map_1, r3:map_2, r4:map_3, r5:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_date_int_int_float {r1:QUERY3_mCUSTOMER2, r2:true,
      r3:vid, r4:new_tuples});
   (nd_QUERY3_mCUSTOMER2_send_correctives {r1:orig_addr, r2:orig_stmt_id,
      r3:orig_vid, r4:1 + hop, r5:vid, r6:new_tuples})))


declare insert_LINEITEM_do_corrective_s20_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
  r1:address, r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int,
  value:int }, r6:int, r7:int, r8:int, r9:int, r10:real, r11:real, r12:real,
  r13:real, r14:string, r15:string, r16:int, r17:int, r18:int, r19:string,
  r20:string, r21:string, r22:collection { r1:int, r2:int, r3:int, r4:int,
  r5:int } @ { Set } } -> int = (\b1 -> bind b1 as {r1:orig_addr,
  r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:vid, r6:LINEITEM_ORDERKEY,
  r7:LINEITEM_PARTKEY, r8:LINEITEM_SUPPKEY, r9:LINEITEM_LINENUMBER,
  r10:LINEITEM_QUANTITY, r11:LINEITEM_EXTENDEDPRICE, r12:LINEITEM_DISCOUNT,
  r13:LINEITEM_TAX, r14:LINEITEM_RETURNFLAG, r15:LINEITEM_LINESTATUS,
  r16:LINEITEM_SHIPDATE, r17:LINEITEM_COMMITDATE, r18:LINEITEM_RECEIPTDATE,
  r19:LINEITEM_SHIPINSTRUCT, r20:LINEITEM_SHIPMODE, r21:LINEITEM_COMMENT,
  r22:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {r1:delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY,
    r2:delta_ORDERS_ORDERDATE, r3:delta_ORDERS_SHIPPRIORITY,
    r4:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
    r5:delta_QUERY3_mLINEITEM1_mCUSTOMER2} in _accext.combine (let
    __prod_ret__63 =
    (((if LINEITEM_ORDERKEY == delta_QUERY3_mLINEITEMLINEITEM_ORDERKEY 
      then 1 else 0) * if 19950315 < LINEITEM_SHIPDATE then 1 else 0) *
      delta_QUERY3_mLINEITEM1_mCUSTOMER2) * LINEITEM_EXTENDEDPRICE in
    {| r1:int, r2:int, r3:int, r4:int, r5:real | {r1:LINEITEM_ORDERKEY,
      r2:delta_ORDERS_ORDERDATE, r3:delta_ORDERS_SHIPPRIORITY,
      r4:delta_QUERY3_mLINEITEM1_mCUSTOMERCUSTOMER_CUSTKEY,
      r5:__prod_ret__63}|} @ { Set })))) empty { r1:int, r2:int, r3:int,
    r4:int, r5:real } @ { Set }).filter ((\b1 -> bind b1 as {r1:map_0,
    r2:map_1, r3:map_2, r4:map_3, r5:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_date_int_int_float {r1:QUERY3_mCUSTOMER4, r2:true,
      r3:vid, r4:new_tuples});
   (nd_QUERY3_mCUSTOMER4_send_correctives {r1:orig_addr, r2:orig_stmt_id,
      r3:orig_vid, r4:1 + hop, r5:vid, r6:new_tuples})))


trigger ms_rcv_sw_init_ack : () = (\_u ->
  (ms_rcv_sw_init_ack_cnt = ms_rcv_sw_init_ack_cnt + 1;
   (if ms_rcv_sw_init_ack_cnt == num_switches
   then
     (ms_start_time = now_int ();
      (sw_rcv_token, sw_next_switch_addr)<- g_start_vid;
      (tm_insert_timer, timer_addr)<- {r1:ms_gc_interval, r2:0, r3:me})
   else ())))
trigger sw_rcv_init : () = (\_u ->
  ((if sw_state == sw_state_pre_init then sw_state = sw_state_idle else ());
   (sw_driver_trig, me)<- ();
   (ms_rcv_sw_init_ack, master_addr)<- ()))
trigger ms_rcv_jobs_ack : () = (\_u ->
  (ms_rcv_jobs_ack_cnt = ms_rcv_jobs_ack_cnt + 1;
   (if ms_rcv_jobs_ack_cnt == num_peers
   then
     (switches.iterate ((\b1 -> bind b1 as {i:addr} in 
      (sw_rcv_init, addr)<- ()))) else ())))
trigger rcv_jobs : collection { key:address, value:int } @ { Map } =
  (\jobs_in ->
  (jobs = jobs_in;
   timer_addr = case ((jobs.filter ((\b1 -> bind b1 as {key:addr,
   value:job} in job == job_timer))).peek ()) of
   {Some timer -> timer.key}{None -> error (print "no timer peer found")};
   nodes = (jobs.filter ((\b1 -> bind b1 as {key:addr, value:job} in job ==
   job_node))).fold ((\_accmap -> (\x ->
   (_accmap.insert ({i:x.key});_accmap)))) empty {i:address} @ { Collection };
   num_nodes = nodes.size ();
   switches = (jobs.filter ((\b1 -> bind b1 as {key:addr, value:job} in job ==
   job_switch))).fold ((\_accmap -> (\x ->
   (_accmap.insert ({i:x.key});_accmap)))) empty {i:address} @ { Collection };
   num_switches = switches.size ();
   (if job <= job_switch
   then sw_next_switch_addr = let addr_list =
     (switches.fold ((\acc_conv -> (\b3 -> bind b3 as {i:x} in 
       (acc_conv.insert {i:x};acc_conv)))) empty {i:address} @ { Seq }).sort
       ((\b2 -> (\b3 -> bind b2 as {i:addr1} in bind b3 as {i:addr2} in 
       if addr1 < addr2 then -1 else 1))) in
     case (addr_list.peek ()) of
       {Some first_addr -> (addr_list.fold ((\b2 -> (\b5 ->
         bind b2 as {key:take, value:result} in bind b5 as {i:x} in if take
         then {key:false, value:x}
         else if x == me then {key:true, value:result}
           else {key:take, value:result}))) {key:false,
         value:first_addr.i}).value}{None ->
                                      error (print "no addresses in addr_list")}
   else ());
   nodes.iterate ((\b1 -> bind b1 as {i:addr} in add_node addr));
   (ms_rcv_jobs_ack, master_addr)<- ()))
trigger ms_rcv_job : { key:address, value:int } = (\b1 -> bind b1 as {key:addr,
  value:job} in 
  (jobs.insert {key:addr, value:job};
   ms_rcv_job_cnt = ms_rcv_job_cnt + 1;
   (if ms_rcv_job_cnt == num_peers
   then my_peers.iterate ((\b1 -> bind b1 as {i:addr} in 
     (rcv_jobs, addr)<- jobs)) else ())))
trigger rcv_master_addr : address = (\addr ->
  (master_addr = addr;(ms_rcv_job, addr)<- {key:me, value:job}))
trigger ms_send_addr_self : () = (\_u -> my_peers.iterate ((\b1 ->
  bind b1 as {i:addr} in (rcv_master_addr, addr)<- me)))
trigger shutdown_trig : () = (\_u -> haltEngine ())
trigger ms_shutdown : () = (\_u -> if ms_rcv_node_done_cnt == num_nodes
  then my_peers.iterate ((\b1 -> bind b1 as {i:addr} in 
    (shutdown_trig, addr)<- ())) else ())
trigger ms_rcv_node_done : bool = (\done -> if done
  then
    (ms_rcv_node_done_cnt = ms_rcv_node_done_cnt + 1;
     (if ms_rcv_node_done_cnt == num_nodes
     then (ms_end_time = now_int ();(ms_shutdown, me)<- ()) else ()))
  else ms_rcv_node_done_cnt = ms_rcv_node_done_cnt - 1)
trigger nd_rcv_done : () = (\_u ->
  (nd_state = nd_state_done;
   (if 0 == nd_stmt_cntrs.size () then (ms_rcv_node_done, master_addr)<- true
   else ())))
trigger ms_rcv_switch_done : () = (\_u ->
  (ms_rcv_switch_done_cnt = ms_rcv_switch_done_cnt + 1;
   (if ms_rcv_switch_done_cnt == num_switches
   then nodes.iterate ((\b1 -> bind b1 as {i:addr} in 
     (nd_rcv_done, addr)<- ())) else ())))
trigger sw_ack_rcv : { key:address, value:{ key:int, value:int } } = (\b1 ->
  bind b1 as {key:addr, value:vid} in case ((sw_ack_log.filter ((\b1 ->
  bind b1 as {key:key, value:value} in key == vid))).peek ()) of
  {Some old_val -> let old_set = old_val.value in
    (old_set.erase {i:addr};
     (if 0 == old_set.size ()
     then
       (sw_ack_log.erase old_val;
        (if 0 == sw_ack_log.size ()
        then if sw_state == sw_state_done
          then (ms_rcv_switch_done, master_addr)<- () else () else ()))
     else sw_ack_log.insert {key:old_val.key, value:old_set}))}{None ->
                                                                 error
                                                                   (print
                                                                    "ack received but no msg sent")})
  
trigger ms_rcv_gc_vid : { key:address, value:{ key:int, value:int } } =
  (\data ->
  (ms_gc_vid_map.insert data;
   ms_gc_vid_ctr = ms_gc_vid_ctr + 1;
   (if ms_gc_vid_ctr >= ms_num_gc_expected
   then let min_vid =
     ms_gc_vid_map.fold ((\min_vid -> (\b3 -> bind b3 as {key:addr,
       value:vid} in if min_vid < vid then min_vid else vid))) g_min_vid in
     (ms_gc_vid_ctr = 0;
      ms_gc_vid_map = empty { key:address, value:{ key:int, value:int }
      } @ { Map };
      my_peers.iterate ((\b1 -> bind b1 as {i:addr} in 
      (do_gc, addr)<- min_vid));
      (tm_insert_timer, timer_addr)<- {r1:ms_gc_interval, r2:0, r3:me})
   else ())))
trigger rcv_req_gc_vid : () = (\_u -> if job == job_switch or job == job_master
  then (ms_rcv_gc_vid, master_addr)<- {key:me, value:sw_ack_log.fold
    ((\min_vid -> (\b3 -> bind b3 as {key:vid, value:addresses} in 
    if min_vid < vid then min_vid else vid))) sw_highest_vid}
  else if job == job_node
    then (ms_rcv_gc_vid, master_addr)<- {key:me, value:nd_stmt_cntrs.fold
      ((\min_vid -> (\b3 -> bind b3 as {key:vid_stmt_id, value:ctr_corrs} in 
      if min_vid < vid_stmt_id.key then min_vid else vid_stmt_id.key)))
      g_max_vid} else ())
trigger ms_send_gc_req : () = (\_u -> my_peers.iterate ((\b1 ->
  bind b1 as {i:addr} in (rcv_req_gc_vid, addr)<- ())))
trigger do_gc : { key:int, value:int } = (\min_gc_vid ->
  (let temp =
   empty { key:{ key:int, value:int }, value:collection {i:address} @ { Set }
     } @ { Map } in
   (sw_ack_log.iterate ((\b1 -> bind b1 as {key:vid, value:addresses} in 
    if vid < min_gc_vid then temp.insert {key:vid, value:addresses} else ()));
    temp.iterate ((\val -> sw_ack_log.erase val)));
   let temp = empty { key:{ key:int, value:int }, value:int } @ { Set } in
   (nd_log_master.iterate ((\b1 -> bind b1 as {key:vid, value:stmt_id} in 
    if vid < min_gc_vid then temp.insert {key:vid, value:stmt_id} else ()));
    temp.iterate ((\val -> nd_log_master.erase val)));
   let temp =
   empty { key:{ key:int, value:int }, value:{ r1:int, r2:string, r3:string,
     r4:int, r5:string, r6:real, r7:string, r8:string } } @ { Map } in
   (nd_log_insert_CUSTOMER.iterate ((\b1 -> bind b1 as {key:vid,
    value:args} in if vid < min_gc_vid then temp.insert {key:vid, value:args}
    else ()));
    temp.iterate ((\val -> nd_log_insert_CUSTOMER.erase val)));
   let temp =
   empty { key:{ key:int, value:int }, value:{ r1:int, r2:int, r3:string,
     r4:real, r5:int, r6:string, r7:string, r8:int, r9:string } } @ { Map } in
   (nd_log_insert_ORDERS.iterate ((\b1 -> bind b1 as {key:vid, value:args} in 
    if vid < min_gc_vid then temp.insert {key:vid, value:args} else ()));
    temp.iterate ((\val -> nd_log_insert_ORDERS.erase val)));
   let temp =
   empty { key:{ key:int, value:int }, value:{ r1:int, r2:int, r3:int, r4:int,
     r5:real, r6:real, r7:real, r8:real, r9:string, r10:string, r11:int,
     r12:int, r13:int, r14:string, r15:string, r16:string } } @ { Map } in
   (nd_log_insert_LINEITEM.iterate ((\b1 -> bind b1 as {key:vid,
    value:args} in if vid < min_gc_vid then temp.insert {key:vid, value:args}
    else ()));
    temp.iterate ((\val -> nd_log_insert_LINEITEM.erase val)));
   let temp =
   empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:real
     } @ { Set } in
   bind map_QUERY3_mCUSTOMER2_s0_buf as ind map_QUERY3_mCUSTOMER2_s0_buf_unwrap
     in
     let frontier =
       frontier_int_date_int_int_float {key:min_gc_vid,
         value:map_QUERY3_mCUSTOMER2_s0_buf_unwrap} in
       (map_QUERY3_mCUSTOMER2_s0_buf_unwrap.iterate ((\b1 ->
        bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
        r6:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
          r6:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mCUSTOMER2_s0_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mCUSTOMER2_s0_buf_unwrap.insert
        val)));
   let temp =
   empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:real
     } @ { Set } in
   bind map_QUERY3_mCUSTOMER4_s0_buf as ind map_QUERY3_mCUSTOMER4_s0_buf_unwrap
     in
     let frontier =
       frontier_int_date_int_int_float {key:min_gc_vid,
         value:map_QUERY3_mCUSTOMER4_s0_buf_unwrap} in
       (map_QUERY3_mCUSTOMER4_s0_buf_unwrap.iterate ((\b1 ->
        bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
        r6:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
          r6:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mCUSTOMER4_s0_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mCUSTOMER4_s0_buf_unwrap.insert
        val)));
   let temp =
   empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int
     } @ { Set } in
   bind map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf as ind
     map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf_unwrap in
     let frontier =
       frontier_int_date_int_int_int {key:min_gc_vid,
         value:map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf_unwrap} in
       (map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf_unwrap.iterate ((\b1 ->
        bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
        r6:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
          r6:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf_unwrap.insert val)));
   let temp =
   empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:real
     } @ { Set } in
   bind map_QUERY3_mCUSTOMER2_s3_buf as ind map_QUERY3_mCUSTOMER2_s3_buf_unwrap
     in
     let frontier =
       frontier_int_date_int_int_float {key:min_gc_vid,
         value:map_QUERY3_mCUSTOMER2_s3_buf_unwrap} in
       (map_QUERY3_mCUSTOMER2_s3_buf_unwrap.iterate ((\b1 ->
        bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
        r6:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
          r6:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mCUSTOMER2_s3_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mCUSTOMER2_s3_buf_unwrap.insert
        val)));
   let temp =
   empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:real
     } @ { Set } in
   bind map_QUERY3_mCUSTOMER4_s3_buf as ind map_QUERY3_mCUSTOMER4_s3_buf_unwrap
     in
     let frontier =
       frontier_int_date_int_int_float {key:min_gc_vid,
         value:map_QUERY3_mCUSTOMER4_s3_buf_unwrap} in
       (map_QUERY3_mCUSTOMER4_s3_buf_unwrap.iterate ((\b1 ->
        bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
        r6:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
          r6:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mCUSTOMER4_s3_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mCUSTOMER4_s3_buf_unwrap.insert
        val)));
   let temp =
   empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int
     } @ { Set } in
   bind map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf as ind
     map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf_unwrap in
     let frontier =
       frontier_int_date_int_int_int {key:min_gc_vid,
         value:map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf_unwrap} in
       (map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf_unwrap.iterate ((\b1 ->
        bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
        r6:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
          r6:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY3_mLINEITEM1_mCUSTOMER2_s4_buf_unwrap.insert val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:int } @ { Set } in
   bind map_QUERY3_mORDERS1_s6_buf as ind map_QUERY3_mORDERS1_s6_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY3_mORDERS1_s6_buf_unwrap} in
       (map_QUERY3_mORDERS1_s6_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS1_s6_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS1_s6_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind map_QUERY3_mORDERS3_s6_buf as ind map_QUERY3_mORDERS3_s6_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY3_mORDERS3_s6_buf_unwrap} in
       (map_QUERY3_mORDERS3_s6_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS3_s6_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS3_s6_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind map_QUERY3_mORDERS6_s6_buf as ind map_QUERY3_mORDERS6_s6_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY3_mORDERS6_s6_buf_unwrap} in
       (map_QUERY3_mORDERS6_s6_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS6_s6_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS6_s6_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:int } @ { Set } in
   bind map_QUERY3_mORDERS1_s7_buf as ind map_QUERY3_mORDERS1_s7_buf_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY3_mORDERS1_s7_buf_unwrap} in
       (map_QUERY3_mORDERS1_s7_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS1_s7_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS1_s7_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind map_QUERY3_mORDERS3_s9_buf as ind map_QUERY3_mORDERS3_s9_buf_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY3_mORDERS3_s9_buf_unwrap} in
       (map_QUERY3_mORDERS3_s9_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS3_s9_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS3_s9_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind map_QUERY3_mORDERS6_s10_buf as ind map_QUERY3_mORDERS6_s10_buf_unwrap
     in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY3_mORDERS6_s10_buf_unwrap} in
       (map_QUERY3_mORDERS6_s10_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS6_s10_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS6_s10_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:int } @ { Set } in
   bind map_QUERY3_mORDERS1_s11_buf as ind map_QUERY3_mORDERS1_s11_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY3_mORDERS1_s11_buf_unwrap} in
       (map_QUERY3_mORDERS1_s11_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS1_s11_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS1_s11_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind map_QUERY3_mORDERS3_s11_buf as ind map_QUERY3_mORDERS3_s11_buf_unwrap
     in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY3_mORDERS3_s11_buf_unwrap} in
       (map_QUERY3_mORDERS3_s11_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS3_s11_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS3_s11_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind map_QUERY3_mORDERS6_s11_buf as ind map_QUERY3_mORDERS6_s11_buf_unwrap
     in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY3_mORDERS6_s11_buf_unwrap} in
       (map_QUERY3_mORDERS6_s11_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS6_s11_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS6_s11_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:int } @ { Set } in
   bind map_QUERY3_mORDERS1_s12_buf as ind map_QUERY3_mORDERS1_s12_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY3_mORDERS1_s12_buf_unwrap} in
       (map_QUERY3_mORDERS1_s12_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS1_s12_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS1_s12_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind map_QUERY3_mORDERS3_s14_buf as ind map_QUERY3_mORDERS3_s14_buf_unwrap
     in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY3_mORDERS3_s14_buf_unwrap} in
       (map_QUERY3_mORDERS3_s14_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS3_s14_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS3_s14_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind map_QUERY3_mORDERS6_s15_buf as ind map_QUERY3_mORDERS6_s15_buf_unwrap
     in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY3_mORDERS6_s15_buf_unwrap} in
       (map_QUERY3_mORDERS6_s15_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS6_s15_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS6_s15_buf_unwrap.insert
        val)));
   let temp =
   empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int
     } @ { Set } in
   bind map_QUERY3_mLINEITEM1_s16_buf as ind
     map_QUERY3_mLINEITEM1_s16_buf_unwrap in
     let frontier =
       frontier_int_date_int_int {key:min_gc_vid,
         value:map_QUERY3_mLINEITEM1_s16_buf_unwrap} in
       (map_QUERY3_mLINEITEM1_s16_buf_unwrap.iterate ((\b1 ->
        bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_val} in 
        if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_val}
        else ()));
        temp.iterate ((\val -> map_QUERY3_mLINEITEM1_s16_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mLINEITEM1_s16_buf_unwrap.insert
        val)));
   let temp =
   empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int
     } @ { Set } in
   bind map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf as ind
     map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf_unwrap in
     let frontier =
       frontier_int_date_int_int_int {key:min_gc_vid,
         value:map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf_unwrap} in
       (map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf_unwrap.iterate ((\b1 ->
        bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
        r6:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
          r6:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf_unwrap.insert val)));
   let temp =
   empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int
     } @ { Set } in
   bind map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf as ind
     map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf_unwrap in
     let frontier =
       frontier_int_date_int_int_int {key:min_gc_vid,
         value:map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf_unwrap} in
       (map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf_unwrap.iterate ((\b1 ->
        bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
        r6:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
          r6:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf_unwrap.insert val)));
   let temp =
   empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int
     } @ { Set } in
   bind map_QUERY3_mLINEITEM1_s21_buf as ind
     map_QUERY3_mLINEITEM1_s21_buf_unwrap in
     let frontier =
       frontier_int_date_int_int {key:min_gc_vid,
         value:map_QUERY3_mLINEITEM1_s21_buf_unwrap} in
       (map_QUERY3_mLINEITEM1_s21_buf_unwrap.iterate ((\b1 ->
        bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_val} in 
        if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_val}
        else ()));
        temp.iterate ((\val -> map_QUERY3_mLINEITEM1_s21_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mLINEITEM1_s21_buf_unwrap.insert
        val)));
   let temp =
   empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int
     } @ { Set } in
   bind map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf as ind
     map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf_unwrap in
     let frontier =
       frontier_int_date_int_int_int {key:min_gc_vid,
         value:map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf_unwrap} in
       (map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf_unwrap.iterate ((\b1 ->
        bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
        r6:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
          r6:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY3_mLINEITEM1_mCUSTOMER2_s24_buf_unwrap.insert val)));
   let temp =
   empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int
     } @ { Set } in
   bind map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf as ind
     map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf_unwrap in
     let frontier =
       frontier_int_date_int_int_int {key:min_gc_vid,
         value:map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf_unwrap} in
       (map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf_unwrap.iterate ((\b1 ->
        bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
        r6:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
          r6:map_val} else ()));
        temp.iterate ((\val ->
        map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_QUERY3_mLINEITEM1_mCUSTOMER2_s25_buf_unwrap.insert val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind map_QUERY3_mORDERS3_s36_buf as ind map_QUERY3_mORDERS3_s36_buf_unwrap
     in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY3_mORDERS3_s36_buf_unwrap} in
       (map_QUERY3_mORDERS3_s36_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS3_s36_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS3_s36_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind map_QUERY3_mORDERS6_s36_buf as ind map_QUERY3_mORDERS6_s36_buf_unwrap
     in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY3_mORDERS6_s36_buf_unwrap} in
       (map_QUERY3_mORDERS6_s36_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS6_s36_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS6_s36_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind map_QUERY3_mORDERS3_s38_buf as ind map_QUERY3_mORDERS3_s38_buf_unwrap
     in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY3_mORDERS3_s38_buf_unwrap} in
       (map_QUERY3_mORDERS3_s38_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS3_s38_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS3_s38_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind map_QUERY3_mORDERS6_s38_buf as ind map_QUERY3_mORDERS6_s38_buf_unwrap
     in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY3_mORDERS6_s38_buf_unwrap} in
       (map_QUERY3_mORDERS6_s38_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS6_s38_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS6_s38_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:int } @ { Set } in
   bind map_QUERY3_mORDERS1_s40_buf as ind map_QUERY3_mORDERS1_s40_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY3_mORDERS1_s40_buf_unwrap} in
       (map_QUERY3_mORDERS1_s40_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS1_s40_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS1_s40_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:int } @ { Set } in
   bind map_QUERY3_mORDERS1_s42_buf as ind map_QUERY3_mORDERS1_s42_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY3_mORDERS1_s42_buf_unwrap} in
       (map_QUERY3_mORDERS1_s42_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS1_s42_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS1_s42_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:int } @ { Set } in
   bind map_QUERY3_mORDERS1_s44_buf as ind map_QUERY3_mORDERS1_s44_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY3_mORDERS1_s44_buf_unwrap} in
       (map_QUERY3_mORDERS1_s44_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS1_s44_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS1_s44_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:int } @ { Set } in
   bind map_QUERY3_mORDERS1_s46_buf as ind map_QUERY3_mORDERS1_s46_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY3_mORDERS1_s46_buf_unwrap} in
       (map_QUERY3_mORDERS1_s46_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS1_s46_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS1_s46_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind map_QUERY3_mORDERS3_s48_buf as ind map_QUERY3_mORDERS3_s48_buf_unwrap
     in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY3_mORDERS3_s48_buf_unwrap} in
       (map_QUERY3_mORDERS3_s48_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS3_s48_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS3_s48_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind map_QUERY3_mORDERS6_s48_buf as ind map_QUERY3_mORDERS6_s48_buf_unwrap
     in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY3_mORDERS6_s48_buf_unwrap} in
       (map_QUERY3_mORDERS6_s48_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS6_s48_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS6_s48_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind map_QUERY3_mORDERS3_s50_buf as ind map_QUERY3_mORDERS3_s50_buf_unwrap
     in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY3_mORDERS3_s50_buf_unwrap} in
       (map_QUERY3_mORDERS3_s50_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS3_s50_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS3_s50_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind map_QUERY3_mORDERS6_s50_buf as ind map_QUERY3_mORDERS6_s50_buf_unwrap
     in
     let frontier =
       frontier_int_float {key:min_gc_vid,
         value:map_QUERY3_mORDERS6_s50_buf_unwrap} in
       (map_QUERY3_mORDERS6_s50_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS6_s50_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS6_s50_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:int } @ { Set } in
   bind map_QUERY3_mORDERS1_s52_buf as ind map_QUERY3_mORDERS1_s52_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY3_mORDERS1_s52_buf_unwrap} in
       (map_QUERY3_mORDERS1_s52_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS1_s52_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS1_s52_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:int } @ { Set } in
   bind map_QUERY3_mORDERS1_s54_buf as ind map_QUERY3_mORDERS1_s54_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY3_mORDERS1_s54_buf_unwrap} in
       (map_QUERY3_mORDERS1_s54_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS1_s54_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS1_s54_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:int } @ { Set } in
   bind map_QUERY3_mORDERS1_s56_buf as ind map_QUERY3_mORDERS1_s56_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY3_mORDERS1_s56_buf_unwrap} in
       (map_QUERY3_mORDERS1_s56_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS1_s56_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS1_s56_buf_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:int } @ { Set } in
   bind map_QUERY3_mORDERS1_s58_buf as ind map_QUERY3_mORDERS1_s58_buf_unwrap
     in
     let frontier =
       frontier_int_int {key:min_gc_vid,
         value:map_QUERY3_mORDERS1_s58_buf_unwrap} in
       (map_QUERY3_mORDERS1_s58_buf_unwrap.iterate ((\b1 -> bind b1 as {r1:vid,
        r2:map_0, r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> map_QUERY3_mORDERS1_s58_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_QUERY3_mORDERS1_s58_buf_unwrap.insert
        val)));
   let temp =
   empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:real
     } @ { Set } in
   bind QUERY3 as ind QUERY3_unwrap in
     let frontier =
       frontier_int_date_int_float {key:min_gc_vid, value:QUERY3_unwrap} in
       (QUERY3_unwrap.iterate ((\b1 -> bind b1 as {r1:vid, r2:map_0, r3:map_1,
        r4:map_2, r5:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_val}
        else ()));
        temp.iterate ((\val -> QUERY3_unwrap.erase val));
        frontier.iterate ((\val -> QUERY3_unwrap.insert val)));
   let temp =
   empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int
     } @ { Set } in
   bind QUERY3_mLINEITEM1 as ind QUERY3_mLINEITEM1_unwrap in
     let frontier =
       frontier_int_date_int_int {key:min_gc_vid,
         value:QUERY3_mLINEITEM1_unwrap} in
       (QUERY3_mLINEITEM1_unwrap.iterate ((\b1 -> bind b1 as {r1:vid, r2:map_0,
        r3:map_1, r4:map_2, r5:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_val}
        else ()));
        temp.iterate ((\val -> QUERY3_mLINEITEM1_unwrap.erase val));
        frontier.iterate ((\val -> QUERY3_mLINEITEM1_unwrap.insert val)));
   let temp =
   empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:int
     } @ { Set } in
   bind QUERY3_mLINEITEM1_mCUSTOMER2 as ind QUERY3_mLINEITEM1_mCUSTOMER2_unwrap
     in
     let frontier =
       frontier_int_date_int_int_int {key:min_gc_vid,
         value:QUERY3_mLINEITEM1_mCUSTOMER2_unwrap} in
       (QUERY3_mLINEITEM1_mCUSTOMER2_unwrap.iterate ((\b1 ->
        bind b1 as {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
        r6:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
          r6:map_val} else ()));
        temp.iterate ((\val -> QUERY3_mLINEITEM1_mCUSTOMER2_unwrap.erase val));
        frontier.iterate ((\val -> QUERY3_mLINEITEM1_mCUSTOMER2_unwrap.insert
        val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:int } @ { Set } in
   bind QUERY3_mORDERS1 as ind QUERY3_mORDERS1_unwrap in
     let frontier =
       frontier_int_int {key:min_gc_vid, value:QUERY3_mORDERS1_unwrap} in
       (QUERY3_mORDERS1_unwrap.iterate ((\b1 -> bind b1 as {r1:vid, r2:map_0,
        r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> QUERY3_mORDERS1_unwrap.erase val));
        frontier.iterate ((\val -> QUERY3_mORDERS1_unwrap.insert val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind QUERY3_mORDERS3 as ind QUERY3_mORDERS3_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid, value:QUERY3_mORDERS3_unwrap} in
       (QUERY3_mORDERS3_unwrap.iterate ((\b1 -> bind b1 as {r1:vid, r2:map_0,
        r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> QUERY3_mORDERS3_unwrap.erase val));
        frontier.iterate ((\val -> QUERY3_mORDERS3_unwrap.insert val)));
   let temp = empty { r1:{ key:int, value:int }, r2:int, r3:real } @ { Set } in
   bind QUERY3_mORDERS6 as ind QUERY3_mORDERS6_unwrap in
     let frontier =
       frontier_int_float {key:min_gc_vid, value:QUERY3_mORDERS6_unwrap} in
       (QUERY3_mORDERS6_unwrap.iterate ((\b1 -> bind b1 as {r1:vid, r2:map_0,
        r3:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_val} else ()));
        temp.iterate ((\val -> QUERY3_mORDERS6_unwrap.erase val));
        frontier.iterate ((\val -> QUERY3_mORDERS6_unwrap.insert val)));
   let temp =
   empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:real
     } @ { Set } in
   bind QUERY3_mCUSTOMER2 as ind QUERY3_mCUSTOMER2_unwrap in
     let frontier =
       frontier_int_date_int_int_float {key:min_gc_vid,
         value:QUERY3_mCUSTOMER2_unwrap} in
       (QUERY3_mCUSTOMER2_unwrap.iterate ((\b1 -> bind b1 as {r1:vid, r2:map_0,
        r3:map_1, r4:map_2, r5:map_3, r6:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
          r6:map_val} else ()));
        temp.iterate ((\val -> QUERY3_mCUSTOMER2_unwrap.erase val));
        frontier.iterate ((\val -> QUERY3_mCUSTOMER2_unwrap.insert val)));
   let temp =
   empty { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:real
     } @ { Set } in
   bind QUERY3_mCUSTOMER4 as ind QUERY3_mCUSTOMER4_unwrap in
     let frontier =
       frontier_int_date_int_int_float {key:min_gc_vid,
         value:QUERY3_mCUSTOMER4_unwrap} in
       (QUERY3_mCUSTOMER4_unwrap.iterate ((\b1 -> bind b1 as {r1:vid, r2:map_0,
        r3:map_1, r4:map_2, r5:map_3, r6:map_val} in if vid < min_gc_vid
        then temp.insert {r1:vid, r2:map_0, r3:map_1, r4:map_2, r5:map_3,
          r6:map_val} else ()));
        temp.iterate ((\val -> QUERY3_mCUSTOMER4_unwrap.erase val));
        frontier.iterate ((\val -> QUERY3_mCUSTOMER4_unwrap.insert val)))))
trigger sw_rcv_token : { key:int, value:int } = (\vid ->
  if sw_need_vid_cntr > 0
  then let next_vid = {key:vid.key, value:vid.value + sw_need_vid_cntr} in
    (sw_token_vid_list.insert {key:vid, value:sw_need_vid_cntr};
     sw_need_vid_cntr = 0;
     sw_highest_vid = next_vid;
     (sw_rcv_token, sw_next_switch_addr)<- next_vid;
     (if sw_state == sw_state_wait_vid then (sw_driver_trig, me)<- () else ()))
  else (sw_rcv_token, sw_next_switch_addr)<- vid)
trigger tm_insert_timer : { r1:int, r2:int, r3:address } = (\b1 ->
  bind b1 as {r1:time, r2:trig_id, r3:addr} in 
  (tm_timer_list.insert {r1:time + now_int (), r2:trig_id, r3:addr};
   tm_timer_list = tm_timer_list.sort ((\b2 -> (\b6 -> bind b2 as {r1:time1,
   r2:trig_id1, r3:addr1} in bind b6 as {r1:time2, r2:trig_id2, r3:addr2} in 
   if time1 < time2 then -1 else 1)));
   (tm_check_time, me)<- ()))
trigger tm_check_time : () = (\_u -> case (tm_timer_list.peek ()) of
  {Some timer -> if now_int () >= timer.r1
    then
      (tm_timer_list.erase timer;
       bind timer as {r1:time, r2:trig_id, r3:addr} in
       if trig_id == 0 then (ms_send_gc_req, addr)<- () else ();
       (tm_check_time, me)<- ()) else ((tm_check_time, me)<- ();(sleep 1000))}
  {None -> ()})
trigger sw_demux : { r1:int, r2:int, r3:string, r4:string, r5:int, r6:string,
  r7:real, r8:string, r9:string, r10:int, r11:int, r12:int, r13:int, r14:real,
  r15:real, r16:real, r17:real, r18:string, r19:string, r20:int, r21:int,
  r22:int, r23:string, r24:string, r25:string, r26:int, r27:int, r28:string,
  r29:real, r30:int, r31:string, r32:string, r33:int, r34:string } = (\args ->
  if args.r1 == 0
  then
    sw_insert_CUSTOMER {r1:args.r2, r2:args.r3, r3:args.r4, r4:args.r5,
      r5:args.r6, r6:args.r7, r7:args.r8, r8:args.r9}
  else if args.r1 == 4
    then
      sw_insert_LINEITEM {r1:args.r10, r2:args.r11, r3:args.r12, r4:args.r13,
        r5:args.r14, r6:args.r15, r7:args.r16, r8:args.r17, r9:args.r18,
        r10:args.r19, r11:args.r20, r12:args.r21, r13:args.r22, r14:args.r23,
        r15:args.r24, r16:args.r25}
    else if args.r1 == 2
      then
        sw_insert_ORDERS {r1:args.r26, r2:args.r27, r3:args.r28, r4:args.r29,
          r5:args.r30, r6:args.r31, r7:args.r32, r8:args.r33, r9:args.r34}
      else if args.r1 == -1
        then
          (sw_trig_buf_idx.insert ({i:-1});
           sw_need_vid_cntr = sw_need_vid_cntr + 1)
        else error (print "unidentified trig id"))
trigger sw_driver_trig : () = (\_u -> if sw_state == sw_state_done then ()
  else case sw_gen_vid () of
    {Some vid -> case (sw_trig_buf_idx.peek ()) of
      {Some trig_id ->
        (sw_trig_buf_idx.erase {i:trig_id.i};
         (if trig_id.i == -1 then sw_state = sw_state_done
         else
           (sw_state = sw_state_sending;
            (if trig_id.i == 4 then sw_insert_LINEITEM_send_fetch vid
            else if trig_id.i == 2 then sw_insert_ORDERS_send_fetch vid
              else if trig_id.i == 0 then sw_insert_CUSTOMER_send_fetch vid
                else error (print "mismatch on trigger id"));
            (sw_driver_trig, me)<- ())))}{None -> sw_state = sw_state_idle}}
    {None -> sw_state = sw_state_wait_vid})
trigger nd_rcv_corr_done : { r1:{ key:int, value:int }, r2:int, r3:int, r4:int
  } = (\b1 -> bind b1 as {r1:vid, r2:stmt_id, r3:hop, r4:count} in 
  ((nd_update_stmt_cntr_corr_map {r1:vid, r2:stmt_id, r3:hop, r4:count,
      r5:false, r6:false});
   (case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
   key == {key:vid, value:stmt_id}))).peek ()) of
   {Some lkup -> if 0 == ((lkup.value).value).size ()
     then
       (nd_stmt_cntrs.erase lkup;
        (if nd_state == nd_state_done
        then if 0 == nd_stmt_cntrs.size ()
          then (ms_rcv_node_done, master_addr)<- true else () else ()))
     else ()}{None ->
               error (print "nd_rcv_corr_done: expected stmt_cntr value")})))
trigger nd_insert_CUSTOMER_rcv_put : { r1:address, r2:collection { key:int,
  value:int } @ { Collection }, r3:{ key:int, value:int }, r4:int, r5:string,
  r6:string, r7:int, r8:string, r9:real, r10:string, r11:string } = (\b1 ->
  bind b1 as {r1:sender_ip, r2:stmt_cnt_list, r3:vid, r4:CUSTOMER_CUSTKEY,
  r5:CUSTOMER_NAME, r6:CUSTOMER_ADDRESS, r7:CUSTOMER_NATIONKEY,
  r8:CUSTOMER_PHONE, r9:CUSTOMER_ACCTBAL, r10:CUSTOMER_MKTSEGMENT,
  r11:CUSTOMER_COMMENT} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {r1:vid, r2:stmt_id, r3:count}
   then if stmt_id == 2
     then
       nd_insert_CUSTOMER_do_complete_s2 {r1:vid, r2:CUSTOMER_CUSTKEY,
         r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY,
         r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT,
         r9:CUSTOMER_COMMENT}
     else if stmt_id == 1
       then
         nd_insert_CUSTOMER_do_complete_s1 {r1:vid, r2:CUSTOMER_CUSTKEY,
           r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY,
           r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT,
           r9:CUSTOMER_COMMENT}
       else if stmt_id == 0
         then
           nd_insert_CUSTOMER_do_complete_s0 {r1:vid, r2:CUSTOMER_CUSTKEY,
             r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY,
             r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT,
             r9:CUSTOMER_COMMENT} else () else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_insert_CUSTOMER_rcv_fetch : { r1:collection { key:int, value:int
  } @ { Collection }, r2:{ key:int, value:int }, r3:int, r4:string, r5:string,
  r6:int, r7:string, r8:real, r9:string, r10:string } = (\b1 ->
  bind b1 as {r1:stmt_map_ids, r2:vid, r3:CUSTOMER_CUSTKEY, r4:CUSTOMER_NAME,
  r5:CUSTOMER_ADDRESS, r6:CUSTOMER_NATIONKEY, r7:CUSTOMER_PHONE,
  r8:CUSTOMER_ACCTBAL, r9:CUSTOMER_MKTSEGMENT, r10:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {r1:vid, r2:CUSTOMER_CUSTKEY,
      r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY,
      r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT,
      r9:CUSTOMER_COMMENT});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 0
   then if map_id == 7
     then (nd_insert_CUSTOMER_send_push_s0_m_QUERY3_mCUSTOMER2, me)<- {r1:vid,
       r2:CUSTOMER_CUSTKEY, r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS,
       r5:CUSTOMER_NATIONKEY, r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL,
       r8:CUSTOMER_MKTSEGMENT, r9:CUSTOMER_COMMENT}
     else if map_id == 8
       then
         (nd_insert_CUSTOMER_send_push_s0_m_QUERY3_mCUSTOMER4, me)<- {r1:vid,
         r2:CUSTOMER_CUSTKEY, r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS,
         r5:CUSTOMER_NATIONKEY, r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL,
         r8:CUSTOMER_MKTSEGMENT, r9:CUSTOMER_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 1
     then if map_id == 3
       then
         (nd_insert_CUSTOMER_send_push_s1_m_QUERY3_mLINEITEM1_mCUSTOMER2, me)<- {r1:vid,
         r2:CUSTOMER_CUSTKEY, r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS,
         r5:CUSTOMER_NATIONKEY, r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL,
         r8:CUSTOMER_MKTSEGMENT, r9:CUSTOMER_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
     else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_insert_CUSTOMER_send_push_s0_m_QUERY3_mCUSTOMER2 : { r1:{ key:int,
  value:int }, r2:int, r3:string, r4:string, r5:int, r6:string, r7:real,
  r8:string, r9:string } = (\b1 -> bind b1 as {r1:vid, r2:CUSTOMER_CUSTKEY,
  r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY,
  r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT,
  r9:CUSTOMER_COMMENT} in bind QUERY3_mCUSTOMER2 as ind QUERY3_mCUSTOMER2_deref
  in
  ((nd_log_master_write {key:vid, value:0});
   (shuffle_QUERY3_mCUSTOMER2_to_QUERY3_bind_0t0_1t1_2t2 {r1:None immut,
      r2:None immut, r3:None immut,
      r4:frontier_int_date_int_int_float {key:vid,
           value:QUERY3_mCUSTOMER2_deref.filter ((\b1 -> bind b1 as {r1:r1,
           r2:r2, r3:r3, r4:r4, r5:r5, r6:r6} in r5 == CUSTOMER_CUSTKEY))},
      r5:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s0_m_QUERY3_mCUSTOMER2, ip)<- {r1:tuples,
   r2:vid, r3:CUSTOMER_CUSTKEY, r4:CUSTOMER_NAME, r5:CUSTOMER_ADDRESS,
   r6:CUSTOMER_NATIONKEY, r7:CUSTOMER_PHONE, r8:CUSTOMER_ACCTBAL,
   r9:CUSTOMER_MKTSEGMENT, r10:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s0_m_QUERY3_mCUSTOMER4 : { r1:{ key:int,
  value:int }, r2:int, r3:string, r4:string, r5:int, r6:string, r7:real,
  r8:string, r9:string } = (\b1 -> bind b1 as {r1:vid, r2:CUSTOMER_CUSTKEY,
  r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY,
  r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT,
  r9:CUSTOMER_COMMENT} in bind QUERY3_mCUSTOMER4 as ind QUERY3_mCUSTOMER4_deref
  in
  ((nd_log_master_write {key:vid, value:0});
   (shuffle_QUERY3_mCUSTOMER4_to_QUERY3_bind_0t0_1t1_2t2 {r1:None immut,
      r2:None immut, r3:None immut,
      r4:frontier_int_date_int_int_float {key:vid,
           value:QUERY3_mCUSTOMER4_deref.filter ((\b1 -> bind b1 as {r1:r1,
           r2:r2, r3:r3, r4:r4, r5:r5, r6:r6} in r5 == CUSTOMER_CUSTKEY))},
      r5:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s0_m_QUERY3_mCUSTOMER4, ip)<- {r1:tuples,
   r2:vid, r3:CUSTOMER_CUSTKEY, r4:CUSTOMER_NAME, r5:CUSTOMER_ADDRESS,
   r6:CUSTOMER_NATIONKEY, r7:CUSTOMER_PHONE, r8:CUSTOMER_ACCTBAL,
   r9:CUSTOMER_MKTSEGMENT, r10:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s1_m_QUERY3_mLINEITEM1_mCUSTOMER2 : { r1:{
  key:int, value:int }, r2:int, r3:string, r4:string, r5:int, r6:string,
  r7:real, r8:string, r9:string } = (\b1 -> bind b1 as {r1:vid,
  r2:CUSTOMER_CUSTKEY, r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS,
  r5:CUSTOMER_NATIONKEY, r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL,
  r8:CUSTOMER_MKTSEGMENT, r9:CUSTOMER_COMMENT} in bind
  QUERY3_mLINEITEM1_mCUSTOMER2 as ind QUERY3_mLINEITEM1_mCUSTOMER2_deref in
  ((nd_log_master_write {key:vid, value:1});
   (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_to_QUERY3_mLINEITEM1_bind_0t0_1t1_2t2
      {r1:None immut, r2:None immut, r3:None immut,
      r4:frontier_int_date_int_int_int {key:vid,
           value:QUERY3_mLINEITEM1_mCUSTOMER2_deref.filter ((\b1 ->
           bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4, r5:r5, r6:r6} in r5 ==
           CUSTOMER_CUSTKEY))}, r5:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s1_m_QUERY3_mLINEITEM1_mCUSTOMER2, ip)<- {r1:tuples,
   r2:vid, r3:CUSTOMER_CUSTKEY, r4:CUSTOMER_NAME, r5:CUSTOMER_ADDRESS,
   r6:CUSTOMER_NATIONKEY, r7:CUSTOMER_PHONE, r8:CUSTOMER_ACCTBAL,
   r9:CUSTOMER_MKTSEGMENT, r10:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_rcv_push_s0_m_QUERY3_mCUSTOMER2 : { r1:collection {
  r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:real
  } @ { Set }, r2:{ key:int, value:int }, r3:int, r4:string, r5:string, r6:int,
  r7:string, r8:real, r9:string, r10:string } = (\b1 -> bind b1 as {r1:tuples,
  r2:vid, r3:CUSTOMER_CUSTKEY, r4:CUSTOMER_NAME, r5:CUSTOMER_ADDRESS,
  r6:CUSTOMER_NATIONKEY, r7:CUSTOMER_PHONE, r8:CUSTOMER_ACCTBAL,
  r9:CUSTOMER_MKTSEGMENT, r10:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {r1:vid, r2:CUSTOMER_CUSTKEY,
      r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY,
      r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT,
      r9:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY3_mCUSTOMER2_s0_buf as ind
   map_QUERY3_mCUSTOMER2_s0_buf_d in
   bind tuple as {r1:_tup0, r2:_tup1, r3:_tup2, r4:_tup3, r5:_tup4, r6:_tup5}
     in
     case ((map_QUERY3_mCUSTOMER2_s0_buf_d.filter ((\b1 -> bind b1 as {r1:r1,
       r2:r2, r3:r3, r4:r4, r5:r5, r6:r6} in (((r1 == _tup0 and r5 == _tup4)
       and r4 == _tup3) and r3 == _tup2) and r2 == _tup1))).peek ()) of
       {Some vals -> map_QUERY3_mCUSTOMER2_s0_buf_d.update vals tuple}
       {None -> map_QUERY3_mCUSTOMER2_s0_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {r1:vid, r2:0, r3:-1}
   then
     nd_insert_CUSTOMER_do_complete_s0 {r1:vid, r2:CUSTOMER_CUSTKEY,
       r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY,
       r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT,
       r9:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s0_m_QUERY3_mCUSTOMER4 : { r1:collection {
  r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:real
  } @ { Set }, r2:{ key:int, value:int }, r3:int, r4:string, r5:string, r6:int,
  r7:string, r8:real, r9:string, r10:string } = (\b1 -> bind b1 as {r1:tuples,
  r2:vid, r3:CUSTOMER_CUSTKEY, r4:CUSTOMER_NAME, r5:CUSTOMER_ADDRESS,
  r6:CUSTOMER_NATIONKEY, r7:CUSTOMER_PHONE, r8:CUSTOMER_ACCTBAL,
  r9:CUSTOMER_MKTSEGMENT, r10:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {r1:vid, r2:CUSTOMER_CUSTKEY,
      r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY,
      r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT,
      r9:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY3_mCUSTOMER4_s0_buf as ind
   map_QUERY3_mCUSTOMER4_s0_buf_d in
   bind tuple as {r1:_tup0, r2:_tup1, r3:_tup2, r4:_tup3, r5:_tup4, r6:_tup5}
     in
     case ((map_QUERY3_mCUSTOMER4_s0_buf_d.filter ((\b1 -> bind b1 as {r1:r1,
       r2:r2, r3:r3, r4:r4, r5:r5, r6:r6} in (((r1 == _tup0 and r5 == _tup4)
       and r4 == _tup3) and r3 == _tup2) and r2 == _tup1))).peek ()) of
       {Some vals -> map_QUERY3_mCUSTOMER4_s0_buf_d.update vals tuple}
       {None -> map_QUERY3_mCUSTOMER4_s0_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {r1:vid, r2:0, r3:-1}
   then
     nd_insert_CUSTOMER_do_complete_s0 {r1:vid, r2:CUSTOMER_CUSTKEY,
       r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY,
       r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT,
       r9:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s1_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
  r1:collection { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int,
  r6:int } @ { Set }, r2:{ key:int, value:int }, r3:int, r4:string, r5:string,
  r6:int, r7:string, r8:real, r9:string, r10:string } = (\b1 ->
  bind b1 as {r1:tuples, r2:vid, r3:CUSTOMER_CUSTKEY, r4:CUSTOMER_NAME,
  r5:CUSTOMER_ADDRESS, r6:CUSTOMER_NATIONKEY, r7:CUSTOMER_PHONE,
  r8:CUSTOMER_ACCTBAL, r9:CUSTOMER_MKTSEGMENT, r10:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {r1:vid, r2:CUSTOMER_CUSTKEY,
      r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY,
      r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT,
      r9:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf as
   ind map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf_d in
   bind tuple as {r1:_tup0, r2:_tup1, r3:_tup2, r4:_tup3, r5:_tup4, r6:_tup5}
     in
     case ((map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf_d.filter ((\b1 ->
       bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4, r5:r5, r6:r6} in (((r1 == _tup0
       and r5 == _tup4) and r4 == _tup3) and r3 == _tup2) and r2 ==
       _tup1))).peek ()) of
       {Some vals -> map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf_d.update vals
         tuple}{None -> map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {r1:vid, r2:1, r3:-1}
   then
     nd_insert_CUSTOMER_do_complete_s1 {r1:vid, r2:CUSTOMER_CUSTKEY,
       r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY,
       r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT,
       r9:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_do_complete_s2_trig : { r1:{ key:int, value:int },
  r2:int, r3:string, r4:string, r5:int, r6:string, r7:real, r8:string,
  r9:string } = (\b1 -> bind b1 as {r1:vid, r2:CUSTOMER_CUSTKEY,
  r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY,
  r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT,
  r9:CUSTOMER_COMMENT} in 
  nd_insert_CUSTOMER_do_complete_s2 {r1:vid, r2:CUSTOMER_CUSTKEY,
    r3:CUSTOMER_NAME, r4:CUSTOMER_ADDRESS, r5:CUSTOMER_NATIONKEY,
    r6:CUSTOMER_PHONE, r7:CUSTOMER_ACCTBAL, r8:CUSTOMER_MKTSEGMENT,
    r9:CUSTOMER_COMMENT})
trigger insert_CUSTOMER_rcv_corrective_s0_m_QUERY3_mCUSTOMER2 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int },
  r6:collection { key:int, value:int } @ { Seq }, r7:collection { r1:int,
  r2:int, r3:int, r4:int, r5:real } @ { Set } } = (\b1 ->
  bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:vid,
  r6:compute_vids, r7:delta_tuples} in 
  ((nd_add_delta_to_int_date_int_int_float {r1:map_QUERY3_mCUSTOMER2_s0_buf,
      r2:false, r3:vid, r4:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:0}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {r1:CUSTOMER_CUSTKEY, r2:CUSTOMER_NAME, r3:CUSTOMER_ADDRESS, r4:CUSTOMER_NATIONKEY, r5:CUSTOMER_PHONE, r6:CUSTOMER_ACCTBAL, r7:CUSTOMER_MKTSEGMENT, r8:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s0_m_QUERY3_mCUSTOMER2 {r1:orig_addr,
             r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:compute_vid,
             r6:CUSTOMER_CUSTKEY, r7:CUSTOMER_NAME, r8:CUSTOMER_ADDRESS,
             r9:CUSTOMER_NATIONKEY, r10:CUSTOMER_PHONE, r11:CUSTOMER_ACCTBAL,
             r12:CUSTOMER_MKTSEGMENT, r13:CUSTOMER_COMMENT, r14:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {r1:orig_vid, r2:orig_stmt_id, r3:hop,
     r4:sent_msgs}))
trigger insert_CUSTOMER_rcv_corrective_s0_m_QUERY3_mCUSTOMER4 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int },
  r6:collection { key:int, value:int } @ { Seq }, r7:collection { r1:int,
  r2:int, r3:int, r4:int, r5:real } @ { Set } } = (\b1 ->
  bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:vid,
  r6:compute_vids, r7:delta_tuples} in 
  ((nd_add_delta_to_int_date_int_int_float {r1:map_QUERY3_mCUSTOMER4_s0_buf,
      r2:false, r3:vid, r4:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:0}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {r1:CUSTOMER_CUSTKEY, r2:CUSTOMER_NAME, r3:CUSTOMER_ADDRESS, r4:CUSTOMER_NATIONKEY, r5:CUSTOMER_PHONE, r6:CUSTOMER_ACCTBAL, r7:CUSTOMER_MKTSEGMENT, r8:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s0_m_QUERY3_mCUSTOMER4 {r1:orig_addr,
             r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:compute_vid,
             r6:CUSTOMER_CUSTKEY, r7:CUSTOMER_NAME, r8:CUSTOMER_ADDRESS,
             r9:CUSTOMER_NATIONKEY, r10:CUSTOMER_PHONE, r11:CUSTOMER_ACCTBAL,
             r12:CUSTOMER_MKTSEGMENT, r13:CUSTOMER_COMMENT, r14:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {r1:orig_vid, r2:orig_stmt_id, r3:hop,
     r4:sent_msgs}))
trigger insert_CUSTOMER_rcv_corrective_s1_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
  r1:address, r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int,
  value:int }, r6:collection { key:int, value:int } @ { Seq }, r7:collection {
  r1:int, r2:int, r3:int, r4:int, r5:int } @ { Set } } = (\b1 ->
  bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:vid,
  r6:compute_vids, r7:delta_tuples} in 
  ((nd_add_delta_to_int_date_int_int_int
      {r1:map_QUERY3_mLINEITEM1_mCUSTOMER2_s1_buf, r2:false, r3:vid,
      r4:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:1}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {r1:CUSTOMER_CUSTKEY, r2:CUSTOMER_NAME, r3:CUSTOMER_ADDRESS, r4:CUSTOMER_NATIONKEY, r5:CUSTOMER_PHONE, r6:CUSTOMER_ACCTBAL, r7:CUSTOMER_MKTSEGMENT, r8:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s1_m_QUERY3_mLINEITEM1_mCUSTOMER2
             {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop,
             r5:compute_vid, r6:CUSTOMER_CUSTKEY, r7:CUSTOMER_NAME,
             r8:CUSTOMER_ADDRESS, r9:CUSTOMER_NATIONKEY, r10:CUSTOMER_PHONE,
             r11:CUSTOMER_ACCTBAL, r12:CUSTOMER_MKTSEGMENT,
             r13:CUSTOMER_COMMENT, r14:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {r1:orig_vid, r2:orig_stmt_id, r3:hop,
     r4:sent_msgs}))
trigger nd_insert_ORDERS_rcv_put : { r1:address, r2:collection { key:int,
  value:int } @ { Collection }, r3:{ key:int, value:int }, r4:int, r5:int,
  r6:string, r7:real, r8:int, r9:string, r10:string, r11:int, r12:string } =
  (\b1 -> bind b1 as {r1:sender_ip, r2:stmt_cnt_list, r3:vid,
  r4:ORDERS_ORDERKEY, r5:ORDERS_CUSTKEY, r6:ORDERS_ORDERSTATUS,
  r7:ORDERS_TOTALPRICE, r8:ORDERS_ORDERDATE, r9:ORDERS_ORDERPRIORITY,
  r10:ORDERS_CLERK, r11:ORDERS_SHIPPRIORITY, r12:ORDERS_COMMENT} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {r1:vid, r2:stmt_id, r3:count}
   then if stmt_id == 10
     then
       nd_insert_ORDERS_do_complete_s10 {r1:vid, r2:ORDERS_ORDERKEY,
         r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE,
         r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK,
         r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT}
     else if stmt_id == 9
       then
         nd_insert_ORDERS_do_complete_s9 {r1:vid, r2:ORDERS_ORDERKEY,
           r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE,
           r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK,
           r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT}
       else if stmt_id == 8
         then
           nd_insert_ORDERS_do_complete_s8 {r1:vid, r2:ORDERS_ORDERKEY,
             r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE,
             r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK,
             r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT}
         else if stmt_id == 7
           then
             nd_insert_ORDERS_do_complete_s7 {r1:vid, r2:ORDERS_ORDERKEY,
               r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE,
               r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK,
               r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT}
           else if stmt_id == 6
             then
               nd_insert_ORDERS_do_complete_s6 {r1:vid, r2:ORDERS_ORDERKEY,
                 r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS,
                 r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE,
                 r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK,
                 r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT} else () 
   else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_insert_ORDERS_rcv_fetch : { r1:collection { key:int, value:int
  } @ { Collection }, r2:{ key:int, value:int }, r3:int, r4:int, r5:string,
  r6:real, r7:int, r8:string, r9:string, r10:int, r11:string } = (\b1 ->
  bind b1 as {r1:stmt_map_ids, r2:vid, r3:ORDERS_ORDERKEY, r4:ORDERS_CUSTKEY,
  r5:ORDERS_ORDERSTATUS, r6:ORDERS_TOTALPRICE, r7:ORDERS_ORDERDATE,
  r8:ORDERS_ORDERPRIORITY, r9:ORDERS_CLERK, r10:ORDERS_SHIPPRIORITY,
  r11:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {r1:vid, r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY,
      r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE,
      r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY,
      r10:ORDERS_COMMENT});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 6
   then if map_id == 4
     then (nd_insert_ORDERS_send_push_s6_m_QUERY3_mORDERS1, me)<- {r1:vid,
       r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS,
       r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY,
       r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT}
     else if map_id == 5
       then (nd_insert_ORDERS_send_push_s6_m_QUERY3_mORDERS3, me)<- {r1:vid,
         r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS,
         r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY,
         r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT}
       else if map_id == 6
         then (nd_insert_ORDERS_send_push_s6_m_QUERY3_mORDERS6, me)<- {r1:vid,
           r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS,
           r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY,
           r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 7
     then if map_id == 4
       then (nd_insert_ORDERS_send_push_s7_m_QUERY3_mORDERS1, me)<- {r1:vid,
         r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS,
         r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY,
         r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 9
       then if map_id == 5
         then (nd_insert_ORDERS_send_push_s9_m_QUERY3_mORDERS3, me)<- {r1:vid,
           r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS,
           r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY,
           r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
       else if stmt_id == 10
         then if map_id == 6
           then
             (nd_insert_ORDERS_send_push_s10_m_QUERY3_mORDERS6, me)<- {r1:vid,
             r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS,
             r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE,
             r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY,
             r10:ORDERS_COMMENT}
           else error (print "nd_rcv_fetch: invalid map id")
         else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_insert_ORDERS_send_push_s6_m_QUERY3_mORDERS1 : { r1:{ key:int,
  value:int }, r2:int, r3:int, r4:string, r5:real, r6:int, r7:string,
  r8:string, r9:int, r10:string } = (\b1 -> bind b1 as {r1:vid,
  r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS,
  r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY,
  r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT} in bind
  QUERY3_mORDERS1 as ind QUERY3_mORDERS1_deref in
  ((nd_log_master_write {key:vid, value:6});
   (shuffle_QUERY3_mORDERS1_to_QUERY3 {r1:Some ORDERS_ORDERKEY,
      r2:Some ORDERS_ORDERDATE, r3:Some ORDERS_SHIPPRIORITY,
      r4:frontier_int_int {key:vid, value:QUERY3_mORDERS1_deref.filter ((\b1 ->
           bind b1 as {r1:r1, r2:r2, r3:r3} in r2 == ORDERS_CUSTKEY))},
      r5:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s6_m_QUERY3_mORDERS1, ip)<- {r1:tuples, r2:vid,
   r3:ORDERS_ORDERKEY, r4:ORDERS_CUSTKEY, r5:ORDERS_ORDERSTATUS,
   r6:ORDERS_TOTALPRICE, r7:ORDERS_ORDERDATE, r8:ORDERS_ORDERPRIORITY,
   r9:ORDERS_CLERK, r10:ORDERS_SHIPPRIORITY, r11:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s6_m_QUERY3_mORDERS3 : { r1:{ key:int,
  value:int }, r2:int, r3:int, r4:string, r5:real, r6:int, r7:string,
  r8:string, r9:int, r10:string } = (\b1 -> bind b1 as {r1:vid,
  r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS,
  r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY,
  r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT} in bind
  QUERY3_mORDERS3 as ind QUERY3_mORDERS3_deref in
  ((nd_log_master_write {key:vid, value:6});
   (shuffle_QUERY3_mORDERS3_to_QUERY3_bind_0t0 {r1:Some ORDERS_ORDERKEY,
      r2:Some ORDERS_ORDERDATE, r3:Some ORDERS_SHIPPRIORITY,
      r4:frontier_int_float {key:vid, value:QUERY3_mORDERS3_deref.filter
           ((\b1 -> bind b1 as {r1:r1, r2:r2, r3:r3} in r2 ==
           ORDERS_ORDERKEY))}, r5:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s6_m_QUERY3_mORDERS3, ip)<- {r1:tuples, r2:vid,
   r3:ORDERS_ORDERKEY, r4:ORDERS_CUSTKEY, r5:ORDERS_ORDERSTATUS,
   r6:ORDERS_TOTALPRICE, r7:ORDERS_ORDERDATE, r8:ORDERS_ORDERPRIORITY,
   r9:ORDERS_CLERK, r10:ORDERS_SHIPPRIORITY, r11:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s6_m_QUERY3_mORDERS6 : { r1:{ key:int,
  value:int }, r2:int, r3:int, r4:string, r5:real, r6:int, r7:string,
  r8:string, r9:int, r10:string } = (\b1 -> bind b1 as {r1:vid,
  r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS,
  r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY,
  r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT} in bind
  QUERY3_mORDERS6 as ind QUERY3_mORDERS6_deref in
  ((nd_log_master_write {key:vid, value:6});
   (shuffle_QUERY3_mORDERS6_to_QUERY3_bind_0t0 {r1:Some ORDERS_ORDERKEY,
      r2:Some ORDERS_ORDERDATE, r3:Some ORDERS_SHIPPRIORITY,
      r4:frontier_int_float {key:vid, value:QUERY3_mORDERS6_deref.filter
           ((\b1 -> bind b1 as {r1:r1, r2:r2, r3:r3} in r2 ==
           ORDERS_ORDERKEY))}, r5:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s6_m_QUERY3_mORDERS6, ip)<- {r1:tuples, r2:vid,
   r3:ORDERS_ORDERKEY, r4:ORDERS_CUSTKEY, r5:ORDERS_ORDERSTATUS,
   r6:ORDERS_TOTALPRICE, r7:ORDERS_ORDERDATE, r8:ORDERS_ORDERPRIORITY,
   r9:ORDERS_CLERK, r10:ORDERS_SHIPPRIORITY, r11:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s7_m_QUERY3_mORDERS1 : { r1:{ key:int,
  value:int }, r2:int, r3:int, r4:string, r5:real, r6:int, r7:string,
  r8:string, r9:int, r10:string } = (\b1 -> bind b1 as {r1:vid,
  r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS,
  r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY,
  r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT} in bind
  QUERY3_mORDERS1 as ind QUERY3_mORDERS1_deref in
  ((nd_log_master_write {key:vid, value:7});
   (shuffle_QUERY3_mORDERS1_to_QUERY3_mLINEITEM1 {r1:Some ORDERS_ORDERKEY,
      r2:Some ORDERS_ORDERDATE, r3:Some ORDERS_SHIPPRIORITY,
      r4:frontier_int_int {key:vid, value:QUERY3_mORDERS1_deref.filter ((\b1 ->
           bind b1 as {r1:r1, r2:r2, r3:r3} in r2 == ORDERS_CUSTKEY))},
      r5:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s7_m_QUERY3_mORDERS1, ip)<- {r1:tuples, r2:vid,
   r3:ORDERS_ORDERKEY, r4:ORDERS_CUSTKEY, r5:ORDERS_ORDERSTATUS,
   r6:ORDERS_TOTALPRICE, r7:ORDERS_ORDERDATE, r8:ORDERS_ORDERPRIORITY,
   r9:ORDERS_CLERK, r10:ORDERS_SHIPPRIORITY, r11:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s9_m_QUERY3_mORDERS3 : { r1:{ key:int,
  value:int }, r2:int, r3:int, r4:string, r5:real, r6:int, r7:string,
  r8:string, r9:int, r10:string } = (\b1 -> bind b1 as {r1:vid,
  r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS,
  r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY,
  r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT} in bind
  QUERY3_mORDERS3 as ind QUERY3_mORDERS3_deref in
  ((nd_log_master_write {key:vid, value:9});
   (shuffle_QUERY3_mORDERS3_to_QUERY3_mCUSTOMER2_bind_0t0
      {r1:Some ORDERS_ORDERKEY, r2:Some ORDERS_ORDERDATE,
      r3:Some ORDERS_SHIPPRIORITY, r4:Some ORDERS_CUSTKEY,
      r5:frontier_int_float {key:vid, value:QUERY3_mORDERS3_deref.filter
           ((\b1 -> bind b1 as {r1:r1, r2:r2, r3:r3} in r2 ==
           ORDERS_ORDERKEY))}, r6:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s9_m_QUERY3_mORDERS3, ip)<- {r1:tuples, r2:vid,
   r3:ORDERS_ORDERKEY, r4:ORDERS_CUSTKEY, r5:ORDERS_ORDERSTATUS,
   r6:ORDERS_TOTALPRICE, r7:ORDERS_ORDERDATE, r8:ORDERS_ORDERPRIORITY,
   r9:ORDERS_CLERK, r10:ORDERS_SHIPPRIORITY, r11:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s10_m_QUERY3_mORDERS6 : { r1:{ key:int,
  value:int }, r2:int, r3:int, r4:string, r5:real, r6:int, r7:string,
  r8:string, r9:int, r10:string } = (\b1 -> bind b1 as {r1:vid,
  r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS,
  r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY,
  r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT} in bind
  QUERY3_mORDERS6 as ind QUERY3_mORDERS6_deref in
  ((nd_log_master_write {key:vid, value:10});
   (shuffle_QUERY3_mORDERS6_to_QUERY3_mCUSTOMER4_bind_0t0
      {r1:Some ORDERS_ORDERKEY, r2:Some ORDERS_ORDERDATE,
      r3:Some ORDERS_SHIPPRIORITY, r4:Some ORDERS_CUSTKEY,
      r5:frontier_int_float {key:vid, value:QUERY3_mORDERS6_deref.filter
           ((\b1 -> bind b1 as {r1:r1, r2:r2, r3:r3} in r2 ==
           ORDERS_ORDERKEY))}, r6:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s10_m_QUERY3_mORDERS6, ip)<- {r1:tuples, r2:vid,
   r3:ORDERS_ORDERKEY, r4:ORDERS_CUSTKEY, r5:ORDERS_ORDERSTATUS,
   r6:ORDERS_TOTALPRICE, r7:ORDERS_ORDERDATE, r8:ORDERS_ORDERPRIORITY,
   r9:ORDERS_CLERK, r10:ORDERS_SHIPPRIORITY, r11:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_rcv_push_s6_m_QUERY3_mORDERS1 : { r1:collection { r1:{
  key:int, value:int }, r2:int, r3:int } @ { Set }, r2:{ key:int, value:int },
  r3:int, r4:int, r5:string, r6:real, r7:int, r8:string, r9:string, r10:int,
  r11:string } = (\b1 -> bind b1 as {r1:tuples, r2:vid, r3:ORDERS_ORDERKEY,
  r4:ORDERS_CUSTKEY, r5:ORDERS_ORDERSTATUS, r6:ORDERS_TOTALPRICE,
  r7:ORDERS_ORDERDATE, r8:ORDERS_ORDERPRIORITY, r9:ORDERS_CLERK,
  r10:ORDERS_SHIPPRIORITY, r11:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {r1:vid, r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY,
      r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE,
      r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY,
      r10:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY3_mORDERS1_s6_buf as ind
   map_QUERY3_mORDERS1_s6_buf_d in
   bind tuple as {r1:_tup0, r2:_tup1, r3:_tup2} in
     case ((map_QUERY3_mORDERS1_s6_buf_d.filter ((\b1 -> bind b1 as {r1:r1,
       r2:r2, r3:r3} in r1 == _tup0 and r2 == _tup1))).peek ()) of
       {Some vals -> map_QUERY3_mORDERS1_s6_buf_d.update vals tuple}{None ->
                                                                    map_QUERY3_mORDERS1_s6_buf_d.insert
                                                                    tuple}));
   (if nd_check_stmt_cntr_index {r1:vid, r2:6, r3:-1}
   then
     nd_insert_ORDERS_do_complete_s6 {r1:vid, r2:ORDERS_ORDERKEY,
       r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE,
       r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK,
       r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s6_m_QUERY3_mORDERS3 : { r1:collection { r1:{
  key:int, value:int }, r2:int, r3:real } @ { Set }, r2:{ key:int, value:int },
  r3:int, r4:int, r5:string, r6:real, r7:int, r8:string, r9:string, r10:int,
  r11:string } = (\b1 -> bind b1 as {r1:tuples, r2:vid, r3:ORDERS_ORDERKEY,
  r4:ORDERS_CUSTKEY, r5:ORDERS_ORDERSTATUS, r6:ORDERS_TOTALPRICE,
  r7:ORDERS_ORDERDATE, r8:ORDERS_ORDERPRIORITY, r9:ORDERS_CLERK,
  r10:ORDERS_SHIPPRIORITY, r11:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {r1:vid, r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY,
      r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE,
      r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY,
      r10:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY3_mORDERS3_s6_buf as ind
   map_QUERY3_mORDERS3_s6_buf_d in
   bind tuple as {r1:_tup0, r2:_tup1, r3:_tup2} in
     case ((map_QUERY3_mORDERS3_s6_buf_d.filter ((\b1 -> bind b1 as {r1:r1,
       r2:r2, r3:r3} in r1 == _tup0 and r2 == _tup1))).peek ()) of
       {Some vals -> map_QUERY3_mORDERS3_s6_buf_d.update vals tuple}{None ->
                                                                    map_QUERY3_mORDERS3_s6_buf_d.insert
                                                                    tuple}));
   (if nd_check_stmt_cntr_index {r1:vid, r2:6, r3:-1}
   then
     nd_insert_ORDERS_do_complete_s6 {r1:vid, r2:ORDERS_ORDERKEY,
       r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE,
       r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK,
       r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s6_m_QUERY3_mORDERS6 : { r1:collection { r1:{
  key:int, value:int }, r2:int, r3:real } @ { Set }, r2:{ key:int, value:int },
  r3:int, r4:int, r5:string, r6:real, r7:int, r8:string, r9:string, r10:int,
  r11:string } = (\b1 -> bind b1 as {r1:tuples, r2:vid, r3:ORDERS_ORDERKEY,
  r4:ORDERS_CUSTKEY, r5:ORDERS_ORDERSTATUS, r6:ORDERS_TOTALPRICE,
  r7:ORDERS_ORDERDATE, r8:ORDERS_ORDERPRIORITY, r9:ORDERS_CLERK,
  r10:ORDERS_SHIPPRIORITY, r11:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {r1:vid, r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY,
      r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE,
      r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY,
      r10:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY3_mORDERS6_s6_buf as ind
   map_QUERY3_mORDERS6_s6_buf_d in
   bind tuple as {r1:_tup0, r2:_tup1, r3:_tup2} in
     case ((map_QUERY3_mORDERS6_s6_buf_d.filter ((\b1 -> bind b1 as {r1:r1,
       r2:r2, r3:r3} in r1 == _tup0 and r2 == _tup1))).peek ()) of
       {Some vals -> map_QUERY3_mORDERS6_s6_buf_d.update vals tuple}{None ->
                                                                    map_QUERY3_mORDERS6_s6_buf_d.insert
                                                                    tuple}));
   (if nd_check_stmt_cntr_index {r1:vid, r2:6, r3:-1}
   then
     nd_insert_ORDERS_do_complete_s6 {r1:vid, r2:ORDERS_ORDERKEY,
       r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE,
       r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK,
       r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s7_m_QUERY3_mORDERS1 : { r1:collection { r1:{
  key:int, value:int }, r2:int, r3:int } @ { Set }, r2:{ key:int, value:int },
  r3:int, r4:int, r5:string, r6:real, r7:int, r8:string, r9:string, r10:int,
  r11:string } = (\b1 -> bind b1 as {r1:tuples, r2:vid, r3:ORDERS_ORDERKEY,
  r4:ORDERS_CUSTKEY, r5:ORDERS_ORDERSTATUS, r6:ORDERS_TOTALPRICE,
  r7:ORDERS_ORDERDATE, r8:ORDERS_ORDERPRIORITY, r9:ORDERS_CLERK,
  r10:ORDERS_SHIPPRIORITY, r11:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {r1:vid, r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY,
      r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE,
      r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY,
      r10:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY3_mORDERS1_s7_buf as ind
   map_QUERY3_mORDERS1_s7_buf_d in
   bind tuple as {r1:_tup0, r2:_tup1, r3:_tup2} in
     case ((map_QUERY3_mORDERS1_s7_buf_d.filter ((\b1 -> bind b1 as {r1:r1,
       r2:r2, r3:r3} in r1 == _tup0 and r2 == _tup1))).peek ()) of
       {Some vals -> map_QUERY3_mORDERS1_s7_buf_d.update vals tuple}{None ->
                                                                    map_QUERY3_mORDERS1_s7_buf_d.insert
                                                                    tuple}));
   (if nd_check_stmt_cntr_index {r1:vid, r2:7, r3:-1}
   then
     nd_insert_ORDERS_do_complete_s7 {r1:vid, r2:ORDERS_ORDERKEY,
       r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE,
       r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK,
       r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s9_m_QUERY3_mORDERS3 : { r1:collection { r1:{
  key:int, value:int }, r2:int, r3:real } @ { Set }, r2:{ key:int, value:int },
  r3:int, r4:int, r5:string, r6:real, r7:int, r8:string, r9:string, r10:int,
  r11:string } = (\b1 -> bind b1 as {r1:tuples, r2:vid, r3:ORDERS_ORDERKEY,
  r4:ORDERS_CUSTKEY, r5:ORDERS_ORDERSTATUS, r6:ORDERS_TOTALPRICE,
  r7:ORDERS_ORDERDATE, r8:ORDERS_ORDERPRIORITY, r9:ORDERS_CLERK,
  r10:ORDERS_SHIPPRIORITY, r11:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {r1:vid, r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY,
      r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE,
      r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY,
      r10:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY3_mORDERS3_s9_buf as ind
   map_QUERY3_mORDERS3_s9_buf_d in
   bind tuple as {r1:_tup0, r2:_tup1, r3:_tup2} in
     case ((map_QUERY3_mORDERS3_s9_buf_d.filter ((\b1 -> bind b1 as {r1:r1,
       r2:r2, r3:r3} in r1 == _tup0 and r2 == _tup1))).peek ()) of
       {Some vals -> map_QUERY3_mORDERS3_s9_buf_d.update vals tuple}{None ->
                                                                    map_QUERY3_mORDERS3_s9_buf_d.insert
                                                                    tuple}));
   (if nd_check_stmt_cntr_index {r1:vid, r2:9, r3:-1}
   then
     nd_insert_ORDERS_do_complete_s9 {r1:vid, r2:ORDERS_ORDERKEY,
       r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE,
       r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK,
       r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s10_m_QUERY3_mORDERS6 : { r1:collection {
  r1:{ key:int, value:int }, r2:int, r3:real } @ { Set }, r2:{ key:int,
  value:int }, r3:int, r4:int, r5:string, r6:real, r7:int, r8:string,
  r9:string, r10:int, r11:string } = (\b1 -> bind b1 as {r1:tuples, r2:vid,
  r3:ORDERS_ORDERKEY, r4:ORDERS_CUSTKEY, r5:ORDERS_ORDERSTATUS,
  r6:ORDERS_TOTALPRICE, r7:ORDERS_ORDERDATE, r8:ORDERS_ORDERPRIORITY,
  r9:ORDERS_CLERK, r10:ORDERS_SHIPPRIORITY, r11:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {r1:vid, r2:ORDERS_ORDERKEY, r3:ORDERS_CUSTKEY,
      r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE, r6:ORDERS_ORDERDATE,
      r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK, r9:ORDERS_SHIPPRIORITY,
      r10:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY3_mORDERS6_s10_buf as ind
   map_QUERY3_mORDERS6_s10_buf_d in
   bind tuple as {r1:_tup0, r2:_tup1, r3:_tup2} in
     case ((map_QUERY3_mORDERS6_s10_buf_d.filter ((\b1 -> bind b1 as {r1:r1,
       r2:r2, r3:r3} in r1 == _tup0 and r2 == _tup1))).peek ()) of
       {Some vals -> map_QUERY3_mORDERS6_s10_buf_d.update vals tuple}
       {None -> map_QUERY3_mORDERS6_s10_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {r1:vid, r2:10, r3:-1}
   then
     nd_insert_ORDERS_do_complete_s10 {r1:vid, r2:ORDERS_ORDERKEY,
       r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE,
       r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK,
       r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_do_complete_s8_trig : { r1:{ key:int, value:int },
  r2:int, r3:int, r4:string, r5:real, r6:int, r7:string, r8:string, r9:int,
  r10:string } = (\b1 -> bind b1 as {r1:vid, r2:ORDERS_ORDERKEY,
  r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE,
  r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK,
  r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT} in 
  nd_insert_ORDERS_do_complete_s8 {r1:vid, r2:ORDERS_ORDERKEY,
    r3:ORDERS_CUSTKEY, r4:ORDERS_ORDERSTATUS, r5:ORDERS_TOTALPRICE,
    r6:ORDERS_ORDERDATE, r7:ORDERS_ORDERPRIORITY, r8:ORDERS_CLERK,
    r9:ORDERS_SHIPPRIORITY, r10:ORDERS_COMMENT})
trigger insert_ORDERS_rcv_corrective_s6_m_QUERY3_mORDERS1 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int },
  r6:collection { key:int, value:int } @ { Seq }, r7:collection { key:int,
  value:int } @ { Set } } = (\b1 -> bind b1 as {r1:orig_addr, r2:orig_stmt_id,
  r3:orig_vid, r4:hop, r5:vid, r6:compute_vids, r7:delta_tuples} in 
  ((nd_add_delta_to_int_int {r1:map_QUERY3_mORDERS1_s6_buf, r2:false, r3:vid,
      r4:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:6}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {r1:ORDERS_ORDERKEY, r2:ORDERS_CUSTKEY, r3:ORDERS_ORDERSTATUS, r4:ORDERS_TOTALPRICE, r5:ORDERS_ORDERDATE, r6:ORDERS_ORDERPRIORITY, r7:ORDERS_CLERK, r8:ORDERS_SHIPPRIORITY, r9:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s6_m_QUERY3_mORDERS1 {r1:orig_addr,
             r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:compute_vid,
             r6:ORDERS_ORDERKEY, r7:ORDERS_CUSTKEY, r8:ORDERS_ORDERSTATUS,
             r9:ORDERS_TOTALPRICE, r10:ORDERS_ORDERDATE,
             r11:ORDERS_ORDERPRIORITY, r12:ORDERS_CLERK,
             r13:ORDERS_SHIPPRIORITY, r14:ORDERS_COMMENT, r15:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {r1:orig_vid, r2:orig_stmt_id, r3:hop,
     r4:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s6_m_QUERY3_mORDERS3 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int },
  r6:collection { key:int, value:int } @ { Seq }, r7:collection { key:int,
  value:real } @ { Set } } = (\b1 -> bind b1 as {r1:orig_addr, r2:orig_stmt_id,
  r3:orig_vid, r4:hop, r5:vid, r6:compute_vids, r7:delta_tuples} in 
  ((nd_add_delta_to_int_float {r1:map_QUERY3_mORDERS3_s6_buf, r2:false, r3:vid,
      r4:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:6}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {r1:ORDERS_ORDERKEY, r2:ORDERS_CUSTKEY, r3:ORDERS_ORDERSTATUS, r4:ORDERS_TOTALPRICE, r5:ORDERS_ORDERDATE, r6:ORDERS_ORDERPRIORITY, r7:ORDERS_CLERK, r8:ORDERS_SHIPPRIORITY, r9:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s6_m_QUERY3_mORDERS3 {r1:orig_addr,
             r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:compute_vid,
             r6:ORDERS_ORDERKEY, r7:ORDERS_CUSTKEY, r8:ORDERS_ORDERSTATUS,
             r9:ORDERS_TOTALPRICE, r10:ORDERS_ORDERDATE,
             r11:ORDERS_ORDERPRIORITY, r12:ORDERS_CLERK,
             r13:ORDERS_SHIPPRIORITY, r14:ORDERS_COMMENT, r15:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {r1:orig_vid, r2:orig_stmt_id, r3:hop,
     r4:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s6_m_QUERY3_mORDERS6 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int },
  r6:collection { key:int, value:int } @ { Seq }, r7:collection { key:int,
  value:real } @ { Set } } = (\b1 -> bind b1 as {r1:orig_addr, r2:orig_stmt_id,
  r3:orig_vid, r4:hop, r5:vid, r6:compute_vids, r7:delta_tuples} in 
  ((nd_add_delta_to_int_float {r1:map_QUERY3_mORDERS6_s6_buf, r2:false, r3:vid,
      r4:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:6}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {r1:ORDERS_ORDERKEY, r2:ORDERS_CUSTKEY, r3:ORDERS_ORDERSTATUS, r4:ORDERS_TOTALPRICE, r5:ORDERS_ORDERDATE, r6:ORDERS_ORDERPRIORITY, r7:ORDERS_CLERK, r8:ORDERS_SHIPPRIORITY, r9:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s6_m_QUERY3_mORDERS6 {r1:orig_addr,
             r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:compute_vid,
             r6:ORDERS_ORDERKEY, r7:ORDERS_CUSTKEY, r8:ORDERS_ORDERSTATUS,
             r9:ORDERS_TOTALPRICE, r10:ORDERS_ORDERDATE,
             r11:ORDERS_ORDERPRIORITY, r12:ORDERS_CLERK,
             r13:ORDERS_SHIPPRIORITY, r14:ORDERS_COMMENT, r15:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {r1:orig_vid, r2:orig_stmt_id, r3:hop,
     r4:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s7_m_QUERY3_mORDERS1 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int },
  r6:collection { key:int, value:int } @ { Seq }, r7:collection { key:int,
  value:int } @ { Set } } = (\b1 -> bind b1 as {r1:orig_addr, r2:orig_stmt_id,
  r3:orig_vid, r4:hop, r5:vid, r6:compute_vids, r7:delta_tuples} in 
  ((nd_add_delta_to_int_int {r1:map_QUERY3_mORDERS1_s7_buf, r2:false, r3:vid,
      r4:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:7}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {r1:ORDERS_ORDERKEY, r2:ORDERS_CUSTKEY, r3:ORDERS_ORDERSTATUS, r4:ORDERS_TOTALPRICE, r5:ORDERS_ORDERDATE, r6:ORDERS_ORDERPRIORITY, r7:ORDERS_CLERK, r8:ORDERS_SHIPPRIORITY, r9:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s7_m_QUERY3_mORDERS1 {r1:orig_addr,
             r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:compute_vid,
             r6:ORDERS_ORDERKEY, r7:ORDERS_CUSTKEY, r8:ORDERS_ORDERSTATUS,
             r9:ORDERS_TOTALPRICE, r10:ORDERS_ORDERDATE,
             r11:ORDERS_ORDERPRIORITY, r12:ORDERS_CLERK,
             r13:ORDERS_SHIPPRIORITY, r14:ORDERS_COMMENT, r15:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {r1:orig_vid, r2:orig_stmt_id, r3:hop,
     r4:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s9_m_QUERY3_mORDERS3 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int },
  r6:collection { key:int, value:int } @ { Seq }, r7:collection { key:int,
  value:real } @ { Set } } = (\b1 -> bind b1 as {r1:orig_addr, r2:orig_stmt_id,
  r3:orig_vid, r4:hop, r5:vid, r6:compute_vids, r7:delta_tuples} in 
  ((nd_add_delta_to_int_float {r1:map_QUERY3_mORDERS3_s9_buf, r2:false, r3:vid,
      r4:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:9}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {r1:ORDERS_ORDERKEY, r2:ORDERS_CUSTKEY, r3:ORDERS_ORDERSTATUS, r4:ORDERS_TOTALPRICE, r5:ORDERS_ORDERDATE, r6:ORDERS_ORDERPRIORITY, r7:ORDERS_CLERK, r8:ORDERS_SHIPPRIORITY, r9:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s9_m_QUERY3_mORDERS3 {r1:orig_addr,
             r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:compute_vid,
             r6:ORDERS_ORDERKEY, r7:ORDERS_CUSTKEY, r8:ORDERS_ORDERSTATUS,
             r9:ORDERS_TOTALPRICE, r10:ORDERS_ORDERDATE,
             r11:ORDERS_ORDERPRIORITY, r12:ORDERS_CLERK,
             r13:ORDERS_SHIPPRIORITY, r14:ORDERS_COMMENT, r15:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {r1:orig_vid, r2:orig_stmt_id, r3:hop,
     r4:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s10_m_QUERY3_mORDERS6 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int },
  r6:collection { key:int, value:int } @ { Seq }, r7:collection { key:int,
  value:real } @ { Set } } = (\b1 -> bind b1 as {r1:orig_addr, r2:orig_stmt_id,
  r3:orig_vid, r4:hop, r5:vid, r6:compute_vids, r7:delta_tuples} in 
  ((nd_add_delta_to_int_float {r1:map_QUERY3_mORDERS6_s10_buf, r2:false,
      r3:vid, r4:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:10}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {r1:ORDERS_ORDERKEY, r2:ORDERS_CUSTKEY, r3:ORDERS_ORDERSTATUS, r4:ORDERS_TOTALPRICE, r5:ORDERS_ORDERDATE, r6:ORDERS_ORDERPRIORITY, r7:ORDERS_CLERK, r8:ORDERS_SHIPPRIORITY, r9:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s10_m_QUERY3_mORDERS6 {r1:orig_addr,
             r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:compute_vid,
             r6:ORDERS_ORDERKEY, r7:ORDERS_CUSTKEY, r8:ORDERS_ORDERSTATUS,
             r9:ORDERS_TOTALPRICE, r10:ORDERS_ORDERDATE,
             r11:ORDERS_ORDERPRIORITY, r12:ORDERS_CLERK,
             r13:ORDERS_SHIPPRIORITY, r14:ORDERS_COMMENT, r15:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {r1:orig_vid, r2:orig_stmt_id, r3:hop,
     r4:sent_msgs}))
trigger nd_insert_LINEITEM_rcv_put : { r1:address, r2:collection { key:int,
  value:int } @ { Collection }, r3:{ key:int, value:int }, r4:int, r5:int,
  r6:int, r7:int, r8:real, r9:real, r10:real, r11:real, r12:string, r13:string,
  r14:int, r15:int, r16:int, r17:string, r18:string, r19:string } = (\b1 ->
  bind b1 as {r1:sender_ip, r2:stmt_cnt_list, r3:vid, r4:LINEITEM_ORDERKEY,
  r5:LINEITEM_PARTKEY, r6:LINEITEM_SUPPKEY, r7:LINEITEM_LINENUMBER,
  r8:LINEITEM_QUANTITY, r9:LINEITEM_EXTENDEDPRICE, r10:LINEITEM_DISCOUNT,
  r11:LINEITEM_TAX, r12:LINEITEM_RETURNFLAG, r13:LINEITEM_LINESTATUS,
  r14:LINEITEM_SHIPDATE, r15:LINEITEM_COMMITDATE, r16:LINEITEM_RECEIPTDATE,
  r17:LINEITEM_SHIPINSTRUCT, r18:LINEITEM_SHIPMODE, r19:LINEITEM_COMMENT} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {r1:vid, r2:stmt_id, r3:count}
   then if stmt_id == 20
     then
       nd_insert_LINEITEM_do_complete_s20 {r1:vid, r2:LINEITEM_ORDERKEY,
         r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
         r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
         r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
         r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE,
         r14:LINEITEM_RECEIPTDATE, r15:LINEITEM_SHIPINSTRUCT,
         r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT}
     else if stmt_id == 19
       then
         nd_insert_LINEITEM_do_complete_s19 {r1:vid, r2:LINEITEM_ORDERKEY,
           r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
           r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE,
           r8:LINEITEM_DISCOUNT, r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG,
           r11:LINEITEM_LINESTATUS, r12:LINEITEM_SHIPDATE,
           r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
           r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE,
           r17:LINEITEM_COMMENT}
       else if stmt_id == 18
         then
           nd_insert_LINEITEM_do_complete_s18 {r1:vid, r2:LINEITEM_ORDERKEY,
             r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
             r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE,
             r8:LINEITEM_DISCOUNT, r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG,
             r11:LINEITEM_LINESTATUS, r12:LINEITEM_SHIPDATE,
             r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
             r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE,
             r17:LINEITEM_COMMENT}
         else if stmt_id == 17
           then
             nd_insert_LINEITEM_do_complete_s17 {r1:vid, r2:LINEITEM_ORDERKEY,
               r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY,
               r5:LINEITEM_LINENUMBER, r6:LINEITEM_QUANTITY,
               r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
               r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG,
               r11:LINEITEM_LINESTATUS, r12:LINEITEM_SHIPDATE,
               r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
               r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE,
               r17:LINEITEM_COMMENT}
           else if stmt_id == 16
             then
               nd_insert_LINEITEM_do_complete_s16 {r1:vid,
                 r2:LINEITEM_ORDERKEY, r3:LINEITEM_PARTKEY,
                 r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
                 r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE,
                 r8:LINEITEM_DISCOUNT, r9:LINEITEM_TAX,
                 r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
                 r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE,
                 r14:LINEITEM_RECEIPTDATE, r15:LINEITEM_SHIPINSTRUCT,
                 r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT} else () 
   else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_insert_LINEITEM_rcv_fetch : { r1:collection { key:int, value:int
  } @ { Collection }, r2:{ key:int, value:int }, r3:int, r4:int, r5:int,
  r6:int, r7:real, r8:real, r9:real, r10:real, r11:string, r12:string, r13:int,
  r14:int, r15:int, r16:string, r17:string, r18:string } = (\b1 ->
  bind b1 as {r1:stmt_map_ids, r2:vid, r3:LINEITEM_ORDERKEY,
  r4:LINEITEM_PARTKEY, r5:LINEITEM_SUPPKEY, r6:LINEITEM_LINENUMBER,
  r7:LINEITEM_QUANTITY, r8:LINEITEM_EXTENDEDPRICE, r9:LINEITEM_DISCOUNT,
  r10:LINEITEM_TAX, r11:LINEITEM_RETURNFLAG, r12:LINEITEM_LINESTATUS,
  r13:LINEITEM_SHIPDATE, r14:LINEITEM_COMMITDATE, r15:LINEITEM_RECEIPTDATE,
  r16:LINEITEM_SHIPINSTRUCT, r17:LINEITEM_SHIPMODE, r18:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {r1:vid, r2:LINEITEM_ORDERKEY,
      r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
      r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
      r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
      r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
      r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 16
   then if map_id == 2
     then (nd_insert_LINEITEM_send_push_s16_m_QUERY3_mLINEITEM1, me)<- {r1:vid,
       r2:LINEITEM_ORDERKEY, r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY,
       r5:LINEITEM_LINENUMBER, r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE,
       r8:LINEITEM_DISCOUNT, r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG,
       r11:LINEITEM_LINESTATUS, r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE,
       r14:LINEITEM_RECEIPTDATE, r15:LINEITEM_SHIPINSTRUCT,
       r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT}
     else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 19
     then if map_id == 3
       then
         (nd_insert_LINEITEM_send_push_s19_m_QUERY3_mLINEITEM1_mCUSTOMER2, me)<- {r1:vid,
         r2:LINEITEM_ORDERKEY, r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY,
         r5:LINEITEM_LINENUMBER, r6:LINEITEM_QUANTITY,
         r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT, r9:LINEITEM_TAX,
         r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
         r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE,
         r14:LINEITEM_RECEIPTDATE, r15:LINEITEM_SHIPINSTRUCT,
         r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 20
       then if map_id == 3
         then
           (nd_insert_LINEITEM_send_push_s20_m_QUERY3_mLINEITEM1_mCUSTOMER2,
             me)<- {r1:vid, r2:LINEITEM_ORDERKEY, r3:LINEITEM_PARTKEY,
           r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER, r6:LINEITEM_QUANTITY,
           r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT, r9:LINEITEM_TAX,
           r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
           r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE,
           r14:LINEITEM_RECEIPTDATE, r15:LINEITEM_SHIPINSTRUCT,
           r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
       else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_insert_LINEITEM_send_push_s16_m_QUERY3_mLINEITEM1 : { r1:{ key:int,
  value:int }, r2:int, r3:int, r4:int, r5:int, r6:real, r7:real, r8:real,
  r9:real, r10:string, r11:string, r12:int, r13:int, r14:int, r15:string,
  r16:string, r17:string } = (\b1 -> bind b1 as {r1:vid, r2:LINEITEM_ORDERKEY,
  r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
  r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
  r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
  r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
  r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT} in 
  bind QUERY3_mLINEITEM1 as ind QUERY3_mLINEITEM1_deref in
  ((nd_log_master_write {key:vid, value:16});
   (shuffle_QUERY3_mLINEITEM1_to_QUERY3_bind_0t0_1t1_2t2
      {r1:Some LINEITEM_ORDERKEY, r2:None immut, r3:None immut,
      r4:frontier_int_date_int_int {key:vid,
           value:QUERY3_mLINEITEM1_deref.filter ((\b1 -> bind b1 as {r1:r1,
           r2:r2, r3:r3, r4:r4, r5:r5} in r2 == LINEITEM_ORDERKEY))}, r5:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s16_m_QUERY3_mLINEITEM1, ip)<- {r1:tuples,
   r2:vid, r3:LINEITEM_ORDERKEY, r4:LINEITEM_PARTKEY, r5:LINEITEM_SUPPKEY,
   r6:LINEITEM_LINENUMBER, r7:LINEITEM_QUANTITY, r8:LINEITEM_EXTENDEDPRICE,
   r9:LINEITEM_DISCOUNT, r10:LINEITEM_TAX, r11:LINEITEM_RETURNFLAG,
   r12:LINEITEM_LINESTATUS, r13:LINEITEM_SHIPDATE, r14:LINEITEM_COMMITDATE,
   r15:LINEITEM_RECEIPTDATE, r16:LINEITEM_SHIPINSTRUCT, r17:LINEITEM_SHIPMODE,
   r18:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s19_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
  r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:real, r7:real,
  r8:real, r9:real, r10:string, r11:string, r12:int, r13:int, r14:int,
  r15:string, r16:string, r17:string } = (\b1 -> bind b1 as {r1:vid,
  r2:LINEITEM_ORDERKEY, r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY,
  r5:LINEITEM_LINENUMBER, r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE,
  r8:LINEITEM_DISCOUNT, r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG,
  r11:LINEITEM_LINESTATUS, r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE,
  r14:LINEITEM_RECEIPTDATE, r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE,
  r17:LINEITEM_COMMENT} in bind QUERY3_mLINEITEM1_mCUSTOMER2 as ind
  QUERY3_mLINEITEM1_mCUSTOMER2_deref in
  ((nd_log_master_write {key:vid, value:19});
   (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_to_QUERY3_mCUSTOMER2_bind_0t0_1t1_2t2_3t3
      {r1:Some LINEITEM_ORDERKEY, r2:None immut, r3:None immut, r4:None immut,
      r5:frontier_int_date_int_int_int {key:vid,
           value:QUERY3_mLINEITEM1_mCUSTOMER2_deref.filter ((\b1 ->
           bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4, r5:r5, r6:r6} in r2 ==
           LINEITEM_ORDERKEY))}, r6:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s19_m_QUERY3_mLINEITEM1_mCUSTOMER2, ip)<- {r1:tuples,
   r2:vid, r3:LINEITEM_ORDERKEY, r4:LINEITEM_PARTKEY, r5:LINEITEM_SUPPKEY,
   r6:LINEITEM_LINENUMBER, r7:LINEITEM_QUANTITY, r8:LINEITEM_EXTENDEDPRICE,
   r9:LINEITEM_DISCOUNT, r10:LINEITEM_TAX, r11:LINEITEM_RETURNFLAG,
   r12:LINEITEM_LINESTATUS, r13:LINEITEM_SHIPDATE, r14:LINEITEM_COMMITDATE,
   r15:LINEITEM_RECEIPTDATE, r16:LINEITEM_SHIPINSTRUCT, r17:LINEITEM_SHIPMODE,
   r18:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s20_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
  r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int, r6:real, r7:real,
  r8:real, r9:real, r10:string, r11:string, r12:int, r13:int, r14:int,
  r15:string, r16:string, r17:string } = (\b1 -> bind b1 as {r1:vid,
  r2:LINEITEM_ORDERKEY, r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY,
  r5:LINEITEM_LINENUMBER, r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE,
  r8:LINEITEM_DISCOUNT, r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG,
  r11:LINEITEM_LINESTATUS, r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE,
  r14:LINEITEM_RECEIPTDATE, r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE,
  r17:LINEITEM_COMMENT} in bind QUERY3_mLINEITEM1_mCUSTOMER2 as ind
  QUERY3_mLINEITEM1_mCUSTOMER2_deref in
  ((nd_log_master_write {key:vid, value:20});
   (shuffle_QUERY3_mLINEITEM1_mCUSTOMER2_to_QUERY3_mCUSTOMER4_bind_0t0_1t1_2t2_3t3
      {r1:Some LINEITEM_ORDERKEY, r2:None immut, r3:None immut, r4:None immut,
      r5:frontier_int_date_int_int_int {key:vid,
           value:QUERY3_mLINEITEM1_mCUSTOMER2_deref.filter ((\b1 ->
           bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4, r5:r5, r6:r6} in r2 ==
           LINEITEM_ORDERKEY))}, r6:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s20_m_QUERY3_mLINEITEM1_mCUSTOMER2, ip)<- {r1:tuples,
   r2:vid, r3:LINEITEM_ORDERKEY, r4:LINEITEM_PARTKEY, r5:LINEITEM_SUPPKEY,
   r6:LINEITEM_LINENUMBER, r7:LINEITEM_QUANTITY, r8:LINEITEM_EXTENDEDPRICE,
   r9:LINEITEM_DISCOUNT, r10:LINEITEM_TAX, r11:LINEITEM_RETURNFLAG,
   r12:LINEITEM_LINESTATUS, r13:LINEITEM_SHIPDATE, r14:LINEITEM_COMMITDATE,
   r15:LINEITEM_RECEIPTDATE, r16:LINEITEM_SHIPINSTRUCT, r17:LINEITEM_SHIPMODE,
   r18:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_rcv_push_s16_m_QUERY3_mLINEITEM1 : { r1:collection {
  r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int } @ { Set }, r2:{
  key:int, value:int }, r3:int, r4:int, r5:int, r6:int, r7:real, r8:real,
  r9:real, r10:real, r11:string, r12:string, r13:int, r14:int, r15:int,
  r16:string, r17:string, r18:string } = (\b1 -> bind b1 as {r1:tuples, r2:vid,
  r3:LINEITEM_ORDERKEY, r4:LINEITEM_PARTKEY, r5:LINEITEM_SUPPKEY,
  r6:LINEITEM_LINENUMBER, r7:LINEITEM_QUANTITY, r8:LINEITEM_EXTENDEDPRICE,
  r9:LINEITEM_DISCOUNT, r10:LINEITEM_TAX, r11:LINEITEM_RETURNFLAG,
  r12:LINEITEM_LINESTATUS, r13:LINEITEM_SHIPDATE, r14:LINEITEM_COMMITDATE,
  r15:LINEITEM_RECEIPTDATE, r16:LINEITEM_SHIPINSTRUCT, r17:LINEITEM_SHIPMODE,
  r18:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {r1:vid, r2:LINEITEM_ORDERKEY,
      r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
      r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
      r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
      r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
      r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY3_mLINEITEM1_s16_buf as ind
   map_QUERY3_mLINEITEM1_s16_buf_d in
   bind tuple as {r1:_tup0, r2:_tup1, r3:_tup2, r4:_tup3, r5:_tup4} in
     case ((map_QUERY3_mLINEITEM1_s16_buf_d.filter ((\b1 -> bind b1 as {r1:r1,
       r2:r2, r3:r3, r4:r4, r5:r5} in ((r1 == _tup0 and r4 == _tup3) and r3 ==
       _tup2) and r2 == _tup1))).peek ()) of
       {Some vals -> map_QUERY3_mLINEITEM1_s16_buf_d.update vals tuple}
       {None -> map_QUERY3_mLINEITEM1_s16_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {r1:vid, r2:16, r3:-1}
   then
     nd_insert_LINEITEM_do_complete_s16 {r1:vid, r2:LINEITEM_ORDERKEY,
       r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
       r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
       r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
       r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE,
       r14:LINEITEM_RECEIPTDATE, r15:LINEITEM_SHIPINSTRUCT,
       r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT} else ())))
trigger nd_insert_LINEITEM_rcv_push_s19_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
  r1:collection { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int,
  r6:int } @ { Set }, r2:{ key:int, value:int }, r3:int, r4:int, r5:int,
  r6:int, r7:real, r8:real, r9:real, r10:real, r11:string, r12:string, r13:int,
  r14:int, r15:int, r16:string, r17:string, r18:string } = (\b1 ->
  bind b1 as {r1:tuples, r2:vid, r3:LINEITEM_ORDERKEY, r4:LINEITEM_PARTKEY,
  r5:LINEITEM_SUPPKEY, r6:LINEITEM_LINENUMBER, r7:LINEITEM_QUANTITY,
  r8:LINEITEM_EXTENDEDPRICE, r9:LINEITEM_DISCOUNT, r10:LINEITEM_TAX,
  r11:LINEITEM_RETURNFLAG, r12:LINEITEM_LINESTATUS, r13:LINEITEM_SHIPDATE,
  r14:LINEITEM_COMMITDATE, r15:LINEITEM_RECEIPTDATE, r16:LINEITEM_SHIPINSTRUCT,
  r17:LINEITEM_SHIPMODE, r18:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {r1:vid, r2:LINEITEM_ORDERKEY,
      r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
      r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
      r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
      r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
      r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf as
   ind map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf_d in
   bind tuple as {r1:_tup0, r2:_tup1, r3:_tup2, r4:_tup3, r5:_tup4, r6:_tup5}
     in
     case ((map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf_d.filter ((\b1 ->
       bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4, r5:r5, r6:r6} in (((r1 == _tup0
       and r5 == _tup4) and r4 == _tup3) and r3 == _tup2) and r2 ==
       _tup1))).peek ()) of
       {Some vals -> map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf_d.update vals
         tuple}{None -> map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {r1:vid, r2:19, r3:-1}
   then
     nd_insert_LINEITEM_do_complete_s19 {r1:vid, r2:LINEITEM_ORDERKEY,
       r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
       r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
       r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
       r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE,
       r14:LINEITEM_RECEIPTDATE, r15:LINEITEM_SHIPINSTRUCT,
       r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT} else ())))
trigger nd_insert_LINEITEM_rcv_push_s20_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
  r1:collection { r1:{ key:int, value:int }, r2:int, r3:int, r4:int, r5:int,
  r6:int } @ { Set }, r2:{ key:int, value:int }, r3:int, r4:int, r5:int,
  r6:int, r7:real, r8:real, r9:real, r10:real, r11:string, r12:string, r13:int,
  r14:int, r15:int, r16:string, r17:string, r18:string } = (\b1 ->
  bind b1 as {r1:tuples, r2:vid, r3:LINEITEM_ORDERKEY, r4:LINEITEM_PARTKEY,
  r5:LINEITEM_SUPPKEY, r6:LINEITEM_LINENUMBER, r7:LINEITEM_QUANTITY,
  r8:LINEITEM_EXTENDEDPRICE, r9:LINEITEM_DISCOUNT, r10:LINEITEM_TAX,
  r11:LINEITEM_RETURNFLAG, r12:LINEITEM_LINESTATUS, r13:LINEITEM_SHIPDATE,
  r14:LINEITEM_COMMITDATE, r15:LINEITEM_RECEIPTDATE, r16:LINEITEM_SHIPINSTRUCT,
  r17:LINEITEM_SHIPMODE, r18:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {r1:vid, r2:LINEITEM_ORDERKEY,
      r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
      r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
      r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
      r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
      r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf as
   ind map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf_d in
   bind tuple as {r1:_tup0, r2:_tup1, r3:_tup2, r4:_tup3, r5:_tup4, r6:_tup5}
     in
     case ((map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf_d.filter ((\b1 ->
       bind b1 as {r1:r1, r2:r2, r3:r3, r4:r4, r5:r5, r6:r6} in (((r1 == _tup0
       and r5 == _tup4) and r4 == _tup3) and r3 == _tup2) and r2 ==
       _tup1))).peek ()) of
       {Some vals -> map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf_d.update vals
         tuple}{None -> map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {r1:vid, r2:20, r3:-1}
   then
     nd_insert_LINEITEM_do_complete_s20 {r1:vid, r2:LINEITEM_ORDERKEY,
       r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
       r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
       r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
       r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE,
       r14:LINEITEM_RECEIPTDATE, r15:LINEITEM_SHIPINSTRUCT,
       r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT} else ())))
trigger nd_insert_LINEITEM_do_complete_s17_trig : { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:int, r6:real, r7:real, r8:real, r9:real,
  r10:string, r11:string, r12:int, r13:int, r14:int, r15:string, r16:string,
  r17:string } = (\b1 -> bind b1 as {r1:vid, r2:LINEITEM_ORDERKEY,
  r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
  r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
  r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
  r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
  r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT} in 
  nd_insert_LINEITEM_do_complete_s17 {r1:vid, r2:LINEITEM_ORDERKEY,
    r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
    r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
    r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
    r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
    r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT})
trigger nd_insert_LINEITEM_do_complete_s18_trig : { r1:{ key:int, value:int },
  r2:int, r3:int, r4:int, r5:int, r6:real, r7:real, r8:real, r9:real,
  r10:string, r11:string, r12:int, r13:int, r14:int, r15:string, r16:string,
  r17:string } = (\b1 -> bind b1 as {r1:vid, r2:LINEITEM_ORDERKEY,
  r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
  r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
  r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
  r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
  r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT} in 
  nd_insert_LINEITEM_do_complete_s18 {r1:vid, r2:LINEITEM_ORDERKEY,
    r3:LINEITEM_PARTKEY, r4:LINEITEM_SUPPKEY, r5:LINEITEM_LINENUMBER,
    r6:LINEITEM_QUANTITY, r7:LINEITEM_EXTENDEDPRICE, r8:LINEITEM_DISCOUNT,
    r9:LINEITEM_TAX, r10:LINEITEM_RETURNFLAG, r11:LINEITEM_LINESTATUS,
    r12:LINEITEM_SHIPDATE, r13:LINEITEM_COMMITDATE, r14:LINEITEM_RECEIPTDATE,
    r15:LINEITEM_SHIPINSTRUCT, r16:LINEITEM_SHIPMODE, r17:LINEITEM_COMMENT})
trigger insert_LINEITEM_rcv_corrective_s16_m_QUERY3_mLINEITEM1 : { r1:address,
  r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int, value:int },
  r6:collection { key:int, value:int } @ { Seq }, r7:collection { r1:int,
  r2:int, r3:int, r4:int } @ { Set } } = (\b1 -> bind b1 as {r1:orig_addr,
  r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:vid, r6:compute_vids,
  r7:delta_tuples} in 
  ((nd_add_delta_to_int_date_int_int {r1:map_QUERY3_mLINEITEM1_s16_buf,
      r2:false, r3:vid, r4:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:16}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {r1:LINEITEM_ORDERKEY, r2:LINEITEM_PARTKEY, r3:LINEITEM_SUPPKEY, r4:LINEITEM_LINENUMBER, r5:LINEITEM_QUANTITY, r6:LINEITEM_EXTENDEDPRICE, r7:LINEITEM_DISCOUNT, r8:LINEITEM_TAX, r9:LINEITEM_RETURNFLAG, r10:LINEITEM_LINESTATUS, r11:LINEITEM_SHIPDATE, r12:LINEITEM_COMMITDATE, r13:LINEITEM_RECEIPTDATE, r14:LINEITEM_SHIPINSTRUCT, r15:LINEITEM_SHIPMODE, r16:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s16_m_QUERY3_mLINEITEM1 {r1:orig_addr,
             r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:compute_vid,
             r6:LINEITEM_ORDERKEY, r7:LINEITEM_PARTKEY, r8:LINEITEM_SUPPKEY,
             r9:LINEITEM_LINENUMBER, r10:LINEITEM_QUANTITY,
             r11:LINEITEM_EXTENDEDPRICE, r12:LINEITEM_DISCOUNT,
             r13:LINEITEM_TAX, r14:LINEITEM_RETURNFLAG,
             r15:LINEITEM_LINESTATUS, r16:LINEITEM_SHIPDATE,
             r17:LINEITEM_COMMITDATE, r18:LINEITEM_RECEIPTDATE,
             r19:LINEITEM_SHIPINSTRUCT, r20:LINEITEM_SHIPMODE,
             r21:LINEITEM_COMMENT, r22:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {r1:orig_vid, r2:orig_stmt_id, r3:hop,
     r4:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s19_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
  r1:address, r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int,
  value:int }, r6:collection { key:int, value:int } @ { Seq }, r7:collection {
  r1:int, r2:int, r3:int, r4:int, r5:int } @ { Set } } = (\b1 ->
  bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:vid,
  r6:compute_vids, r7:delta_tuples} in 
  ((nd_add_delta_to_int_date_int_int_int
      {r1:map_QUERY3_mLINEITEM1_mCUSTOMER2_s19_buf, r2:false, r3:vid,
      r4:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:19}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {r1:LINEITEM_ORDERKEY, r2:LINEITEM_PARTKEY, r3:LINEITEM_SUPPKEY, r4:LINEITEM_LINENUMBER, r5:LINEITEM_QUANTITY, r6:LINEITEM_EXTENDEDPRICE, r7:LINEITEM_DISCOUNT, r8:LINEITEM_TAX, r9:LINEITEM_RETURNFLAG, r10:LINEITEM_LINESTATUS, r11:LINEITEM_SHIPDATE, r12:LINEITEM_COMMITDATE, r13:LINEITEM_RECEIPTDATE, r14:LINEITEM_SHIPINSTRUCT, r15:LINEITEM_SHIPMODE, r16:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s19_m_QUERY3_mLINEITEM1_mCUSTOMER2
             {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop,
             r5:compute_vid, r6:LINEITEM_ORDERKEY, r7:LINEITEM_PARTKEY,
             r8:LINEITEM_SUPPKEY, r9:LINEITEM_LINENUMBER,
             r10:LINEITEM_QUANTITY, r11:LINEITEM_EXTENDEDPRICE,
             r12:LINEITEM_DISCOUNT, r13:LINEITEM_TAX, r14:LINEITEM_RETURNFLAG,
             r15:LINEITEM_LINESTATUS, r16:LINEITEM_SHIPDATE,
             r17:LINEITEM_COMMITDATE, r18:LINEITEM_RECEIPTDATE,
             r19:LINEITEM_SHIPINSTRUCT, r20:LINEITEM_SHIPMODE,
             r21:LINEITEM_COMMENT, r22:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {r1:orig_vid, r2:orig_stmt_id, r3:hop,
     r4:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s20_m_QUERY3_mLINEITEM1_mCUSTOMER2 : {
  r1:address, r2:int, r3:{ key:int, value:int }, r4:int, r5:{ key:int,
  value:int }, r6:collection { key:int, value:int } @ { Seq }, r7:collection {
  r1:int, r2:int, r3:int, r4:int, r5:int } @ { Set } } = (\b1 ->
  bind b1 as {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop, r5:vid,
  r6:compute_vids, r7:delta_tuples} in 
  ((nd_add_delta_to_int_date_int_int_int
      {r1:map_QUERY3_mLINEITEM1_mCUSTOMER2_s20_buf, r2:false, r3:vid,
      r4:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:20}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {r1:LINEITEM_ORDERKEY, r2:LINEITEM_PARTKEY, r3:LINEITEM_SUPPKEY, r4:LINEITEM_LINENUMBER, r5:LINEITEM_QUANTITY, r6:LINEITEM_EXTENDEDPRICE, r7:LINEITEM_DISCOUNT, r8:LINEITEM_TAX, r9:LINEITEM_RETURNFLAG, r10:LINEITEM_LINESTATUS, r11:LINEITEM_SHIPDATE, r12:LINEITEM_COMMITDATE, r13:LINEITEM_RECEIPTDATE, r14:LINEITEM_SHIPINSTRUCT, r15:LINEITEM_SHIPMODE, r16:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s20_m_QUERY3_mLINEITEM1_mCUSTOMER2
             {r1:orig_addr, r2:orig_stmt_id, r3:orig_vid, r4:hop,
             r5:compute_vid, r6:LINEITEM_ORDERKEY, r7:LINEITEM_PARTKEY,
             r8:LINEITEM_SUPPKEY, r9:LINEITEM_LINENUMBER,
             r10:LINEITEM_QUANTITY, r11:LINEITEM_EXTENDEDPRICE,
             r12:LINEITEM_DISCOUNT, r13:LINEITEM_TAX, r14:LINEITEM_RETURNFLAG,
             r15:LINEITEM_LINESTATUS, r16:LINEITEM_SHIPDATE,
             r17:LINEITEM_COMMITDATE, r18:LINEITEM_RECEIPTDATE,
             r19:LINEITEM_SHIPINSTRUCT, r20:LINEITEM_SHIPMODE,
             r21:LINEITEM_COMMENT, r22:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {r1:orig_vid, r2:orig_stmt_id, r3:hop,
     r4:sent_msgs}))


source master : () = value(())feed master |> ms_send_addr_self


source switch : { r1:int, r2:int, r3:string, r4:string, r5:int, r6:string,
r7:real, r8:string, r9:string, r10:int, r11:int, r12:int, r13:int, r14:real,
r15:real, r16:real, r17:real, r18:string, r19:string, r20:int, r21:int,
r22:int, r23:string, r24:string, r25:string, r26:int, r27:int, r28:string,
r29:real, r30:int, r31:string, r32:string, r33:int, r34:string
} = file "/Users/yotambarnoy/source/k3/k3/temp/tpch3.csv" psv
feed switch |> sw_demux








