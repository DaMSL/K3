include "Core/Builtins.k3"
include "Annotation/Map.k3"
include "Annotation/Set.k3"
include "Annotation/Seq.k3"
declare my_peers : collection { i:address } @ {Collection} =
  peers.fold (\acc -> (\x -> (acc.insert {i:x.addr}; acc))) empty { i:address} @ Collection
declare switch_path : string = "agenda.csv"


declare nd_sent_done : mut bool = false


declare sw_sent_done : mut bool = false


declare ms_rcv_sw_init_ack_cnt : mut int = 0


declare ms_rcv_jobs_ack_cnt : mut int = 0


declare ms_rcv_job_cnt : mut int = 0


declare ms_rcv_node_done_cnt : mut int = 0


declare ms_rcv_switch_done_cnt : mut int = 0


declare g_init_vid : { key:int, value:int } = {key:0, value:0}


declare g_min_vid : { key:int, value:int } = {key:0, value:0}


declare g_max_vid : { key:int, value:int } = {key:get_max_int (),
  value:get_max_int ()}


declare g_start_vid : { key:int, value:int } = {key:0, value:1}


declare job_master : int = 0


declare job_switch : int = 1


declare job_node : int = 2


declare job_timer : int = 3


declare job : mut int = if role == "master" then job_master
  else if role == "switch" then job_switch
    else if role == "node" then job_node
      else if role == "timer" then job_timer
        else error (print "failed to find proper role")


declare jobs : mut collection { key:address, value:int } @ { Map }


declare master_addr : mut address


declare timer_addr : mut address


declare nodes : mut collection {i:address} @ { Collection }


declare switches : mut collection {i:address} @ { Collection }


declare num_peers : mut int = my_peers.size ()


declare num_switches : mut int = 0


declare num_nodes : mut int = 0


declare map_ids : collection { ra:int, rb:string, rc:int } @ { Collection } =
  {| ra:int, rb:string, rc:int | {ra:1, rb:"NATION", rc:5}, {ra:2,
  rb:"REVENUE", rc:4}, {ra:3, rb:"REVENUE_mCUSTOMER11", rc:6}, {ra:4,
  rb:"REVENUE_mCUSTOMER11_mORDERS1", rc:6}, {ra:5,
  rb:"REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1", rc:4}, {ra:6,
  rb:"REVENUE_mCUSTOMER11_mLINEITEM4", rc:5}, {ra:7,
  rb:"REVENUE_mCUSTOMER11_mLINEITEM5", rc:3}, {ra:8,
  rb:"REVENUE_mCUSTOMER11_mSUPPLIER1", rc:4}, {ra:9,
  rb:"REVENUE_mCUSTOMER11_mSUPPLIER2", rc:5}, {ra:10, rb:"REVENUE_mCUSTOMER12",
  rc:6}, {ra:11, rb:"REVENUE_mCUSTOMER12_mORDERS1", rc:6}, {ra:12,
  rb:"REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1", rc:4}, {ra:13,
  rb:"REVENUE_mCUSTOMER12_mSUPPLIER1", rc:4}, {ra:14, rb:"REVENUE_mORDERS11",
  rc:6}, {ra:15, rb:"REVENUE_mORDERS11_mLINEITEM4", rc:5}, {ra:16,
  rb:"REVENUE_mORDERS11_mSUPPLIER2", rc:5}, {ra:17, rb:"REVENUE_mORDERS12",
  rc:6}, {ra:18, rb:"REVENUE_mLINEITEM4", rc:5}, {ra:19,
  rb:"REVENUE_mLINEITEM4_mSUPPLIER1", rc:5}, {ra:20, rb:"REVENUE_mSUPPLIER11",
  rc:6}, {ra:21, rb:"REVENUE_mSUPPLIER12", rc:6}|} @ { Collection }


declare nd_stmt_cntrs : collection { key:{ key:{ key:int, value:int },
  value:int }, value:{ key:int, value:collection { key:int, value:int
  } @ { Map } } } @ { Map }


declare nd_log_master : collection { key:{ key:int, value:int }, value:int
  } @ { Set }


declare nd_rcvd_sys_done : mut bool = false


declare sw_init : mut bool = false


declare sw_seen_sentry : mut bool = false


declare sw_trig_buf_idx : collection {i:int} @ { Seq }


declare ms_start_time : mut int = 0


declare ms_end_time : mut int = 0


declare sw_buf_insert_SUPPLIER : collection { ra:int, rb:string, rc:string,
  rd:int, re:string, rf:real, rg:string } @ { Seq }


declare sw_buf_delete_SUPPLIER : collection { ra:int, rb:string, rc:string,
  rd:int, re:string, rf:real, rg:string } @ { Seq }


declare sw_buf_insert_CUSTOMER : collection { ra:int, rb:string, rc:string,
  rd:int, re:string, rf:real, rg:string, rh:string } @ { Seq }


declare sw_buf_delete_CUSTOMER : collection { ra:int, rb:string, rc:string,
  rd:int, re:string, rf:real, rg:string, rh:string } @ { Seq }


declare sw_buf_insert_ORDERS : collection { ra:int, rb:int, rc:string, rd:real,
  re:int, rf:string, rg:string, rh:int, ri:string } @ { Seq }


declare sw_buf_delete_ORDERS : collection { ra:int, rb:int, rc:string, rd:real,
  re:int, rf:string, rg:string, rh:int, ri:string } @ { Seq }


declare sw_buf_insert_LINEITEM : collection { ra:int, rb:int, rc:int, rd:int,
  re:real, rf:real, rg:real, rh:real, ri:string, rj:string, rk:int, rl:int,
  rm:int, rn:string, ro:string, rp:string } @ { Seq }


declare sw_buf_delete_LINEITEM : collection { ra:int, rb:int, rc:int, rd:int,
  re:real, rf:real, rg:real, rh:real, ri:string, rj:string, rk:int, rl:int,
  rm:int, rn:string, ro:string, rp:string } @ { Seq }


declare nd_log_insert_SUPPLIER : collection { key:{ key:int, value:int },
  value:{ ra:int, rb:string, rc:string, rd:int, re:string, rf:real, rg:string }
  } @ { Map }


declare nd_log_delete_SUPPLIER : collection { key:{ key:int, value:int },
  value:{ ra:int, rb:string, rc:string, rd:int, re:string, rf:real, rg:string }
  } @ { Map }


declare nd_log_insert_CUSTOMER : collection { key:{ key:int, value:int },
  value:{ ra:int, rb:string, rc:string, rd:int, re:string, rf:real, rg:string,
  rh:string } } @ { Map }


declare nd_log_delete_CUSTOMER : collection { key:{ key:int, value:int },
  value:{ ra:int, rb:string, rc:string, rd:int, re:string, rf:real, rg:string,
  rh:string } } @ { Map }


declare nd_log_insert_ORDERS : collection { key:{ key:int, value:int }, value:{
  ra:int, rb:int, rc:string, rd:real, re:int, rf:string, rg:string, rh:int,
  ri:string } } @ { Map }


declare nd_log_delete_ORDERS : collection { key:{ key:int, value:int }, value:{
  ra:int, rb:int, rc:string, rd:real, re:int, rf:string, rg:string, rh:int,
  ri:string } } @ { Map }


declare nd_log_insert_LINEITEM : collection { key:{ key:int, value:int },
  value:{ ra:int, rb:int, rc:int, rd:int, re:real, rf:real, rg:real, rh:real,
  ri:string, rj:string, rk:int, rl:int, rm:int, rn:string, ro:string, rp:string
  } } @ { Map }


declare nd_log_delete_LINEITEM : collection { key:{ key:int, value:int },
  value:{ ra:int, rb:int, rc:int, rd:int, re:real, rf:real, rg:real, rh:real,
  ri:string, rj:string, rk:int, rl:int, rm:int, rn:string, ro:string, rp:string
  } } @ { Map }


declare NATION : ind collection { ra:{ key:int, value:int }, rb:int, rc:string,
  rd:int, re:string, rf:int } @ { Set } = ind
  ((load_csv_set "data/tpch/nation.csv").fold ((\_accmap -> (\b3 ->
  bind b3 as {ra:m0, rb:m1, rc:m2, rd:m3} in 
  (_accmap.insert {ra:m0, rb:m1, rc:m2, rd:m3, re:1};_accmap)))) empty {
  ra:int, rb:string, rc:int, rd:string, re:int } @ { Set }).fold ((\_accmap ->
  (\b3 -> bind b3 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 
  (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
   rf:map_val};
   _accmap)))) empty { ra:{ key:int, value:int }, rb:int, rc:string, rd:int,
  re:string, rf:int } @ { Set }


declare REVENUE : ind collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:real } @ { Set } = ind empty { ra:{ key:int, value:int
  }, rb:string, rc:string, rd:int, re:real } @ { Set }


declare REVENUE_mCUSTOMER11 : ind collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
  rf:int, rg:real } @ { Set }


declare REVENUE_mCUSTOMER11_mORDERS1 : ind collection { ra:{ key:int, value:int
  }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
  rf:int, rg:real } @ { Set }


declare REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare REVENUE_mCUSTOMER11_mLINEITEM4 : ind collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
  rf:int } @ { Set }


declare REVENUE_mCUSTOMER11_mLINEITEM5 : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set }


declare REVENUE_mCUSTOMER11_mSUPPLIER1 : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set }


declare REVENUE_mCUSTOMER11_mSUPPLIER2 : ind collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
  rf:int } @ { Set }


declare REVENUE_mCUSTOMER12 : ind collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
  rf:int, rg:real } @ { Set }


declare REVENUE_mCUSTOMER12_mORDERS1 : ind collection { ra:{ key:int, value:int
  }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
  rf:int, rg:real } @ { Set }


declare REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare REVENUE_mCUSTOMER12_mSUPPLIER1 : ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set }


declare REVENUE_mORDERS11 : ind collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
  rf:int, rg:real } @ { Set }


declare REVENUE_mORDERS11_mLINEITEM4 : ind collection { ra:{ key:int, value:int
  }, rb:string, rc:string, rd:int, re:int, rf:int } @ { Set } = ind empty {
  ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set }


declare REVENUE_mORDERS11_mSUPPLIER2 : ind collection { ra:{ key:int, value:int
  }, rb:string, rc:string, rd:int, re:int, rf:int } @ { Set } = ind empty {
  ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set }


declare REVENUE_mORDERS12 : ind collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
  rf:int, rg:real } @ { Set }


declare REVENUE_mLINEITEM4 : ind collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set }


declare REVENUE_mLINEITEM4_mSUPPLIER1 : ind collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
  rf:int } @ { Set }


declare REVENUE_mSUPPLIER11 : ind collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
  rf:int, rg:real } @ { Set }


declare REVENUE_mSUPPLIER12 : ind collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
  rf:int, rg:real } @ { Set }


declare map_REVENUE_mSUPPLIER11_s0_buf : ind collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mSUPPLIER12_s0_buf : ind collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s1_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s1_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s2_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s2_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s3_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s4_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s4_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s5_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s5_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s6_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s6_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s7_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s8_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s8_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mLINEITEM4_mSUPPLIER1_s9_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mSUPPLIER11_s10_buf : ind collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mSUPPLIER12_s10_buf : ind collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s11_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s11_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s12_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s12_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s13_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s14_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s14_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s15_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s15_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s16_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s16_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s17_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s18_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s18_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mLINEITEM4_mSUPPLIER1_s19_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_s20_buf : ind collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mCUSTOMER12_s20_buf : ind collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_s21_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s22_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s23_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_s24_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s25_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s25_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s26_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s26_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s27_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s27_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s28_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s28_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_s29_buf : ind collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mCUSTOMER12_s29_buf : ind collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_s30_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s31_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s32_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_s33_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s34_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s34_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s35_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s35_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s36_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s36_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s37_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s37_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_s38_buf : ind collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mORDERS12_s38_buf : ind collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_s39_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s41_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_s42_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s43_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mORDERS11_mLINEITEM4_s44_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s45_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s46_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s46_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s47_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s47_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_s48_buf : ind collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mORDERS12_s48_buf : ind collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_s49_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s51_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_s52_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s53_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mORDERS11_mLINEITEM4_s54_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s55_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s56_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s56_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s57_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s57_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mLINEITEM4_s58_buf : ind collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
  rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s59_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s59_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s60_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s62_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s63_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s63_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s64_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s66_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mORDERS11_mLINEITEM4_s67_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mLINEITEM4_s68_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mLINEITEM4_mSUPPLIER1_s69_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mLINEITEM4_mSUPPLIER1_s70_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mLINEITEM4_s71_buf : ind collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
  rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s72_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s72_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s73_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s75_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s76_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s76_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s77_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s79_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mORDERS11_mLINEITEM4_s80_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mLINEITEM4_s81_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mLINEITEM4_mSUPPLIER1_s82_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mLINEITEM4_mSUPPLIER1_s83_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_NATION_s84_buf : ind collection { ra:{ key:int, value:int },
  rb:int, rc:string, rd:int, re:string, rf:int } @ { Set } = ind
  ((load_csv_set "data/tpch/nation.csv").fold ((\_accmap -> (\b3 ->
  bind b3 as {ra:m0, rb:m1, rc:m2, rd:m3} in 
  (_accmap.insert {ra:m0, rb:m1, rc:m2, rd:m3, re:1};_accmap)))) empty {
  ra:int, rb:string, rc:int, rd:string, re:int } @ { Set }).fold ((\_accmap ->
  (\b3 -> bind b3 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 
  (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
   rf:map_val};
   _accmap)))) empty { ra:{ key:int, value:int }, rb:int, rc:string, rd:int,
  re:string, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s86_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s88_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s90_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s92_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s94_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s96_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s98_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s100_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s102_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s104_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s106_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s108_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s110_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s112_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s114_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s116_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s127_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s129_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s131_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s133_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s135_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s137_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s139_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s141_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s143_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s145_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s147_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s149_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s151_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s153_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s155_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s157_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s171_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s173_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s176_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s178_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s181_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s182_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s184_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s185_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s187_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s188_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s193_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s195_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s198_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s200_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s203_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s204_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s206_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s207_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s209_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s210_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s215_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s217_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s219_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s220_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s221_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s223_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s224_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s225_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s227_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s228_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s229_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s231_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s232_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s233_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s235_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s236_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s237_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s238_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s239_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s240_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s245_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s247_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s249_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s250_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s251_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s253_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s254_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s255_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s257_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s258_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s259_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM5_s261_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } = ind empty { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s262_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s263_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s265_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s266_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mLINEITEM4_s267_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s268_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s269_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s270_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s273_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s274_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s275_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s277_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s278_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s279_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s280_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s282_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s283_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s284_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s285_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s287_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s288_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s289_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s290_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s292_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s293_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s294_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s295_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s297_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s298_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s299_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s300_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s301_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s302_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s303_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s304_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s305_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s306_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s307_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s308_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s310_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s311_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s313_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s314_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s316_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s320_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s321_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s322_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s324_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s325_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s326_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s327_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s329_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s330_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s331_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s332_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s334_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s335_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s336_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s337_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s339_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s340_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER1_s341_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s342_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mSUPPLIER1_s344_buf : ind collection { ra:{
  key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s345_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s346_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s347_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s348_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s349_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s350_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s351_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s352_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mSUPPLIER2_s353_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mORDERS11_mSUPPLIER2_s354_buf : ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set } = ind empty { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s355_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s357_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s358_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s360_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s361_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s363_buf : ind collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Set } = ind
  empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set }


declare tm_timer_list : mut collection { ra:int, rb:int, rc:address } @ { Seq }


declare sw_next_switch_addr : mut address


declare sw_need_vid_cntr : mut int = 0


declare sw_token_vid_list : collection { key:{ key:int, value:int }, value:int
  } @ { Seq }


declare sw_highest_vid : mut { key:int, value:int }


declare node_ring : mut collection { key:address, value:int } @ { Seq }


declare replicas : mut int = 8


declare pmap_input : collection { key:string, value:collection { key:int,
  value:int } @ { Seq } } @ { Seq } = {| key:string, value:collection {
  key:int, value:int } @ { Seq } | {key:"NATION", value:{| key:int, value:int |
  {key:0, value:2}, {key:1, value:2}, {key:2, value:2}, {key:3,
  value:2}|} @ { Seq }}, {key:"REVENUE", value:{| key:int, value:int | {key:0,
  value:4}, {key:1, value:2}, {key:2, value:2}|} @ { Seq }},
  {key:"REVENUE_mCUSTOMER11", value:{| key:int, value:int | {key:0, value:2},
  {key:1, value:2}, {key:2, value:2}, {key:3, value:2}|} @ { Seq }},
  {key:"REVENUE_mCUSTOMER11_mORDERS1", value:{| key:int, value:int | {key:0,
  value:2}, {key:1, value:2}, {key:2, value:2}, {key:3, value:2}|} @ { Seq }},
  {key:"REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1", value:{| key:int, value:int |
  {key:0, value:4}, {key:1, value:2}, {key:2, value:2}|} @ { Seq }},
  {key:"REVENUE_mCUSTOMER11_mLINEITEM4", value:{| key:int, value:int | {key:0,
  value:2}, {key:1, value:2}, {key:2, value:2}, {key:3, value:2}|} @ { Seq }},
  {key:"REVENUE_mCUSTOMER11_mLINEITEM5", value:{| key:int, value:int | {key:0,
  value:4}, {key:1, value:4}|} @ { Seq }},
  {key:"REVENUE_mCUSTOMER11_mSUPPLIER1", value:{| key:int, value:int | {key:0,
  value:4}, {key:1, value:2}, {key:2, value:2}|} @ { Seq }},
  {key:"REVENUE_mCUSTOMER11_mSUPPLIER2", value:{| key:int, value:int | {key:0,
  value:2}, {key:1, value:2}, {key:2, value:2}, {key:3, value:2}|} @ { Seq }},
  {key:"REVENUE_mCUSTOMER12", value:{| key:int, value:int | {key:0, value:2},
  {key:1, value:2}, {key:2, value:2}, {key:3, value:2}|} @ { Seq }},
  {key:"REVENUE_mCUSTOMER12_mORDERS1", value:{| key:int, value:int | {key:0,
  value:2}, {key:1, value:2}, {key:2, value:2}, {key:3, value:2}|} @ { Seq }},
  {key:"REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1", value:{| key:int, value:int |
  {key:0, value:4}, {key:1, value:2}, {key:2, value:2}|} @ { Seq }},
  {key:"REVENUE_mCUSTOMER12_mSUPPLIER1", value:{| key:int, value:int | {key:0,
  value:4}, {key:1, value:2}, {key:2, value:2}|} @ { Seq }},
  {key:"REVENUE_mORDERS11", value:{| key:int, value:int | {key:0, value:2},
  {key:1, value:2}, {key:2, value:2}, {key:3, value:2}|} @ { Seq }},
  {key:"REVENUE_mORDERS11_mLINEITEM4", value:{| key:int, value:int | {key:0,
  value:2}, {key:1, value:2}, {key:2, value:2}, {key:3, value:2}|} @ { Seq }},
  {key:"REVENUE_mORDERS11_mSUPPLIER2", value:{| key:int, value:int | {key:0,
  value:2}, {key:1, value:2}, {key:2, value:2}, {key:3, value:2}|} @ { Seq }},
  {key:"REVENUE_mORDERS12", value:{| key:int, value:int | {key:0, value:2},
  {key:1, value:2}, {key:2, value:2}, {key:3, value:2}|} @ { Seq }},
  {key:"REVENUE_mLINEITEM4", value:{| key:int, value:int | {key:0, value:2},
  {key:1, value:2}, {key:2, value:2}, {key:3, value:2}|} @ { Seq }},
  {key:"REVENUE_mLINEITEM4_mSUPPLIER1", value:{| key:int, value:int | {key:0,
  value:2}, {key:1, value:2}, {key:2, value:2}, {key:3, value:2}|} @ { Seq }},
  {key:"REVENUE_mSUPPLIER11", value:{| key:int, value:int | {key:0, value:2},
  {key:1, value:2}, {key:2, value:2}, {key:3, value:2}|} @ { Seq }},
  {key:"REVENUE_mSUPPLIER12", value:{| key:int, value:int | {key:0, value:2},
  {key:1, value:2}, {key:2, value:2}, {key:3, value:2}|} @ { Seq }}|} @ { Seq }


declare pmap_data : collection { key:int, value:collection { key:int, value:int
  } @ { Seq } } @ { Seq } = pmap_input.fold ((\_accmap -> (\b3 ->
  bind b3 as {key:map_name, value:map_types} in 
  (_accmap.insert {key:(case ((map_ids.filter ((\b1 -> bind b1 as {ra:ra,
   rb:rb, rc:rc} in rb == map_name))).peek ()) of
   {Some x -> x}{None -> error (print "can't find map in map_ids")}).ra,
   value:map_types};
   _accmap)))) empty { key:int, value:collection { key:int, value:int
  } @ { Seq } } @ { Seq }


declare sw_num_ack : mut int = 0


declare sw_num_sent : mut int = 0


declare sw_ack_log : collection { key:{ key:int, value:int }, value:int
  } @ { Map }


declare ms_gc_interval : mut int = 20000


declare ms_gc_vid_map : mut collection { key:address, value:{ key:int,
  value:int } } @ { Map }


declare ms_gc_vid_ctr : mut int = 0


declare ms_num_gc_expected : mut int = my_peers.size ()


declare nd_log_master_write : { key:{ key:int, value:int }, value:int } -> () =
  (\b1 -> bind b1 as {key:vid, value:stmt_id} in nd_log_master.insert {key:vid,
  value:stmt_id})


declare nd_log_write_insert_SUPPLIER : { ra:{ key:int, value:int }, rb:int,
  rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () = (\b1 ->
  bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in nd_log_insert_SUPPLIER.insert
  {key:vid, value:{ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS,
  rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL,
  rg:SUPPLIER_COMMENT}})


declare nd_log_write_delete_SUPPLIER : { ra:{ key:int, value:int }, rb:int,
  rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () = (\b1 ->
  bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in nd_log_delete_SUPPLIER.insert
  {key:vid, value:{ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS,
  rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL,
  rg:SUPPLIER_COMMENT}})


declare nd_log_write_insert_CUSTOMER : { ra:{ key:int, value:int }, rb:int,
  rc:string, rd:string, re:int, rf:string, rg:real, rh:string, ri:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
  rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE,
  rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in 
  nd_log_insert_CUSTOMER.insert {key:vid, value:{ra:CUSTOMER_CUSTKEY,
  rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY,
  re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT,
  rh:CUSTOMER_COMMENT}})


declare nd_log_write_delete_CUSTOMER : { ra:{ key:int, value:int }, rb:int,
  rc:string, rd:string, re:int, rf:string, rg:real, rh:string, ri:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
  rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE,
  rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in 
  nd_log_delete_CUSTOMER.insert {key:vid, value:{ra:CUSTOMER_CUSTKEY,
  rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY,
  re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT,
  rh:CUSTOMER_COMMENT}})


declare nd_log_write_insert_ORDERS : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in nd_log_insert_ORDERS.insert {key:vid,
  value:{ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS,
  rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY,
  rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}})


declare nd_log_write_delete_ORDERS : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in nd_log_delete_ORDERS.insert {key:vid,
  value:{ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS,
  rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY,
  rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}})


declare nd_log_write_insert_LINEITEM : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real, rj:string,
  rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
  rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
  rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
  rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
  rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
  rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in nd_log_insert_LINEITEM.insert
  {key:vid, value:{ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY,
  rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY,
  rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX,
  ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE,
  rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT,
  ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}})


declare nd_log_write_delete_LINEITEM : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real, rj:string,
  rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
  rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
  rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
  rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
  rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
  rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in nd_log_delete_LINEITEM.insert
  {key:vid, value:{ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY,
  rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY,
  rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX,
  ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE,
  rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT,
  ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}})


declare nd_log_get_bound_insert_SUPPLIER : { key:int, value:int } -> { ra:int,
  rb:string, rc:string, rd:int, re:string, rf:real, rg:string } = (\vid ->
  (case ((nd_log_insert_SUPPLIER.filter ((\b1 -> bind b1 as {key:key,
  value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_delete_SUPPLIER : { key:int, value:int } -> { ra:int,
  rb:string, rc:string, rd:int, re:string, rf:real, rg:string } = (\vid ->
  (case ((nd_log_delete_SUPPLIER.filter ((\b1 -> bind b1 as {key:key,
  value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_insert_CUSTOMER : { key:int, value:int } -> { ra:int,
  rb:string, rc:string, rd:int, re:string, rf:real, rg:string, rh:string } =
  (\vid -> (case ((nd_log_insert_CUSTOMER.filter ((\b1 -> bind b1 as {key:key,
  value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_delete_CUSTOMER : { key:int, value:int } -> { ra:int,
  rb:string, rc:string, rd:int, re:string, rf:real, rg:string, rh:string } =
  (\vid -> (case ((nd_log_delete_CUSTOMER.filter ((\b1 -> bind b1 as {key:key,
  value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_insert_ORDERS : { key:int, value:int } -> { ra:int,
  rb:int, rc:string, rd:real, re:int, rf:string, rg:string, rh:int, ri:string
  } = (\vid -> (case ((nd_log_insert_ORDERS.filter ((\b1 ->
  bind b1 as {key:key, value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_delete_ORDERS : { key:int, value:int } -> { ra:int,
  rb:int, rc:string, rd:real, re:int, rf:string, rg:string, rh:int, ri:string
  } = (\vid -> (case ((nd_log_delete_ORDERS.filter ((\b1 ->
  bind b1 as {key:key, value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_insert_LINEITEM : { key:int, value:int } -> { ra:int,
  rb:int, rc:int, rd:int, re:real, rf:real, rg:real, rh:real, ri:string,
  rj:string, rk:int, rl:int, rm:int, rn:string, ro:string, rp:string } =
  (\vid -> (case ((nd_log_insert_LINEITEM.filter ((\b1 -> bind b1 as {key:key,
  value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_get_bound_delete_LINEITEM : { key:int, value:int } -> { ra:int,
  rb:int, rc:int, rd:int, re:real, rf:real, rg:real, rh:real, ri:string,
  rj:string, rk:int, rl:int, rm:int, rn:string, ro:string, rp:string } =
  (\vid -> (case ((nd_log_delete_LINEITEM.filter ((\b1 -> bind b1 as {key:key,
  value:value} in key == vid))).peek ()) of
  {Some x -> x}{None -> error (print "failed to find log")}).value)


declare nd_log_read_geq : { key:int, value:int } -> collection { key:{ key:int,
  value:int }, value:int } @ { Set } = (\vid2 -> nd_log_master.filter ((\b1 ->
  bind b1 as {key:vid, value:stmt_id} in vid >= vid2)))


declare nd_check_stmt_cntr_index : { ra:{ key:int, value:int }, rb:int, rc:int
  } -> bool = (\b1 -> bind b1 as {ra:vid, rb:stmt_id, rc:add_to_count} in case
  ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
  {key:vid, value:stmt_id}))).peek ()) of
  {Some lookup_value -> let new_count = add_to_count + (lookup_value.value).key
    in
    (nd_stmt_cntrs.update lookup_value {key:{key:vid, value:stmt_id},
     value:{key:new_count, value:(lookup_value.value).value}};
     0 == new_count)}{None ->
                       (nd_stmt_cntrs.insert {key:{key:vid, value:stmt_id},
                        value:{key:add_to_count, value:empty { key:int,
                        value:int } @ { Map }}};
                        false)})


declare nd_complete_stmt_cntr_check : { key:{ key:int, value:int }, value:int
  } -> () = (\b1 -> bind b1 as {key:vid, value:stmt_id} in 
  ((case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
   key == {key:vid, value:stmt_id}))).peek ()) of
   {Some lookup_data -> nd_stmt_cntrs.erase lookup_data}{None -> ()});
   (if nd_rcvd_sys_done
   then if not nd_sent_done and nd_stmt_cntrs.size () == 0
     then ((ms_rcv_node_done, master_addr)<- true;nd_sent_done = true) 
     else () else ())))


declare nd_update_stmt_cntr_corr_map : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:int, re:bool, rf:bool } -> () = (\b1 -> bind b1 as {ra:vid,
  rb:stmt_id, rc:hop, rd:count, re:root, rf:create} in 
  ((if create
   then nd_stmt_cntrs.insert {key:{key:vid, value:stmt_id}, value:{key:0,
     value:empty { key:int, value:int } @ { Map }}} else ());
   (case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
   key == {key:vid, value:stmt_id}))).peek ()) of
   {Some lkup -> nd_stmt_cntrs.update lkup {key:{key:vid, value:stmt_id},
     value:let sc_corr_map = (lkup.value).value in
     ((case ((sc_corr_map.filter ((\b1 -> bind b1 as {key:key, value:value} in 
      key == hop))).peek ()) of
      {Some lkup2 -> sc_corr_map.update lkup2 {key:hop, value:lkup2.value +
        count}}{None -> sc_corr_map.insert {key:hop, value:count}});
      (if root then ()
      else case ((sc_corr_map.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == hop))).peek ()) of
        {Some lkup2 -> let new_corr_cnt = lkup2.value - 1 in
          if new_corr_cnt == 0 then sc_corr_map.erase lkup2
            else sc_corr_map.update lkup2 {key:hop, value:new_corr_cnt}}
        {None -> sc_corr_map.insert {key:hop, value:-1}});
      {key:(lkup.value).key, value:sc_corr_map})}}{None ->
                                                    error
                                                      (print
                                                         "nd_update_stmt_cntr_corr_map: missing stmt_cntrs value")})))


declare nd_filter_corrective_list : { key:{ key:int, value:int },
  value:collection { key:int, value:int } @ { Collection } } -> collection {
  key:int, value:collection { key:int, value:int } @ { Seq }
  } @ { Collection } = (\b1 -> bind b1 as {key:request_vid,
  value:trig_stmt_list} in ((((nd_log_read_geq request_vid).fold ((\acc_conv ->
  (\x -> (acc_conv.insert x;acc_conv)))) empty { key:{ key:int, value:int },
  value:int } @ { Seq }).sort ((\b2 -> (\b5 -> bind b2 as {key:vid1,
  value:stmt1} in bind b5 as {key:vid2, value:stmt2} in if vid1 < vid2 
  then -1 else 1)))).groupBy ((\b1 -> bind b1 as {value:stmt_id} in stmt_id))
  ((\vid_list -> (\b3 -> bind b3 as {key:vid} in 
  (vid_list.insert vid;vid_list)))) empty { key:int, value:int
  } @ { Seq }).fold ((\acc_conv -> (\x -> (acc_conv.insert x;acc_conv))))
  empty { key:int, value:collection { key:int, value:int } @ { Seq }
  } @ { Collection })


declare add_node : address -> () = (\addr -> let rng = range replicas in
  let new_elems =
    rng.fold ((\_accmap -> (\b3 -> bind b3 as {i:i} in 
      (_accmap.insert {key:addr, value:abs (hash ((i * 2683) + hash addr))};
       _accmap)))) empty { key:address, value:int } @ { Seq } in
    (node_ring = node_ring.combine new_elems;
     node_ring = node_ring.sort ((\b2 -> (\b5 -> bind b2 as {key:addr,
     value:hash1} in bind b5 as {key:addr, value:hash2} in if hash1 < hash2
     then -1 else 1)))))


declare get_ring_node : { key:int, value:int } -> address = (\b1 ->
  bind b1 as {key:data, value:max_val} in let scaled =
  truncate (real_of_int (get_max_int ()) * (real_of_int data /
    real_of_int max_val)) in
  let results =
    node_ring.filter ((\b1 -> bind b1 as {key:addr, value:hash} in hash >=
      scaled)) in
    bind
      case (results.peek ()) of
        {Some x -> x}{None -> case (node_ring.peek ()) of
                       {Some x -> x}{None -> error (print "empty node ring")}}
      as {key:addr, value:_} in addr)


declare frontier_int_int_int_float : { key:{ key:int, value:int },
  value:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Set } } -> collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int, re:real } @ { Collection } = (\b1 -> bind b1 as {key:vid,
  value:input_map} in (input_map.groupBy ((\b1 -> bind b1 as {ra:map_vid,
  rb:map_0, rc:map_1, rd:map_2, re:map_val} in {ra:map_0, rb:map_1, rc:map_2}))
  ((\b2 -> (\b5 -> bind b2 as {key:acc, value:max_vid} in 
  bind b5 as {ra:map_vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
  if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {ra:map_vid, rb:map_0, rc:map_1, rd:map_2, re:map_val};
       {key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real |
        {ra:map_vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val}|} @ { Collection }, value:map_vid}
      else {key:acc, value:max_vid} else {key:acc, value:max_vid})))
  {key:empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, value:g_min_vid}).fold ((\_accext -> (\b3 ->
  bind b3 as {value:b4} in bind b4 as {key:project} in _accext.combine
  project))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection })


declare frontier_int_int_int : { key:{ key:int, value:int }, value:collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set }
  } -> collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection } = (\b1 -> bind b1 as {key:vid, value:input_map} in 
  (input_map.groupBy ((\b1 -> bind b1 as {ra:map_vid, rb:map_0, rc:map_1,
  rd:map_val} in {key:map_0, value:map_1})) ((\b2 -> (\b5 ->
  bind b2 as {key:acc, value:max_vid} in bind b5 as {ra:map_vid, rb:map_0,
  rc:map_1, rd:map_val} in if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {ra:map_vid, rb:map_0, rc:map_1, rd:map_val};
       {key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| ra:{ key:int, value:int }, rb:int, rc:int, rd:int |
        {ra:map_vid, rb:map_0, rc:map_1, rd:map_val}|} @ { Collection },
        value:map_vid} else {key:acc, value:max_vid}
  else {key:acc, value:max_vid}))) {key:empty { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int } @ { Collection }, value:g_min_vid}).fold
  ((\_accext -> (\b3 -> bind b3 as {value:b4} in bind b4 as {key:project} in 
  _accext.combine project))) empty { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int } @ { Collection })


declare frontier_int_string_int_string_int : { key:{ key:int, value:int },
  value:collection { ra:{ key:int, value:int }, rb:int, rc:string, rd:int,
  re:string, rf:int } @ { Set } } -> collection { ra:{ key:int, value:int },
  rb:int, rc:string, rd:int, re:string, rf:int } @ { Collection } = (\b1 ->
  bind b1 as {key:vid, value:input_map} in (input_map.groupBy ((\b1 ->
  bind b1 as {ra:map_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
  rf:map_val} in {ra:map_0, rb:map_1, rc:map_2, rd:map_3})) ((\b2 -> (\b5 ->
  bind b2 as {key:acc, value:max_vid} in bind b5 as {ra:map_vid, rb:map_0,
  rc:map_1, rd:map_2, re:map_3, rf:map_val} in if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {ra:map_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
       rf:map_val};
       {key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| ra:{ key:int, value:int }, rb:int, rc:string, rd:int,
        re:string, rf:int | {ra:map_vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_3, rf:map_val}|} @ { Collection }, value:map_vid}
      else {key:acc, value:max_vid} else {key:acc, value:max_vid})))
  {key:empty { ra:{ key:int, value:int }, rb:int, rc:string, rd:int, re:string,
  rf:int } @ { Collection }, value:g_min_vid}).fold ((\_accext -> (\b3 ->
  bind b3 as {value:b4} in bind b4 as {key:project} in _accext.combine
  project))) empty { ra:{ key:int, value:int }, rb:int, rc:string, rd:int,
  re:string, rf:int } @ { Collection })


declare frontier_string_string_int_int_int_float : { key:{ key:int, value:int
  }, value:collection { ra:{ key:int, value:int }, rb:string, rc:string,
  rd:int, re:int, rf:int, rg:real } @ { Set } } -> collection { ra:{ key:int,
  value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Collection } = (\b1 -> bind b1 as {key:vid, value:input_map} in 
  (input_map.groupBy ((\b1 -> bind b1 as {ra:map_vid, rb:map_0, rc:map_1,
  rd:map_2, re:map_3, rf:map_4, rg:map_val} in {ra:map_0, rb:map_1, rc:map_2,
  rd:map_3, re:map_4})) ((\b2 -> (\b5 -> bind b2 as {key:acc,
  value:max_vid} in bind b5 as {ra:map_vid, rb:map_0, rc:map_1, rd:map_2,
  re:map_3, rf:map_4, rg:map_val} in if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {ra:map_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
       rf:map_4, rg:map_val};
       {key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
        re:int, rf:int, rg:real | {ra:map_vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_3, rf:map_4, rg:map_val}|} @ { Collection }, value:map_vid}
      else {key:acc, value:max_vid} else {key:acc, value:max_vid})))
  {key:empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
  rf:int, rg:real } @ { Collection }, value:g_min_vid}).fold ((\_accext ->
  (\b3 -> bind b3 as {value:b4} in bind b4 as {key:project} in _accext.combine
  project))) empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int, rg:real } @ { Collection })


declare frontier_string_string_int_int_int : { key:{ key:int, value:int },
  value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Set } } -> collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection } = (\b1 ->
  bind b1 as {key:vid, value:input_map} in (input_map.groupBy ((\b1 ->
  bind b1 as {ra:map_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
  rf:map_val} in {ra:map_0, rb:map_1, rc:map_2, rd:map_3})) ((\b2 -> (\b5 ->
  bind b2 as {key:acc, value:max_vid} in bind b5 as {ra:map_vid, rb:map_0,
  rc:map_1, rd:map_2, re:map_3, rf:map_val} in if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {ra:map_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
       rf:map_val};
       {key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
        re:int, rf:int | {ra:map_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val}|} @ { Collection }, value:map_vid}
      else {key:acc, value:max_vid} else {key:acc, value:max_vid})))
  {key:empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
  rf:int } @ { Collection }, value:g_min_vid}).fold ((\_accext -> (\b3 ->
  bind b3 as {value:b4} in bind b4 as {key:project} in _accext.combine
  project))) empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection })


declare frontier_string_string_int_float : { key:{ key:int, value:int },
  value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:real } @ { Set } } -> collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:real } @ { Collection } = (\b1 -> bind b1 as {key:vid,
  value:input_map} in (input_map.groupBy ((\b1 -> bind b1 as {ra:map_vid,
  rb:map_0, rc:map_1, rd:map_2, re:map_val} in {ra:map_0, rb:map_1, rc:map_2}))
  ((\b2 -> (\b5 -> bind b2 as {key:acc, value:max_vid} in 
  bind b5 as {ra:map_vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
  if map_vid < vid
  then if map_vid == max_vid
    then
      (acc.insert {ra:map_vid, rb:map_0, rc:map_1, rd:map_2, re:map_val};
       {key:acc, value:max_vid})
    else if map_vid > max_vid
      then {key:{| ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
        re:real | {ra:map_vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val}|} @ { Collection }, value:map_vid}
      else {key:acc, value:max_vid} else {key:acc, value:max_vid})))
  {key:empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:real
  } @ { Collection }, value:g_min_vid}).fold ((\_accext -> (\b3 ->
  bind b3 as {value:b4} in bind b4 as {key:project} in _accext.combine
  project))) empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:real } @ { Collection })


declare nd_add_delta_to_int_int_int_float : { ra:ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int, re:real } @ { Set }, rb:bool, rc:{
  key:int, value:int }, rd:collection { ra:int, rb:int, rc:int, rd:real
  } @ { Collection } } -> () = (\b1 -> bind b1 as {ra:target_map,
  rb:corrective, rc:min_vid, rd:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2,
   rd:map_val} in bind target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc,
         rd:rd, re:re} in ((ra == min_vid and rd == map_2) and rc == map_1) and
         rb == map_0))
       else empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
         } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.re in
         target_map_d.update val {ra:min_vid, rb:map_0, rc:map_1, rd:map_2,
           re:update_value}}{None -> let lookup_value =
                              frontier_int_int_int_float {key:min_vid,
                                value:target_map_d.filter ((\b1 ->
                                bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd,
                                re:re} in (rb == map_0 and rd == map_2) and rc
                                == map_1))} in
                              let update_value =
                                map_val + case (lookup_value.peek ()) of
                                  {Some val -> val.re}{None -> 0} in
                                target_map_d.insert {ra:min_vid, rb:map_0,
                                  rc:map_1, rd:map_2, re:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0_delta, rb:map_1_delta,
   rc:map_2_delta, rd:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd,
       re:re} in (rb == map_0_delta and rd == map_2_delta) and rc ==
       map_1_delta))).filter ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1,
       rd:map_2, re:map_val} in vid > min_vid)) in
   filtered.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
     re:map_val} in bind target_map as ind target_map_d in
     target_map_d.update {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
       {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val + map_val_delta}))))))


declare nd_add_delta_to_int_int_int : { ra:ind collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Set }, rb:bool, rc:{ key:int,
  value:int }, rd:collection { ra:int, rb:int, rc:int } @ { Collection }
  } -> () = (\b1 -> bind b1 as {ra:target_map, rb:corrective, rc:min_vid,
  rd:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
   rc:map_val} in bind target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc,
         rd:rd} in (ra == min_vid and rc == map_1) and rb == map_0))
       else empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
         } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.rd in
         target_map_d.update val {ra:min_vid, rb:map_0, rc:map_1,
           rd:update_value}}{None -> let lookup_value =
                              frontier_int_int_int {key:min_vid,
                                value:target_map_d.filter ((\b1 ->
                                bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb
                                == map_0 and rc == map_1))} in
                              let update_value =
                                map_val + case (lookup_value.peek ()) of
                                  {Some val -> val.rd}{None -> 0} in
                                target_map_d.insert {ra:min_vid, rb:map_0,
                                  rc:map_1, rd:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0_delta, rb:map_1_delta,
   rc:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in 
       rb == map_0_delta and rc == map_1_delta))).filter ((\b1 ->
       bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in vid > min_vid))
   in
   filtered.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1,
     rd:map_val} in bind target_map as ind target_map_d in
     target_map_d.update {ra:vid, rb:map_0, rc:map_1, rd:map_val} {ra:vid,
       rb:map_0, rc:map_1, rd:map_val + map_val_delta}))))))


declare nd_add_delta_to_int_string_int_string_int : { ra:ind collection { ra:{
  key:int, value:int }, rb:int, rc:string, rd:int, re:string, rf:int
  } @ { Set }, rb:bool, rc:{ key:int, value:int }, rd:collection { ra:int,
  rb:string, rc:int, rd:string, re:int } @ { Collection } } -> () = (\b1 ->
  bind b1 as {ra:target_map, rb:corrective, rc:min_vid, rd:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2,
   rd:map_3, re:map_val} in bind target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc,
         rd:rd, re:re, rf:rf} in (((ra == min_vid and re == map_3) and rd ==
         map_2) and rc == map_1) and rb == map_0))
       else empty { ra:{ key:int, value:int }, rb:int, rc:string, rd:int,
         re:string, rf:int } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.rf in
         target_map_d.update val {ra:min_vid, rb:map_0, rc:map_1, rd:map_2,
           re:map_3, rf:update_value}}{None -> let lookup_value =
                                        frontier_int_string_int_string_int
                                          {key:min_vid,
                                          value:target_map_d.filter ((\b1 ->
                                          bind b1 as {ra:ra, rb:rb, rc:rc,
                                          rd:rd, re:re, rf:rf} in ((rb == map_0
                                          and re == map_3) and rd == map_2) and
                                          rc == map_1))} in
                                        let update_value =
                                          map_val + case (lookup_value.peek ())
                                            of {Some val -> val.rf}{None -> 0}
                                          in
                                          target_map_d.insert {ra:min_vid,
                                            rb:map_0, rc:map_1, rd:map_2,
                                            re:map_3, rf:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0_delta, rb:map_1_delta,
   rc:map_2_delta, rd:map_3_delta, re:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd,
       re:re, rf:rf} in ((rb == map_0_delta and re == map_3_delta) and rd ==
       map_2_delta) and rc == map_1_delta))).filter ((\b1 ->
       bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
       rf:map_val} in vid > min_vid)) in
   filtered.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
     re:map_3, rf:map_val} in bind target_map as ind target_map_d in
     target_map_d.update {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
       rf:map_val} {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val
       + map_val_delta}))))))


declare nd_add_delta_to_string_string_int_int_int_float : { ra:ind collection {
  ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int,
  rg:real } @ { Set }, rb:bool, rc:{ key:int, value:int }, rd:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
  } -> () = (\b1 -> bind b1 as {ra:target_map, rb:corrective, rc:min_vid,
  rd:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2,
   rd:map_3, re:map_4, rf:map_val} in bind target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc,
         rd:rd, re:re, rf:rf, rg:rg} in ((((ra == min_vid and rf == map_4) and
         re == map_3) and rd == map_2) and rc == map_1) and rb == map_0))
       else empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
         re:int, rf:int, rg:real } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.rg in
         target_map_d.update val {ra:min_vid, rb:map_0, rc:map_1, rd:map_2,
           re:map_3, rf:map_4, rg:update_value}}{None -> let lookup_value =
                                                  frontier_string_string_int_int_int_float
                                                    {key:min_vid,
                                                    value:target_map_d.filter
                                                    ((\b1 -> bind b1 as {ra:ra,
                                                    rb:rb, rc:rc, rd:rd, re:re,
                                                    rf:rf, rg:rg} in (((rb ==
                                                    map_0 and rf == map_4) and
                                                    re == map_3) and rd ==
                                                    map_2) and rc == map_1))}
                                                  in
                                                  let update_value =
                                                    map_val + case
                                                      (lookup_value.peek ()) of
                                                      {Some val -> val.rg}
                                                      {None -> 0} in
                                                    target_map_d.insert
                                                      {ra:min_vid, rb:map_0,
                                                      rc:map_1, rd:map_2,
                                                      re:map_3, rf:map_4,
                                                      rg:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0_delta, rb:map_1_delta,
   rc:map_2_delta, rd:map_3_delta, re:map_4_delta, rf:map_val_delta} in let
   filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd,
       re:re, rf:rf, rg:rg} in (((rb == map_0_delta and rf == map_4_delta) and
       re == map_3_delta) and rd == map_2_delta) and rc ==
       map_1_delta))).filter ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1,
       rd:map_2, re:map_3, rf:map_4, rg:map_val} in vid > min_vid)) in
   filtered.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
     re:map_3, rf:map_4, rg:map_val} in bind target_map as ind target_map_d in
     target_map_d.update {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
       rf:map_4, rg:map_val} {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
       rf:map_4, rg:map_val + map_val_delta}))))))


declare nd_add_delta_to_string_string_int_int_int : { ra:ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Set }, rb:bool, rc:{ key:int, value:int }, rd:collection { ra:string,
  rb:string, rc:int, rd:int, re:int } @ { Collection } } -> () = (\b1 ->
  bind b1 as {ra:target_map, rb:corrective, rc:min_vid, rd:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2,
   rd:map_3, re:map_val} in bind target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc,
         rd:rd, re:re, rf:rf} in (((ra == min_vid and re == map_3) and rd ==
         map_2) and rc == map_1) and rb == map_0))
       else empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
         re:int, rf:int } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.rf in
         target_map_d.update val {ra:min_vid, rb:map_0, rc:map_1, rd:map_2,
           re:map_3, rf:update_value}}{None -> let lookup_value =
                                        frontier_string_string_int_int_int
                                          {key:min_vid,
                                          value:target_map_d.filter ((\b1 ->
                                          bind b1 as {ra:ra, rb:rb, rc:rc,
                                          rd:rd, re:re, rf:rf} in ((rb == map_0
                                          and re == map_3) and rd == map_2) and
                                          rc == map_1))} in
                                        let update_value =
                                          map_val + case (lookup_value.peek ())
                                            of {Some val -> val.rf}{None -> 0}
                                          in
                                          target_map_d.insert {ra:min_vid,
                                            rb:map_0, rc:map_1, rd:map_2,
                                            re:map_3, rf:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0_delta, rb:map_1_delta,
   rc:map_2_delta, rd:map_3_delta, re:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd,
       re:re, rf:rf} in ((rb == map_0_delta and re == map_3_delta) and rd ==
       map_2_delta) and rc == map_1_delta))).filter ((\b1 ->
       bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
       rf:map_val} in vid > min_vid)) in
   filtered.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
     re:map_3, rf:map_val} in bind target_map as ind target_map_d in
     target_map_d.update {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
       rf:map_val} {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val
       + map_val_delta}))))))


declare nd_add_delta_to_string_string_int_float : { ra:ind collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:real } @ { Set },
  rb:bool, rc:{ key:int, value:int }, rd:collection { ra:string, rb:string,
  rc:int, rd:real } @ { Collection } } -> () = (\b1 ->
  bind b1 as {ra:target_map, rb:corrective, rc:min_vid, rd:delta_tuples} in 
  (delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2,
   rd:map_val} in bind target_map as ind target_map_d in
   let lookup_value =
     if corrective
       then target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc,
         rd:rd, re:re} in ((ra == min_vid and rd == map_2) and rc == map_1) and
         rb == map_0))
       else empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
         re:real } @ { Set } in
     case (lookup_value.peek ()) of
       {Some val -> let update_value = map_val + val.re in
         target_map_d.update val {ra:min_vid, rb:map_0, rc:map_1, rd:map_2,
           re:update_value}}{None -> let lookup_value =
                              frontier_string_string_int_float {key:min_vid,
                                value:target_map_d.filter ((\b1 ->
                                bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd,
                                re:re} in (rb == map_0 and rd == map_2) and rc
                                == map_1))} in
                              let update_value =
                                map_val + case (lookup_value.peek ()) of
                                  {Some val -> val.re}{None -> 0} in
                                target_map_d.insert {ra:min_vid, rb:map_0,
                                  rc:map_1, rd:map_2, re:update_value}}));
   delta_tuples.iterate ((\b1 -> bind b1 as {ra:map_0_delta, rb:map_1_delta,
   rc:map_2_delta, rd:map_val_delta} in let filtered =
   bind target_map as ind target_map_d in
     (target_map_d.filter ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd,
       re:re} in (rb == map_0_delta and rd == map_2_delta) and rc ==
       map_1_delta))).filter ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1,
       rd:map_2, re:map_val} in vid > min_vid)) in
   filtered.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
     re:map_val} in bind target_map as ind target_map_d in
     target_map_d.update {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
       {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val + map_val_delta}))))))


declare sw_gen_vid : () -> option { key:int, value:int } = (\_ -> case
  (sw_token_vid_list.peek ()) of
  {Some vid_num -> let num_new = vid_num.value - 1 in
    let vid_new = {key:(vid_num.key).key, value:(vid_num.key).value + 1} in
      ((if num_new <= 0 then sw_token_vid_list.erase vid_num
       else sw_token_vid_list.update vid_num {key:vid_new, value:num_new});
       Some (vid_num.key))}{None -> None immut})


declare calc_dim_bounds : collection { key:int, value:int } @ { Seq } -> {
  key:collection { key:int, value:int } @ { Seq }, value:int } = (\pmap ->
  pmap.fold ((\b2 -> (\b5 -> bind b2 as {key:xs, value:acc_size} in 
  bind b5 as {key:pos, value:bin_size} in {key:xs.combine ({| key:int,
  value:int | {key:pos, value:acc_size}|} @ { Seq }), value:bin_size *
  acc_size}))) {key:empty { key:int, value:int } @ { Seq }, value:1})


declare route_to_int_int : { ra:int, rb:option int, rc:option int
  } -> collection {i:address} @ { Collection } = (\b1 -> bind b1 as {ra:map_id,
  rb:key_0, rc:key_1} in let pmap =
  (case ((pmap_data.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
    map_id))).peek ()) of
    {Some x -> x}{None -> error (print "can't find map_id in pmap_data")}).value
  in
  case (pmap.peek ()) of
    {Some _ -> bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in
      let bound_bucket =
        case key_1 of
          {Some key_1_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              1)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_1_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 1))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 1 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_0 of
          {Some key_0_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              0)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_0_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 0))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 0 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + 0) in
        let free_dims =
          (if key_1 != None immut then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 1))).combine ((if key_0 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 0))).combine empty { key:int, value:int } @ { Seq }) in
          let free_domains =
            free_dims.fold ((\_accmap -> (\b3 -> bind b3 as {key:i,
              value:b_i} in 
              (_accmap.insert {key:i, value:range b_i};_accmap)))) empty {
              key:int, value:collection {i:int} @ { Seq } } @ { Seq } in
            let free_cart_prod =
              free_domains.fold ((\prev_cart_prod -> (\b3 -> bind b3 as {key:i,
                value:domain} in domain.fold ((\_accext -> (\b3 ->
                bind b3 as {i:domain_element} in _accext.combine
                (if 0 == prev_cart_prod.size ()
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int | {key:i,
                  value:domain_element}|} @ { Seq }|} @ { Seq }
                else prev_cart_prod.fold ((\_accmap -> (\b3 ->
                  bind b3 as {i:rest_tup} in 
                  (_accmap.insert ({i:rest_tup.combine ({| key:int, value:int |
                   {key:i, value:domain_element}|} @ { Seq })});
                   _accmap)))) empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq })))) empty {i:collection { key:int,
                value:int } @ { Seq }} @ { Seq }))) empty {i:collection {
                key:int, value:int } @ { Seq }} @ { Seq } in
              let sorted_ip_list =
                (free_cart_prod.fold ((\acc_ips -> (\b3 ->
                  bind b3 as {i:free_bucket} in acc_ips.combine ({|i:address|
                  get_ring_node {key:free_bucket.fold ((\acc -> (\b3 ->
                    bind b3 as {key:i, value:val} in acc + (val * (case
                    ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                    value:value} in key == i))).peek ()) of
                    {Some x -> x}{None ->
                                   error (print "can't find i in dim_bounds")}).value))))
                    bound_bucket, value:max_val}|} @ { Collection }))))
                  empty {i:address} @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {i:ip} in ip)) ((\_ -> (\_ -> ()))) () in
                if 0 == sorted_ip_list.size ()
                  then {|i:address|
                    get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
                  else sorted_ip_list.fold ((\_accmap -> (\x ->
                    (_accmap.insert ({i:x.key});_accmap))))
                    empty {i:address} @ { Collection }}{None -> nodes})


declare route_to_int_int_int : { ra:int, rb:option int, rc:option int,
  rd:option int } -> collection {i:address} @ { Collection } = (\b1 ->
  bind b1 as {ra:map_id, rb:key_0, rc:key_1, rd:key_2} in let pmap =
  (case ((pmap_data.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
    map_id))).peek ()) of
    {Some x -> x}{None -> error (print "can't find map_id in pmap_data")}).value
  in
  case (pmap.peek ()) of
    {Some _ -> bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in
      let bound_bucket =
        case key_2 of
          {Some key_2_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              2)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_2_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 2))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 2 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_1 of
          {Some key_1_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              1)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_1_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 1))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 1 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_0 of
          {Some key_0_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              0)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_0_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 0))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 0 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + 0)) in
        let free_dims =
          (if key_2 != None immut then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 2))).combine ((if key_1 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 1))).combine ((if key_0 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 0))).combine empty { key:int, value:int } @ { Seq })) in
          let free_domains =
            free_dims.fold ((\_accmap -> (\b3 -> bind b3 as {key:i,
              value:b_i} in 
              (_accmap.insert {key:i, value:range b_i};_accmap)))) empty {
              key:int, value:collection {i:int} @ { Seq } } @ { Seq } in
            let free_cart_prod =
              free_domains.fold ((\prev_cart_prod -> (\b3 -> bind b3 as {key:i,
                value:domain} in domain.fold ((\_accext -> (\b3 ->
                bind b3 as {i:domain_element} in _accext.combine
                (if 0 == prev_cart_prod.size ()
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int | {key:i,
                  value:domain_element}|} @ { Seq }|} @ { Seq }
                else prev_cart_prod.fold ((\_accmap -> (\b3 ->
                  bind b3 as {i:rest_tup} in 
                  (_accmap.insert ({i:rest_tup.combine ({| key:int, value:int |
                   {key:i, value:domain_element}|} @ { Seq })});
                   _accmap)))) empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq })))) empty {i:collection { key:int,
                value:int } @ { Seq }} @ { Seq }))) empty {i:collection {
                key:int, value:int } @ { Seq }} @ { Seq } in
              let sorted_ip_list =
                (free_cart_prod.fold ((\acc_ips -> (\b3 ->
                  bind b3 as {i:free_bucket} in acc_ips.combine ({|i:address|
                  get_ring_node {key:free_bucket.fold ((\acc -> (\b3 ->
                    bind b3 as {key:i, value:val} in acc + (val * (case
                    ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                    value:value} in key == i))).peek ()) of
                    {Some x -> x}{None ->
                                   error (print "can't find i in dim_bounds")}).value))))
                    bound_bucket, value:max_val}|} @ { Collection }))))
                  empty {i:address} @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {i:ip} in ip)) ((\_ -> (\_ -> ()))) () in
                if 0 == sorted_ip_list.size ()
                  then {|i:address|
                    get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
                  else sorted_ip_list.fold ((\_accmap -> (\x ->
                    (_accmap.insert ({i:x.key});_accmap))))
                    empty {i:address} @ { Collection }}{None -> nodes})


declare route_to_int_string_int_string : { ra:int, rb:option int,
  rc:option string, rd:option int, re:option string
  } -> collection {i:address} @ { Collection } = (\b1 -> bind b1 as {ra:map_id,
  rb:key_0, rc:key_1, rd:key_2, re:key_3} in let pmap =
  (case ((pmap_data.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
    map_id))).peek ()) of
    {Some x -> x}{None -> error (print "can't find map_id in pmap_data")}).value
  in
  case (pmap.peek ()) of
    {Some _ -> bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in
      let bound_bucket =
        case key_3 of
          {Some key_3_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              3)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_3_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 3))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 3 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_2 of
          {Some key_2_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              2)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_2_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 2))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 2 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_1 of
          {Some key_1_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              1)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_1_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 1))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 1 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_0 of
          {Some key_0_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              0)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_0_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 0))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 0 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + 0))) in
        let free_dims =
          (if key_3 != None immut then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 3))).combine ((if key_2 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 2))).combine ((if key_1 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 1))).combine ((if key_0 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 0))).combine empty { key:int, value:int } @ { Seq }))) in
          let free_domains =
            free_dims.fold ((\_accmap -> (\b3 -> bind b3 as {key:i,
              value:b_i} in 
              (_accmap.insert {key:i, value:range b_i};_accmap)))) empty {
              key:int, value:collection {i:int} @ { Seq } } @ { Seq } in
            let free_cart_prod =
              free_domains.fold ((\prev_cart_prod -> (\b3 -> bind b3 as {key:i,
                value:domain} in domain.fold ((\_accext -> (\b3 ->
                bind b3 as {i:domain_element} in _accext.combine
                (if 0 == prev_cart_prod.size ()
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int | {key:i,
                  value:domain_element}|} @ { Seq }|} @ { Seq }
                else prev_cart_prod.fold ((\_accmap -> (\b3 ->
                  bind b3 as {i:rest_tup} in 
                  (_accmap.insert ({i:rest_tup.combine ({| key:int, value:int |
                   {key:i, value:domain_element}|} @ { Seq })});
                   _accmap)))) empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq })))) empty {i:collection { key:int,
                value:int } @ { Seq }} @ { Seq }))) empty {i:collection {
                key:int, value:int } @ { Seq }} @ { Seq } in
              let sorted_ip_list =
                (free_cart_prod.fold ((\acc_ips -> (\b3 ->
                  bind b3 as {i:free_bucket} in acc_ips.combine ({|i:address|
                  get_ring_node {key:free_bucket.fold ((\acc -> (\b3 ->
                    bind b3 as {key:i, value:val} in acc + (val * (case
                    ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                    value:value} in key == i))).peek ()) of
                    {Some x -> x}{None ->
                                   error (print "can't find i in dim_bounds")}).value))))
                    bound_bucket, value:max_val}|} @ { Collection }))))
                  empty {i:address} @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {i:ip} in ip)) ((\_ -> (\_ -> ()))) () in
                if 0 == sorted_ip_list.size ()
                  then {|i:address|
                    get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
                  else sorted_ip_list.fold ((\_accmap -> (\x ->
                    (_accmap.insert ({i:x.key});_accmap))))
                    empty {i:address} @ { Collection }}{None -> nodes})


declare route_to_string_string_int : { ra:int, rb:option string,
  rc:option string, rd:option int
  } -> collection {i:address} @ { Collection } = (\b1 -> bind b1 as {ra:map_id,
  rb:key_0, rc:key_1, rd:key_2} in let pmap =
  (case ((pmap_data.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
    map_id))).peek ()) of
    {Some x -> x}{None -> error (print "can't find map_id in pmap_data")}).value
  in
  case (pmap.peek ()) of
    {Some _ -> bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in
      let bound_bucket =
        case key_2 of
          {Some key_2_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              2)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_2_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 2))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 2 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_1 of
          {Some key_1_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              1)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_1_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 1))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 1 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_0 of
          {Some key_0_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              0)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_0_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 0))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 0 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + 0)) in
        let free_dims =
          (if key_2 != None immut then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 2))).combine ((if key_1 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 1))).combine ((if key_0 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 0))).combine empty { key:int, value:int } @ { Seq })) in
          let free_domains =
            free_dims.fold ((\_accmap -> (\b3 -> bind b3 as {key:i,
              value:b_i} in 
              (_accmap.insert {key:i, value:range b_i};_accmap)))) empty {
              key:int, value:collection {i:int} @ { Seq } } @ { Seq } in
            let free_cart_prod =
              free_domains.fold ((\prev_cart_prod -> (\b3 -> bind b3 as {key:i,
                value:domain} in domain.fold ((\_accext -> (\b3 ->
                bind b3 as {i:domain_element} in _accext.combine
                (if 0 == prev_cart_prod.size ()
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int | {key:i,
                  value:domain_element}|} @ { Seq }|} @ { Seq }
                else prev_cart_prod.fold ((\_accmap -> (\b3 ->
                  bind b3 as {i:rest_tup} in 
                  (_accmap.insert ({i:rest_tup.combine ({| key:int, value:int |
                   {key:i, value:domain_element}|} @ { Seq })});
                   _accmap)))) empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq })))) empty {i:collection { key:int,
                value:int } @ { Seq }} @ { Seq }))) empty {i:collection {
                key:int, value:int } @ { Seq }} @ { Seq } in
              let sorted_ip_list =
                (free_cart_prod.fold ((\acc_ips -> (\b3 ->
                  bind b3 as {i:free_bucket} in acc_ips.combine ({|i:address|
                  get_ring_node {key:free_bucket.fold ((\acc -> (\b3 ->
                    bind b3 as {key:i, value:val} in acc + (val * (case
                    ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                    value:value} in key == i))).peek ()) of
                    {Some x -> x}{None ->
                                   error (print "can't find i in dim_bounds")}).value))))
                    bound_bucket, value:max_val}|} @ { Collection }))))
                  empty {i:address} @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {i:ip} in ip)) ((\_ -> (\_ -> ()))) () in
                if 0 == sorted_ip_list.size ()
                  then {|i:address|
                    get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
                  else sorted_ip_list.fold ((\_accmap -> (\x ->
                    (_accmap.insert ({i:x.key});_accmap))))
                    empty {i:address} @ { Collection }}{None -> nodes})


declare route_to_string_string_int_int_int : { ra:int, rb:option string,
  rc:option string, rd:option int, re:option int, rf:option int
  } -> collection {i:address} @ { Collection } = (\b1 -> bind b1 as {ra:map_id,
  rb:key_0, rc:key_1, rd:key_2, re:key_3, rf:key_4} in let pmap =
  (case ((pmap_data.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
    map_id))).peek ()) of
    {Some x -> x}{None -> error (print "can't find map_id in pmap_data")}).value
  in
  case (pmap.peek ()) of
    {Some _ -> bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in
      let bound_bucket =
        case key_4 of
          {Some key_4_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              4)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_4_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 4))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 4 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_3 of
          {Some key_3_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              3)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_3_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 3))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 3 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_2 of
          {Some key_2_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              2)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_2_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 2))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 2 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_1 of
          {Some key_1_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              1)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_1_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 1))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 1 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_0 of
          {Some key_0_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              0)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_0_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 0))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 0 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + 0)))) in
        let free_dims =
          (if key_4 != None immut then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 4))).combine ((if key_3 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 3))).combine ((if key_2 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 2))).combine ((if key_1 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 1))).combine ((if key_0 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 0))).combine empty { key:int, value:int } @ { Seq })))) in
          let free_domains =
            free_dims.fold ((\_accmap -> (\b3 -> bind b3 as {key:i,
              value:b_i} in 
              (_accmap.insert {key:i, value:range b_i};_accmap)))) empty {
              key:int, value:collection {i:int} @ { Seq } } @ { Seq } in
            let free_cart_prod =
              free_domains.fold ((\prev_cart_prod -> (\b3 -> bind b3 as {key:i,
                value:domain} in domain.fold ((\_accext -> (\b3 ->
                bind b3 as {i:domain_element} in _accext.combine
                (if 0 == prev_cart_prod.size ()
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int | {key:i,
                  value:domain_element}|} @ { Seq }|} @ { Seq }
                else prev_cart_prod.fold ((\_accmap -> (\b3 ->
                  bind b3 as {i:rest_tup} in 
                  (_accmap.insert ({i:rest_tup.combine ({| key:int, value:int |
                   {key:i, value:domain_element}|} @ { Seq })});
                   _accmap)))) empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq })))) empty {i:collection { key:int,
                value:int } @ { Seq }} @ { Seq }))) empty {i:collection {
                key:int, value:int } @ { Seq }} @ { Seq } in
              let sorted_ip_list =
                (free_cart_prod.fold ((\acc_ips -> (\b3 ->
                  bind b3 as {i:free_bucket} in acc_ips.combine ({|i:address|
                  get_ring_node {key:free_bucket.fold ((\acc -> (\b3 ->
                    bind b3 as {key:i, value:val} in acc + (val * (case
                    ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                    value:value} in key == i))).peek ()) of
                    {Some x -> x}{None ->
                                   error (print "can't find i in dim_bounds")}).value))))
                    bound_bucket, value:max_val}|} @ { Collection }))))
                  empty {i:address} @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {i:ip} in ip)) ((\_ -> (\_ -> ()))) () in
                if 0 == sorted_ip_list.size ()
                  then {|i:address|
                    get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
                  else sorted_ip_list.fold ((\_accmap -> (\x ->
                    (_accmap.insert ({i:x.key});_accmap))))
                    empty {i:address} @ { Collection }}{None -> nodes})


declare route_to_string_string_int_int : { ra:int, rb:option string,
  rc:option string, rd:option int, re:option int
  } -> collection {i:address} @ { Collection } = (\b1 -> bind b1 as {ra:map_id,
  rb:key_0, rc:key_1, rd:key_2, re:key_3} in let pmap =
  (case ((pmap_data.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
    map_id))).peek ()) of
    {Some x -> x}{None -> error (print "can't find map_id in pmap_data")}).value
  in
  case (pmap.peek ()) of
    {Some _ -> bind calc_dim_bounds pmap as {key:dim_bounds, value:max_val} in
      let bound_bucket =
        case key_3 of
          {Some key_3_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              3)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_3_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 3))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 3 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_2 of
          {Some key_2_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              2)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_2_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 2))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 2 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_1 of
          {Some key_1_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              1)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_1_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 1))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 1 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + (case key_0 of
          {Some key_0_unwrap -> let pmap_slice =
            pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key ==
              0)) in
            case (pmap_slice.peek ()) of
              {Some peek_slice -> let value =
                abs (hash key_0_unwrap) % peek_slice.value in
                value * (case ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                  value:value} in key == 0))).peek ()) of
                  {Some x -> x}{None ->
                                 error (print "can't find 0 in dim_bounds")}).value}
              {None -> 0}}{None -> 0} + 0))) in
        let free_dims =
          (if key_3 != None immut then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 3))).combine ((if key_2 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 2))).combine ((if key_1 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 1))).combine ((if key_0 != None immut
            then empty { key:int, value:int } @ { Seq }
            else pmap.filter ((\b1 -> bind b1 as {key:key, value:value} in key
              == 0))).combine empty { key:int, value:int } @ { Seq }))) in
          let free_domains =
            free_dims.fold ((\_accmap -> (\b3 -> bind b3 as {key:i,
              value:b_i} in 
              (_accmap.insert {key:i, value:range b_i};_accmap)))) empty {
              key:int, value:collection {i:int} @ { Seq } } @ { Seq } in
            let free_cart_prod =
              free_domains.fold ((\prev_cart_prod -> (\b3 -> bind b3 as {key:i,
                value:domain} in domain.fold ((\_accext -> (\b3 ->
                bind b3 as {i:domain_element} in _accext.combine
                (if 0 == prev_cart_prod.size ()
                then {|i:collection { key:int, value:int } @ { Seq }| {|
                  key:int, value:int | {key:i,
                  value:domain_element}|} @ { Seq }|} @ { Seq }
                else prev_cart_prod.fold ((\_accmap -> (\b3 ->
                  bind b3 as {i:rest_tup} in 
                  (_accmap.insert ({i:rest_tup.combine ({| key:int, value:int |
                   {key:i, value:domain_element}|} @ { Seq })});
                   _accmap)))) empty {i:collection { key:int, value:int
                  } @ { Seq }} @ { Seq })))) empty {i:collection { key:int,
                value:int } @ { Seq }} @ { Seq }))) empty {i:collection {
                key:int, value:int } @ { Seq }} @ { Seq } in
              let sorted_ip_list =
                (free_cart_prod.fold ((\acc_ips -> (\b3 ->
                  bind b3 as {i:free_bucket} in acc_ips.combine ({|i:address|
                  get_ring_node {key:free_bucket.fold ((\acc -> (\b3 ->
                    bind b3 as {key:i, value:val} in acc + (val * (case
                    ((dim_bounds.filter ((\b1 -> bind b1 as {key:key,
                    value:value} in key == i))).peek ()) of
                    {Some x -> x}{None ->
                                   error (print "can't find i in dim_bounds")}).value))))
                    bound_bucket, value:max_val}|} @ { Collection }))))
                  empty {i:address} @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {i:ip} in ip)) ((\_ -> (\_ -> ()))) () in
                if 0 == sorted_ip_list.size ()
                  then {|i:address|
                    get_ring_node {key:bound_bucket, value:max_val}|} @ { Collection }
                  else sorted_ip_list.fold ((\_accmap -> (\x ->
                    (_accmap.insert ({i:x.key});_accmap))))
                    empty {i:address} @ { Collection }}{None -> nodes})


declare shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:21, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:21, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_4, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:20, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:20, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_4, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mORDERS12_bind_0t0_1t1_3t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:17, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:17, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mORDERS11_bind_0t0_1t1_3t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:14, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:14, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER12_mSUPPLIER1_bind_1t0 :
  { ra:option int, rb:option int, rc:option int, rd:collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Collection }, re:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:tuples,
  re:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_int_int {ra:13, rb:lkey_0, rc:lkey_1, rd:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3} in
    (route_to_int_int_int {ra:13, rb:lkey_0, rc:Some rkey_1, rd:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int, rd:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER12_mORDERS1_bind_0t0_1t1_3t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:11, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:11, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER12_bind_4t0 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int } @ { Collection }, rg:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:lkey_2, rd:lkey_3, re:lkey_4, rf:tuples,
  rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:10, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3} in
    (route_to_string_string_int_int_int {ra:10, rb:lkey_0, rc:lkey_1,
       rd:lkey_2, re:lkey_3, rf:Some rkey_1}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int, rd:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_3t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:10, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:10, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER11_mSUPPLIER1_bind_1t0 :
  { ra:option int, rb:option int, rc:option int, rd:collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int } @ { Collection }, re:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:tuples,
  re:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_int_int {ra:8, rb:lkey_0, rc:lkey_1, rd:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3} in
    (route_to_int_int_int {ra:8, rb:lkey_0, rc:Some rkey_1, rd:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int, rd:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER11_mORDERS1_bind_0t0_1t1_3t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:4, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:4, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER11_bind_4t0 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int } @ { Collection }, rg:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:lkey_2, rd:lkey_3, re:lkey_4, rf:tuples,
  rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:3, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3} in
    (route_to_string_string_int_int_int {ra:3, rb:lkey_0, rc:lkey_1, rd:lkey_2,
       re:lkey_3, rf:Some rkey_1}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int, rd:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_3t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:3, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:3, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mLINEITEM4_to_REVENUE_bind_0t0_1t1 : {
  ra:option string, rb:option string, rc:option int, rd:collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Collection }, re:bool } -> collection { key:address, value:collection {
  ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:lkey_2, rd:tuples, re:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int {ra:2, rb:lkey_0, rc:lkey_1, rd:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int {ra:2, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:21, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:21, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_4, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_2t0_4t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int, re:real } @ { Collection }, rg:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:lkey_2, rd:lkey_3, re:lkey_4, rf:tuples,
  rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:21, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int, re:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4} in
    (route_to_string_string_int_int_int {ra:21, rb:lkey_0, rc:lkey_1,
       rd:Some rkey_1, re:lkey_3, rf:Some rkey_3}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection })))) empty { key:address, value:collection { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
    } @ { Collection })


declare shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:20, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:20, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_4, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_2t0_4t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int, re:real } @ { Collection }, rg:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:lkey_2, rd:lkey_3, re:lkey_4, rf:tuples,
  rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:20, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int, re:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4} in
    (route_to_string_string_int_int_int {ra:20, rb:lkey_0, rc:lkey_1,
       rd:Some rkey_1, re:lkey_3, rf:Some rkey_3}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection })))) empty { key:address, value:collection { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
    } @ { Collection })


declare shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_0t0_1t1_3t3 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rf:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:lkey_3, re:tuples,
  rf:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int {ra:19, rb:lkey_0, rc:lkey_1, rd:lkey_2,
         re:lkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int {ra:19, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mLINEITEM4_bind_0t0_1t1_3t3 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rf:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:lkey_3, re:tuples,
  rf:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int {ra:18, rb:lkey_0, rc:lkey_1, rd:lkey_2,
         re:lkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int {ra:18, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER12_mSUPPLIER1_bind_0t0_2t2 :
  { ra:option int, rb:option int, rc:option int, rd:collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }, re:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:real } @ { Collection } } @ { Collection } =
  (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:tuples,
  re:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_int_int {ra:13, rb:lkey_0, rc:lkey_1, rd:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int, re:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4} in
    (route_to_int_int_int {ra:13, rb:Some rkey_1, rc:lkey_1, rd:Some rkey_3}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection })))) empty { key:address, value:collection { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER12_mORDERS1_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_2t2_3t3 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:10, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int, rg:real
       } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5, rg:rkey_6}
    in
    (route_to_string_string_int_int_int {ra:10, rb:Some rkey_1, rc:Some rkey_2,
       rd:Some rkey_3, re:Some rkey_4, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int, rg:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int, rg:real } @ { Collection } } @ { Collection })).groupBy
    ((\b1 -> bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER11_mSUPPLIER1_bind_0t0_2t2 :
  { ra:option int, rb:option int, rc:option int, rd:collection { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }, re:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:real } @ { Collection } } @ { Collection } =
  (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:tuples,
  re:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then (route_to_int_int_int {ra:8, rb:lkey_0, rc:lkey_1, rd:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int, re:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4} in
    (route_to_int_int_int {ra:8, rb:Some rkey_1, rc:lkey_1, rd:Some rkey_3}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection })))) empty { key:address, value:collection { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mORDERS1_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_2t2_3t3 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:3, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int, rg:real
       } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5, rg:rkey_6}
    in
    (route_to_string_string_int_int_int {ra:3, rb:Some rkey_1, rc:Some rkey_2,
       rd:Some rkey_3, re:Some rkey_4, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int, rg:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int, rg:real } @ { Collection } } @ { Collection })).groupBy
    ((\b1 -> bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
    } @ { Collection })


declare shuffle_REVENUE_mORDERS12_to_REVENUE_bind_0t0_1t1_2t2 : {
  ra:option string, rb:option string, rc:option int, rd:collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Collection }, re:bool } -> collection { key:address, value:collection {
  ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int,
  rg:real } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:tuples,
  re:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int {ra:2, rb:lkey_0, rc:lkey_1, rd:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int, rg:real
       } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5, rg:rkey_6}
    in
    (route_to_string_string_int {ra:2, rb:Some rkey_1, rc:Some rkey_2,
       rd:Some rkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int, rg:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int, rg:real } @ { Collection } } @ { Collection })).groupBy
    ((\b1 -> bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
    } @ { Collection })


declare shuffle_REVENUE_mORDERS11_to_REVENUE_bind_0t0_1t1_2t2 : {
  ra:option string, rb:option string, rc:option int, rd:collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Collection }, re:bool } -> collection { key:address, value:collection {
  ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int,
  rg:real } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:tuples,
  re:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int {ra:2, rb:lkey_0, rc:lkey_1, rd:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int, rg:real
       } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5, rg:rkey_6}
    in
    (route_to_string_string_int {ra:2, rb:Some rkey_1, rc:Some rkey_2,
       rd:Some rkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int, rg:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int, rg:real } @ { Collection } } @ { Collection })).groupBy
    ((\b1 -> bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:21, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:21, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_4, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER12_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_2t0_4t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int, re:real } @ { Collection }, rg:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:lkey_2, rd:lkey_3, re:lkey_4, rf:tuples,
  rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:21, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int, re:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4} in
    (route_to_string_string_int_int_int {ra:21, rb:lkey_0, rc:lkey_1,
       rd:Some rkey_1, re:lkey_3, rf:Some rkey_3}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection })))) empty { key:address, value:collection { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:20, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:20, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_4, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_2t0_4t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int, re:real } @ { Collection }, rg:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:lkey_2, rd:lkey_3, re:lkey_4, rf:tuples,
  rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:20, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int, re:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4} in
    (route_to_string_string_int_int_int {ra:20, rb:lkey_0, rc:lkey_1,
       rd:Some rkey_1, re:lkey_3, rf:Some rkey_3}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection })))) empty { key:address, value:collection { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_0t0_1t1_3t3 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rf:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:lkey_3, re:tuples,
  rf:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int {ra:19, rb:lkey_0, rc:lkey_1, rd:lkey_2,
         re:lkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int {ra:19, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_2t1 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rf:bool } -> collection { key:address, value:collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:tuples, rf:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int {ra:19, rb:lkey_0, rc:lkey_1, rd:lkey_2,
         re:lkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3} in
    (route_to_string_string_int_int {ra:19, rb:lkey_0, rc:lkey_1,
       rd:Some rkey_2, re:lkey_3}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int, rd:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mLINEITEM4_bind_2t1 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rf:bool } -> collection { key:address, value:collection {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:tuples, rf:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int {ra:18, rb:lkey_0, rc:lkey_1, rd:lkey_2,
         re:lkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3} in
    (route_to_string_string_int_int {ra:18, rb:lkey_0, rc:lkey_1,
       rd:Some rkey_2, re:lkey_3}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int } @ { Collection } } @ { Collection }))))
    empty { key:address, value:collection { ra:{ key:int, value:int }, rb:int,
    rc:int, rd:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mLINEITEM4_bind_0t0_1t1_3t3 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rf:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:lkey_3, re:tuples,
  rf:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int {ra:18, rb:lkey_0, rc:lkey_1, rd:lkey_2,
         re:lkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int {ra:18, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER12_mORDERS1_to_REVENUE_mORDERS12_bind_0t0_1t1_2t2_4t4 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:17, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int, rg:real
       } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5, rg:rkey_6}
    in
    (route_to_string_string_int_int_int {ra:17, rb:Some rkey_1, rc:Some rkey_2,
       rd:Some rkey_3, re:lkey_3, rf:Some rkey_5}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int, rg:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int, rg:real } @ { Collection } } @ { Collection })).groupBy
    ((\b1 -> bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mORDERS11_mSUPPLIER2_bind_0t0_1t1_3t3 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rf:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:lkey_3, re:tuples,
  rf:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int {ra:16, rb:lkey_0, rc:lkey_1, rd:lkey_2,
         re:lkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int {ra:16, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mORDERS11_mLINEITEM4_bind_0t0_1t1_3t3 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rf:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:lkey_3, re:tuples,
  rf:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int {ra:15, rb:lkey_0, rc:lkey_1, rd:lkey_2,
         re:lkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int {ra:15, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mORDERS1_to_REVENUE_mORDERS11_bind_0t0_1t1_2t2_4t4 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:14, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int, rg:real
       } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5, rg:rkey_6}
    in
    (route_to_string_string_int_int_int {ra:14, rb:Some rkey_1, rc:Some rkey_2,
       rd:Some rkey_3, re:lkey_3, rf:Some rkey_5}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int, rg:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int, rg:real } @ { Collection } } @ { Collection })).groupBy
    ((\b1 -> bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER12_to_REVENUE_bind_0t0_1t1_2t2 : {
  ra:option string, rb:option string, rc:option int, rd:collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Collection }, re:bool } -> collection { key:address, value:collection {
  ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int,
  rg:real } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:tuples,
  re:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int {ra:2, rb:lkey_0, rc:lkey_1, rd:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int, rg:real
       } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5, rg:rkey_6}
    in
    (route_to_string_string_int {ra:2, rb:Some rkey_1, rc:Some rkey_2,
       rd:Some rkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int, rg:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int, rg:real } @ { Collection } } @ { Collection })).groupBy
    ((\b1 -> bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_to_REVENUE_bind_0t0_1t1_2t2 : {
  ra:option string, rb:option string, rc:option int, rd:collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Collection }, re:bool } -> collection { key:address, value:collection {
  ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int,
  rg:real } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:tuples,
  re:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int {ra:2, rb:lkey_0, rc:lkey_1, rd:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int, rg:real
       } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5, rg:rkey_6}
    in
    (route_to_string_string_int {ra:2, rb:Some rkey_1, rc:Some rkey_2,
       rd:Some rkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int, rg:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int, rg:real } @ { Collection } } @ { Collection })).groupBy
    ((\b1 -> bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
    } @ { Collection })


declare shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mLINEITEM4_bind_0t0_1t1_2t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rf:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:lkey_3, re:tuples,
  rf:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int {ra:18, rb:lkey_0, rc:lkey_1, rd:lkey_2,
         re:lkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int {ra:18, rb:Some rkey_1, rc:Some rkey_2,
       rd:Some rkey_3, re:lkey_3}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS12_bind_0t0_1t1_3t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:17, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:17, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mORDERS12_bind_2t0_4t1 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int, re:real } @ { Collection }, rg:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:lkey_2, rd:lkey_3, re:lkey_4, rf:tuples,
  rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:17, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int, re:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4} in
    (route_to_string_string_int_int_int {ra:17, rb:lkey_0, rc:lkey_1,
       rd:Some rkey_1, re:lkey_3, rf:Some rkey_2}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection })))) empty { key:address, value:collection { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
    } @ { Collection })


declare shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS11_mLINEITEM4_bind_0t0_1t1_2t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rf:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:lkey_3, re:tuples,
  rf:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int {ra:15, rb:lkey_0, rc:lkey_1, rd:lkey_2,
         re:lkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int {ra:15, rb:Some rkey_1, rc:Some rkey_2,
       rd:Some rkey_3, re:lkey_3}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS11_bind_0t0_1t1_3t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:14, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:14, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mORDERS11_bind_2t0_4t1 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int, re:real } @ { Collection }, rg:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:lkey_2, rd:lkey_3, re:lkey_4, rf:tuples,
  rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:14, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int, re:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4} in
    (route_to_string_string_int_int_int {ra:14, rb:lkey_0, rc:lkey_1,
       rd:Some rkey_1, re:lkey_3, rf:Some rkey_2}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection })))) empty { key:address, value:collection { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER12_mORDERS1_bind_0t0_1t1_3t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:11, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:11, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER12_mORDERS1_bind_2t0_4t1 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int, re:real } @ { Collection }, rg:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:lkey_2, rd:lkey_3, re:lkey_4, rf:tuples,
  rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:11, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int, re:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4} in
    (route_to_string_string_int_int_int {ra:11, rb:lkey_0, rc:lkey_1,
       rd:Some rkey_1, re:lkey_3, rf:Some rkey_2}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection })))) empty { key:address, value:collection { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_3t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:10, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:10, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER12_mSUPPLIER1_to_REVENUE_mCUSTOMER12_bind_2t0_4t1 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int, re:real } @ { Collection }, rg:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:lkey_2, rd:lkey_3, re:lkey_4, rf:tuples,
  rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:10, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int, re:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4} in
    (route_to_string_string_int_int_int {ra:10, rb:lkey_0, rc:lkey_1,
       rd:Some rkey_1, re:lkey_3, rf:Some rkey_2}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection })))) empty { key:address, value:collection { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER11_mLINEITEM4_bind_0t0_1t1_2t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rf:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:lkey_3, re:tuples,
  rf:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int {ra:6, rb:lkey_0, rc:lkey_1, rd:lkey_2,
         re:lkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int {ra:6, rb:Some rkey_1, rc:Some rkey_2,
       rd:Some rkey_3, re:lkey_3}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER11_mORDERS1_bind_0t0_1t1_3t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:4, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:4, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER11_mORDERS1_bind_2t0_4t1 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int, re:real } @ { Collection }, rg:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:lkey_2, rd:lkey_3, re:lkey_4, rf:tuples,
  rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:4, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int, re:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4} in
    (route_to_string_string_int_int_int {ra:4, rb:lkey_0, rc:lkey_1,
       rd:Some rkey_1, re:lkey_3, rf:Some rkey_2}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection })))) empty { key:address, value:collection { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_3t2 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:string,
  rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:bool
  } -> collection { key:address, value:collection { ra:{ key:int, value:int },
  rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
  } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2,
  rd:lkey_3, re:lkey_4, rf:tuples, rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:3, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5} in
    (route_to_string_string_int_int_int {ra:3, rb:Some rkey_1, rc:Some rkey_2,
       rd:lkey_2, re:Some rkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection } } @ { Collection })).groupBy ((\b1 ->
    bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })


declare shuffle_REVENUE_mCUSTOMER11_mSUPPLIER1_to_REVENUE_mCUSTOMER11_bind_2t0_4t1 :
  { ra:option string, rb:option string, rc:option int, rd:option int,
  re:option int, rf:collection { ra:{ key:int, value:int }, rb:int, rc:int,
  rd:int, re:real } @ { Collection }, rg:bool } -> collection { key:address,
  value:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection } } @ { Collection } = (\b1 -> bind b1 as {ra:lkey_0,
  rb:lkey_1, rc:lkey_2, rd:lkey_3, re:lkey_4, rf:tuples,
  rg:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int_int_int {ra:3, rb:lkey_0, rc:lkey_1,
         rd:lkey_2, re:lkey_3, rf:lkey_4}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:int, rc:int, rd:int, re:real } @ { Collection } } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4} in
    (route_to_string_string_int_int_int {ra:3, rb:lkey_0, rc:lkey_1,
       rd:Some rkey_1, re:lkey_3, rf:Some rkey_2}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:int,
       rc:int, rd:int, re:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
      } @ { Collection })))) empty { key:address, value:collection { ra:{
    key:int, value:int }, rb:int, rc:int, rd:int, re:real } @ { Collection }
    } @ { Collection })).groupBy ((\b1 -> bind b1 as {key:ip, value:tuple} in 
    ip)) ((\acc -> (\b3 -> bind b3 as {key:ip, value:tuple} in tuple.combine
    acc))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
    } @ { Collection })


declare shuffle_REVENUE_mSUPPLIER12_to_REVENUE_bind_0t0_1t1_2t2 : {
  ra:option string, rb:option string, rc:option int, rd:collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Collection }, re:bool } -> collection { key:address, value:collection {
  ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int,
  rg:real } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:tuples,
  re:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int {ra:2, rb:lkey_0, rc:lkey_1, rd:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int, rg:real
       } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5, rg:rkey_6}
    in
    (route_to_string_string_int {ra:2, rb:Some rkey_1, rc:Some rkey_2,
       rd:Some rkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int, rg:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int, rg:real } @ { Collection } } @ { Collection })).groupBy
    ((\b1 -> bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
    } @ { Collection })


declare shuffle_REVENUE_mSUPPLIER11_to_REVENUE_bind_0t0_1t1_2t2 : {
  ra:option string, rb:option string, rc:option int, rd:collection { ra:{
  key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
  } @ { Collection }, re:bool } -> collection { key:address, value:collection {
  ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int,
  rg:real } @ { Collection } } @ { Collection } = (\b1 ->
  bind b1 as {ra:lkey_0, rb:lkey_1, rc:lkey_2, rd:tuples,
  re:shuffle_on_empty} in let all_targets =
  if shuffle_on_empty == true
    then
      (route_to_string_string_int {ra:2, rb:lkey_0, rc:lkey_1, rd:lkey_2}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:empty { ra:{ key:int, value:int },
       rb:string, rc:string, rd:int, re:int, rf:int, rg:real
       } @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection }
    else empty { key:address, value:collection { ra:{ key:int, value:int },
      rb:string, rc:string, rd:int, re:int, rf:int, rg:real } @ { Collection }
      } @ { Collection } in
  (all_targets.combine (tuples.fold ((\_accext -> (\r_tuple -> _accext.combine
    (bind r_tuple as
    {ra:rkey_0, rb:rkey_1, rc:rkey_2, rd:rkey_3, re:rkey_4, rf:rkey_5, rg:rkey_6}
    in
    (route_to_string_string_int {ra:2, rb:Some rkey_1, rc:Some rkey_2,
       rd:Some rkey_3}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {key:ip, value:{| ra:{ key:int, value:int }, rb:string,
       rc:string, rd:int, re:int, rf:int, rg:real | r_tuple|} @ { Collection }};
       _accmap)))) empty { key:address, value:collection { ra:{ key:int,
      value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
      } @ { Collection } } @ { Collection })))) empty { key:address,
    value:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
    re:int, rf:int, rg:real } @ { Collection } } @ { Collection })).groupBy
    ((\b1 -> bind b1 as {key:ip, value:tuple} in ip)) ((\acc -> (\b3 ->
    bind b3 as {key:ip, value:tuple} in tuple.combine acc))) empty { ra:{
    key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int, rg:real
    } @ { Collection })


declare nd_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_send_correctives : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { ra:int, rb:int, rc:int, rd:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid, rf:delta_tuples} in 
  let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:0, value:5}, {key:0, value:8}, {key:1, value:15}, {key:1, value:18},
    {key:4, value:43}, {key:4, value:47}, {key:5, value:53}, {key:5,
    value:57}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_2, rd:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2,
         re:map_val};
         _accmap)))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int,
        re:real } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 57
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_ORDERS vid as
            {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
            in
            (shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_2t0_4t2
               {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
               re:None immut, rf:delta_tuples2, rg:false}).fold ((\_accmap ->
              (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
               re:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};
                _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
               } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:int, rb:int, rc:int, rd:real
              } @ { Collection } } @ { Collection })))) empty { ra:address,
            rb:{ key:int, value:int }, rc:collection { ra:int, rb:int, rc:int,
            rd:real } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
            bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
            bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
            rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int, rb:int,
             rc:int, rd:real } @ { Collection }})))) {key:empty { key:int,
            value:int } @ { Seq }, value:empty { ra:int, rb:int, rc:int,
            rd:real } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_ORDERS_rcv_corrective_s57_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
               ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:corrective_vid, rf:vid_send_list_tup.key,
             rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 53
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_delete_ORDERS vid as
              {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
              in
              (shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER12_mSUPPLIER1_bind_0t0_2t2
                 {ra:None immut, rb:Some ORDERS_CUSTKEY, rc:None immut,
                 rd:delta_tuples2, re:false}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                 re:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};
                  _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                 } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:int, rb:int, rc:int, rd:real
                } @ { Collection } } @ { Collection })))) empty { ra:address,
              rb:{ key:int, value:int }, rc:collection { ra:int, rb:int,
              rc:int, rd:real } @ { Collection } } @ { Collection }).groupBy
              ((\b1 -> bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
              (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
              bind b5 as {ra:ip, rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int,
               rb:int, rc:int, rd:real } @ { Collection }})))) {key:empty {
              key:int, value:int } @ { Seq }, value:empty { ra:int, rb:int,
              rc:int, rd:real } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((delete_ORDERS_rcv_corrective_s53_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
                 ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
               re:corrective_vid, rf:vid_send_list_tup.key,
               rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 47
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_insert_ORDERS vid as
                {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                in
                (shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_2t0_4t2
                   {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                   re:None immut, rf:delta_tuples2, rg:false}).fold
                  ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                   re:map_val} in 
                   (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};
                    _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                   } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { ra:int, rb:int, rc:int, rd:real
                  } @ { Collection } } @ { Collection })))) empty { ra:address,
                rb:{ key:int, value:int }, rc:collection { ra:int, rb:int,
                rc:int, rd:real } @ { Collection } } @ { Collection }).groupBy
                ((\b1 -> bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { ra:int, rb:int, rc:int, rd:real } @ { Collection }}))))
                {key:empty { key:int, value:int } @ { Seq }, value:empty {
                ra:int, rb:int, rc:int, rd:real } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((insert_ORDERS_rcv_corrective_s47_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
                   ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                 re:corrective_vid, rf:vid_send_list_tup.key,
                 rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 43
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_insert_ORDERS vid as
                  {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                  in
                  (shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER12_mSUPPLIER1_bind_0t0_2t2
                     {ra:None immut, rb:Some ORDERS_CUSTKEY, rc:None immut,
                     rd:delta_tuples2, re:false}).fold ((\_accmap -> (\b3 ->
                    bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_1, rd:map_2, re:map_val} in 
                     (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};
                      _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                     } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { ra:int, rb:int, rc:int, rd:real
                    } @ { Collection } } @ { Collection })))) empty {
                  ra:address, rb:{ key:int, value:int }, rc:collection {
                  ra:int, rb:int, rc:int, rd:real } @ { Collection }
                  } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                  rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                  bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { ra:int, rb:int, rc:int, rd:real } @ { Collection }}))))
                  {key:empty { key:int, value:int } @ { Seq }, value:empty {
                  ra:int, rb:int, rc:int, rd:real } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((insert_ORDERS_rcv_corrective_s43_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
                     ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                   re:corrective_vid, rf:vid_send_list_tup.key,
                   rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count
              else if stmt_id == 18
                then let ips_vids =
                  (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                    nd_log_get_bound_delete_SUPPLIER vid as
                    {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                    in
                    (shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mORDERS12_bind_2t0_4t1
                       {ra:None immut, rb:None immut, rc:None immut,
                       rd:None immut, re:None immut, rf:delta_tuples2,
                       rg:false}).fold ((\_accmap -> (\b3 ->
                      bind b3 as {key:ip, value:tuples} in 
                      (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                       ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                       rc:map_1, rd:map_2, re:map_val} in 
                       (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                        rd:map_val};
                        _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                       } @ { Collection }};
                       _accmap)))) empty { ra:address, rb:{ key:int, value:int
                      }, rc:collection { ra:int, rb:int, rc:int, rd:real
                      } @ { Collection } } @ { Collection })))) empty {
                    ra:address, rb:{ key:int, value:int }, rc:collection {
                    ra:int, rb:int, rc:int, rd:real } @ { Collection }
                    } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                    rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                    bind b2 as {key:acc_vid, value:acc_tuples} in 
                    bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                    (acc_vid.insert vid;
                     {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                     ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                     ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                     empty { ra:int, rb:int, rc:int, rd:real
                     } @ { Collection }})))) {key:empty { key:int, value:int
                    } @ { Seq }, value:empty { ra:int, rb:int, rc:int, rd:real
                    } @ { Collection }} in
                  ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                    value:vid_send_list_tup} in 
                    ((delete_SUPPLIER_rcv_corrective_s18_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
                       ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                     rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                     rg:vid_send_list_tup.value};
                     acc_count + 1)))) acc_count
                else if stmt_id == 15
                  then let ips_vids =
                    (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                      nd_log_get_bound_delete_SUPPLIER vid as
                      {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                      in
                      (shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER12_mORDERS1_bind_2t0_4t1
                         {ra:None immut, rb:None immut, rc:None immut,
                         rd:None immut, re:None immut, rf:delta_tuples2,
                         rg:false}).fold ((\_accmap -> (\b3 ->
                        bind b3 as {key:ip, value:tuples} in 
                        (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                         ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                         rc:map_1, rd:map_2, re:map_val} in 
                         (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                          rd:map_val};
                          _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                         } @ { Collection }};
                         _accmap)))) empty { ra:address, rb:{ key:int,
                        value:int }, rc:collection { ra:int, rb:int, rc:int,
                        rd:real } @ { Collection } } @ { Collection }))))
                      empty { ra:address, rb:{ key:int, value:int },
                      rc:collection { ra:int, rb:int, rc:int, rd:real
                      } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                      bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                      (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                      bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                      (acc_vid.insert vid;
                       {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                       ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                       ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                       empty { ra:int, rb:int, rc:int, rd:real
                       } @ { Collection }})))) {key:empty { key:int, value:int
                      } @ { Seq }, value:empty { ra:int, rb:int, rc:int,
                      rd:real } @ { Collection }} in
                    ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                      value:vid_send_list_tup} in 
                      ((delete_SUPPLIER_rcv_corrective_s15_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
                         ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                       rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                       rg:vid_send_list_tup.value};
                       acc_count + 1)))) acc_count
                  else if stmt_id == 8
                    then let ips_vids =
                      (vid_list.fold ((\_accext -> (\vid -> _accext.combine
                        (bind nd_log_get_bound_insert_SUPPLIER vid as
                        {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                        in
                        (shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mORDERS12_bind_2t0_4t1
                           {ra:None immut, rb:None immut, rc:None immut,
                           rd:None immut, re:None immut, rf:delta_tuples2,
                           rg:false}).fold ((\_accmap -> (\b3 ->
                          bind b3 as {key:ip, value:tuples} in 
                          (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                           ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                           rc:map_1, rd:map_2, re:map_val} in 
                           (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                            rd:map_val};
                            _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                           } @ { Collection }};
                           _accmap)))) empty { ra:address, rb:{ key:int,
                          value:int }, rc:collection { ra:int, rb:int, rc:int,
                          rd:real } @ { Collection } } @ { Collection }))))
                        empty { ra:address, rb:{ key:int, value:int },
                        rc:collection { ra:int, rb:int, rc:int, rd:real
                        } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                        bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                        (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                        bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                        (acc_vid.insert vid;
                         {key:acc_vid, value:((acc_tuples.combine
                         tuples).groupBy ((\tuple -> tuple)) ((\_ -> (\_ ->
                         ()))) ()).fold ((\_accmap -> (\x ->
                         (_accmap.insert (x.key);_accmap)))) empty { ra:int,
                         rb:int, rc:int, rd:real } @ { Collection }}))))
                        {key:empty { key:int, value:int } @ { Seq },
                        value:empty { ra:int, rb:int, rc:int, rd:real
                        } @ { Collection }} in
                      ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                        value:vid_send_list_tup} in 
                        ((insert_SUPPLIER_rcv_corrective_s8_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
                           ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                         rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                         rg:vid_send_list_tup.value};
                         acc_count + 1)))) acc_count
                    else if stmt_id == 5
                      then let ips_vids =
                        (vid_list.fold ((\_accext -> (\vid -> _accext.combine
                          (bind nd_log_get_bound_insert_SUPPLIER vid as
                          {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                          in
                          (shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER12_mORDERS1_bind_2t0_4t1
                             {ra:None immut, rb:None immut, rc:None immut,
                             rd:None immut, re:None immut, rf:delta_tuples2,
                             rg:false}).fold ((\_accmap -> (\b3 ->
                            bind b3 as {key:ip, value:tuples} in 
                            (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                             ((\_accmap -> (\b3 -> bind b3 as {ra:vid,
                             rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
                             (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                              rd:map_val};
                              _accmap)))) empty { ra:int, rb:int, rc:int,
                             rd:real } @ { Collection }};
                             _accmap)))) empty { ra:address, rb:{ key:int,
                            value:int }, rc:collection { ra:int, rb:int,
                            rc:int, rd:real } @ { Collection }
                            } @ { Collection })))) empty { ra:address, rb:{
                          key:int, value:int }, rc:collection { ra:int, rb:int,
                          rc:int, rd:real } @ { Collection }
                          } @ { Collection }).groupBy ((\b1 ->
                          bind b1 as {ra:ip, rb:vid, rc:tuples} in ip))
                          ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                          value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                          rc:tuples} in 
                          (acc_vid.insert vid;
                           {key:acc_vid, value:((acc_tuples.combine
                           tuples).groupBy ((\tuple -> tuple)) ((\_ -> (\_ ->
                           ()))) ()).fold ((\_accmap -> (\x ->
                           (_accmap.insert (x.key);_accmap)))) empty { ra:int,
                           rb:int, rc:int, rd:real } @ { Collection }}))))
                          {key:empty { key:int, value:int } @ { Seq },
                          value:empty { ra:int, rb:int, rc:int, rd:real
                          } @ { Collection }} in
                        ips_vids.fold ((\acc_count -> (\b3 ->
                          bind b3 as {key:ip, value:vid_send_list_tup} in 
                          ((insert_SUPPLIER_rcv_corrective_s5_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
                             ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                           rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                           rg:vid_send_list_tup.value};
                           acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_send_correctives : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { ra:int, rb:int, rc:int, rd:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid, rf:delta_tuples} in 
  let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:0, value:2}, {key:0, value:6}, {key:1, value:12}, {key:1, value:16},
    {key:4, value:41}, {key:4, value:46}, {key:5, value:51}, {key:5,
    value:56}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_2, rd:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2,
         re:map_val};
         _accmap)))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int,
        re:real } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 56
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_ORDERS vid as
            {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
            in
            (shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_2t0_4t2
               {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
               re:None immut, rf:delta_tuples2, rg:false}).fold ((\_accmap ->
              (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
               re:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};
                _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
               } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:int, rb:int, rc:int, rd:real
              } @ { Collection } } @ { Collection })))) empty { ra:address,
            rb:{ key:int, value:int }, rc:collection { ra:int, rb:int, rc:int,
            rd:real } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
            bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
            bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
            rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int, rb:int,
             rc:int, rd:real } @ { Collection }})))) {key:empty { key:int,
            value:int } @ { Seq }, value:empty { ra:int, rb:int, rc:int,
            rd:real } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_ORDERS_rcv_corrective_s56_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
               ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:corrective_vid, rf:vid_send_list_tup.key,
             rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 51
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_delete_ORDERS vid as
              {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
              in
              (shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER11_mSUPPLIER1_bind_0t0_2t2
                 {ra:None immut, rb:Some ORDERS_CUSTKEY, rc:None immut,
                 rd:delta_tuples2, re:false}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                 re:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};
                  _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                 } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:int, rb:int, rc:int, rd:real
                } @ { Collection } } @ { Collection })))) empty { ra:address,
              rb:{ key:int, value:int }, rc:collection { ra:int, rb:int,
              rc:int, rd:real } @ { Collection } } @ { Collection }).groupBy
              ((\b1 -> bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
              (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
              bind b5 as {ra:ip, rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int,
               rb:int, rc:int, rd:real } @ { Collection }})))) {key:empty {
              key:int, value:int } @ { Seq }, value:empty { ra:int, rb:int,
              rc:int, rd:real } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((delete_ORDERS_rcv_corrective_s51_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
                 ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
               re:corrective_vid, rf:vid_send_list_tup.key,
               rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 46
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_insert_ORDERS vid as
                {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                in
                (shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_2t0_4t2
                   {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                   re:None immut, rf:delta_tuples2, rg:false}).fold
                  ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                   re:map_val} in 
                   (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};
                    _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                   } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { ra:int, rb:int, rc:int, rd:real
                  } @ { Collection } } @ { Collection })))) empty { ra:address,
                rb:{ key:int, value:int }, rc:collection { ra:int, rb:int,
                rc:int, rd:real } @ { Collection } } @ { Collection }).groupBy
                ((\b1 -> bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { ra:int, rb:int, rc:int, rd:real } @ { Collection }}))))
                {key:empty { key:int, value:int } @ { Seq }, value:empty {
                ra:int, rb:int, rc:int, rd:real } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((insert_ORDERS_rcv_corrective_s46_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
                   ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                 re:corrective_vid, rf:vid_send_list_tup.key,
                 rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 41
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_insert_ORDERS vid as
                  {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                  in
                  (shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER11_mSUPPLIER1_bind_0t0_2t2
                     {ra:None immut, rb:Some ORDERS_CUSTKEY, rc:None immut,
                     rd:delta_tuples2, re:false}).fold ((\_accmap -> (\b3 ->
                    bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_1, rd:map_2, re:map_val} in 
                     (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};
                      _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                     } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { ra:int, rb:int, rc:int, rd:real
                    } @ { Collection } } @ { Collection })))) empty {
                  ra:address, rb:{ key:int, value:int }, rc:collection {
                  ra:int, rb:int, rc:int, rd:real } @ { Collection }
                  } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                  rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                  bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { ra:int, rb:int, rc:int, rd:real } @ { Collection }}))))
                  {key:empty { key:int, value:int } @ { Seq }, value:empty {
                  ra:int, rb:int, rc:int, rd:real } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((insert_ORDERS_rcv_corrective_s41_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
                     ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                   re:corrective_vid, rf:vid_send_list_tup.key,
                   rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count
              else if stmt_id == 16
                then let ips_vids =
                  (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                    nd_log_get_bound_delete_SUPPLIER vid as
                    {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                    in
                    (shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mORDERS11_bind_2t0_4t1
                       {ra:None immut, rb:None immut, rc:None immut,
                       rd:None immut, re:None immut, rf:delta_tuples2,
                       rg:false}).fold ((\_accmap -> (\b3 ->
                      bind b3 as {key:ip, value:tuples} in 
                      (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                       ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                       rc:map_1, rd:map_2, re:map_val} in 
                       (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                        rd:map_val};
                        _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                       } @ { Collection }};
                       _accmap)))) empty { ra:address, rb:{ key:int, value:int
                      }, rc:collection { ra:int, rb:int, rc:int, rd:real
                      } @ { Collection } } @ { Collection })))) empty {
                    ra:address, rb:{ key:int, value:int }, rc:collection {
                    ra:int, rb:int, rc:int, rd:real } @ { Collection }
                    } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                    rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                    bind b2 as {key:acc_vid, value:acc_tuples} in 
                    bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                    (acc_vid.insert vid;
                     {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                     ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                     ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                     empty { ra:int, rb:int, rc:int, rd:real
                     } @ { Collection }})))) {key:empty { key:int, value:int
                    } @ { Seq }, value:empty { ra:int, rb:int, rc:int, rd:real
                    } @ { Collection }} in
                  ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                    value:vid_send_list_tup} in 
                    ((delete_SUPPLIER_rcv_corrective_s16_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
                       ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                     rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                     rg:vid_send_list_tup.value};
                     acc_count + 1)))) acc_count
                else if stmt_id == 12
                  then let ips_vids =
                    (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                      nd_log_get_bound_delete_SUPPLIER vid as
                      {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                      in
                      (shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER11_mORDERS1_bind_2t0_4t1
                         {ra:None immut, rb:None immut, rc:None immut,
                         rd:None immut, re:None immut, rf:delta_tuples2,
                         rg:false}).fold ((\_accmap -> (\b3 ->
                        bind b3 as {key:ip, value:tuples} in 
                        (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                         ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                         rc:map_1, rd:map_2, re:map_val} in 
                         (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                          rd:map_val};
                          _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                         } @ { Collection }};
                         _accmap)))) empty { ra:address, rb:{ key:int,
                        value:int }, rc:collection { ra:int, rb:int, rc:int,
                        rd:real } @ { Collection } } @ { Collection }))))
                      empty { ra:address, rb:{ key:int, value:int },
                      rc:collection { ra:int, rb:int, rc:int, rd:real
                      } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                      bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                      (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                      bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                      (acc_vid.insert vid;
                       {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                       ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                       ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                       empty { ra:int, rb:int, rc:int, rd:real
                       } @ { Collection }})))) {key:empty { key:int, value:int
                      } @ { Seq }, value:empty { ra:int, rb:int, rc:int,
                      rd:real } @ { Collection }} in
                    ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                      value:vid_send_list_tup} in 
                      ((delete_SUPPLIER_rcv_corrective_s12_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
                         ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                       rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                       rg:vid_send_list_tup.value};
                       acc_count + 1)))) acc_count
                  else if stmt_id == 6
                    then let ips_vids =
                      (vid_list.fold ((\_accext -> (\vid -> _accext.combine
                        (bind nd_log_get_bound_insert_SUPPLIER vid as
                        {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                        in
                        (shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mORDERS11_bind_2t0_4t1
                           {ra:None immut, rb:None immut, rc:None immut,
                           rd:None immut, re:None immut, rf:delta_tuples2,
                           rg:false}).fold ((\_accmap -> (\b3 ->
                          bind b3 as {key:ip, value:tuples} in 
                          (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                           ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                           rc:map_1, rd:map_2, re:map_val} in 
                           (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                            rd:map_val};
                            _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                           } @ { Collection }};
                           _accmap)))) empty { ra:address, rb:{ key:int,
                          value:int }, rc:collection { ra:int, rb:int, rc:int,
                          rd:real } @ { Collection } } @ { Collection }))))
                        empty { ra:address, rb:{ key:int, value:int },
                        rc:collection { ra:int, rb:int, rc:int, rd:real
                        } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                        bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                        (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                        bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                        (acc_vid.insert vid;
                         {key:acc_vid, value:((acc_tuples.combine
                         tuples).groupBy ((\tuple -> tuple)) ((\_ -> (\_ ->
                         ()))) ()).fold ((\_accmap -> (\x ->
                         (_accmap.insert (x.key);_accmap)))) empty { ra:int,
                         rb:int, rc:int, rd:real } @ { Collection }}))))
                        {key:empty { key:int, value:int } @ { Seq },
                        value:empty { ra:int, rb:int, rc:int, rd:real
                        } @ { Collection }} in
                      ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                        value:vid_send_list_tup} in 
                        ((insert_SUPPLIER_rcv_corrective_s6_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
                           ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                         rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                         rg:vid_send_list_tup.value};
                         acc_count + 1)))) acc_count
                    else if stmt_id == 2
                      then let ips_vids =
                        (vid_list.fold ((\_accext -> (\vid -> _accext.combine
                          (bind nd_log_get_bound_insert_SUPPLIER vid as
                          {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                          in
                          (shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER11_mORDERS1_bind_2t0_4t1
                             {ra:None immut, rb:None immut, rc:None immut,
                             rd:None immut, re:None immut, rf:delta_tuples2,
                             rg:false}).fold ((\_accmap -> (\b3 ->
                            bind b3 as {key:ip, value:tuples} in 
                            (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                             ((\_accmap -> (\b3 -> bind b3 as {ra:vid,
                             rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
                             (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                              rd:map_val};
                              _accmap)))) empty { ra:int, rb:int, rc:int,
                             rd:real } @ { Collection }};
                             _accmap)))) empty { ra:address, rb:{ key:int,
                            value:int }, rc:collection { ra:int, rb:int,
                            rc:int, rd:real } @ { Collection }
                            } @ { Collection })))) empty { ra:address, rb:{
                          key:int, value:int }, rc:collection { ra:int, rb:int,
                          rc:int, rd:real } @ { Collection }
                          } @ { Collection }).groupBy ((\b1 ->
                          bind b1 as {ra:ip, rb:vid, rc:tuples} in ip))
                          ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                          value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                          rc:tuples} in 
                          (acc_vid.insert vid;
                           {key:acc_vid, value:((acc_tuples.combine
                           tuples).groupBy ((\tuple -> tuple)) ((\_ -> (\_ ->
                           ()))) ()).fold ((\_accmap -> (\x ->
                           (_accmap.insert (x.key);_accmap)))) empty { ra:int,
                           rb:int, rc:int, rd:real } @ { Collection }}))))
                          {key:empty { key:int, value:int } @ { Seq },
                          value:empty { ra:int, rb:int, rc:int, rd:real
                          } @ { Collection }} in
                        ips_vids.fold ((\acc_count -> (\b3 ->
                          bind b3 as {key:ip, value:vid_send_list_tup} in 
                          ((insert_SUPPLIER_rcv_corrective_s2_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
                             ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                           rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                           rg:vid_send_list_tup.value};
                           acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_REVENUE_mCUSTOMER12_mSUPPLIER1_send_correctives : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { ra:int, rb:int, rc:int, rd:real } @ { Collection } } -> int =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:0, value:4}, {key:1, value:14}, {key:2, value:28}, {key:3,
    value:37}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_2, rd:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2,
         re:map_val};
         _accmap)))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int,
        re:real } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 37
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_CUSTOMER vid as
            {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
            in
            (shuffle_REVENUE_mCUSTOMER12_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_2t0_4t2
               {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
               re:None immut, rf:delta_tuples2, rg:false}).fold ((\_accmap ->
              (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
               re:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};
                _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
               } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:int, rb:int, rc:int, rd:real
              } @ { Collection } } @ { Collection })))) empty { ra:address,
            rb:{ key:int, value:int }, rc:collection { ra:int, rb:int, rc:int,
            rd:real } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
            bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
            bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
            rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int, rb:int,
             rc:int, rd:real } @ { Collection }})))) {key:empty { key:int,
            value:int } @ { Seq }, value:empty { ra:int, rb:int, rc:int,
            rd:real } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_CUSTOMER_rcv_corrective_s37_m_REVENUE_mCUSTOMER12_mSUPPLIER1,
               ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:corrective_vid, rf:vid_send_list_tup.key,
             rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 28
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_CUSTOMER vid as
              {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
              in
              (shuffle_REVENUE_mCUSTOMER12_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_2t0_4t2
                 {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                 re:None immut, rf:delta_tuples2, rg:false}).fold ((\_accmap ->
                (\b3 -> bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                 re:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};
                  _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                 } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:int, rb:int, rc:int, rd:real
                } @ { Collection } } @ { Collection })))) empty { ra:address,
              rb:{ key:int, value:int }, rc:collection { ra:int, rb:int,
              rc:int, rd:real } @ { Collection } } @ { Collection }).groupBy
              ((\b1 -> bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
              (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
              bind b5 as {ra:ip, rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int,
               rb:int, rc:int, rd:real } @ { Collection }})))) {key:empty {
              key:int, value:int } @ { Seq }, value:empty { ra:int, rb:int,
              rc:int, rd:real } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_CUSTOMER_rcv_corrective_s28_m_REVENUE_mCUSTOMER12_mSUPPLIER1,
                 ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
               re:corrective_vid, rf:vid_send_list_tup.key,
               rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 14
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_delete_SUPPLIER vid as
                {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                in
                (shuffle_REVENUE_mCUSTOMER12_mSUPPLIER1_to_REVENUE_mCUSTOMER12_bind_2t0_4t1
                   {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                   re:None immut, rf:delta_tuples2, rg:false}).fold
                  ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                   re:map_val} in 
                   (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};
                    _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                   } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { ra:int, rb:int, rc:int, rd:real
                  } @ { Collection } } @ { Collection })))) empty { ra:address,
                rb:{ key:int, value:int }, rc:collection { ra:int, rb:int,
                rc:int, rd:real } @ { Collection } } @ { Collection }).groupBy
                ((\b1 -> bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { ra:int, rb:int, rc:int, rd:real } @ { Collection }}))))
                {key:empty { key:int, value:int } @ { Seq }, value:empty {
                ra:int, rb:int, rc:int, rd:real } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((delete_SUPPLIER_rcv_corrective_s14_m_REVENUE_mCUSTOMER12_mSUPPLIER1,
                   ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                 re:corrective_vid, rf:vid_send_list_tup.key,
                 rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 4
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_insert_SUPPLIER vid as
                  {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                  in
                  (shuffle_REVENUE_mCUSTOMER12_mSUPPLIER1_to_REVENUE_mCUSTOMER12_bind_2t0_4t1
                     {ra:None immut, rb:None immut, rc:None immut,
                     rd:None immut, re:None immut, rf:delta_tuples2, rg:false}).fold
                    ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_1, rd:map_2, re:map_val} in 
                     (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};
                      _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                     } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { ra:int, rb:int, rc:int, rd:real
                    } @ { Collection } } @ { Collection })))) empty {
                  ra:address, rb:{ key:int, value:int }, rc:collection {
                  ra:int, rb:int, rc:int, rd:real } @ { Collection }
                  } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                  rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                  bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { ra:int, rb:int, rc:int, rd:real } @ { Collection }}))))
                  {key:empty { key:int, value:int } @ { Seq }, value:empty {
                  ra:int, rb:int, rc:int, rd:real } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((insert_SUPPLIER_rcv_corrective_s4_m_REVENUE_mCUSTOMER12_mSUPPLIER1,
                     ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                   re:corrective_vid, rf:vid_send_list_tup.key,
                   rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_REVENUE_mCUSTOMER11_mSUPPLIER1_send_correctives : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { ra:int, rb:int, rc:int, rd:real } @ { Collection } } -> int =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:0, value:1}, {key:1, value:11}, {key:2, value:27}, {key:3,
    value:36}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_2, rd:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2,
         re:map_val};
         _accmap)))) empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int,
        re:real } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 36
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_CUSTOMER vid as
            {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
            in
            (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_2t0_4t2
               {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
               re:None immut, rf:delta_tuples2, rg:false}).fold ((\_accmap ->
              (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
               re:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};
                _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
               } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:int, rb:int, rc:int, rd:real
              } @ { Collection } } @ { Collection })))) empty { ra:address,
            rb:{ key:int, value:int }, rc:collection { ra:int, rb:int, rc:int,
            rd:real } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
            bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
            bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
            rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int, rb:int,
             rc:int, rd:real } @ { Collection }})))) {key:empty { key:int,
            value:int } @ { Seq }, value:empty { ra:int, rb:int, rc:int,
            rd:real } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_CUSTOMER_rcv_corrective_s36_m_REVENUE_mCUSTOMER11_mSUPPLIER1,
               ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:corrective_vid, rf:vid_send_list_tup.key,
             rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 27
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_CUSTOMER vid as
              {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
              in
              (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_2t0_4t2
                 {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                 re:None immut, rf:delta_tuples2, rg:false}).fold ((\_accmap ->
                (\b3 -> bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                 re:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};
                  _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                 } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:int, rb:int, rc:int, rd:real
                } @ { Collection } } @ { Collection })))) empty { ra:address,
              rb:{ key:int, value:int }, rc:collection { ra:int, rb:int,
              rc:int, rd:real } @ { Collection } } @ { Collection }).groupBy
              ((\b1 -> bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
              (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
              bind b5 as {ra:ip, rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int,
               rb:int, rc:int, rd:real } @ { Collection }})))) {key:empty {
              key:int, value:int } @ { Seq }, value:empty { ra:int, rb:int,
              rc:int, rd:real } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_CUSTOMER_rcv_corrective_s27_m_REVENUE_mCUSTOMER11_mSUPPLIER1,
                 ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
               re:corrective_vid, rf:vid_send_list_tup.key,
               rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 11
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_delete_SUPPLIER vid as
                {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                in
                (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER1_to_REVENUE_mCUSTOMER11_bind_2t0_4t1
                   {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                   re:None immut, rf:delta_tuples2, rg:false}).fold
                  ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                   re:map_val} in 
                   (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};
                    _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                   } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { ra:int, rb:int, rc:int, rd:real
                  } @ { Collection } } @ { Collection })))) empty { ra:address,
                rb:{ key:int, value:int }, rc:collection { ra:int, rb:int,
                rc:int, rd:real } @ { Collection } } @ { Collection }).groupBy
                ((\b1 -> bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { ra:int, rb:int, rc:int, rd:real } @ { Collection }}))))
                {key:empty { key:int, value:int } @ { Seq }, value:empty {
                ra:int, rb:int, rc:int, rd:real } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((delete_SUPPLIER_rcv_corrective_s11_m_REVENUE_mCUSTOMER11_mSUPPLIER1,
                   ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                 re:corrective_vid, rf:vid_send_list_tup.key,
                 rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 1
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_insert_SUPPLIER vid as
                  {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                  in
                  (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER1_to_REVENUE_mCUSTOMER11_bind_2t0_4t1
                     {ra:None immut, rb:None immut, rc:None immut,
                     rd:None immut, re:None immut, rf:delta_tuples2, rg:false}).fold
                    ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_1, rd:map_2, re:map_val} in 
                     (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};
                      _accmap)))) empty { ra:int, rb:int, rc:int, rd:real
                     } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { ra:int, rb:int, rc:int, rd:real
                    } @ { Collection } } @ { Collection })))) empty {
                  ra:address, rb:{ key:int, value:int }, rc:collection {
                  ra:int, rb:int, rc:int, rd:real } @ { Collection }
                  } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                  rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                  bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { ra:int, rb:int, rc:int, rd:real } @ { Collection }}))))
                  {key:empty { key:int, value:int } @ { Seq }, value:empty {
                  ra:int, rb:int, rc:int, rd:real } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((insert_SUPPLIER_rcv_corrective_s1_m_REVENUE_mCUSTOMER11_mSUPPLIER1,
                     ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                   re:corrective_vid, rf:vid_send_list_tup.key,
                   rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_REVENUE_mCUSTOMER11_mLINEITEM5_send_correctives : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { ra:int, rb:int, rc:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:2, value:25}, {key:2, value:26}, {key:3, value:34}, {key:3, value:35},
    {key:6, value:59}, {key:6, value:62}, {key:6, value:63}, {key:6, value:66},
    {key:7, value:72}, {key:7, value:75}, {key:7, value:76}, {key:7,
    value:79}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_val};_accmap))))
        empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
        } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 79
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_LINEITEM vid as
            {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
            in
            (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER12_mSUPPLIER1_bind_1t0
               {ra:None immut, rb:None immut, rc:Some LINEITEM_SUPPKEY,
               rd:delta_tuples2, re:false}).fold ((\_accmap -> (\b3 ->
              bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
               empty { ra:int, rb:int, rc:int } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:int, rb:int, rc:int } @ { Collection }
              } @ { Collection })))) empty { ra:address, rb:{ key:int,
            value:int }, rc:collection { ra:int, rb:int, rc:int
            } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
            bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
            bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
            rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int, rb:int,
             rc:int } @ { Collection }})))) {key:empty { key:int, value:int
            } @ { Seq }, value:empty { ra:int, rb:int, rc:int
            } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_LINEITEM_rcv_corrective_s79_m_REVENUE_mCUSTOMER11_mLINEITEM5,
               ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:corrective_vid, rf:vid_send_list_tup.key,
             rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 76
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_delete_LINEITEM vid as
              {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
              in
              (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER12_bind_4t0
                 {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                 re:None immut, rf:delta_tuples2, rg:false}).fold ((\_accmap ->
                (\b3 -> bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
                 rd:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
                 empty { ra:int, rb:int, rc:int } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:int, rb:int, rc:int } @ { Collection }
                } @ { Collection })))) empty { ra:address, rb:{ key:int,
              value:int }, rc:collection { ra:int, rb:int, rc:int
              } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
              bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
              bind b2 as {key:acc_vid, value:acc_tuples} in bind b5 as {ra:ip,
              rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:int,
               rb:int, rc:int } @ { Collection }})))) {key:empty { key:int,
              value:int } @ { Seq }, value:empty { ra:int, rb:int, rc:int
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((delete_LINEITEM_rcv_corrective_s76_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                 ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
               re:corrective_vid, rf:vid_send_list_tup.key,
               rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 75
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_delete_LINEITEM vid as
                {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                in
                (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER11_mSUPPLIER1_bind_1t0
                   {ra:None immut, rb:None immut, rc:Some LINEITEM_SUPPKEY,
                   rd:delta_tuples2, re:false}).fold ((\_accmap -> (\b3 ->
                  bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
                   rd:map_val} in 
                   (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
                   empty { ra:int, rb:int, rc:int } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { ra:int, rb:int, rc:int } @ { Collection }
                  } @ { Collection })))) empty { ra:address, rb:{ key:int,
                value:int }, rc:collection { ra:int, rb:int, rc:int
                } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                bind b2 as {key:acc_vid, value:acc_tuples} in 
                bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { ra:int, rb:int, rc:int } @ { Collection }}))))
                {key:empty { key:int, value:int } @ { Seq }, value:empty {
                ra:int, rb:int, rc:int } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((delete_LINEITEM_rcv_corrective_s75_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                   ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                 re:corrective_vid, rf:vid_send_list_tup.key,
                 rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 72
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_delete_LINEITEM vid as
                  {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                  in
                  (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER11_bind_4t0
                     {ra:None immut, rb:None immut, rc:None immut,
                     rd:None immut, re:None immut, rf:delta_tuples2, rg:false}).fold
                    ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_1, rd:map_val} in 
                     (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
                     empty { ra:int, rb:int, rc:int } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { ra:int, rb:int, rc:int } @ { Collection }
                    } @ { Collection })))) empty { ra:address, rb:{ key:int,
                  value:int }, rc:collection { ra:int, rb:int, rc:int
                  } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                  (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { ra:int, rb:int, rc:int } @ { Collection }}))))
                  {key:empty { key:int, value:int } @ { Seq }, value:empty {
                  ra:int, rb:int, rc:int } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((delete_LINEITEM_rcv_corrective_s72_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                     ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                   re:corrective_vid, rf:vid_send_list_tup.key,
                   rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count
              else if stmt_id == 66
                then let ips_vids =
                  (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                    nd_log_get_bound_insert_LINEITEM vid as
                    {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                    in
                    (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER12_mSUPPLIER1_bind_1t0
                       {ra:None immut, rb:None immut, rc:Some LINEITEM_SUPPKEY,
                       rd:delta_tuples2, re:false}).fold ((\_accmap -> (\b3 ->
                      bind b3 as {key:ip, value:tuples} in 
                      (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                       ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                       rc:map_1, rd:map_val} in 
                       (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};_accmap))))
                       empty { ra:int, rb:int, rc:int } @ { Collection }};
                       _accmap)))) empty { ra:address, rb:{ key:int, value:int
                      }, rc:collection { ra:int, rb:int, rc:int
                      } @ { Collection } } @ { Collection })))) empty {
                    ra:address, rb:{ key:int, value:int }, rc:collection {
                    ra:int, rb:int, rc:int } @ { Collection }
                    } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                    rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                    bind b2 as {key:acc_vid, value:acc_tuples} in 
                    bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                    (acc_vid.insert vid;
                     {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                     ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                     ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                     empty { ra:int, rb:int, rc:int } @ { Collection }}))))
                    {key:empty { key:int, value:int } @ { Seq }, value:empty {
                    ra:int, rb:int, rc:int } @ { Collection }} in
                  ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                    value:vid_send_list_tup} in 
                    ((insert_LINEITEM_rcv_corrective_s66_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                       ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                     rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                     rg:vid_send_list_tup.value};
                     acc_count + 1)))) acc_count
                else if stmt_id == 63
                  then let ips_vids =
                    (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                      nd_log_get_bound_insert_LINEITEM vid as
                      {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                      in
                      (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER12_bind_4t0
                         {ra:None immut, rb:None immut, rc:None immut,
                         rd:None immut, re:None immut, rf:delta_tuples2,
                         rg:false}).fold ((\_accmap -> (\b3 ->
                        bind b3 as {key:ip, value:tuples} in 
                        (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                         ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                         rc:map_1, rd:map_val} in 
                         (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};
                          _accmap)))) empty { ra:int, rb:int, rc:int
                         } @ { Collection }};
                         _accmap)))) empty { ra:address, rb:{ key:int,
                        value:int }, rc:collection { ra:int, rb:int, rc:int
                        } @ { Collection } } @ { Collection })))) empty {
                      ra:address, rb:{ key:int, value:int }, rc:collection {
                      ra:int, rb:int, rc:int } @ { Collection }
                      } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                      rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                      bind b2 as {key:acc_vid, value:acc_tuples} in 
                      bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                      (acc_vid.insert vid;
                       {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                       ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                       ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                       empty { ra:int, rb:int, rc:int } @ { Collection }}))))
                      {key:empty { key:int, value:int } @ { Seq },
                      value:empty { ra:int, rb:int, rc:int } @ { Collection }}
                    in
                    ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                      value:vid_send_list_tup} in 
                      ((insert_LINEITEM_rcv_corrective_s63_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                         ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                       rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                       rg:vid_send_list_tup.value};
                       acc_count + 1)))) acc_count
                  else if stmt_id == 62
                    then let ips_vids =
                      (vid_list.fold ((\_accext -> (\vid -> _accext.combine
                        (bind nd_log_get_bound_insert_LINEITEM vid as
                        {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                        in
                        (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER11_mSUPPLIER1_bind_1t0
                           {ra:None immut, rb:None immut,
                           rc:Some LINEITEM_SUPPKEY, rd:delta_tuples2,
                           re:false}).fold ((\_accmap -> (\b3 ->
                          bind b3 as {key:ip, value:tuples} in 
                          (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                           ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                           rc:map_1, rd:map_val} in 
                           (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};
                            _accmap)))) empty { ra:int, rb:int, rc:int
                           } @ { Collection }};
                           _accmap)))) empty { ra:address, rb:{ key:int,
                          value:int }, rc:collection { ra:int, rb:int, rc:int
                          } @ { Collection } } @ { Collection })))) empty {
                        ra:address, rb:{ key:int, value:int }, rc:collection {
                        ra:int, rb:int, rc:int } @ { Collection }
                        } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                        rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                        bind b2 as {key:acc_vid, value:acc_tuples} in 
                        bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                        (acc_vid.insert vid;
                         {key:acc_vid, value:((acc_tuples.combine
                         tuples).groupBy ((\tuple -> tuple)) ((\_ -> (\_ ->
                         ()))) ()).fold ((\_accmap -> (\x ->
                         (_accmap.insert (x.key);_accmap)))) empty { ra:int,
                         rb:int, rc:int } @ { Collection }})))) {key:empty {
                        key:int, value:int } @ { Seq }, value:empty { ra:int,
                        rb:int, rc:int } @ { Collection }} in
                      ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                        value:vid_send_list_tup} in 
                        ((insert_LINEITEM_rcv_corrective_s62_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                           ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                         rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                         rg:vid_send_list_tup.value};
                         acc_count + 1)))) acc_count
                    else if stmt_id == 59
                      then let ips_vids =
                        (vid_list.fold ((\_accext -> (\vid -> _accext.combine
                          (bind nd_log_get_bound_insert_LINEITEM vid as
                          {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                          in
                          (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER11_bind_4t0
                             {ra:None immut, rb:None immut, rc:None immut,
                             rd:None immut, re:None immut, rf:delta_tuples2,
                             rg:false}).fold ((\_accmap -> (\b3 ->
                            bind b3 as {key:ip, value:tuples} in 
                            (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                             ((\_accmap -> (\b3 -> bind b3 as {ra:vid,
                             rb:map_0, rc:map_1, rd:map_val} in 
                             (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};
                              _accmap)))) empty { ra:int, rb:int, rc:int
                             } @ { Collection }};
                             _accmap)))) empty { ra:address, rb:{ key:int,
                            value:int }, rc:collection { ra:int, rb:int, rc:int
                            } @ { Collection } } @ { Collection })))) empty {
                          ra:address, rb:{ key:int, value:int },
                          rc:collection { ra:int, rb:int, rc:int
                          } @ { Collection } } @ { Collection }).groupBy
                          ((\b1 -> bind b1 as {ra:ip, rb:vid, rc:tuples} in 
                          ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                          value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                          rc:tuples} in 
                          (acc_vid.insert vid;
                           {key:acc_vid, value:((acc_tuples.combine
                           tuples).groupBy ((\tuple -> tuple)) ((\_ -> (\_ ->
                           ()))) ()).fold ((\_accmap -> (\x ->
                           (_accmap.insert (x.key);_accmap)))) empty { ra:int,
                           rb:int, rc:int } @ { Collection }})))) {key:empty {
                          key:int, value:int } @ { Seq }, value:empty { ra:int,
                          rb:int, rc:int } @ { Collection }} in
                        ips_vids.fold ((\acc_count -> (\b3 ->
                          bind b3 as {key:ip, value:vid_send_list_tup} in 
                          ((insert_LINEITEM_rcv_corrective_s59_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                             ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                           rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                           rg:vid_send_list_tup.value};
                           acc_count + 1)))) acc_count
                      else if stmt_id == 35
                        then let ips_vids =
                          (vid_list.fold ((\_accext -> (\vid -> _accext.combine
                            (bind nd_log_get_bound_delete_CUSTOMER vid as
                            {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                            in
                            (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_2t1
                               {ra:None immut, rb:None immut, rc:None immut,
                               rd:None immut, re:delta_tuples2, rf:false}).fold
                              ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                              value:tuples} in 
                              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                               ((\_accmap -> (\b3 -> bind b3 as {ra:vid,
                               rb:map_0, rc:map_1, rd:map_val} in 
                               (_accmap.insert {ra:map_0, rb:map_1, rc:map_val};
                                _accmap)))) empty { ra:int, rb:int, rc:int
                               } @ { Collection }};
                               _accmap)))) empty { ra:address, rb:{ key:int,
                              value:int }, rc:collection { ra:int, rb:int,
                              rc:int } @ { Collection } } @ { Collection }))))
                            empty { ra:address, rb:{ key:int, value:int },
                            rc:collection { ra:int, rb:int, rc:int
                            } @ { Collection } } @ { Collection }).groupBy
                            ((\b1 -> bind b1 as {ra:ip, rb:vid, rc:tuples} in 
                            ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                            value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                            rc:tuples} in 
                            (acc_vid.insert vid;
                             {key:acc_vid, value:((acc_tuples.combine
                             tuples).groupBy ((\tuple -> tuple)) ((\_ -> (\_ ->
                             ()))) ()).fold ((\_accmap -> (\x ->
                             (_accmap.insert (x.key);_accmap)))) empty {
                             ra:int, rb:int, rc:int } @ { Collection }}))))
                            {key:empty { key:int, value:int } @ { Seq },
                            value:empty { ra:int, rb:int, rc:int
                            } @ { Collection }} in
                          ips_vids.fold ((\acc_count -> (\b3 ->
                            bind b3 as {key:ip, value:vid_send_list_tup} in 
                            ((delete_CUSTOMER_rcv_corrective_s35_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                               ip)<- {ra:orig_addr, rb:orig_stmt_id,
                             rc:orig_vid, rd:hop, re:corrective_vid,
                             rf:vid_send_list_tup.key,
                             rg:vid_send_list_tup.value};
                             acc_count + 1)))) acc_count
                        else if stmt_id == 34
                          then let ips_vids =
                            (vid_list.fold ((\_accext -> (\vid ->
                              _accext.combine (bind
                              nd_log_get_bound_delete_CUSTOMER vid as
                              {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                              in
                              (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mLINEITEM4_bind_2t1
                                 {ra:None immut, rb:None immut, rc:None immut,
                                 rd:None immut, re:delta_tuples2, rf:false}).fold
                                ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                value:tuples} in 
                                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                                 ((\_accmap -> (\b3 -> bind b3 as {ra:vid,
                                 rb:map_0, rc:map_1, rd:map_val} in 
                                 (_accmap.insert {ra:map_0, rb:map_1,
                                  rc:map_val};
                                  _accmap)))) empty { ra:int, rb:int, rc:int
                                 } @ { Collection }};
                                 _accmap)))) empty { ra:address, rb:{ key:int,
                                value:int }, rc:collection { ra:int, rb:int,
                                rc:int } @ { Collection } } @ { Collection }))))
                              empty { ra:address, rb:{ key:int, value:int },
                              rc:collection { ra:int, rb:int, rc:int
                              } @ { Collection } } @ { Collection }).groupBy
                              ((\b1 -> bind b1 as {ra:ip, rb:vid,
                              rc:tuples} in ip)) ((\b2 -> (\b5 ->
                              bind b2 as {key:acc_vid, value:acc_tuples} in 
                              bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                              (acc_vid.insert vid;
                               {key:acc_vid, value:((acc_tuples.combine
                               tuples).groupBy ((\tuple -> tuple)) ((\_ ->
                               (\_ -> ()))) ()).fold ((\_accmap -> (\x ->
                               (_accmap.insert (x.key);_accmap)))) empty {
                               ra:int, rb:int, rc:int } @ { Collection }}))))
                              {key:empty { key:int, value:int } @ { Seq },
                              value:empty { ra:int, rb:int, rc:int
                              } @ { Collection }} in
                            ips_vids.fold ((\acc_count -> (\b3 ->
                              bind b3 as {key:ip, value:vid_send_list_tup} in 
                              ((delete_CUSTOMER_rcv_corrective_s34_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                                 ip)<- {ra:orig_addr, rb:orig_stmt_id,
                               rc:orig_vid, rd:hop, re:corrective_vid,
                               rf:vid_send_list_tup.key,
                               rg:vid_send_list_tup.value};
                               acc_count + 1)))) acc_count
                          else if stmt_id == 26
                            then let ips_vids =
                              (vid_list.fold ((\_accext -> (\vid ->
                                _accext.combine (bind
                                nd_log_get_bound_insert_CUSTOMER vid as
                                {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                                in
                                (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_2t1
                                   {ra:None immut, rb:None immut,
                                   rc:None immut, rd:None immut,
                                   re:delta_tuples2, rf:false}).fold
                                  ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                  value:tuples} in 
                                  (_accmap.insert {ra:ip, rb:vid,
                                   rc:tuples.fold ((\_accmap -> (\b3 ->
                                   bind b3 as {ra:vid, rb:map_0, rc:map_1,
                                   rd:map_val} in 
                                   (_accmap.insert {ra:map_0, rb:map_1,
                                    rc:map_val};
                                    _accmap)))) empty { ra:int, rb:int, rc:int
                                   } @ { Collection }};
                                   _accmap)))) empty { ra:address, rb:{
                                  key:int, value:int }, rc:collection { ra:int,
                                  rb:int, rc:int } @ { Collection }
                                  } @ { Collection })))) empty { ra:address,
                                rb:{ key:int, value:int }, rc:collection {
                                ra:int, rb:int, rc:int } @ { Collection }
                                } @ { Collection }).groupBy ((\b1 ->
                                bind b1 as {ra:ip, rb:vid, rc:tuples} in ip))
                                ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                                value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                                rc:tuples} in 
                                (acc_vid.insert vid;
                                 {key:acc_vid, value:((acc_tuples.combine
                                 tuples).groupBy ((\tuple -> tuple)) ((\_ ->
                                 (\_ -> ()))) ()).fold ((\_accmap -> (\x ->
                                 (_accmap.insert (x.key);_accmap)))) empty {
                                 ra:int, rb:int, rc:int } @ { Collection }}))))
                                {key:empty { key:int, value:int } @ { Seq },
                                value:empty { ra:int, rb:int, rc:int
                                } @ { Collection }} in
                              ips_vids.fold ((\acc_count -> (\b3 ->
                                bind b3 as {key:ip,
                                value:vid_send_list_tup} in 
                                ((insert_CUSTOMER_rcv_corrective_s26_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                                   ip)<- {ra:orig_addr, rb:orig_stmt_id,
                                 rc:orig_vid, rd:hop, re:corrective_vid,
                                 rf:vid_send_list_tup.key,
                                 rg:vid_send_list_tup.value};
                                 acc_count + 1)))) acc_count
                            else if stmt_id == 25
                              then let ips_vids =
                                (vid_list.fold ((\_accext -> (\vid ->
                                  _accext.combine (bind
                                  nd_log_get_bound_insert_CUSTOMER vid as
                                  {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                                  in
                                  (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mLINEITEM4_bind_2t1
                                     {ra:None immut, rb:None immut,
                                     rc:None immut, rd:None immut,
                                     re:delta_tuples2, rf:false}).fold
                                    ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                    value:tuples} in 
                                    (_accmap.insert {ra:ip, rb:vid,
                                     rc:tuples.fold ((\_accmap -> (\b3 ->
                                     bind b3 as {ra:vid, rb:map_0, rc:map_1,
                                     rd:map_val} in 
                                     (_accmap.insert {ra:map_0, rb:map_1,
                                      rc:map_val};
                                      _accmap)))) empty { ra:int, rb:int,
                                     rc:int } @ { Collection }};
                                     _accmap)))) empty { ra:address, rb:{
                                    key:int, value:int }, rc:collection {
                                    ra:int, rb:int, rc:int } @ { Collection }
                                    } @ { Collection })))) empty { ra:address,
                                  rb:{ key:int, value:int }, rc:collection {
                                  ra:int, rb:int, rc:int } @ { Collection }
                                  } @ { Collection }).groupBy ((\b1 ->
                                  bind b1 as {ra:ip, rb:vid, rc:tuples} in ip))
                                  ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                                  value:acc_tuples} in bind b5 as {ra:ip,
                                  rb:vid, rc:tuples} in 
                                  (acc_vid.insert vid;
                                   {key:acc_vid, value:((acc_tuples.combine
                                   tuples).groupBy ((\tuple -> tuple)) ((\_ ->
                                   (\_ -> ()))) ()).fold ((\_accmap -> (\x ->
                                   (_accmap.insert (x.key);_accmap)))) empty {
                                   ra:int, rb:int, rc:int } @ { Collection }}))))
                                  {key:empty { key:int, value:int } @ { Seq },
                                  value:empty { ra:int, rb:int, rc:int
                                  } @ { Collection }} in
                                ips_vids.fold ((\acc_count -> (\b3 ->
                                  bind b3 as {key:ip,
                                  value:vid_send_list_tup} in 
                                  ((insert_CUSTOMER_rcv_corrective_s25_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                                     ip)<- {ra:orig_addr, rb:orig_stmt_id,
                                   rc:orig_vid, rd:hop, re:corrective_vid,
                                   rf:vid_send_list_tup.key,
                                   rg:vid_send_list_tup.value};
                                   acc_count + 1)))) acc_count else acc_count)))
        0)


declare nd_REVENUE_mSUPPLIER12_send_correctives : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:0, value:0}, {key:1, value:10}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_2, rd:map_3, re:map_4, rf:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
         rf:map_4, rg:map_val};
         _accmap)))) empty { ra:{ key:int, value:int }, rb:string, rc:string,
        rd:int, re:int, rf:int, rg:real } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 10
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_SUPPLIER vid as
            {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
            in
            (shuffle_REVENUE_mSUPPLIER12_to_REVENUE_bind_0t0_1t1_2t2
               {ra:None immut, rb:None immut, rc:None immut, rd:delta_tuples2,
               re:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
              value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
               re:map_3, rf:map_4, rg:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                re:map_4, rf:map_val};
                _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
               re:int, rf:real } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
              rf:real } @ { Collection } } @ { Collection })))) empty {
            ra:address, rb:{ key:int, value:int }, rc:collection { ra:string,
            rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
             rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }}))))
            {key:empty { key:int, value:int } @ { Seq }, value:empty {
            ra:string, rb:string, rc:int, rd:int, re:int, rf:real
            } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_SUPPLIER_rcv_corrective_s10_m_REVENUE_mSUPPLIER12, ip)<- {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
             rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 0
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_SUPPLIER vid as
              {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
              in
              (shuffle_REVENUE_mSUPPLIER12_to_REVENUE_bind_0t0_1t1_2t2
                 {ra:None immut, rb:None immut, rc:None immut,
                 rd:delta_tuples2, re:false}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                 re:map_3, rf:map_4, rg:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                  re:map_4, rf:map_val};
                  _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                 re:int, rf:real } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
                rf:real } @ { Collection } } @ { Collection })))) empty {
              ra:address, rb:{ key:int, value:int }, rc:collection { ra:string,
              rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
              } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
              rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
              value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
               rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }}))))
              {key:empty { key:int, value:int } @ { Seq }, value:empty {
              ra:string, rb:string, rc:int, rd:int, re:int, rf:real
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_SUPPLIER_rcv_corrective_s0_m_REVENUE_mSUPPLIER12, ip)<- {ra:orig_addr,
               rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
               rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_REVENUE_mSUPPLIER11_send_correctives : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:0, value:0}, {key:1, value:10}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_2, rd:map_3, re:map_4, rf:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
         rf:map_4, rg:map_val};
         _accmap)))) empty { ra:{ key:int, value:int }, rb:string, rc:string,
        rd:int, re:int, rf:int, rg:real } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 10
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_SUPPLIER vid as
            {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
            in
            (shuffle_REVENUE_mSUPPLIER11_to_REVENUE_bind_0t0_1t1_2t2
               {ra:None immut, rb:None immut, rc:None immut, rd:delta_tuples2,
               re:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
              value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
               re:map_3, rf:map_4, rg:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                re:map_4, rf:map_val};
                _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
               re:int, rf:real } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
              rf:real } @ { Collection } } @ { Collection })))) empty {
            ra:address, rb:{ key:int, value:int }, rc:collection { ra:string,
            rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
             rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }}))))
            {key:empty { key:int, value:int } @ { Seq }, value:empty {
            ra:string, rb:string, rc:int, rd:int, re:int, rf:real
            } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_SUPPLIER_rcv_corrective_s10_m_REVENUE_mSUPPLIER11, ip)<- {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
             rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 0
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_SUPPLIER vid as
              {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
              in
              (shuffle_REVENUE_mSUPPLIER11_to_REVENUE_bind_0t0_1t1_2t2
                 {ra:None immut, rb:None immut, rc:None immut,
                 rd:delta_tuples2, re:false}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                 re:map_3, rf:map_4, rg:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                  re:map_4, rf:map_val};
                  _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                 re:int, rf:real } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
                rf:real } @ { Collection } } @ { Collection })))) empty {
              ra:address, rb:{ key:int, value:int }, rc:collection { ra:string,
              rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
              } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
              rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
              value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
               rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }}))))
              {key:empty { key:int, value:int } @ { Seq }, value:empty {
              ra:string, rb:string, rc:int, rd:int, re:int, rf:real
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_SUPPLIER_rcv_corrective_s0_m_REVENUE_mSUPPLIER11, ip)<- {ra:orig_addr,
               rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
               rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_REVENUE_mLINEITEM4_mSUPPLIER1_send_correctives : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid, rf:delta_tuples} in 
  let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:0, value:9}, {key:1, value:19}, {key:6, value:69}, {key:6, value:70},
    {key:7, value:82}, {key:7, value:83}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_2, rd:map_3, re:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
         rf:map_val};
         _accmap)))) empty { ra:{ key:int, value:int }, rb:string, rc:string,
        rd:int, re:int, rf:int } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 83
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_LINEITEM vid as
            {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
            in
            (shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3
               {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
               re:Some LINEITEM_SUPPKEY, rf:delta_tuples2, rg:false}).fold
              ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
               re:map_3, rf:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                re:map_val};
                _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
               re:int } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:string, rb:string, rc:int, rd:int, re:int
              } @ { Collection } } @ { Collection })))) empty { ra:address,
            rb:{ key:int, value:int }, rc:collection { ra:string, rb:string,
            rc:int, rd:int, re:int } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
             rb:string, rc:int, rd:int, re:int } @ { Collection }}))))
            {key:empty { key:int, value:int } @ { Seq }, value:empty {
            ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_LINEITEM_rcv_corrective_s83_m_REVENUE_mLINEITEM4_mSUPPLIER1,
               ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:corrective_vid, rf:vid_send_list_tup.key,
             rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 82
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_delete_LINEITEM vid as
              {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
              in
              (shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3
                 {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                 re:Some LINEITEM_SUPPKEY, rf:delta_tuples2, rg:false}).fold
                ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                 re:map_3, rf:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                  re:map_val};
                  _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                 re:int } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:string, rb:string, rc:int, rd:int, re:int
                } @ { Collection } } @ { Collection })))) empty { ra:address,
              rb:{ key:int, value:int }, rc:collection { ra:string, rb:string,
              rc:int, rd:int, re:int } @ { Collection }
              } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
              rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
              value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
               rb:string, rc:int, rd:int, re:int } @ { Collection }}))))
              {key:empty { key:int, value:int } @ { Seq }, value:empty {
              ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }}
            in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((delete_LINEITEM_rcv_corrective_s82_m_REVENUE_mLINEITEM4_mSUPPLIER1,
                 ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
               re:corrective_vid, rf:vid_send_list_tup.key,
               rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 70
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_insert_LINEITEM vid as
                {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                in
                (shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3
                   {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                   re:Some LINEITEM_SUPPKEY, rf:delta_tuples2, rg:false}).fold
                  ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                   re:map_3, rf:map_val} in 
                   (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                    re:map_val};
                    _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                   re:int } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { ra:string, rb:string, rc:int, rd:int, re:int
                  } @ { Collection } } @ { Collection })))) empty { ra:address,
                rb:{ key:int, value:int }, rc:collection { ra:string,
                rb:string, rc:int, rd:int, re:int } @ { Collection }
                } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
                rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { ra:string, rb:string, rc:int, rd:int, re:int
                 } @ { Collection }})))) {key:empty { key:int, value:int
                } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                rd:int, re:int } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((insert_LINEITEM_rcv_corrective_s70_m_REVENUE_mLINEITEM4_mSUPPLIER1,
                   ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                 re:corrective_vid, rf:vid_send_list_tup.key,
                 rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 69
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_insert_LINEITEM vid as
                  {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                  in
                  (shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3
                     {ra:None immut, rb:None immut, rc:None immut,
                     rd:None immut, re:Some LINEITEM_SUPPKEY, rf:delta_tuples2,
                     rg:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                    value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
                     (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                      re:map_val};
                      _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                     re:int } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { ra:string, rb:string, rc:int, rd:int,
                    re:int } @ { Collection } } @ { Collection })))) empty {
                  ra:address, rb:{ key:int, value:int }, rc:collection {
                  ra:string, rb:string, rc:int, rd:int, re:int
                  } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                  (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { ra:string, rb:string, rc:int, rd:int, re:int
                   } @ { Collection }})))) {key:empty { key:int, value:int
                  } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                  rd:int, re:int } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((insert_LINEITEM_rcv_corrective_s69_m_REVENUE_mLINEITEM4_mSUPPLIER1,
                     ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                   re:corrective_vid, rf:vid_send_list_tup.key,
                   rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count
              else if stmt_id == 19
                then let ips_vids =
                  (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                    nd_log_get_bound_delete_SUPPLIER vid as
                    {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                    in
                    (shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mLINEITEM4_bind_0t0_1t1_2t2
                       {ra:None immut, rb:None immut, rc:None immut,
                       rd:Some SUPPLIER_SUPPKEY, re:delta_tuples2, rf:false}).fold
                      ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                      value:tuples} in 
                      (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                       ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                       rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
                       (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                        re:map_val};
                        _accmap)))) empty { ra:string, rb:string, rc:int,
                       rd:int, re:int } @ { Collection }};
                       _accmap)))) empty { ra:address, rb:{ key:int, value:int
                      }, rc:collection { ra:string, rb:string, rc:int, rd:int,
                      re:int } @ { Collection } } @ { Collection })))) empty {
                    ra:address, rb:{ key:int, value:int }, rc:collection {
                    ra:string, rb:string, rc:int, rd:int, re:int
                    } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                    bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                    (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                    bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                    (acc_vid.insert vid;
                     {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                     ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                     ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                     empty { ra:string, rb:string, rc:int, rd:int, re:int
                     } @ { Collection }})))) {key:empty { key:int, value:int
                    } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                    rd:int, re:int } @ { Collection }} in
                  ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                    value:vid_send_list_tup} in 
                    ((delete_SUPPLIER_rcv_corrective_s19_m_REVENUE_mLINEITEM4_mSUPPLIER1,
                       ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                     rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                     rg:vid_send_list_tup.value};
                     acc_count + 1)))) acc_count
                else if stmt_id == 9
                  then let ips_vids =
                    (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                      nd_log_get_bound_insert_SUPPLIER vid as
                      {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                      in
                      (shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mLINEITEM4_bind_0t0_1t1_2t2
                         {ra:None immut, rb:None immut, rc:None immut,
                         rd:Some SUPPLIER_SUPPKEY, re:delta_tuples2, rf:false}).fold
                        ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                        value:tuples} in 
                        (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                         ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                         rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
                         (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                          rd:map_3, re:map_val};
                          _accmap)))) empty { ra:string, rb:string, rc:int,
                         rd:int, re:int } @ { Collection }};
                         _accmap)))) empty { ra:address, rb:{ key:int,
                        value:int }, rc:collection { ra:string, rb:string,
                        rc:int, rd:int, re:int } @ { Collection }
                        } @ { Collection })))) empty { ra:address, rb:{
                      key:int, value:int }, rc:collection { ra:string,
                      rb:string, rc:int, rd:int, re:int } @ { Collection }
                      } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                      rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                      bind b2 as {key:acc_vid, value:acc_tuples} in 
                      bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                      (acc_vid.insert vid;
                       {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                       ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                       ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                       empty { ra:string, rb:string, rc:int, rd:int, re:int
                       } @ { Collection }})))) {key:empty { key:int, value:int
                      } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                      rd:int, re:int } @ { Collection }} in
                    ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                      value:vid_send_list_tup} in 
                      ((insert_SUPPLIER_rcv_corrective_s9_m_REVENUE_mLINEITEM4_mSUPPLIER1,
                         ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                       rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                       rg:vid_send_list_tup.value};
                       acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_REVENUE_mORDERS11_mSUPPLIER2_send_correctives : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid, rf:delta_tuples} in 
  let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:0, value:6}, {key:0, value:7}, {key:0, value:8}, {key:1, value:16},
    {key:1, value:17}, {key:1, value:18}, {key:4, value:45}, {key:4, value:46},
    {key:4, value:47}, {key:5, value:55}, {key:5, value:56}, {key:5,
    value:57}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_2, rd:map_3, re:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
         rf:map_val};
         _accmap)))) empty { ra:{ key:int, value:int }, rb:string, rc:string,
        rd:int, re:int, rf:int } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 57
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_ORDERS vid as
            {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
            in
            (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3
               {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
               re:None immut, rf:delta_tuples2, rg:false}).fold ((\_accmap ->
              (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
               re:map_3, rf:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                re:map_val};
                _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
               re:int } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:string, rb:string, rc:int, rd:int, re:int
              } @ { Collection } } @ { Collection })))) empty { ra:address,
            rb:{ key:int, value:int }, rc:collection { ra:string, rb:string,
            rc:int, rd:int, re:int } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
             rb:string, rc:int, rd:int, re:int } @ { Collection }}))))
            {key:empty { key:int, value:int } @ { Seq }, value:empty {
            ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_ORDERS_rcv_corrective_s57_m_REVENUE_mORDERS11_mSUPPLIER2,
               ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:corrective_vid, rf:vid_send_list_tup.key,
             rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 56
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_delete_ORDERS vid as
              {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
              in
              (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3
                 {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                 re:None immut, rf:delta_tuples2, rg:false}).fold ((\_accmap ->
                (\b3 -> bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                 re:map_3, rf:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                  re:map_val};
                  _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                 re:int } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:string, rb:string, rc:int, rd:int, re:int
                } @ { Collection } } @ { Collection })))) empty { ra:address,
              rb:{ key:int, value:int }, rc:collection { ra:string, rb:string,
              rc:int, rd:int, re:int } @ { Collection }
              } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
              rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
              value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
               rb:string, rc:int, rd:int, re:int } @ { Collection }}))))
              {key:empty { key:int, value:int } @ { Seq }, value:empty {
              ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }}
            in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((delete_ORDERS_rcv_corrective_s56_m_REVENUE_mORDERS11_mSUPPLIER2,
                 ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
               re:corrective_vid, rf:vid_send_list_tup.key,
               rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 55
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_delete_ORDERS vid as
                {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                in
                (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_0t0_1t1_3t3
                   {ra:None immut, rb:None immut, rc:Some ORDERS_ORDERKEY,
                   rd:None immut, re:delta_tuples2, rf:false}).fold
                  ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                   re:map_3, rf:map_val} in 
                   (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                    re:map_val};
                    _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                   re:int } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { ra:string, rb:string, rc:int, rd:int, re:int
                  } @ { Collection } } @ { Collection })))) empty { ra:address,
                rb:{ key:int, value:int }, rc:collection { ra:string,
                rb:string, rc:int, rd:int, re:int } @ { Collection }
                } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
                rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { ra:string, rb:string, rc:int, rd:int, re:int
                 } @ { Collection }})))) {key:empty { key:int, value:int
                } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                rd:int, re:int } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((delete_ORDERS_rcv_corrective_s55_m_REVENUE_mORDERS11_mSUPPLIER2,
                   ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                 re:corrective_vid, rf:vid_send_list_tup.key,
                 rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 47
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_insert_ORDERS vid as
                  {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                  in
                  (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3
                     {ra:None immut, rb:None immut, rc:None immut,
                     rd:None immut, re:None immut, rf:delta_tuples2, rg:false}).fold
                    ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
                     (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                      re:map_val};
                      _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                     re:int } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { ra:string, rb:string, rc:int, rd:int,
                    re:int } @ { Collection } } @ { Collection })))) empty {
                  ra:address, rb:{ key:int, value:int }, rc:collection {
                  ra:string, rb:string, rc:int, rd:int, re:int
                  } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                  (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { ra:string, rb:string, rc:int, rd:int, re:int
                   } @ { Collection }})))) {key:empty { key:int, value:int
                  } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                  rd:int, re:int } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((insert_ORDERS_rcv_corrective_s47_m_REVENUE_mORDERS11_mSUPPLIER2,
                     ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                   re:corrective_vid, rf:vid_send_list_tup.key,
                   rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count
              else if stmt_id == 46
                then let ips_vids =
                  (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                    nd_log_get_bound_insert_ORDERS vid as
                    {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                    in
                    (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3
                       {ra:None immut, rb:None immut, rc:None immut,
                       rd:None immut, re:None immut, rf:delta_tuples2,
                       rg:false}).fold ((\_accmap -> (\b3 ->
                      bind b3 as {key:ip, value:tuples} in 
                      (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                       ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                       rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
                       (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                        re:map_val};
                        _accmap)))) empty { ra:string, rb:string, rc:int,
                       rd:int, re:int } @ { Collection }};
                       _accmap)))) empty { ra:address, rb:{ key:int, value:int
                      }, rc:collection { ra:string, rb:string, rc:int, rd:int,
                      re:int } @ { Collection } } @ { Collection })))) empty {
                    ra:address, rb:{ key:int, value:int }, rc:collection {
                    ra:string, rb:string, rc:int, rd:int, re:int
                    } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                    bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                    (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                    bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                    (acc_vid.insert vid;
                     {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                     ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                     ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                     empty { ra:string, rb:string, rc:int, rd:int, re:int
                     } @ { Collection }})))) {key:empty { key:int, value:int
                    } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                    rd:int, re:int } @ { Collection }} in
                  ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                    value:vid_send_list_tup} in 
                    ((insert_ORDERS_rcv_corrective_s46_m_REVENUE_mORDERS11_mSUPPLIER2,
                       ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                     rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                     rg:vid_send_list_tup.value};
                     acc_count + 1)))) acc_count
                else if stmt_id == 45
                  then let ips_vids =
                    (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                      nd_log_get_bound_insert_ORDERS vid as
                      {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                      in
                      (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_0t0_1t1_3t3
                         {ra:None immut, rb:None immut,
                         rc:Some ORDERS_ORDERKEY, rd:None immut,
                         re:delta_tuples2, rf:false}).fold ((\_accmap ->
                        (\b3 -> bind b3 as {key:ip, value:tuples} in 
                        (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                         ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                         rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
                         (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                          rd:map_3, re:map_val};
                          _accmap)))) empty { ra:string, rb:string, rc:int,
                         rd:int, re:int } @ { Collection }};
                         _accmap)))) empty { ra:address, rb:{ key:int,
                        value:int }, rc:collection { ra:string, rb:string,
                        rc:int, rd:int, re:int } @ { Collection }
                        } @ { Collection })))) empty { ra:address, rb:{
                      key:int, value:int }, rc:collection { ra:string,
                      rb:string, rc:int, rd:int, re:int } @ { Collection }
                      } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                      rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                      bind b2 as {key:acc_vid, value:acc_tuples} in 
                      bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                      (acc_vid.insert vid;
                       {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                       ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                       ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                       empty { ra:string, rb:string, rc:int, rd:int, re:int
                       } @ { Collection }})))) {key:empty { key:int, value:int
                      } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                      rd:int, re:int } @ { Collection }} in
                    ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                      value:vid_send_list_tup} in 
                      ((insert_ORDERS_rcv_corrective_s45_m_REVENUE_mORDERS11_mSUPPLIER2,
                         ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                       rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                       rg:vid_send_list_tup.value};
                       acc_count + 1)))) acc_count
                  else if stmt_id == 18
                    then let ips_vids =
                      (vid_list.fold ((\_accext -> (\vid -> _accext.combine
                        (bind nd_log_get_bound_delete_SUPPLIER vid as
                        {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                        in
                        (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS12_bind_0t0_1t1_3t2
                           {ra:None immut, rb:None immut, rc:None immut,
                           rd:None immut, re:None immut, rf:delta_tuples2,
                           rg:false}).fold ((\_accmap -> (\b3 ->
                          bind b3 as {key:ip, value:tuples} in 
                          (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                           ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                           rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
                           (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                            rd:map_3, re:map_val};
                            _accmap)))) empty { ra:string, rb:string, rc:int,
                           rd:int, re:int } @ { Collection }};
                           _accmap)))) empty { ra:address, rb:{ key:int,
                          value:int }, rc:collection { ra:string, rb:string,
                          rc:int, rd:int, re:int } @ { Collection }
                          } @ { Collection })))) empty { ra:address, rb:{
                        key:int, value:int }, rc:collection { ra:string,
                        rb:string, rc:int, rd:int, re:int } @ { Collection }
                        } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                        rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                        bind b2 as {key:acc_vid, value:acc_tuples} in 
                        bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                        (acc_vid.insert vid;
                         {key:acc_vid, value:((acc_tuples.combine
                         tuples).groupBy ((\tuple -> tuple)) ((\_ -> (\_ ->
                         ()))) ()).fold ((\_accmap -> (\x ->
                         (_accmap.insert (x.key);_accmap)))) empty { ra:string,
                         rb:string, rc:int, rd:int, re:int } @ { Collection }}))))
                        {key:empty { key:int, value:int } @ { Seq },
                        value:empty { ra:string, rb:string, rc:int, rd:int,
                        re:int } @ { Collection }} in
                      ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                        value:vid_send_list_tup} in 
                        ((delete_SUPPLIER_rcv_corrective_s18_m_REVENUE_mORDERS11_mSUPPLIER2,
                           ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                         rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                         rg:vid_send_list_tup.value};
                         acc_count + 1)))) acc_count
                    else if stmt_id == 17
                      then let ips_vids =
                        (vid_list.fold ((\_accext -> (\vid -> _accext.combine
                          (bind nd_log_get_bound_delete_SUPPLIER vid as
                          {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                          in
                          (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS11_mLINEITEM4_bind_0t0_1t1_2t2
                             {ra:None immut, rb:None immut, rc:None immut,
                             rd:Some SUPPLIER_SUPPKEY, re:delta_tuples2,
                             rf:false}).fold ((\_accmap -> (\b3 ->
                            bind b3 as {key:ip, value:tuples} in 
                            (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                             ((\_accmap -> (\b3 -> bind b3 as {ra:vid,
                             rb:map_0, rc:map_1, rd:map_2, re:map_3,
                             rf:map_val} in 
                             (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                              rd:map_3, re:map_val};
                              _accmap)))) empty { ra:string, rb:string, rc:int,
                             rd:int, re:int } @ { Collection }};
                             _accmap)))) empty { ra:address, rb:{ key:int,
                            value:int }, rc:collection { ra:string, rb:string,
                            rc:int, rd:int, re:int } @ { Collection }
                            } @ { Collection })))) empty { ra:address, rb:{
                          key:int, value:int }, rc:collection { ra:string,
                          rb:string, rc:int, rd:int, re:int } @ { Collection }
                          } @ { Collection }).groupBy ((\b1 ->
                          bind b1 as {ra:ip, rb:vid, rc:tuples} in ip))
                          ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                          value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                          rc:tuples} in 
                          (acc_vid.insert vid;
                           {key:acc_vid, value:((acc_tuples.combine
                           tuples).groupBy ((\tuple -> tuple)) ((\_ -> (\_ ->
                           ()))) ()).fold ((\_accmap -> (\x ->
                           (_accmap.insert (x.key);_accmap)))) empty {
                           ra:string, rb:string, rc:int, rd:int, re:int
                           } @ { Collection }})))) {key:empty { key:int,
                          value:int } @ { Seq }, value:empty { ra:string,
                          rb:string, rc:int, rd:int, re:int } @ { Collection }}
                        in
                        ips_vids.fold ((\acc_count -> (\b3 ->
                          bind b3 as {key:ip, value:vid_send_list_tup} in 
                          ((delete_SUPPLIER_rcv_corrective_s17_m_REVENUE_mORDERS11_mSUPPLIER2,
                             ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                           rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                           rg:vid_send_list_tup.value};
                           acc_count + 1)))) acc_count
                      else if stmt_id == 16
                        then let ips_vids =
                          (vid_list.fold ((\_accext -> (\vid -> _accext.combine
                            (bind nd_log_get_bound_delete_SUPPLIER vid as
                            {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                            in
                            (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS11_bind_0t0_1t1_3t2
                               {ra:None immut, rb:None immut, rc:None immut,
                               rd:None immut, re:None immut, rf:delta_tuples2,
                               rg:false}).fold ((\_accmap -> (\b3 ->
                              bind b3 as {key:ip, value:tuples} in 
                              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                               ((\_accmap -> (\b3 -> bind b3 as {ra:vid,
                               rb:map_0, rc:map_1, rd:map_2, re:map_3,
                               rf:map_val} in 
                               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                                rd:map_3, re:map_val};
                                _accmap)))) empty { ra:string, rb:string,
                               rc:int, rd:int, re:int } @ { Collection }};
                               _accmap)))) empty { ra:address, rb:{ key:int,
                              value:int }, rc:collection { ra:string,
                              rb:string, rc:int, rd:int, re:int
                              } @ { Collection } } @ { Collection })))) empty {
                            ra:address, rb:{ key:int, value:int },
                            rc:collection { ra:string, rb:string, rc:int,
                            rd:int, re:int } @ { Collection }
                            } @ { Collection }).groupBy ((\b1 ->
                            bind b1 as {ra:ip, rb:vid, rc:tuples} in ip))
                            ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                            value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                            rc:tuples} in 
                            (acc_vid.insert vid;
                             {key:acc_vid, value:((acc_tuples.combine
                             tuples).groupBy ((\tuple -> tuple)) ((\_ -> (\_ ->
                             ()))) ()).fold ((\_accmap -> (\x ->
                             (_accmap.insert (x.key);_accmap)))) empty {
                             ra:string, rb:string, rc:int, rd:int, re:int
                             } @ { Collection }})))) {key:empty { key:int,
                            value:int } @ { Seq }, value:empty { ra:string,
                            rb:string, rc:int, rd:int, re:int
                            } @ { Collection }} in
                          ips_vids.fold ((\acc_count -> (\b3 ->
                            bind b3 as {key:ip, value:vid_send_list_tup} in 
                            ((delete_SUPPLIER_rcv_corrective_s16_m_REVENUE_mORDERS11_mSUPPLIER2,
                               ip)<- {ra:orig_addr, rb:orig_stmt_id,
                             rc:orig_vid, rd:hop, re:corrective_vid,
                             rf:vid_send_list_tup.key,
                             rg:vid_send_list_tup.value};
                             acc_count + 1)))) acc_count
                        else if stmt_id == 8
                          then let ips_vids =
                            (vid_list.fold ((\_accext -> (\vid ->
                              _accext.combine (bind
                              nd_log_get_bound_insert_SUPPLIER vid as
                              {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                              in
                              (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS12_bind_0t0_1t1_3t2
                                 {ra:None immut, rb:None immut, rc:None immut,
                                 rd:None immut, re:None immut,
                                 rf:delta_tuples2, rg:false}).fold
                                ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                value:tuples} in 
                                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                                 ((\_accmap -> (\b3 -> bind b3 as {ra:vid,
                                 rb:map_0, rc:map_1, rd:map_2, re:map_3,
                                 rf:map_val} in 
                                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                                  rd:map_3, re:map_val};
                                  _accmap)))) empty { ra:string, rb:string,
                                 rc:int, rd:int, re:int } @ { Collection }};
                                 _accmap)))) empty { ra:address, rb:{ key:int,
                                value:int }, rc:collection { ra:string,
                                rb:string, rc:int, rd:int, re:int
                                } @ { Collection } } @ { Collection }))))
                              empty { ra:address, rb:{ key:int, value:int },
                              rc:collection { ra:string, rb:string, rc:int,
                              rd:int, re:int } @ { Collection }
                              } @ { Collection }).groupBy ((\b1 ->
                              bind b1 as {ra:ip, rb:vid, rc:tuples} in ip))
                              ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                              value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                              rc:tuples} in 
                              (acc_vid.insert vid;
                               {key:acc_vid, value:((acc_tuples.combine
                               tuples).groupBy ((\tuple -> tuple)) ((\_ ->
                               (\_ -> ()))) ()).fold ((\_accmap -> (\x ->
                               (_accmap.insert (x.key);_accmap)))) empty {
                               ra:string, rb:string, rc:int, rd:int, re:int
                               } @ { Collection }})))) {key:empty { key:int,
                              value:int } @ { Seq }, value:empty { ra:string,
                              rb:string, rc:int, rd:int, re:int
                              } @ { Collection }} in
                            ips_vids.fold ((\acc_count -> (\b3 ->
                              bind b3 as {key:ip, value:vid_send_list_tup} in 
                              ((insert_SUPPLIER_rcv_corrective_s8_m_REVENUE_mORDERS11_mSUPPLIER2,
                                 ip)<- {ra:orig_addr, rb:orig_stmt_id,
                               rc:orig_vid, rd:hop, re:corrective_vid,
                               rf:vid_send_list_tup.key,
                               rg:vid_send_list_tup.value};
                               acc_count + 1)))) acc_count
                          else if stmt_id == 7
                            then let ips_vids =
                              (vid_list.fold ((\_accext -> (\vid ->
                                _accext.combine (bind
                                nd_log_get_bound_insert_SUPPLIER vid as
                                {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                                in
                                (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS11_mLINEITEM4_bind_0t0_1t1_2t2
                                   {ra:None immut, rb:None immut,
                                   rc:None immut, rd:Some SUPPLIER_SUPPKEY,
                                   re:delta_tuples2, rf:false}).fold
                                  ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                  value:tuples} in 
                                  (_accmap.insert {ra:ip, rb:vid,
                                   rc:tuples.fold ((\_accmap -> (\b3 ->
                                   bind b3 as {ra:vid, rb:map_0, rc:map_1,
                                   rd:map_2, re:map_3, rf:map_val} in 
                                   (_accmap.insert {ra:map_0, rb:map_1,
                                    rc:map_2, rd:map_3, re:map_val};
                                    _accmap)))) empty { ra:string, rb:string,
                                   rc:int, rd:int, re:int } @ { Collection }};
                                   _accmap)))) empty { ra:address, rb:{
                                  key:int, value:int }, rc:collection {
                                  ra:string, rb:string, rc:int, rd:int, re:int
                                  } @ { Collection } } @ { Collection }))))
                                empty { ra:address, rb:{ key:int, value:int },
                                rc:collection { ra:string, rb:string, rc:int,
                                rd:int, re:int } @ { Collection }
                                } @ { Collection }).groupBy ((\b1 ->
                                bind b1 as {ra:ip, rb:vid, rc:tuples} in ip))
                                ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                                value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                                rc:tuples} in 
                                (acc_vid.insert vid;
                                 {key:acc_vid, value:((acc_tuples.combine
                                 tuples).groupBy ((\tuple -> tuple)) ((\_ ->
                                 (\_ -> ()))) ()).fold ((\_accmap -> (\x ->
                                 (_accmap.insert (x.key);_accmap)))) empty {
                                 ra:string, rb:string, rc:int, rd:int, re:int
                                 } @ { Collection }})))) {key:empty { key:int,
                                value:int } @ { Seq }, value:empty { ra:string,
                                rb:string, rc:int, rd:int, re:int
                                } @ { Collection }} in
                              ips_vids.fold ((\acc_count -> (\b3 ->
                                bind b3 as {key:ip,
                                value:vid_send_list_tup} in 
                                ((insert_SUPPLIER_rcv_corrective_s7_m_REVENUE_mORDERS11_mSUPPLIER2,
                                   ip)<- {ra:orig_addr, rb:orig_stmt_id,
                                 rc:orig_vid, rd:hop, re:corrective_vid,
                                 rf:vid_send_list_tup.key,
                                 rg:vid_send_list_tup.value};
                                 acc_count + 1)))) acc_count
                            else if stmt_id == 6
                              then let ips_vids =
                                (vid_list.fold ((\_accext -> (\vid ->
                                  _accext.combine (bind
                                  nd_log_get_bound_insert_SUPPLIER vid as
                                  {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
                                  in
                                  (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS11_bind_0t0_1t1_3t2
                                     {ra:None immut, rb:None immut,
                                     rc:None immut, rd:None immut,
                                     re:None immut, rf:delta_tuples2, rg:false}).fold
                                    ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                    value:tuples} in 
                                    (_accmap.insert {ra:ip, rb:vid,
                                     rc:tuples.fold ((\_accmap -> (\b3 ->
                                     bind b3 as {ra:vid, rb:map_0, rc:map_1,
                                     rd:map_2, re:map_3, rf:map_val} in 
                                     (_accmap.insert {ra:map_0, rb:map_1,
                                      rc:map_2, rd:map_3, re:map_val};
                                      _accmap)))) empty { ra:string, rb:string,
                                     rc:int, rd:int, re:int } @ { Collection }};
                                     _accmap)))) empty { ra:address, rb:{
                                    key:int, value:int }, rc:collection {
                                    ra:string, rb:string, rc:int, rd:int,
                                    re:int } @ { Collection }
                                    } @ { Collection })))) empty { ra:address,
                                  rb:{ key:int, value:int }, rc:collection {
                                  ra:string, rb:string, rc:int, rd:int, re:int
                                  } @ { Collection }
                                  } @ { Collection }).groupBy ((\b1 ->
                                  bind b1 as {ra:ip, rb:vid, rc:tuples} in ip))
                                  ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                                  value:acc_tuples} in bind b5 as {ra:ip,
                                  rb:vid, rc:tuples} in 
                                  (acc_vid.insert vid;
                                   {key:acc_vid, value:((acc_tuples.combine
                                   tuples).groupBy ((\tuple -> tuple)) ((\_ ->
                                   (\_ -> ()))) ()).fold ((\_accmap -> (\x ->
                                   (_accmap.insert (x.key);_accmap)))) empty {
                                   ra:string, rb:string, rc:int, rd:int, re:int
                                   } @ { Collection }})))) {key:empty {
                                  key:int, value:int } @ { Seq }, value:empty {
                                  ra:string, rb:string, rc:int, rd:int, re:int
                                  } @ { Collection }} in
                                ips_vids.fold ((\acc_count -> (\b3 ->
                                  bind b3 as {key:ip,
                                  value:vid_send_list_tup} in 
                                  ((insert_SUPPLIER_rcv_corrective_s6_m_REVENUE_mORDERS11_mSUPPLIER2,
                                     ip)<- {ra:orig_addr, rb:orig_stmt_id,
                                   rc:orig_vid, rd:hop, re:corrective_vid,
                                   rf:vid_send_list_tup.key,
                                   rg:vid_send_list_tup.value};
                                   acc_count + 1)))) acc_count else acc_count)))
        0)


declare nd_REVENUE_mLINEITEM4_send_correctives : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } -> int =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:6, value:58}, {key:7, value:71}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_2, rd:map_3, re:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
         rf:map_val};
         _accmap)))) empty { ra:{ key:int, value:int }, rb:string, rc:string,
        rd:int, re:int, rf:int } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 71
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_LINEITEM vid as
            {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
            in
            (shuffle_REVENUE_mLINEITEM4_to_REVENUE_bind_0t0_1t1 {ra:None immut,
               rb:None immut, rc:None immut, rd:delta_tuples2, re:false}).fold
              ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
               re:map_3, rf:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                re:map_val};
                _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
               re:int } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:string, rb:string, rc:int, rd:int, re:int
              } @ { Collection } } @ { Collection })))) empty { ra:address,
            rb:{ key:int, value:int }, rc:collection { ra:string, rb:string,
            rc:int, rd:int, re:int } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
             rb:string, rc:int, rd:int, re:int } @ { Collection }}))))
            {key:empty { key:int, value:int } @ { Seq }, value:empty {
            ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_LINEITEM_rcv_corrective_s71_m_REVENUE_mLINEITEM4, ip)<- {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
             rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 58
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_LINEITEM vid as
              {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
              in
              (shuffle_REVENUE_mLINEITEM4_to_REVENUE_bind_0t0_1t1
                 {ra:None immut, rb:None immut, rc:None immut,
                 rd:delta_tuples2, re:false}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                 re:map_3, rf:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                  re:map_val};
                  _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                 re:int } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:string, rb:string, rc:int, rd:int, re:int
                } @ { Collection } } @ { Collection })))) empty { ra:address,
              rb:{ key:int, value:int }, rc:collection { ra:string, rb:string,
              rc:int, rd:int, re:int } @ { Collection }
              } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
              rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
              value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
               rb:string, rc:int, rd:int, re:int } @ { Collection }}))))
              {key:empty { key:int, value:int } @ { Seq }, value:empty {
              ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }}
            in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_LINEITEM_rcv_corrective_s58_m_REVENUE_mLINEITEM4, ip)<- {ra:orig_addr,
               rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
               rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_REVENUE_mORDERS12_send_correctives : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:4, value:38}, {key:5, value:48}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_2, rd:map_3, re:map_4, rf:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
         rf:map_4, rg:map_val};
         _accmap)))) empty { ra:{ key:int, value:int }, rb:string, rc:string,
        rd:int, re:int, rf:int, rg:real } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 48
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_ORDERS vid as
            {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
            in
            (shuffle_REVENUE_mORDERS12_to_REVENUE_bind_0t0_1t1_2t2
               {ra:None immut, rb:None immut, rc:None immut, rd:delta_tuples2,
               re:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
              value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
               re:map_3, rf:map_4, rg:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                re:map_4, rf:map_val};
                _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
               re:int, rf:real } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
              rf:real } @ { Collection } } @ { Collection })))) empty {
            ra:address, rb:{ key:int, value:int }, rc:collection { ra:string,
            rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
             rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }}))))
            {key:empty { key:int, value:int } @ { Seq }, value:empty {
            ra:string, rb:string, rc:int, rd:int, re:int, rf:real
            } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_ORDERS_rcv_corrective_s48_m_REVENUE_mORDERS12, ip)<- {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
             rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 38
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_ORDERS vid as
              {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
              in
              (shuffle_REVENUE_mORDERS12_to_REVENUE_bind_0t0_1t1_2t2
                 {ra:None immut, rb:None immut, rc:None immut,
                 rd:delta_tuples2, re:false}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                 re:map_3, rf:map_4, rg:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                  re:map_4, rf:map_val};
                  _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                 re:int, rf:real } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
                rf:real } @ { Collection } } @ { Collection })))) empty {
              ra:address, rb:{ key:int, value:int }, rc:collection { ra:string,
              rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
              } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
              rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
              value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
               rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }}))))
              {key:empty { key:int, value:int } @ { Seq }, value:empty {
              ra:string, rb:string, rc:int, rd:int, re:int, rf:real
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_ORDERS_rcv_corrective_s38_m_REVENUE_mORDERS12, ip)<- {ra:orig_addr,
               rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
               rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_REVENUE_mORDERS11_mLINEITEM4_send_correctives : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid, rf:delta_tuples} in 
  let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:4, value:44}, {key:5, value:54}, {key:6, value:67}, {key:6, value:68},
    {key:7, value:80}, {key:7, value:81}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_2, rd:map_3, re:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
         rf:map_val};
         _accmap)))) empty { ra:{ key:int, value:int }, rb:string, rc:string,
        rd:int, re:int, rf:int } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 81
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_LINEITEM vid as
            {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
            in
            (shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mORDERS12_bind_0t0_1t1_3t2
               {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
               re:Some LINEITEM_ORDERKEY, rf:delta_tuples2, rg:false}).fold
              ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
               re:map_3, rf:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                re:map_val};
                _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
               re:int } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:string, rb:string, rc:int, rd:int, re:int
              } @ { Collection } } @ { Collection })))) empty { ra:address,
            rb:{ key:int, value:int }, rc:collection { ra:string, rb:string,
            rc:int, rd:int, re:int } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
             rb:string, rc:int, rd:int, re:int } @ { Collection }}))))
            {key:empty { key:int, value:int } @ { Seq }, value:empty {
            ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_LINEITEM_rcv_corrective_s81_m_REVENUE_mORDERS11_mLINEITEM4,
               ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:corrective_vid, rf:vid_send_list_tup.key,
             rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 80
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_delete_LINEITEM vid as
              {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
              in
              (shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mORDERS11_bind_0t0_1t1_3t2
                 {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                 re:Some LINEITEM_ORDERKEY, rf:delta_tuples2, rg:false}).fold
                ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                 re:map_3, rf:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                  re:map_val};
                  _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                 re:int } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:string, rb:string, rc:int, rd:int, re:int
                } @ { Collection } } @ { Collection })))) empty { ra:address,
              rb:{ key:int, value:int }, rc:collection { ra:string, rb:string,
              rc:int, rd:int, re:int } @ { Collection }
              } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
              rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
              value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
               rb:string, rc:int, rd:int, re:int } @ { Collection }}))))
              {key:empty { key:int, value:int } @ { Seq }, value:empty {
              ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }}
            in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((delete_LINEITEM_rcv_corrective_s80_m_REVENUE_mORDERS11_mLINEITEM4,
                 ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
               re:corrective_vid, rf:vid_send_list_tup.key,
               rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 68
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_insert_LINEITEM vid as
                {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                in
                (shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mORDERS12_bind_0t0_1t1_3t2
                   {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                   re:Some LINEITEM_ORDERKEY, rf:delta_tuples2, rg:false}).fold
                  ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                   re:map_3, rf:map_val} in 
                   (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                    re:map_val};
                    _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                   re:int } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { ra:string, rb:string, rc:int, rd:int, re:int
                  } @ { Collection } } @ { Collection })))) empty { ra:address,
                rb:{ key:int, value:int }, rc:collection { ra:string,
                rb:string, rc:int, rd:int, re:int } @ { Collection }
                } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
                rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { ra:string, rb:string, rc:int, rd:int, re:int
                 } @ { Collection }})))) {key:empty { key:int, value:int
                } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                rd:int, re:int } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((insert_LINEITEM_rcv_corrective_s68_m_REVENUE_mORDERS11_mLINEITEM4,
                   ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                 re:corrective_vid, rf:vid_send_list_tup.key,
                 rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 67
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_insert_LINEITEM vid as
                  {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                  in
                  (shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mORDERS11_bind_0t0_1t1_3t2
                     {ra:None immut, rb:None immut, rc:None immut,
                     rd:None immut, re:Some LINEITEM_ORDERKEY,
                     rf:delta_tuples2, rg:false}).fold ((\_accmap -> (\b3 ->
                    bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
                     (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                      re:map_val};
                      _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                     re:int } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { ra:string, rb:string, rc:int, rd:int,
                    re:int } @ { Collection } } @ { Collection })))) empty {
                  ra:address, rb:{ key:int, value:int }, rc:collection {
                  ra:string, rb:string, rc:int, rd:int, re:int
                  } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                  (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { ra:string, rb:string, rc:int, rd:int, re:int
                   } @ { Collection }})))) {key:empty { key:int, value:int
                  } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                  rd:int, re:int } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((insert_LINEITEM_rcv_corrective_s67_m_REVENUE_mORDERS11_mLINEITEM4,
                     ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                   re:corrective_vid, rf:vid_send_list_tup.key,
                   rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count
              else if stmt_id == 54
                then let ips_vids =
                  (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                    nd_log_get_bound_delete_ORDERS vid as
                    {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                    in
                    (shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mLINEITEM4_bind_0t0_1t1_3t3
                       {ra:None immut, rb:None immut, rc:Some ORDERS_ORDERKEY,
                       rd:None immut, re:delta_tuples2, rf:false}).fold
                      ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                      value:tuples} in 
                      (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                       ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                       rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
                       (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                        re:map_val};
                        _accmap)))) empty { ra:string, rb:string, rc:int,
                       rd:int, re:int } @ { Collection }};
                       _accmap)))) empty { ra:address, rb:{ key:int, value:int
                      }, rc:collection { ra:string, rb:string, rc:int, rd:int,
                      re:int } @ { Collection } } @ { Collection })))) empty {
                    ra:address, rb:{ key:int, value:int }, rc:collection {
                    ra:string, rb:string, rc:int, rd:int, re:int
                    } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                    bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                    (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                    bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                    (acc_vid.insert vid;
                     {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                     ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                     ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                     empty { ra:string, rb:string, rc:int, rd:int, re:int
                     } @ { Collection }})))) {key:empty { key:int, value:int
                    } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                    rd:int, re:int } @ { Collection }} in
                  ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                    value:vid_send_list_tup} in 
                    ((delete_ORDERS_rcv_corrective_s54_m_REVENUE_mORDERS11_mLINEITEM4,
                       ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                     rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                     rg:vid_send_list_tup.value};
                     acc_count + 1)))) acc_count
                else if stmt_id == 44
                  then let ips_vids =
                    (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                      nd_log_get_bound_insert_ORDERS vid as
                      {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
                      in
                      (shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mLINEITEM4_bind_0t0_1t1_3t3
                         {ra:None immut, rb:None immut,
                         rc:Some ORDERS_ORDERKEY, rd:None immut,
                         re:delta_tuples2, rf:false}).fold ((\_accmap ->
                        (\b3 -> bind b3 as {key:ip, value:tuples} in 
                        (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                         ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                         rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
                         (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                          rd:map_3, re:map_val};
                          _accmap)))) empty { ra:string, rb:string, rc:int,
                         rd:int, re:int } @ { Collection }};
                         _accmap)))) empty { ra:address, rb:{ key:int,
                        value:int }, rc:collection { ra:string, rb:string,
                        rc:int, rd:int, re:int } @ { Collection }
                        } @ { Collection })))) empty { ra:address, rb:{
                      key:int, value:int }, rc:collection { ra:string,
                      rb:string, rc:int, rd:int, re:int } @ { Collection }
                      } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                      rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                      bind b2 as {key:acc_vid, value:acc_tuples} in 
                      bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                      (acc_vid.insert vid;
                       {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                       ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                       ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                       empty { ra:string, rb:string, rc:int, rd:int, re:int
                       } @ { Collection }})))) {key:empty { key:int, value:int
                      } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                      rd:int, re:int } @ { Collection }} in
                    ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                      value:vid_send_list_tup} in 
                      ((insert_ORDERS_rcv_corrective_s44_m_REVENUE_mORDERS11_mLINEITEM4,
                         ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                       rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                       rg:vid_send_list_tup.value};
                       acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_REVENUE_mORDERS11_send_correctives : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:4, value:38}, {key:5, value:48}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_2, rd:map_3, re:map_4, rf:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
         rf:map_4, rg:map_val};
         _accmap)))) empty { ra:{ key:int, value:int }, rb:string, rc:string,
        rd:int, re:int, rf:int, rg:real } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 48
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_ORDERS vid as
            {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
            in
            (shuffle_REVENUE_mORDERS11_to_REVENUE_bind_0t0_1t1_2t2
               {ra:None immut, rb:None immut, rc:None immut, rd:delta_tuples2,
               re:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
              value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
               re:map_3, rf:map_4, rg:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                re:map_4, rf:map_val};
                _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
               re:int, rf:real } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
              rf:real } @ { Collection } } @ { Collection })))) empty {
            ra:address, rb:{ key:int, value:int }, rc:collection { ra:string,
            rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
             rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }}))))
            {key:empty { key:int, value:int } @ { Seq }, value:empty {
            ra:string, rb:string, rc:int, rd:int, re:int, rf:real
            } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_ORDERS_rcv_corrective_s48_m_REVENUE_mORDERS11, ip)<- {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
             rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 38
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_ORDERS vid as
              {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
              in
              (shuffle_REVENUE_mORDERS11_to_REVENUE_bind_0t0_1t1_2t2
                 {ra:None immut, rb:None immut, rc:None immut,
                 rd:delta_tuples2, re:false}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                 re:map_3, rf:map_4, rg:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                  re:map_4, rf:map_val};
                  _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                 re:int, rf:real } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
                rf:real } @ { Collection } } @ { Collection })))) empty {
              ra:address, rb:{ key:int, value:int }, rc:collection { ra:string,
              rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
              } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
              rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
              value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
               rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }}))))
              {key:empty { key:int, value:int } @ { Seq }, value:empty {
              ra:string, rb:string, rc:int, rd:int, re:int, rf:real
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_ORDERS_rcv_corrective_s38_m_REVENUE_mORDERS11, ip)<- {ra:orig_addr,
               rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
               rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_REVENUE_mCUSTOMER12_mORDERS1_send_correctives : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid, rf:delta_tuples} in 
  let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:2, value:24}, {key:3, value:33}, {key:4, value:42}, {key:5,
    value:52}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_2, rd:map_3, re:map_4, rf:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
         rf:map_4, rg:map_val};
         _accmap)))) empty { ra:{ key:int, value:int }, rb:string, rc:string,
        rd:int, re:int, rf:int, rg:real } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 52
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_ORDERS vid as
            {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
            in
            (shuffle_REVENUE_mCUSTOMER12_mORDERS1_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_2t2_3t3
               {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
               re:Some ORDERS_CUSTKEY, rf:delta_tuples2, rg:false}).fold
              ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
               re:map_3, rf:map_4, rg:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                re:map_4, rf:map_val};
                _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
               re:int, rf:real } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
              rf:real } @ { Collection } } @ { Collection })))) empty {
            ra:address, rb:{ key:int, value:int }, rc:collection { ra:string,
            rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
             rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }}))))
            {key:empty { key:int, value:int } @ { Seq }, value:empty {
            ra:string, rb:string, rc:int, rd:int, re:int, rf:real
            } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_ORDERS_rcv_corrective_s52_m_REVENUE_mCUSTOMER12_mORDERS1,
               ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:corrective_vid, rf:vid_send_list_tup.key,
             rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 42
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_ORDERS vid as
              {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
              in
              (shuffle_REVENUE_mCUSTOMER12_mORDERS1_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_2t2_3t3
                 {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                 re:Some ORDERS_CUSTKEY, rf:delta_tuples2, rg:false}).fold
                ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                 re:map_3, rf:map_4, rg:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                  re:map_4, rf:map_val};
                  _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                 re:int, rf:real } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
                rf:real } @ { Collection } } @ { Collection })))) empty {
              ra:address, rb:{ key:int, value:int }, rc:collection { ra:string,
              rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
              } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
              rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
              value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
               rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }}))))
              {key:empty { key:int, value:int } @ { Seq }, value:empty {
              ra:string, rb:string, rc:int, rd:int, re:int, rf:real
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_ORDERS_rcv_corrective_s42_m_REVENUE_mCUSTOMER12_mORDERS1,
                 ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
               re:corrective_vid, rf:vid_send_list_tup.key,
               rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 33
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_delete_CUSTOMER vid as
                {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                in
                (shuffle_REVENUE_mCUSTOMER12_mORDERS1_to_REVENUE_mORDERS12_bind_0t0_1t1_2t2_4t4
                   {ra:None immut, rb:None immut, rc:None immut,
                   rd:Some CUSTOMER_CUSTKEY, re:None immut, rf:delta_tuples2,
                   rg:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                  value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                   re:map_3, rf:map_4, rg:map_val} in 
                   (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                    re:map_4, rf:map_val};
                    _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                   re:int, rf:real } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
                  rf:real } @ { Collection } } @ { Collection })))) empty {
                ra:address, rb:{ key:int, value:int }, rc:collection {
                ra:string, rb:string, rc:int, rd:int, re:int, rf:real
                } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                bind b2 as {key:acc_vid, value:acc_tuples} in 
                bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
                 } @ { Collection }})))) {key:empty { key:int, value:int
                } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                rd:int, re:int, rf:real } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((delete_CUSTOMER_rcv_corrective_s33_m_REVENUE_mCUSTOMER12_mORDERS1,
                   ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                 re:corrective_vid, rf:vid_send_list_tup.key,
                 rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 24
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_insert_CUSTOMER vid as
                  {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                  in
                  (shuffle_REVENUE_mCUSTOMER12_mORDERS1_to_REVENUE_mORDERS12_bind_0t0_1t1_2t2_4t4
                     {ra:None immut, rb:None immut, rc:None immut,
                     rd:Some CUSTOMER_CUSTKEY, re:None immut, rf:delta_tuples2,
                     rg:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                    value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_1, rd:map_2, re:map_3, rf:map_4, rg:map_val} in 
                     (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                      re:map_4, rf:map_val};
                      _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                     re:int, rf:real } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { ra:string, rb:string, rc:int, rd:int,
                    re:int, rf:real } @ { Collection } } @ { Collection }))))
                  empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
                  rf:real } @ { Collection } } @ { Collection }).groupBy
                  ((\b1 -> bind b1 as {ra:ip, rb:vid, rc:tuples} in ip))
                  ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                  value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                  rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { ra:string, rb:string, rc:int, rd:int, re:int,
                   rf:real } @ { Collection }})))) {key:empty { key:int,
                  value:int } @ { Seq }, value:empty { ra:string, rb:string,
                  rc:int, rd:int, re:int, rf:real } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((insert_CUSTOMER_rcv_corrective_s24_m_REVENUE_mCUSTOMER12_mORDERS1,
                     ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                   re:corrective_vid, rf:vid_send_list_tup.key,
                   rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_REVENUE_mCUSTOMER12_send_correctives : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:2, value:20}, {key:3, value:29}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_2, rd:map_3, re:map_4, rf:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
         rf:map_4, rg:map_val};
         _accmap)))) empty { ra:{ key:int, value:int }, rb:string, rc:string,
        rd:int, re:int, rf:int, rg:real } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 29
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_CUSTOMER vid as
            {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
            in
            (shuffle_REVENUE_mCUSTOMER12_to_REVENUE_bind_0t0_1t1_2t2
               {ra:None immut, rb:None immut, rc:None immut, rd:delta_tuples2,
               re:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
              value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
               re:map_3, rf:map_4, rg:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                re:map_4, rf:map_val};
                _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
               re:int, rf:real } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
              rf:real } @ { Collection } } @ { Collection })))) empty {
            ra:address, rb:{ key:int, value:int }, rc:collection { ra:string,
            rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
             rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }}))))
            {key:empty { key:int, value:int } @ { Seq }, value:empty {
            ra:string, rb:string, rc:int, rd:int, re:int, rf:real
            } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_CUSTOMER_rcv_corrective_s29_m_REVENUE_mCUSTOMER12, ip)<- {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
             rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 20
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_CUSTOMER vid as
              {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
              in
              (shuffle_REVENUE_mCUSTOMER12_to_REVENUE_bind_0t0_1t1_2t2
                 {ra:None immut, rb:None immut, rc:None immut,
                 rd:delta_tuples2, re:false}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                 re:map_3, rf:map_4, rg:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                  re:map_4, rf:map_val};
                  _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                 re:int, rf:real } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
                rf:real } @ { Collection } } @ { Collection })))) empty {
              ra:address, rb:{ key:int, value:int }, rc:collection { ra:string,
              rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
              } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
              rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
              value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
               rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }}))))
              {key:empty { key:int, value:int } @ { Seq }, value:empty {
              ra:string, rb:string, rc:int, rd:int, re:int, rf:real
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_CUSTOMER_rcv_corrective_s20_m_REVENUE_mCUSTOMER12, ip)<- {ra:orig_addr,
               rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
               rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_REVENUE_mCUSTOMER11_mLINEITEM4_send_correctives : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid, rf:delta_tuples} in 
  let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:2, value:22}, {key:2, value:25}, {key:3, value:31}, {key:3, value:34},
    {key:6, value:59}, {key:6, value:60}, {key:6, value:63}, {key:6, value:64},
    {key:7, value:72}, {key:7, value:73}, {key:7, value:76}, {key:7,
    value:77}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_2, rd:map_3, re:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
         rf:map_val};
         _accmap)))) empty { ra:{ key:int, value:int }, rb:string, rc:string,
        rd:int, re:int, rf:int } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 77
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_LINEITEM vid as
            {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
            in
            (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER12_mORDERS1_bind_0t0_1t1_3t2
               {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
               re:Some LINEITEM_ORDERKEY, rf:delta_tuples2, rg:false}).fold
              ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
               re:map_3, rf:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                re:map_val};
                _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
               re:int } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:string, rb:string, rc:int, rd:int, re:int
              } @ { Collection } } @ { Collection })))) empty { ra:address,
            rb:{ key:int, value:int }, rc:collection { ra:string, rb:string,
            rc:int, rd:int, re:int } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
             rb:string, rc:int, rd:int, re:int } @ { Collection }}))))
            {key:empty { key:int, value:int } @ { Seq }, value:empty {
            ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_LINEITEM_rcv_corrective_s77_m_REVENUE_mCUSTOMER11_mLINEITEM4,
               ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:corrective_vid, rf:vid_send_list_tup.key,
             rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 76
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_delete_LINEITEM vid as
              {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
              in
              (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_3t2
                 {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                 re:None immut, rf:delta_tuples2, rg:false}).fold ((\_accmap ->
                (\b3 -> bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                 re:map_3, rf:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                  re:map_val};
                  _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                 re:int } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:string, rb:string, rc:int, rd:int, re:int
                } @ { Collection } } @ { Collection })))) empty { ra:address,
              rb:{ key:int, value:int }, rc:collection { ra:string, rb:string,
              rc:int, rd:int, re:int } @ { Collection }
              } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
              rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
              value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
               rb:string, rc:int, rd:int, re:int } @ { Collection }}))))
              {key:empty { key:int, value:int } @ { Seq }, value:empty {
              ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }}
            in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((delete_LINEITEM_rcv_corrective_s76_m_REVENUE_mCUSTOMER11_mLINEITEM4,
                 ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
               re:corrective_vid, rf:vid_send_list_tup.key,
               rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 73
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_delete_LINEITEM vid as
                {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                in
                (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER11_mORDERS1_bind_0t0_1t1_3t2
                   {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                   re:Some LINEITEM_ORDERKEY, rf:delta_tuples2, rg:false}).fold
                  ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                   re:map_3, rf:map_val} in 
                   (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                    re:map_val};
                    _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                   re:int } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { ra:string, rb:string, rc:int, rd:int, re:int
                  } @ { Collection } } @ { Collection })))) empty { ra:address,
                rb:{ key:int, value:int }, rc:collection { ra:string,
                rb:string, rc:int, rd:int, re:int } @ { Collection }
                } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
                rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { ra:string, rb:string, rc:int, rd:int, re:int
                 } @ { Collection }})))) {key:empty { key:int, value:int
                } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                rd:int, re:int } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((delete_LINEITEM_rcv_corrective_s73_m_REVENUE_mCUSTOMER11_mLINEITEM4,
                   ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                 re:corrective_vid, rf:vid_send_list_tup.key,
                 rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 72
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_delete_LINEITEM vid as
                  {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                  in
                  (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_3t2
                     {ra:None immut, rb:None immut, rc:None immut,
                     rd:None immut, re:None immut, rf:delta_tuples2, rg:false}).fold
                    ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
                     (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                      re:map_val};
                      _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                     re:int } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { ra:string, rb:string, rc:int, rd:int,
                    re:int } @ { Collection } } @ { Collection })))) empty {
                  ra:address, rb:{ key:int, value:int }, rc:collection {
                  ra:string, rb:string, rc:int, rd:int, re:int
                  } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                  bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                  (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                  bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { ra:string, rb:string, rc:int, rd:int, re:int
                   } @ { Collection }})))) {key:empty { key:int, value:int
                  } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                  rd:int, re:int } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((delete_LINEITEM_rcv_corrective_s72_m_REVENUE_mCUSTOMER11_mLINEITEM4,
                     ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                   re:corrective_vid, rf:vid_send_list_tup.key,
                   rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count
              else if stmt_id == 64
                then let ips_vids =
                  (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                    nd_log_get_bound_insert_LINEITEM vid as
                    {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                    in
                    (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER12_mORDERS1_bind_0t0_1t1_3t2
                       {ra:None immut, rb:None immut, rc:None immut,
                       rd:None immut, re:Some LINEITEM_ORDERKEY,
                       rf:delta_tuples2, rg:false}).fold ((\_accmap -> (\b3 ->
                      bind b3 as {key:ip, value:tuples} in 
                      (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                       ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                       rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
                       (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                        re:map_val};
                        _accmap)))) empty { ra:string, rb:string, rc:int,
                       rd:int, re:int } @ { Collection }};
                       _accmap)))) empty { ra:address, rb:{ key:int, value:int
                      }, rc:collection { ra:string, rb:string, rc:int, rd:int,
                      re:int } @ { Collection } } @ { Collection })))) empty {
                    ra:address, rb:{ key:int, value:int }, rc:collection {
                    ra:string, rb:string, rc:int, rd:int, re:int
                    } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                    bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 ->
                    (\b5 -> bind b2 as {key:acc_vid, value:acc_tuples} in 
                    bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                    (acc_vid.insert vid;
                     {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                     ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                     ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                     empty { ra:string, rb:string, rc:int, rd:int, re:int
                     } @ { Collection }})))) {key:empty { key:int, value:int
                    } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                    rd:int, re:int } @ { Collection }} in
                  ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                    value:vid_send_list_tup} in 
                    ((insert_LINEITEM_rcv_corrective_s64_m_REVENUE_mCUSTOMER11_mLINEITEM4,
                       ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                     rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                     rg:vid_send_list_tup.value};
                     acc_count + 1)))) acc_count
                else if stmt_id == 63
                  then let ips_vids =
                    (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                      nd_log_get_bound_insert_LINEITEM vid as
                      {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                      in
                      (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_3t2
                         {ra:None immut, rb:None immut, rc:None immut,
                         rd:None immut, re:None immut, rf:delta_tuples2,
                         rg:false}).fold ((\_accmap -> (\b3 ->
                        bind b3 as {key:ip, value:tuples} in 
                        (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                         ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                         rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
                         (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                          rd:map_3, re:map_val};
                          _accmap)))) empty { ra:string, rb:string, rc:int,
                         rd:int, re:int } @ { Collection }};
                         _accmap)))) empty { ra:address, rb:{ key:int,
                        value:int }, rc:collection { ra:string, rb:string,
                        rc:int, rd:int, re:int } @ { Collection }
                        } @ { Collection })))) empty { ra:address, rb:{
                      key:int, value:int }, rc:collection { ra:string,
                      rb:string, rc:int, rd:int, re:int } @ { Collection }
                      } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                      rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                      bind b2 as {key:acc_vid, value:acc_tuples} in 
                      bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                      (acc_vid.insert vid;
                       {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                       ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                       ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                       empty { ra:string, rb:string, rc:int, rd:int, re:int
                       } @ { Collection }})))) {key:empty { key:int, value:int
                      } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                      rd:int, re:int } @ { Collection }} in
                    ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                      value:vid_send_list_tup} in 
                      ((insert_LINEITEM_rcv_corrective_s63_m_REVENUE_mCUSTOMER11_mLINEITEM4,
                         ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                       rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                       rg:vid_send_list_tup.value};
                       acc_count + 1)))) acc_count
                  else if stmt_id == 60
                    then let ips_vids =
                      (vid_list.fold ((\_accext -> (\vid -> _accext.combine
                        (bind nd_log_get_bound_insert_LINEITEM vid as
                        {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                        in
                        (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER11_mORDERS1_bind_0t0_1t1_3t2
                           {ra:None immut, rb:None immut, rc:None immut,
                           rd:None immut, re:Some LINEITEM_ORDERKEY,
                           rf:delta_tuples2, rg:false}).fold ((\_accmap ->
                          (\b3 -> bind b3 as {key:ip, value:tuples} in 
                          (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                           ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                           rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
                           (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                            rd:map_3, re:map_val};
                            _accmap)))) empty { ra:string, rb:string, rc:int,
                           rd:int, re:int } @ { Collection }};
                           _accmap)))) empty { ra:address, rb:{ key:int,
                          value:int }, rc:collection { ra:string, rb:string,
                          rc:int, rd:int, re:int } @ { Collection }
                          } @ { Collection })))) empty { ra:address, rb:{
                        key:int, value:int }, rc:collection { ra:string,
                        rb:string, rc:int, rd:int, re:int } @ { Collection }
                        } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip,
                        rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                        bind b2 as {key:acc_vid, value:acc_tuples} in 
                        bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                        (acc_vid.insert vid;
                         {key:acc_vid, value:((acc_tuples.combine
                         tuples).groupBy ((\tuple -> tuple)) ((\_ -> (\_ ->
                         ()))) ()).fold ((\_accmap -> (\x ->
                         (_accmap.insert (x.key);_accmap)))) empty { ra:string,
                         rb:string, rc:int, rd:int, re:int } @ { Collection }}))))
                        {key:empty { key:int, value:int } @ { Seq },
                        value:empty { ra:string, rb:string, rc:int, rd:int,
                        re:int } @ { Collection }} in
                      ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                        value:vid_send_list_tup} in 
                        ((insert_LINEITEM_rcv_corrective_s60_m_REVENUE_mCUSTOMER11_mLINEITEM4,
                           ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                         rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                         rg:vid_send_list_tup.value};
                         acc_count + 1)))) acc_count
                    else if stmt_id == 59
                      then let ips_vids =
                        (vid_list.fold ((\_accext -> (\vid -> _accext.combine
                          (bind nd_log_get_bound_insert_LINEITEM vid as
                          {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
                          in
                          (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_3t2
                             {ra:None immut, rb:None immut, rc:None immut,
                             rd:None immut, re:None immut, rf:delta_tuples2,
                             rg:false}).fold ((\_accmap -> (\b3 ->
                            bind b3 as {key:ip, value:tuples} in 
                            (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                             ((\_accmap -> (\b3 -> bind b3 as {ra:vid,
                             rb:map_0, rc:map_1, rd:map_2, re:map_3,
                             rf:map_val} in 
                             (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                              rd:map_3, re:map_val};
                              _accmap)))) empty { ra:string, rb:string, rc:int,
                             rd:int, re:int } @ { Collection }};
                             _accmap)))) empty { ra:address, rb:{ key:int,
                            value:int }, rc:collection { ra:string, rb:string,
                            rc:int, rd:int, re:int } @ { Collection }
                            } @ { Collection })))) empty { ra:address, rb:{
                          key:int, value:int }, rc:collection { ra:string,
                          rb:string, rc:int, rd:int, re:int } @ { Collection }
                          } @ { Collection }).groupBy ((\b1 ->
                          bind b1 as {ra:ip, rb:vid, rc:tuples} in ip))
                          ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                          value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                          rc:tuples} in 
                          (acc_vid.insert vid;
                           {key:acc_vid, value:((acc_tuples.combine
                           tuples).groupBy ((\tuple -> tuple)) ((\_ -> (\_ ->
                           ()))) ()).fold ((\_accmap -> (\x ->
                           (_accmap.insert (x.key);_accmap)))) empty {
                           ra:string, rb:string, rc:int, rd:int, re:int
                           } @ { Collection }})))) {key:empty { key:int,
                          value:int } @ { Seq }, value:empty { ra:string,
                          rb:string, rc:int, rd:int, re:int } @ { Collection }}
                        in
                        ips_vids.fold ((\acc_count -> (\b3 ->
                          bind b3 as {key:ip, value:vid_send_list_tup} in 
                          ((insert_LINEITEM_rcv_corrective_s59_m_REVENUE_mCUSTOMER11_mLINEITEM4,
                             ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
                           rd:hop, re:corrective_vid, rf:vid_send_list_tup.key,
                           rg:vid_send_list_tup.value};
                           acc_count + 1)))) acc_count
                      else if stmt_id == 34
                        then let ips_vids =
                          (vid_list.fold ((\_accext -> (\vid -> _accext.combine
                            (bind nd_log_get_bound_delete_CUSTOMER vid as
                            {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                            in
                            (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mLINEITEM4_bind_0t0_1t1_3t3
                               {ra:None immut, rb:None immut, rc:None immut,
                               rd:None immut, re:delta_tuples2, rf:false}).fold
                              ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                              value:tuples} in 
                              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                               ((\_accmap -> (\b3 -> bind b3 as {ra:vid,
                               rb:map_0, rc:map_1, rd:map_2, re:map_3,
                               rf:map_val} in 
                               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                                rd:map_3, re:map_val};
                                _accmap)))) empty { ra:string, rb:string,
                               rc:int, rd:int, re:int } @ { Collection }};
                               _accmap)))) empty { ra:address, rb:{ key:int,
                              value:int }, rc:collection { ra:string,
                              rb:string, rc:int, rd:int, re:int
                              } @ { Collection } } @ { Collection })))) empty {
                            ra:address, rb:{ key:int, value:int },
                            rc:collection { ra:string, rb:string, rc:int,
                            rd:int, re:int } @ { Collection }
                            } @ { Collection }).groupBy ((\b1 ->
                            bind b1 as {ra:ip, rb:vid, rc:tuples} in ip))
                            ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                            value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                            rc:tuples} in 
                            (acc_vid.insert vid;
                             {key:acc_vid, value:((acc_tuples.combine
                             tuples).groupBy ((\tuple -> tuple)) ((\_ -> (\_ ->
                             ()))) ()).fold ((\_accmap -> (\x ->
                             (_accmap.insert (x.key);_accmap)))) empty {
                             ra:string, rb:string, rc:int, rd:int, re:int
                             } @ { Collection }})))) {key:empty { key:int,
                            value:int } @ { Seq }, value:empty { ra:string,
                            rb:string, rc:int, rd:int, re:int
                            } @ { Collection }} in
                          ips_vids.fold ((\acc_count -> (\b3 ->
                            bind b3 as {key:ip, value:vid_send_list_tup} in 
                            ((delete_CUSTOMER_rcv_corrective_s34_m_REVENUE_mCUSTOMER11_mLINEITEM4,
                               ip)<- {ra:orig_addr, rb:orig_stmt_id,
                             rc:orig_vid, rd:hop, re:corrective_vid,
                             rf:vid_send_list_tup.key,
                             rg:vid_send_list_tup.value};
                             acc_count + 1)))) acc_count
                        else if stmt_id == 31
                          then let ips_vids =
                            (vid_list.fold ((\_accext -> (\vid ->
                              _accext.combine (bind
                              nd_log_get_bound_delete_CUSTOMER vid as
                              {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                              in
                              (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mORDERS11_mLINEITEM4_bind_0t0_1t1_3t3
                                 {ra:None immut, rb:None immut,
                                 rc:Some CUSTOMER_CUSTKEY, rd:None immut,
                                 re:delta_tuples2, rf:false}).fold
                                ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                value:tuples} in 
                                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                                 ((\_accmap -> (\b3 -> bind b3 as {ra:vid,
                                 rb:map_0, rc:map_1, rd:map_2, re:map_3,
                                 rf:map_val} in 
                                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2,
                                  rd:map_3, re:map_val};
                                  _accmap)))) empty { ra:string, rb:string,
                                 rc:int, rd:int, re:int } @ { Collection }};
                                 _accmap)))) empty { ra:address, rb:{ key:int,
                                value:int }, rc:collection { ra:string,
                                rb:string, rc:int, rd:int, re:int
                                } @ { Collection } } @ { Collection }))))
                              empty { ra:address, rb:{ key:int, value:int },
                              rc:collection { ra:string, rb:string, rc:int,
                              rd:int, re:int } @ { Collection }
                              } @ { Collection }).groupBy ((\b1 ->
                              bind b1 as {ra:ip, rb:vid, rc:tuples} in ip))
                              ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                              value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                              rc:tuples} in 
                              (acc_vid.insert vid;
                               {key:acc_vid, value:((acc_tuples.combine
                               tuples).groupBy ((\tuple -> tuple)) ((\_ ->
                               (\_ -> ()))) ()).fold ((\_accmap -> (\x ->
                               (_accmap.insert (x.key);_accmap)))) empty {
                               ra:string, rb:string, rc:int, rd:int, re:int
                               } @ { Collection }})))) {key:empty { key:int,
                              value:int } @ { Seq }, value:empty { ra:string,
                              rb:string, rc:int, rd:int, re:int
                              } @ { Collection }} in
                            ips_vids.fold ((\acc_count -> (\b3 ->
                              bind b3 as {key:ip, value:vid_send_list_tup} in 
                              ((delete_CUSTOMER_rcv_corrective_s31_m_REVENUE_mCUSTOMER11_mLINEITEM4,
                                 ip)<- {ra:orig_addr, rb:orig_stmt_id,
                               rc:orig_vid, rd:hop, re:corrective_vid,
                               rf:vid_send_list_tup.key,
                               rg:vid_send_list_tup.value};
                               acc_count + 1)))) acc_count
                          else if stmt_id == 25
                            then let ips_vids =
                              (vid_list.fold ((\_accext -> (\vid ->
                                _accext.combine (bind
                                nd_log_get_bound_insert_CUSTOMER vid as
                                {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                                in
                                (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mLINEITEM4_bind_0t0_1t1_3t3
                                   {ra:None immut, rb:None immut,
                                   rc:None immut, rd:None immut,
                                   re:delta_tuples2, rf:false}).fold
                                  ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                  value:tuples} in 
                                  (_accmap.insert {ra:ip, rb:vid,
                                   rc:tuples.fold ((\_accmap -> (\b3 ->
                                   bind b3 as {ra:vid, rb:map_0, rc:map_1,
                                   rd:map_2, re:map_3, rf:map_val} in 
                                   (_accmap.insert {ra:map_0, rb:map_1,
                                    rc:map_2, rd:map_3, re:map_val};
                                    _accmap)))) empty { ra:string, rb:string,
                                   rc:int, rd:int, re:int } @ { Collection }};
                                   _accmap)))) empty { ra:address, rb:{
                                  key:int, value:int }, rc:collection {
                                  ra:string, rb:string, rc:int, rd:int, re:int
                                  } @ { Collection } } @ { Collection }))))
                                empty { ra:address, rb:{ key:int, value:int },
                                rc:collection { ra:string, rb:string, rc:int,
                                rd:int, re:int } @ { Collection }
                                } @ { Collection }).groupBy ((\b1 ->
                                bind b1 as {ra:ip, rb:vid, rc:tuples} in ip))
                                ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                                value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                                rc:tuples} in 
                                (acc_vid.insert vid;
                                 {key:acc_vid, value:((acc_tuples.combine
                                 tuples).groupBy ((\tuple -> tuple)) ((\_ ->
                                 (\_ -> ()))) ()).fold ((\_accmap -> (\x ->
                                 (_accmap.insert (x.key);_accmap)))) empty {
                                 ra:string, rb:string, rc:int, rd:int, re:int
                                 } @ { Collection }})))) {key:empty { key:int,
                                value:int } @ { Seq }, value:empty { ra:string,
                                rb:string, rc:int, rd:int, re:int
                                } @ { Collection }} in
                              ips_vids.fold ((\acc_count -> (\b3 ->
                                bind b3 as {key:ip,
                                value:vid_send_list_tup} in 
                                ((insert_CUSTOMER_rcv_corrective_s25_m_REVENUE_mCUSTOMER11_mLINEITEM4,
                                   ip)<- {ra:orig_addr, rb:orig_stmt_id,
                                 rc:orig_vid, rd:hop, re:corrective_vid,
                                 rf:vid_send_list_tup.key,
                                 rg:vid_send_list_tup.value};
                                 acc_count + 1)))) acc_count
                            else if stmt_id == 22
                              then let ips_vids =
                                (vid_list.fold ((\_accext -> (\vid ->
                                  _accext.combine (bind
                                  nd_log_get_bound_insert_CUSTOMER vid as
                                  {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                                  in
                                  (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mORDERS11_mLINEITEM4_bind_0t0_1t1_3t3
                                     {ra:None immut, rb:None immut,
                                     rc:Some CUSTOMER_CUSTKEY, rd:None immut,
                                     re:delta_tuples2, rf:false}).fold
                                    ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                    value:tuples} in 
                                    (_accmap.insert {ra:ip, rb:vid,
                                     rc:tuples.fold ((\_accmap -> (\b3 ->
                                     bind b3 as {ra:vid, rb:map_0, rc:map_1,
                                     rd:map_2, re:map_3, rf:map_val} in 
                                     (_accmap.insert {ra:map_0, rb:map_1,
                                      rc:map_2, rd:map_3, re:map_val};
                                      _accmap)))) empty { ra:string, rb:string,
                                     rc:int, rd:int, re:int } @ { Collection }};
                                     _accmap)))) empty { ra:address, rb:{
                                    key:int, value:int }, rc:collection {
                                    ra:string, rb:string, rc:int, rd:int,
                                    re:int } @ { Collection }
                                    } @ { Collection })))) empty { ra:address,
                                  rb:{ key:int, value:int }, rc:collection {
                                  ra:string, rb:string, rc:int, rd:int, re:int
                                  } @ { Collection }
                                  } @ { Collection }).groupBy ((\b1 ->
                                  bind b1 as {ra:ip, rb:vid, rc:tuples} in ip))
                                  ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                                  value:acc_tuples} in bind b5 as {ra:ip,
                                  rb:vid, rc:tuples} in 
                                  (acc_vid.insert vid;
                                   {key:acc_vid, value:((acc_tuples.combine
                                   tuples).groupBy ((\tuple -> tuple)) ((\_ ->
                                   (\_ -> ()))) ()).fold ((\_accmap -> (\x ->
                                   (_accmap.insert (x.key);_accmap)))) empty {
                                   ra:string, rb:string, rc:int, rd:int, re:int
                                   } @ { Collection }})))) {key:empty {
                                  key:int, value:int } @ { Seq }, value:empty {
                                  ra:string, rb:string, rc:int, rd:int, re:int
                                  } @ { Collection }} in
                                ips_vids.fold ((\acc_count -> (\b3 ->
                                  bind b3 as {key:ip,
                                  value:vid_send_list_tup} in 
                                  ((insert_CUSTOMER_rcv_corrective_s22_m_REVENUE_mCUSTOMER11_mLINEITEM4,
                                     ip)<- {ra:orig_addr, rb:orig_stmt_id,
                                   rc:orig_vid, rd:hop, re:corrective_vid,
                                   rf:vid_send_list_tup.key,
                                   rg:vid_send_list_tup.value};
                                   acc_count + 1)))) acc_count else acc_count)))
        0)


declare nd_REVENUE_mCUSTOMER11_mORDERS1_send_correctives : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid, rf:delta_tuples} in 
  let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:2, value:21}, {key:3, value:30}, {key:4, value:39}, {key:5,
    value:49}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_2, rd:map_3, re:map_4, rf:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
         rf:map_4, rg:map_val};
         _accmap)))) empty { ra:{ key:int, value:int }, rb:string, rc:string,
        rd:int, re:int, rf:int, rg:real } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 49
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_ORDERS vid as
            {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
            in
            (shuffle_REVENUE_mCUSTOMER11_mORDERS1_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_2t2_3t3
               {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
               re:Some ORDERS_CUSTKEY, rf:delta_tuples2, rg:false}).fold
              ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
               re:map_3, rf:map_4, rg:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                re:map_4, rf:map_val};
                _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
               re:int, rf:real } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
              rf:real } @ { Collection } } @ { Collection })))) empty {
            ra:address, rb:{ key:int, value:int }, rc:collection { ra:string,
            rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
             rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }}))))
            {key:empty { key:int, value:int } @ { Seq }, value:empty {
            ra:string, rb:string, rc:int, rd:int, re:int, rf:real
            } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_ORDERS_rcv_corrective_s49_m_REVENUE_mCUSTOMER11_mORDERS1,
               ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:corrective_vid, rf:vid_send_list_tup.key,
             rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 39
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_ORDERS vid as
              {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
              in
              (shuffle_REVENUE_mCUSTOMER11_mORDERS1_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_2t2_3t3
                 {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                 re:Some ORDERS_CUSTKEY, rf:delta_tuples2, rg:false}).fold
                ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                 re:map_3, rf:map_4, rg:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                  re:map_4, rf:map_val};
                  _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                 re:int, rf:real } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
                rf:real } @ { Collection } } @ { Collection })))) empty {
              ra:address, rb:{ key:int, value:int }, rc:collection { ra:string,
              rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
              } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
              rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
              value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
               rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }}))))
              {key:empty { key:int, value:int } @ { Seq }, value:empty {
              ra:string, rb:string, rc:int, rd:int, re:int, rf:real
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_ORDERS_rcv_corrective_s39_m_REVENUE_mCUSTOMER11_mORDERS1,
                 ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
               re:corrective_vid, rf:vid_send_list_tup.key,
               rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count
          else if stmt_id == 30
            then let ips_vids =
              (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                nd_log_get_bound_delete_CUSTOMER vid as
                {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                in
                (shuffle_REVENUE_mCUSTOMER11_mORDERS1_to_REVENUE_mORDERS11_bind_0t0_1t1_2t2_4t4
                   {ra:None immut, rb:None immut, rc:None immut,
                   rd:Some CUSTOMER_CUSTKEY, re:None immut, rf:delta_tuples2,
                   rg:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                  value:tuples} in 
                  (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                   (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                   re:map_3, rf:map_4, rg:map_val} in 
                   (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                    re:map_4, rf:map_val};
                    _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                   re:int, rf:real } @ { Collection }};
                   _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
                  rf:real } @ { Collection } } @ { Collection })))) empty {
                ra:address, rb:{ key:int, value:int }, rc:collection {
                ra:string, rb:string, rc:int, rd:int, re:int, rf:real
                } @ { Collection } } @ { Collection }).groupBy ((\b1 ->
                bind b1 as {ra:ip, rb:vid, rc:tuples} in ip)) ((\b2 -> (\b5 ->
                bind b2 as {key:acc_vid, value:acc_tuples} in 
                bind b5 as {ra:ip, rb:vid, rc:tuples} in 
                (acc_vid.insert vid;
                 {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                 ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                 ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                 empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
                 } @ { Collection }})))) {key:empty { key:int, value:int
                } @ { Seq }, value:empty { ra:string, rb:string, rc:int,
                rd:int, re:int, rf:real } @ { Collection }} in
              ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                value:vid_send_list_tup} in 
                ((delete_CUSTOMER_rcv_corrective_s30_m_REVENUE_mCUSTOMER11_mORDERS1,
                   ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                 re:corrective_vid, rf:vid_send_list_tup.key,
                 rg:vid_send_list_tup.value};
                 acc_count + 1)))) acc_count
            else if stmt_id == 21
              then let ips_vids =
                (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
                  nd_log_get_bound_insert_CUSTOMER vid as
                  {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
                  in
                  (shuffle_REVENUE_mCUSTOMER11_mORDERS1_to_REVENUE_mORDERS11_bind_0t0_1t1_2t2_4t4
                     {ra:None immut, rb:None immut, rc:None immut,
                     rd:Some CUSTOMER_CUSTKEY, re:None immut, rf:delta_tuples2,
                     rg:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                    value:tuples} in 
                    (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold
                     ((\_accmap -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
                     rc:map_1, rd:map_2, re:map_3, rf:map_4, rg:map_val} in 
                     (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                      re:map_4, rf:map_val};
                      _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                     re:int, rf:real } @ { Collection }};
                     _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                    rc:collection { ra:string, rb:string, rc:int, rd:int,
                    re:int, rf:real } @ { Collection } } @ { Collection }))))
                  empty { ra:address, rb:{ key:int, value:int },
                  rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
                  rf:real } @ { Collection } } @ { Collection }).groupBy
                  ((\b1 -> bind b1 as {ra:ip, rb:vid, rc:tuples} in ip))
                  ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
                  value:acc_tuples} in bind b5 as {ra:ip, rb:vid,
                  rc:tuples} in 
                  (acc_vid.insert vid;
                   {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
                   ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold
                   ((\_accmap -> (\x -> (_accmap.insert (x.key);_accmap))))
                   empty { ra:string, rb:string, rc:int, rd:int, re:int,
                   rf:real } @ { Collection }})))) {key:empty { key:int,
                  value:int } @ { Seq }, value:empty { ra:string, rb:string,
                  rc:int, rd:int, re:int, rf:real } @ { Collection }} in
                ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
                  value:vid_send_list_tup} in 
                  ((insert_CUSTOMER_rcv_corrective_s21_m_REVENUE_mCUSTOMER11_mORDERS1,
                     ip)<- {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
                   re:corrective_vid, rf:vid_send_list_tup.key,
                   rg:vid_send_list_tup.value};
                   acc_count + 1)))) acc_count else acc_count))) 0)


declare nd_REVENUE_mCUSTOMER11_send_correctives : { ra:address, rb:int, rc:{
  key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:corrective_vid, rf:delta_tuples} in let corrective_list =
  nd_filter_corrective_list {key:corrective_vid, value:{| key:int, value:int |
    {key:2, value:20}, {key:3, value:29}|} @ { Collection }} in
  if 0 == corrective_list.size () then 0
    else let delta_tuples2 =
      delta_tuples.fold ((\_accmap -> (\b3 -> bind b3 as {ra:map_0, rb:map_1,
        rc:map_2, rd:map_3, re:map_4, rf:map_val} in 
        (_accmap.insert {ra:g_min_vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
         rf:map_4, rg:map_val};
         _accmap)))) empty { ra:{ key:int, value:int }, rb:string, rc:string,
        rd:int, re:int, rf:int, rg:real } @ { Collection } in
      corrective_list.fold ((\acc_count -> (\b3 -> bind b3 as {key:stmt_id,
        value:vid_list} in if stmt_id == 29
        then let ips_vids =
          (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
            nd_log_get_bound_delete_CUSTOMER vid as
            {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
            in
            (shuffle_REVENUE_mCUSTOMER11_to_REVENUE_bind_0t0_1t1_2t2
               {ra:None immut, rb:None immut, rc:None immut, rd:delta_tuples2,
               re:false}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
              value:tuples} in 
              (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
               (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
               re:map_3, rf:map_4, rg:map_val} in 
               (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                re:map_4, rf:map_val};
                _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
               re:int, rf:real } @ { Collection }};
               _accmap)))) empty { ra:address, rb:{ key:int, value:int },
              rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
              rf:real } @ { Collection } } @ { Collection })))) empty {
            ra:address, rb:{ key:int, value:int }, rc:collection { ra:string,
            rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
            } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
            rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
            value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
            (acc_vid.insert vid;
             {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
             ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
             (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
             rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }}))))
            {key:empty { key:int, value:int } @ { Seq }, value:empty {
            ra:string, rb:string, rc:int, rd:int, re:int, rf:real
            } @ { Collection }} in
          ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
            value:vid_send_list_tup} in 
            ((delete_CUSTOMER_rcv_corrective_s29_m_REVENUE_mCUSTOMER11, ip)<- {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
             rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
             acc_count + 1)))) acc_count
        else if stmt_id == 20
          then let ips_vids =
            (vid_list.fold ((\_accext -> (\vid -> _accext.combine (bind
              nd_log_get_bound_insert_CUSTOMER vid as
              {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
              in
              (shuffle_REVENUE_mCUSTOMER11_to_REVENUE_bind_0t0_1t1_2t2
                 {ra:None immut, rb:None immut, rc:None immut,
                 rd:delta_tuples2, re:false}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:vid, rc:tuples.fold ((\_accmap ->
                 (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
                 re:map_3, rf:map_4, rg:map_val} in 
                 (_accmap.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3,
                  re:map_4, rf:map_val};
                  _accmap)))) empty { ra:string, rb:string, rc:int, rd:int,
                 re:int, rf:real } @ { Collection }};
                 _accmap)))) empty { ra:address, rb:{ key:int, value:int },
                rc:collection { ra:string, rb:string, rc:int, rd:int, re:int,
                rf:real } @ { Collection } } @ { Collection })))) empty {
              ra:address, rb:{ key:int, value:int }, rc:collection { ra:string,
              rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
              } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:ip, rb:vid,
              rc:tuples} in ip)) ((\b2 -> (\b5 -> bind b2 as {key:acc_vid,
              value:acc_tuples} in bind b5 as {ra:ip, rb:vid, rc:tuples} in 
              (acc_vid.insert vid;
               {key:acc_vid, value:((acc_tuples.combine tuples).groupBy
               ((\tuple -> tuple)) ((\_ -> (\_ -> ()))) ()).fold ((\_accmap ->
               (\x -> (_accmap.insert (x.key);_accmap)))) empty { ra:string,
               rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }}))))
              {key:empty { key:int, value:int } @ { Seq }, value:empty {
              ra:string, rb:string, rc:int, rd:int, re:int, rf:real
              } @ { Collection }} in
            ips_vids.fold ((\acc_count -> (\b3 -> bind b3 as {key:ip,
              value:vid_send_list_tup} in 
              ((insert_CUSTOMER_rcv_corrective_s20_m_REVENUE_mCUSTOMER11, ip)<- {ra:orig_addr,
               rb:orig_stmt_id, rc:orig_vid, rd:hop, re:corrective_vid,
               rf:vid_send_list_tup.key, rg:vid_send_list_tup.value};
               acc_count + 1)))) acc_count else acc_count))) 0)


declare sw_insert_SUPPLIER : { ra:int, rb:string, rc:string, rd:int, re:string,
  rf:real, rg:string } -> () = (\args ->
  (sw_buf_insert_SUPPLIER.insert args;
   sw_trig_buf_idx.insert {i:0};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_insert_SUPPLIER_send_fetch : { key:int, value:int } -> () = (\vid ->
  case (sw_buf_insert_SUPPLIER.peek ()) of
  {Some args ->
    (sw_buf_insert_SUPPLIER.erase args;
     bind args as
     {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
     in
     (((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_string_string_int_int_int {ra:20, rb:None immut, rc:None immut,
         rd:None immut, re:Some SUPPLIER_NATIONKEY, rf:Some SUPPLIER_SUPPKEY}).fold
        ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_REVENUE_mSUPPLIER11_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
          rb:None immut, rc:None immut, rd:empty { ra:{ key:int, value:int },
          rb:string, rc:string, rd:int, re:int, rf:int, rg:real
          } @ { Collection }, re:true}).fold ((\_accmap -> (\b3 ->
        bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:0, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_string_string_int_int_int {ra:21, rb:None immut,
           rc:None immut, rd:None immut, re:Some SUPPLIER_NATIONKEY,
           rf:Some SUPPLIER_SUPPKEY}).fold ((\count -> (\b3 ->
          bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_REVENUE_mSUPPLIER12_to_REVENUE_bind_0t0_1t1_2t2
            {ra:None immut, rb:None immut, rc:None immut, rd:empty { ra:{
            key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int,
            rg:real } @ { Collection }, re:true}).fold ((\_accmap -> (\b3 ->
          bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:0, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }).combine (let
          sender_count =
          (route_to_int_int_int {ra:8, rb:None immut, rc:None immut,
             rd:Some SUPPLIER_SUPPKEY}).fold ((\count -> (\b3 ->
            bind b3 as {i:ip} in count + 1))) 0 in
          ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER1_to_REVENUE_mCUSTOMER11_bind_2t0_4t1
              {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
              re:None immut, rf:empty { ra:{ key:int, value:int }, rb:int,
              rc:int, rd:int, re:real } @ { Collection }, rg:true}).fold
            ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {ra:ip, rb:1, rc:sender_count};_accmap)))) empty {
            ra:address, rb:int, rc:int } @ { Collection }).combine (let
            sender_count =
            (route_to_string_string_int_int {ra:9, rb:None immut,
               rc:None immut, rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold
              ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
            ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_3t2
                {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                re:None immut, rf:empty { ra:{ key:int, value:int }, rb:string,
                rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:true}).fold
              ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:1, rc:sender_count};_accmap))))
              empty { ra:address, rb:int, rc:int } @ { Collection }).combine
              (let sender_count =
              (route_to_int_int_int {ra:5, rb:None immut, rc:None immut,
                 rd:Some SUPPLIER_SUPPKEY}).fold ((\count -> (\b3 ->
                bind b3 as {i:ip} in count + 1))) 0 in
              ((shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER11_mORDERS1_bind_2t0_4t1
                  {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                  re:None immut, rf:empty { ra:{ key:int, value:int }, rb:int,
                  rc:int, rd:int, re:real } @ { Collection }, rg:true}).fold
                ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:2, rc:sender_count};_accmap))))
                empty { ra:address, rb:int, rc:int } @ { Collection }).combine
                (let sender_count =
                (route_to_string_string_int_int {ra:9, rb:None immut,
                   rc:None immut, rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold
                  ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER11_mORDERS1_bind_0t0_1t1_3t2
                    {ra:None immut, rb:None immut, rc:None immut,
                    rd:None immut, re:None immut, rf:empty { ra:{ key:int,
                    value:int }, rb:string, rc:string, rd:int, re:int, rf:int
                    } @ { Collection }, rg:true}).fold ((\_accmap -> (\b3 ->
                  bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:2, rc:sender_count};_accmap))))
                  empty { ra:address, rb:int, rc:int
                  } @ { Collection }).combine (let sender_count =
                  (route_to_string_string_int_int {ra:9, rb:None immut,
                     rc:None immut, rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold
                    ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                  ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER11_mLINEITEM4_bind_0t0_1t1_2t2
                      {ra:None immut, rb:None immut, rc:None immut,
                      rd:Some SUPPLIER_SUPPKEY, re:empty { ra:{ key:int,
                      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
                      } @ { Collection }, rf:true}).fold ((\_accmap -> (\b3 ->
                    bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:3, rc:sender_count};_accmap))))
                    empty { ra:address, rb:int, rc:int
                    } @ { Collection }).combine (let sender_count =
                    (route_to_int_int_int {ra:13, rb:None immut, rc:None immut,
                       rd:Some SUPPLIER_SUPPKEY}).fold ((\count -> (\b3 ->
                      bind b3 as {i:ip} in count + 1))) 0 in
                    ((shuffle_REVENUE_mCUSTOMER12_mSUPPLIER1_to_REVENUE_mCUSTOMER12_bind_2t0_4t1
                        {ra:None immut, rb:None immut, rc:None immut,
                        rd:None immut, re:None immut, rf:empty { ra:{ key:int,
                        value:int }, rb:int, rc:int, rd:int, re:real
                        } @ { Collection }, rg:true}).fold ((\_accmap ->
                      (\b3 -> bind b3 as {key:ip, value:tuples} in 
                      (_accmap.insert {ra:ip, rb:4, rc:sender_count};_accmap))))
                      empty { ra:address, rb:int, rc:int
                      } @ { Collection }).combine (let sender_count =
                      (route_to_string_string_int_int {ra:9, rb:None immut,
                         rc:None immut, rd:None immut,
                         re:Some SUPPLIER_NATIONKEY}).fold ((\count -> (\b3 ->
                        bind b3 as {i:ip} in count + 1))) 0 in
                      ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_3t2
                          {ra:None immut, rb:None immut, rc:None immut,
                          rd:None immut, re:None immut, rf:empty { ra:{
                          key:int, value:int }, rb:string, rc:string, rd:int,
                          re:int, rf:int } @ { Collection }, rg:true}).fold
                        ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                        value:tuples} in 
                        (_accmap.insert {ra:ip, rb:4, rc:sender_count};_accmap))))
                        empty { ra:address, rb:int, rc:int
                        } @ { Collection }).combine (let sender_count =
                        (route_to_int_int_int {ra:12, rb:None immut,
                           rc:None immut, rd:Some SUPPLIER_SUPPKEY}).fold
                          ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1)))
                          0 in
                        ((shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER12_mORDERS1_bind_2t0_4t1
                            {ra:None immut, rb:None immut, rc:None immut,
                            rd:None immut, re:None immut, rf:empty { ra:{
                            key:int, value:int }, rb:int, rc:int, rd:int,
                            re:real } @ { Collection }, rg:true}).fold
                          ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                          value:tuples} in 
                          (_accmap.insert {ra:ip, rb:5, rc:sender_count};
                           _accmap)))) empty { ra:address, rb:int, rc:int
                          } @ { Collection }).combine (let sender_count =
                          (route_to_string_string_int_int {ra:9, rb:None immut,
                             rc:None immut, rd:None immut,
                             re:Some SUPPLIER_NATIONKEY}).fold ((\count ->
                            (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                          ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER12_mORDERS1_bind_0t0_1t1_3t2
                              {ra:None immut, rb:None immut, rc:None immut,
                              rd:None immut, re:None immut, rf:empty { ra:{
                              key:int, value:int }, rb:string, rc:string,
                              rd:int, re:int, rf:int } @ { Collection },
                              rg:true}).fold ((\_accmap -> (\b3 ->
                            bind b3 as {key:ip, value:tuples} in 
                            (_accmap.insert {ra:ip, rb:5, rc:sender_count};
                             _accmap)))) empty { ra:address, rb:int, rc:int
                            } @ { Collection }).combine (let sender_count =
                            (route_to_int_int_int {ra:5, rb:None immut,
                               rc:None immut, rd:Some SUPPLIER_SUPPKEY}).fold
                              ((\count -> (\b3 -> bind b3 as {i:ip} in count +
                              1))) 0 in
                            ((shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mORDERS11_bind_2t0_4t1
                                {ra:None immut, rb:None immut, rc:None immut,
                                rd:None immut, re:None immut, rf:empty { ra:{
                                key:int, value:int }, rb:int, rc:int, rd:int,
                                re:real } @ { Collection }, rg:true}).fold
                              ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                              value:tuples} in 
                              (_accmap.insert {ra:ip, rb:6, rc:sender_count};
                               _accmap)))) empty { ra:address, rb:int, rc:int
                              } @ { Collection }).combine (let sender_count =
                              (route_to_string_string_int_int {ra:16,
                                 rb:None immut, rc:None immut, rd:None immut,
                                 re:Some SUPPLIER_NATIONKEY}).fold ((\count ->
                                (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                              ((shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS11_bind_0t0_1t1_3t2
                                  {ra:None immut, rb:None immut, rc:None immut,
                                  rd:None immut, re:None immut, rf:empty { ra:{
                                  key:int, value:int }, rb:string, rc:string,
                                  rd:int, re:int, rf:int } @ { Collection },
                                  rg:true}).fold ((\_accmap -> (\b3 ->
                                bind b3 as {key:ip, value:tuples} in 
                                (_accmap.insert {ra:ip, rb:6, rc:sender_count};
                                 _accmap)))) empty { ra:address, rb:int, rc:int
                                } @ { Collection }).combine (let sender_count =
                                (route_to_string_string_int_int {ra:16,
                                   rb:None immut, rc:None immut, rd:None immut,
                                   re:Some SUPPLIER_NATIONKEY}).fold
                                  ((\count -> (\b3 -> bind b3 as {i:ip} in 
                                  count + 1))) 0 in
                                ((shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS11_mLINEITEM4_bind_0t0_1t1_2t2
                                    {ra:None immut, rb:None immut,
                                    rc:None immut, rd:Some SUPPLIER_SUPPKEY,
                                    re:empty { ra:{ key:int, value:int },
                                    rb:string, rc:string, rd:int, re:int,
                                    rf:int } @ { Collection }, rf:true}).fold
                                  ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                  value:tuples} in 
                                  (_accmap.insert {ra:ip, rb:7,
                                   rc:sender_count};
                                   _accmap)))) empty { ra:address, rb:int,
                                  rc:int } @ { Collection }).combine (let
                                  sender_count =
                                  (route_to_int_int_int {ra:12, rb:None immut,
                                     rc:None immut, rd:Some SUPPLIER_SUPPKEY}).fold
                                    ((\count -> (\b3 -> bind b3 as {i:ip} in 
                                    count + 1))) 0 in
                                  ((shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mORDERS12_bind_2t0_4t1
                                      {ra:None immut, rb:None immut,
                                      rc:None immut, rd:None immut,
                                      re:None immut, rf:empty { ra:{ key:int,
                                      value:int }, rb:int, rc:int, rd:int,
                                      re:real } @ { Collection }, rg:true}).fold
                                    ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                    value:tuples} in 
                                    (_accmap.insert {ra:ip, rb:8,
                                     rc:sender_count};
                                     _accmap)))) empty { ra:address, rb:int,
                                    rc:int } @ { Collection }).combine (let
                                    sender_count =
                                    (route_to_string_string_int_int {ra:16,
                                       rb:None immut, rc:None immut,
                                       rd:None immut,
                                       re:Some SUPPLIER_NATIONKEY}).fold
                                      ((\count -> (\b3 -> bind b3 as {i:ip} in 
                                      count + 1))) 0 in
                                    ((shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS12_bind_0t0_1t1_3t2
                                        {ra:None immut, rb:None immut,
                                        rc:None immut, rd:None immut,
                                        re:None immut, rf:empty { ra:{ key:int,
                                        value:int }, rb:string, rc:string,
                                        rd:int, re:int, rf:int
                                        } @ { Collection }, rg:true}).fold
                                      ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                      value:tuples} in 
                                      (_accmap.insert {ra:ip, rb:8,
                                       rc:sender_count};
                                       _accmap)))) empty { ra:address, rb:int,
                                      rc:int } @ { Collection }).combine (let
                                      sender_count =
                                      (route_to_string_string_int_int {ra:19,
                                         rb:None immut, rc:None immut,
                                         rd:None immut,
                                         re:Some SUPPLIER_NATIONKEY}).fold
                                        ((\count -> (\b3 ->
                                        bind b3 as {i:ip} in count + 1))) 0 in
                                      (shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mLINEITEM4_bind_0t0_1t1_2t2
                                         {ra:None immut, rb:None immut,
                                         rc:None immut,
                                         rd:Some SUPPLIER_SUPPKEY, re:empty {
                                         ra:{ key:int, value:int }, rb:string,
                                         rc:string, rd:int, re:int, rf:int
                                         } @ { Collection }, rf:true}).fold
                                        ((\_accmap -> (\b3 ->
                                        bind b3 as {key:ip, value:tuples} in 
                                        (_accmap.insert {ra:ip, rb:9,
                                         rc:sender_count};
                                         _accmap)))) empty { ra:address,
                                        rb:int, rc:int } @ { Collection })))))))))))))))))).groupBy
      ((\b1 -> bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip,
      value:stmt_id})) ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id,
      rc:count} in acc + count))) 0).groupBy ((\b1 -> bind b1 as {key:b2,
      value:count} in bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc ->
      (\b3 -> bind b3 as {key:ip_and_stmt_id, value:count} in bind
      ip_and_stmt_id as {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_insert_SUPPLIER_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid,
       rd:SUPPLIER_SUPPKEY, re:SUPPLIER_NAME, rf:SUPPLIER_ADDRESS,
       rg:SUPPLIER_NATIONKEY, rh:SUPPLIER_PHONE, ri:SUPPLIER_ACCTBAL,
       rj:SUPPLIER_COMMENT};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_string_string_int_int {ra:19, rb:None immut, rc:None immut,
            rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:9, rb:19, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:16, rb:None immut, rc:None immut,
           rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:8, rb:16, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:12, rb:None immut, rc:None immut,
           rd:Some SUPPLIER_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:8, rb:12, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:16, rb:None immut, rc:None immut,
           rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:7, rb:16, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:16, rb:None immut, rc:None immut,
           rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:6, rb:16, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:5, rb:None immut, rc:None immut,
           rd:Some SUPPLIER_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:6, rb:5, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
           rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:5, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:12, rb:None immut, rc:None immut,
           rd:Some SUPPLIER_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:5, rb:12, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
           rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:4, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:13, rb:None immut, rc:None immut,
           rd:Some SUPPLIER_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:4, rb:13, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
           rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:3, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
           rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:2, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:5, rb:None immut, rc:None immut,
           rd:Some SUPPLIER_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:2, rb:5, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
           rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:1, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:8, rb:None immut, rc:None immut,
           rd:Some SUPPLIER_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:1, rb:8, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:21, rb:None immut,
           rc:None immut, rd:None immut, re:Some SUPPLIER_NATIONKEY,
           rf:Some SUPPLIER_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:0, rb:21, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:20, rb:None immut,
           rc:None immut, rd:None immut, re:Some SUPPLIER_NATIONKEY,
           rf:Some SUPPLIER_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:0, rb:20, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine empty {
      ra:int, rb:int, rc:address } @ { Collection }))))))))))))))))).groupBy
      ((\b1 -> bind b1 as {ra:stmt_id, rb:map_id, rc:ip} in ip)) ((\acc ->
      (\b3 -> bind b3 as {ra:stmt_id, rb:map_id, rc:ip} in 
      (acc.insert {key:stmt_id, value:map_id};acc)))) empty { key:int,
      value:int } @ { Collection }).iterate ((\b1 -> bind b1 as {key:ip,
      value:stmt_map_ids} in 
      (nd_insert_SUPPLIER_rcv_fetch, ip)<- {ra:stmt_map_ids, rb:vid,
      rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
      rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
      ri:SUPPLIER_COMMENT}))))}{None ->
                                 error
                                   (print
                                      "unexpected missing arguments in sw_buf_insert_SUPPLIER")})


declare nd_insert_SUPPLIER_do_complete_s0 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  ((((((bind map_REVENUE_mSUPPLIER11_s0_buf as ind __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in re == SUPPLIER_NATIONKEY and rf == SUPPLIER_SUPPKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
      re:map_3, rf:map_4, rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_SUPPKEY,
    rf:__map_ret__1} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:__map_ret__1} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__1 * -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).combine ((bind map_REVENUE_mSUPPLIER12_s0_buf as ind
    __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in re == SUPPLIER_NATIONKEY and rf == SUPPLIER_SUPPKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
      re:map_3, rf:map_4, rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_SUPPKEY,
    rf:__map_ret__2} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__2};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection })).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:__sum_ret__1} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__sum_ret__1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_2, rd:map_val} in {ra:map_0, rb:map_1, rc:map_2})) ((\acc -> (\b3 ->
    bind b3 as {ra:map_0, rb:map_1, rc:map_2, rd:map_val} in acc + map_val)))
    0).fold ((\acc -> (\b3 -> bind b3 as {key:g, value:val} in 
    (acc.insert {ra:g.ra, rb:g.rb, rc:g.rc, rd:val};acc)))) empty { ra:string,
    rb:string, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:false, rc:vid,
      rd:delta_values});
   (nd_complete_stmt_cntr_check {key:vid, value:0})))


declare nd_insert_SUPPLIER_do_complete_s1 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s1_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
       SUPPLIER_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:SUPPLIER_SUPPKEY,
    rd:__map_ret__3} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:__map_ret__3};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__map_ret__3} in _accext.combine
    (((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s1_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__4} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__4};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__4} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rf:__map_ret__3 * __map_ret__4};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rf:__prod_ret__2} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__2};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_send_correctives {ra:me, rb:1, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:1}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:1, rc:1, rd:sent_msgs, re:true,
         rf:false}))


declare nd_insert_SUPPLIER_do_complete_s2 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s2_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
       SUPPLIER_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY, rc:SUPPLIER_SUPPKEY,
    rd:__map_ret__5} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR,
     rb:REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY, rc:__map_ret__5};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY, rc:__map_ret__5} in 
    _accext.combine (((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s2_buf as ind
    __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__6} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__6};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__6} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR,
     rb:REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY, rc:SHIPPING_SUPP_NATION,
     rd:SHIPPING_CUST_NATION, re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     rf:__map_ret__5 * __map_ret__6};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY, rc:SHIPPING_SUPP_NATION,
    rd:SHIPPING_CUST_NATION, re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rf:__prod_ret__3} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY, rf:__prod_ret__3};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:REVENUE_mCUSTOMER11_mORDERS1, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_mORDERS1_send_correctives {ra:me, rb:2, rc:vid, rd:1,
     re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:2}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:2, rc:1, rd:sent_msgs, re:true,
         rf:false}))


declare nd_insert_SUPPLIER_do_complete_s3 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  ((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s3_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__7} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__7};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__7} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:SUPPLIER_SUPPKEY,
     re:__map_ret__7};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int
      {ra:REVENUE_mCUSTOMER11_mLINEITEM4, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_mLINEITEM4_send_correctives {ra:me, rb:3, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:3}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:3, rc:1, rd:sent_msgs, re:true,
         rf:false}))


declare nd_insert_SUPPLIER_do_complete_s4 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s4_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
       SUPPLIER_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:SUPPLIER_SUPPKEY,
    rd:__map_ret__8} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:__map_ret__8};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__map_ret__8} in _accext.combine
    (((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s4_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__9} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__9};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__9} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rf:__map_ret__8 * __map_ret__9};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rf:__prod_ret__4} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__4};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER12_send_correctives {ra:me, rb:4, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:4}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:4, rc:1, rd:sent_msgs, re:true,
         rf:false}))


declare nd_insert_SUPPLIER_do_complete_s5 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s5_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
       SUPPLIER_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY, rc:SUPPLIER_SUPPKEY,
    rd:__map_ret__10} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR,
     rb:REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY, rc:__map_ret__10};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY, rc:__map_ret__10} in 
    _accext.combine (((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s5_buf as ind
    __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__11} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__11};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__11} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR,
     rb:REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY, rc:SHIPPING_SUPP_NATION,
     rd:SHIPPING_CUST_NATION, re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     rf:__map_ret__10 * __map_ret__11};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY, rc:SHIPPING_SUPP_NATION,
    rd:SHIPPING_CUST_NATION, re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rf:__prod_ret__5} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY, rf:__prod_ret__5};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:REVENUE_mCUSTOMER12_mORDERS1, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER12_mORDERS1_send_correctives {ra:me, rb:5, rc:vid, rd:1,
     re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:5}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:5, rc:1, rd:sent_msgs, re:true,
         rf:false}))


declare nd_insert_SUPPLIER_do_complete_s6 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s6_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
       SUPPLIER_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
    rc:SUPPLIER_SUPPKEY, rd:__map_ret__12} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
     rc:__map_ret__12};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:__map_ret__12} in _accext.combine
    (((bind map_REVENUE_mORDERS11_mSUPPLIER2_s6_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mORDERSORDERS_CUSTKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__13} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__13};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__13} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mORDERSORDERS_CUSTKEY, rf:__map_ret__12 * __map_ret__13};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mORDERSORDERS_CUSTKEY, rf:__prod_ret__6} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_CUSTKEY,
     re:REVENUE_mORDERSORDERS_ORDERKEY, rf:__prod_ret__6};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS11_send_correctives {ra:me, rb:6, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:6}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:6, rc:1, rd:sent_msgs, re:true,
         rf:false}))


declare nd_insert_SUPPLIER_do_complete_s7 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  ((bind map_REVENUE_mORDERS11_mSUPPLIER2_s7_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mORDERSORDERS_CUSTKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__14} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__14};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__14} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:SUPPLIER_SUPPKEY, re:__map_ret__14};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mORDERS11_mLINEITEM4,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS11_mLINEITEM4_send_correctives {ra:me, rb:7, rc:vid, rd:1,
     re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:7}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:7, rc:1, rd:sent_msgs, re:true,
         rf:false}))


declare nd_insert_SUPPLIER_do_complete_s8 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s8_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
       SUPPLIER_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
    rc:SUPPLIER_SUPPKEY, rd:__map_ret__15} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
     rc:__map_ret__15};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:__map_ret__15} in _accext.combine
    (((bind map_REVENUE_mORDERS11_mSUPPLIER2_s8_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mORDERSORDERS_CUSTKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__16} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__16};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__16} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mORDERSORDERS_CUSTKEY, rf:__map_ret__15 * __map_ret__16};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mORDERSORDERS_CUSTKEY, rf:__prod_ret__7} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_CUSTKEY,
     re:REVENUE_mORDERSORDERS_ORDERKEY, rf:__prod_ret__7};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS12_send_correctives {ra:me, rb:8, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:8}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:8, rc:1, rd:sent_msgs, re:true,
         rf:false}))


declare nd_insert_SUPPLIER_do_complete_s9 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  ((bind map_REVENUE_mLINEITEM4_mSUPPLIER1_s9_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__17} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEMLINEITEM_ORDERKEY, rd:__map_ret__17};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mLINEITEMLINEITEM_ORDERKEY, rd:__map_ret__17} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEMLINEITEM_ORDERKEY, rd:SUPPLIER_SUPPKEY,
     re:__map_ret__17};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mLINEITEM4, rb:false,
      rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mLINEITEM4_send_correctives {ra:me, rb:9, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:9}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:9, rc:1, rd:sent_msgs, re:true,
         rf:false}))


declare insert_SUPPLIER_do_corrective_s0_m_REVENUE_mSUPPLIER11 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:string, rh:string, ri:int, rj:string, rk:real, rl:string, rm:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS,
  ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL,
  rl:SUPPLIER_COMMENT, rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
    rf:delta_REVENUE_mSUPPLIER11} in _accext.combine (let __prod_ret__947 =
    ((if SUPPLIER_SUPPKEY == delta_REVENUE_mSUPPLIERSUPPLIER_SUPPKEY 
      then 1 else 0) *
      if SUPPLIER_NATIONKEY == delta_REVENUE_mSUPPLIERSUPPLIER_NATIONKEY 
      then 1 else 0) * -delta_REVENUE_mSUPPLIER11 in
    {| ra:string, rb:string, rc:int, rd:real | {ra:delta_SHIPPING_SUPP_NATION,
      rb:delta_SHIPPING_CUST_NATION, rc:delta_SHIPPING_L_YEAR,
      rd:__prod_ret__947}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare insert_SUPPLIER_do_corrective_s0_m_REVENUE_mSUPPLIER12 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:string, rh:string, ri:int, rj:string, rk:real, rl:string, rm:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS,
  ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL,
  rl:SUPPLIER_COMMENT, rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
    rf:delta_REVENUE_mSUPPLIER12} in _accext.combine (let __prod_ret__949 =
    ((if SUPPLIER_SUPPKEY == delta_REVENUE_mSUPPLIERSUPPLIER_SUPPKEY 
      then 1 else 0) *
      if SUPPLIER_NATIONKEY == delta_REVENUE_mSUPPLIERSUPPLIER_NATIONKEY 
      then 1 else 0) * delta_REVENUE_mSUPPLIER12 in
    {| ra:string, rb:string, rc:int, rd:real | {ra:delta_SHIPPING_SUPP_NATION,
      rb:delta_SHIPPING_CUST_NATION, rc:delta_SHIPPING_L_YEAR,
      rd:__prod_ret__949}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare insert_SUPPLIER_do_corrective_s1_m_REVENUE_mCUSTOMER11_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:int, rb:int, rc:int, rd:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS,
  ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL,
  rl:SUPPLIER_COMMENT, rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:delta_REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER11_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s1_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
         SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      rd:SUPPLIER_NATIONKEY, re:__map_ret__207} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__207};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__207} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__207 *
       if SUPPLIER_SUPPKEY ==
         delta_REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__950} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__950 *
       delta_REVENUE_mCUSTOMER11_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__951} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__951};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_SUPPLIER_do_corrective_s2_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 :
  { ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:int, rb:int, rc:int, rd:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS,
  ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL,
  rl:SUPPLIER_COMMENT, rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s2_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
         SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      rd:SUPPLIER_NATIONKEY, re:__map_ret__228} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__228};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__228} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__228 *
       if SUPPLIER_SUPPKEY ==
         delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY 
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__997} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__997 *
       delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__998} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY, rf:__prod_ret__998};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:REVENUE_mCUSTOMER11_mORDERS1, rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER11_mORDERS1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_SUPPLIER_do_corrective_s4_m_REVENUE_mCUSTOMER12_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:int, rb:int, rc:int, rd:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS,
  ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL,
  rl:SUPPLIER_COMMENT, rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:delta_REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER12_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s4_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
         SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      rd:SUPPLIER_NATIONKEY, re:__map_ret__232} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__232};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__232} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__232 *
       if SUPPLIER_SUPPKEY ==
         delta_REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1005} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1005 *
       delta_REVENUE_mCUSTOMER12_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1006} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__1006};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_SUPPLIER_do_corrective_s5_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 :
  { ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:int, rb:int, rc:int, rd:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS,
  ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL,
  rl:SUPPLIER_COMMENT, rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s5_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
         SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      rd:SUPPLIER_NATIONKEY, re:__map_ret__233} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__233};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__233} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__233 *
       if SUPPLIER_SUPPKEY ==
         delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY 
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1007} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1007 *
       delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1008} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
       rf:__prod_ret__1008};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:REVENUE_mCUSTOMER12_mORDERS1, rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER12_mORDERS1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_SUPPLIER_do_corrective_s6_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 :
  { ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:int, rb:int, rc:int, rd:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS,
  ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL,
  rl:SUPPLIER_COMMENT, rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mORDERS11_mSUPPLIER2_s6_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
         SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:REVENUE_mORDERSORDERS_CUSTKEY,
      rd:SUPPLIER_NATIONKEY, re:__map_ret__229} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__229};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__229} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__229 *
       if SUPPLIER_SUPPKEY ==
         delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY 
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__prod_ret__999} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__prod_ret__999 *
       delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__prod_ret__1000} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_CUSTKEY,
       re:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY,
       rf:__prod_ret__1000};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_SUPPLIER_do_corrective_s6_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:SUPPLIER_SUPPKEY,
  rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY,
  rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT,
  rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mORDERS11_mSUPPLIER2} in _accext.combine (let delta_values
    =
    ((((bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s6_buf as ind __x in
      (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
         SUPPLIER_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
        ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:SUPPLIER_SUPPKEY,
      rd:__map_ret__237} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
       rc:__map_ret__237};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:__map_ret__237} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
       rc:__map_ret__237 *
       if SUPPLIER_NATIONKEY ==
         delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY then 1 else 0};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:__prod_ret__1015} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
       rc:__prod_ret__1015 * delta_REVENUE_mORDERS11_mSUPPLIER2};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:__prod_ret__1016} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mORDERSORDERS_CUSTKEY,
       re:REVENUE_mORDERSORDERS_ORDERKEY, rf:__prod_ret__1016};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_SUPPLIER_do_corrective_s7_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:SUPPLIER_SUPPKEY,
  rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY,
  rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT,
  rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mORDERS11_mSUPPLIER2} in _accext.combine (let
    __prod_ret__1017 =
    (if SUPPLIER_NATIONKEY ==
       delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY then 1 else 0) *
      delta_REVENUE_mORDERS11_mSUPPLIER2 in
    {| ra:string, rb:string, rc:int, rd:int, re:int |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:delta_REVENUE_mORDERSORDERS_CUSTKEY, rd:SUPPLIER_SUPPKEY,
      re:__prod_ret__1017}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 0 !=
    map_val)) in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mORDERS11_mLINEITEM4,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS11_mLINEITEM4_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_SUPPLIER_do_corrective_s8_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 :
  { ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:int, rb:int, rc:int, rd:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS,
  ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL,
  rl:SUPPLIER_COMMENT, rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mORDERS11_mSUPPLIER2_s8_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
         SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:REVENUE_mORDERSORDERS_CUSTKEY,
      rd:SUPPLIER_NATIONKEY, re:__map_ret__234} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__234};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__234} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__234 *
       if SUPPLIER_SUPPKEY ==
         delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY 
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__prod_ret__1009} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__prod_ret__1009 *
       delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__prod_ret__1010} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_CUSTKEY,
       re:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
       rf:__prod_ret__1010};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_SUPPLIER_do_corrective_s8_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:SUPPLIER_SUPPKEY,
  rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY,
  rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT,
  rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mORDERS11_mSUPPLIER2} in _accext.combine (let delta_values
    =
    ((((bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s8_buf as ind __x in
      (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
         SUPPLIER_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
        ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:SUPPLIER_SUPPKEY,
      rd:__map_ret__238} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
       rc:__map_ret__238};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:__map_ret__238} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
       rc:__map_ret__238 *
       if SUPPLIER_NATIONKEY ==
         delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY then 1 else 0};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:__prod_ret__1018} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
       rc:__prod_ret__1018 * delta_REVENUE_mORDERS11_mSUPPLIER2};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:__prod_ret__1019} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mORDERSORDERS_CUSTKEY,
       re:REVENUE_mORDERSORDERS_ORDERKEY, rf:__prod_ret__1019};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_SUPPLIER_do_corrective_s9_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:SUPPLIER_SUPPKEY,
  rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY,
  rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT,
  rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    rd:delta_REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mLINEITEM4_mSUPPLIER1} in _accext.combine (let
    __prod_ret__1030 =
    (if SUPPLIER_NATIONKEY ==
       delta_REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY then 1 else 0) *
      delta_REVENUE_mLINEITEM4_mSUPPLIER1 in
    {| ra:string, rb:string, rc:int, rd:int, re:int |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:delta_REVENUE_mLINEITEMLINEITEM_ORDERKEY, rd:SUPPLIER_SUPPKEY,
      re:__prod_ret__1030}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 0 !=
    map_val)) in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mLINEITEM4, rb:true,
      rc:vid, rd:new_tuples});
   (nd_REVENUE_mLINEITEM4_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare sw_delete_SUPPLIER : { ra:int, rb:string, rc:string, rd:int, re:string,
  rf:real, rg:string } -> () = (\args ->
  (sw_buf_delete_SUPPLIER.insert args;
   sw_trig_buf_idx.insert {i:1};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_delete_SUPPLIER_send_fetch : { key:int, value:int } -> () = (\vid ->
  case (sw_buf_delete_SUPPLIER.peek ()) of
  {Some args ->
    (sw_buf_delete_SUPPLIER.erase args;
     bind args as
     {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
     in
     (((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_string_string_int_int_int {ra:20, rb:None immut, rc:None immut,
         rd:None immut, re:Some SUPPLIER_NATIONKEY, rf:Some SUPPLIER_SUPPKEY}).fold
        ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_REVENUE_mSUPPLIER11_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
          rb:None immut, rc:None immut, rd:empty { ra:{ key:int, value:int },
          rb:string, rc:string, rd:int, re:int, rf:int, rg:real
          } @ { Collection }, re:true}).fold ((\_accmap -> (\b3 ->
        bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:10, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_string_string_int_int_int {ra:21, rb:None immut,
           rc:None immut, rd:None immut, re:Some SUPPLIER_NATIONKEY,
           rf:Some SUPPLIER_SUPPKEY}).fold ((\count -> (\b3 ->
          bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_REVENUE_mSUPPLIER12_to_REVENUE_bind_0t0_1t1_2t2
            {ra:None immut, rb:None immut, rc:None immut, rd:empty { ra:{
            key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int,
            rg:real } @ { Collection }, re:true}).fold ((\_accmap -> (\b3 ->
          bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:10, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }).combine (let
          sender_count =
          (route_to_int_int_int {ra:8, rb:None immut, rc:None immut,
             rd:Some SUPPLIER_SUPPKEY}).fold ((\count -> (\b3 ->
            bind b3 as {i:ip} in count + 1))) 0 in
          ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER1_to_REVENUE_mCUSTOMER11_bind_2t0_4t1
              {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
              re:None immut, rf:empty { ra:{ key:int, value:int }, rb:int,
              rc:int, rd:int, re:real } @ { Collection }, rg:true}).fold
            ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {ra:ip, rb:11, rc:sender_count};_accmap)))) empty {
            ra:address, rb:int, rc:int } @ { Collection }).combine (let
            sender_count =
            (route_to_string_string_int_int {ra:9, rb:None immut,
               rc:None immut, rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold
              ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
            ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_3t2
                {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                re:None immut, rf:empty { ra:{ key:int, value:int }, rb:string,
                rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:true}).fold
              ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:11, rc:sender_count};_accmap))))
              empty { ra:address, rb:int, rc:int } @ { Collection }).combine
              (let sender_count =
              (route_to_int_int_int {ra:5, rb:None immut, rc:None immut,
                 rd:Some SUPPLIER_SUPPKEY}).fold ((\count -> (\b3 ->
                bind b3 as {i:ip} in count + 1))) 0 in
              ((shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER11_mORDERS1_bind_2t0_4t1
                  {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                  re:None immut, rf:empty { ra:{ key:int, value:int }, rb:int,
                  rc:int, rd:int, re:real } @ { Collection }, rg:true}).fold
                ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:12, rc:sender_count};_accmap))))
                empty { ra:address, rb:int, rc:int } @ { Collection }).combine
                (let sender_count =
                (route_to_string_string_int_int {ra:9, rb:None immut,
                   rc:None immut, rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold
                  ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER11_mORDERS1_bind_0t0_1t1_3t2
                    {ra:None immut, rb:None immut, rc:None immut,
                    rd:None immut, re:None immut, rf:empty { ra:{ key:int,
                    value:int }, rb:string, rc:string, rd:int, re:int, rf:int
                    } @ { Collection }, rg:true}).fold ((\_accmap -> (\b3 ->
                  bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:12, rc:sender_count};_accmap))))
                  empty { ra:address, rb:int, rc:int
                  } @ { Collection }).combine (let sender_count =
                  (route_to_string_string_int_int {ra:9, rb:None immut,
                     rc:None immut, rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold
                    ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                  ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER11_mLINEITEM4_bind_0t0_1t1_2t2
                      {ra:None immut, rb:None immut, rc:None immut,
                      rd:Some SUPPLIER_SUPPKEY, re:empty { ra:{ key:int,
                      value:int }, rb:string, rc:string, rd:int, re:int, rf:int
                      } @ { Collection }, rf:true}).fold ((\_accmap -> (\b3 ->
                    bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:13, rc:sender_count};_accmap))))
                    empty { ra:address, rb:int, rc:int
                    } @ { Collection }).combine (let sender_count =
                    (route_to_int_int_int {ra:13, rb:None immut, rc:None immut,
                       rd:Some SUPPLIER_SUPPKEY}).fold ((\count -> (\b3 ->
                      bind b3 as {i:ip} in count + 1))) 0 in
                    ((shuffle_REVENUE_mCUSTOMER12_mSUPPLIER1_to_REVENUE_mCUSTOMER12_bind_2t0_4t1
                        {ra:None immut, rb:None immut, rc:None immut,
                        rd:None immut, re:None immut, rf:empty { ra:{ key:int,
                        value:int }, rb:int, rc:int, rd:int, re:real
                        } @ { Collection }, rg:true}).fold ((\_accmap ->
                      (\b3 -> bind b3 as {key:ip, value:tuples} in 
                      (_accmap.insert {ra:ip, rb:14, rc:sender_count};_accmap))))
                      empty { ra:address, rb:int, rc:int
                      } @ { Collection }).combine (let sender_count =
                      (route_to_string_string_int_int {ra:9, rb:None immut,
                         rc:None immut, rd:None immut,
                         re:Some SUPPLIER_NATIONKEY}).fold ((\count -> (\b3 ->
                        bind b3 as {i:ip} in count + 1))) 0 in
                      ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_3t2
                          {ra:None immut, rb:None immut, rc:None immut,
                          rd:None immut, re:None immut, rf:empty { ra:{
                          key:int, value:int }, rb:string, rc:string, rd:int,
                          re:int, rf:int } @ { Collection }, rg:true}).fold
                        ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                        value:tuples} in 
                        (_accmap.insert {ra:ip, rb:14, rc:sender_count};_accmap))))
                        empty { ra:address, rb:int, rc:int
                        } @ { Collection }).combine (let sender_count =
                        (route_to_int_int_int {ra:12, rb:None immut,
                           rc:None immut, rd:Some SUPPLIER_SUPPKEY}).fold
                          ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1)))
                          0 in
                        ((shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER12_mORDERS1_bind_2t0_4t1
                            {ra:None immut, rb:None immut, rc:None immut,
                            rd:None immut, re:None immut, rf:empty { ra:{
                            key:int, value:int }, rb:int, rc:int, rd:int,
                            re:real } @ { Collection }, rg:true}).fold
                          ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                          value:tuples} in 
                          (_accmap.insert {ra:ip, rb:15, rc:sender_count};
                           _accmap)))) empty { ra:address, rb:int, rc:int
                          } @ { Collection }).combine (let sender_count =
                          (route_to_string_string_int_int {ra:9, rb:None immut,
                             rc:None immut, rd:None immut,
                             re:Some SUPPLIER_NATIONKEY}).fold ((\count ->
                            (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                          ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER12_mORDERS1_bind_0t0_1t1_3t2
                              {ra:None immut, rb:None immut, rc:None immut,
                              rd:None immut, re:None immut, rf:empty { ra:{
                              key:int, value:int }, rb:string, rc:string,
                              rd:int, re:int, rf:int } @ { Collection },
                              rg:true}).fold ((\_accmap -> (\b3 ->
                            bind b3 as {key:ip, value:tuples} in 
                            (_accmap.insert {ra:ip, rb:15, rc:sender_count};
                             _accmap)))) empty { ra:address, rb:int, rc:int
                            } @ { Collection }).combine (let sender_count =
                            (route_to_int_int_int {ra:5, rb:None immut,
                               rc:None immut, rd:Some SUPPLIER_SUPPKEY}).fold
                              ((\count -> (\b3 -> bind b3 as {i:ip} in count +
                              1))) 0 in
                            ((shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mORDERS11_bind_2t0_4t1
                                {ra:None immut, rb:None immut, rc:None immut,
                                rd:None immut, re:None immut, rf:empty { ra:{
                                key:int, value:int }, rb:int, rc:int, rd:int,
                                re:real } @ { Collection }, rg:true}).fold
                              ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                              value:tuples} in 
                              (_accmap.insert {ra:ip, rb:16, rc:sender_count};
                               _accmap)))) empty { ra:address, rb:int, rc:int
                              } @ { Collection }).combine (let sender_count =
                              (route_to_string_string_int_int {ra:16,
                                 rb:None immut, rc:None immut, rd:None immut,
                                 re:Some SUPPLIER_NATIONKEY}).fold ((\count ->
                                (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                              ((shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS11_bind_0t0_1t1_3t2
                                  {ra:None immut, rb:None immut, rc:None immut,
                                  rd:None immut, re:None immut, rf:empty { ra:{
                                  key:int, value:int }, rb:string, rc:string,
                                  rd:int, re:int, rf:int } @ { Collection },
                                  rg:true}).fold ((\_accmap -> (\b3 ->
                                bind b3 as {key:ip, value:tuples} in 
                                (_accmap.insert {ra:ip, rb:16, rc:sender_count};
                                 _accmap)))) empty { ra:address, rb:int, rc:int
                                } @ { Collection }).combine (let sender_count =
                                (route_to_string_string_int_int {ra:16,
                                   rb:None immut, rc:None immut, rd:None immut,
                                   re:Some SUPPLIER_NATIONKEY}).fold
                                  ((\count -> (\b3 -> bind b3 as {i:ip} in 
                                  count + 1))) 0 in
                                ((shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS11_mLINEITEM4_bind_0t0_1t1_2t2
                                    {ra:None immut, rb:None immut,
                                    rc:None immut, rd:Some SUPPLIER_SUPPKEY,
                                    re:empty { ra:{ key:int, value:int },
                                    rb:string, rc:string, rd:int, re:int,
                                    rf:int } @ { Collection }, rf:true}).fold
                                  ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                  value:tuples} in 
                                  (_accmap.insert {ra:ip, rb:17,
                                   rc:sender_count};
                                   _accmap)))) empty { ra:address, rb:int,
                                  rc:int } @ { Collection }).combine (let
                                  sender_count =
                                  (route_to_int_int_int {ra:12, rb:None immut,
                                     rc:None immut, rd:Some SUPPLIER_SUPPKEY}).fold
                                    ((\count -> (\b3 -> bind b3 as {i:ip} in 
                                    count + 1))) 0 in
                                  ((shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mORDERS12_bind_2t0_4t1
                                      {ra:None immut, rb:None immut,
                                      rc:None immut, rd:None immut,
                                      re:None immut, rf:empty { ra:{ key:int,
                                      value:int }, rb:int, rc:int, rd:int,
                                      re:real } @ { Collection }, rg:true}).fold
                                    ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                    value:tuples} in 
                                    (_accmap.insert {ra:ip, rb:18,
                                     rc:sender_count};
                                     _accmap)))) empty { ra:address, rb:int,
                                    rc:int } @ { Collection }).combine (let
                                    sender_count =
                                    (route_to_string_string_int_int {ra:16,
                                       rb:None immut, rc:None immut,
                                       rd:None immut,
                                       re:Some SUPPLIER_NATIONKEY}).fold
                                      ((\count -> (\b3 -> bind b3 as {i:ip} in 
                                      count + 1))) 0 in
                                    ((shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS12_bind_0t0_1t1_3t2
                                        {ra:None immut, rb:None immut,
                                        rc:None immut, rd:None immut,
                                        re:None immut, rf:empty { ra:{ key:int,
                                        value:int }, rb:string, rc:string,
                                        rd:int, re:int, rf:int
                                        } @ { Collection }, rg:true}).fold
                                      ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                      value:tuples} in 
                                      (_accmap.insert {ra:ip, rb:18,
                                       rc:sender_count};
                                       _accmap)))) empty { ra:address, rb:int,
                                      rc:int } @ { Collection }).combine (let
                                      sender_count =
                                      (route_to_string_string_int_int {ra:19,
                                         rb:None immut, rc:None immut,
                                         rd:None immut,
                                         re:Some SUPPLIER_NATIONKEY}).fold
                                        ((\count -> (\b3 ->
                                        bind b3 as {i:ip} in count + 1))) 0 in
                                      (shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mLINEITEM4_bind_0t0_1t1_2t2
                                         {ra:None immut, rb:None immut,
                                         rc:None immut,
                                         rd:Some SUPPLIER_SUPPKEY, re:empty {
                                         ra:{ key:int, value:int }, rb:string,
                                         rc:string, rd:int, re:int, rf:int
                                         } @ { Collection }, rf:true}).fold
                                        ((\_accmap -> (\b3 ->
                                        bind b3 as {key:ip, value:tuples} in 
                                        (_accmap.insert {ra:ip, rb:19,
                                         rc:sender_count};
                                         _accmap)))) empty { ra:address,
                                        rb:int, rc:int } @ { Collection })))))))))))))))))).groupBy
      ((\b1 -> bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip,
      value:stmt_id})) ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id,
      rc:count} in acc + count))) 0).groupBy ((\b1 -> bind b1 as {key:b2,
      value:count} in bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc ->
      (\b3 -> bind b3 as {key:ip_and_stmt_id, value:count} in bind
      ip_and_stmt_id as {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_delete_SUPPLIER_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid,
       rd:SUPPLIER_SUPPKEY, re:SUPPLIER_NAME, rf:SUPPLIER_ADDRESS,
       rg:SUPPLIER_NATIONKEY, rh:SUPPLIER_PHONE, ri:SUPPLIER_ACCTBAL,
       rj:SUPPLIER_COMMENT};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_string_string_int_int {ra:19, rb:None immut, rc:None immut,
            rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:19, rb:19, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:16, rb:None immut, rc:None immut,
           rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:18, rb:16, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:12, rb:None immut, rc:None immut,
           rd:Some SUPPLIER_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:18, rb:12, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:16, rb:None immut, rc:None immut,
           rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:17, rb:16, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:16, rb:None immut, rc:None immut,
           rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:16, rb:16, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:5, rb:None immut, rc:None immut,
           rd:Some SUPPLIER_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:16, rb:5, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
           rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:15, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:12, rb:None immut, rc:None immut,
           rd:Some SUPPLIER_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:15, rb:12, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
           rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:14, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:13, rb:None immut, rc:None immut,
           rd:Some SUPPLIER_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:14, rb:13, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
           rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:13, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
           rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:12, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:5, rb:None immut, rc:None immut,
           rd:Some SUPPLIER_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:12, rb:5, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
           rd:None immut, re:Some SUPPLIER_NATIONKEY}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:11, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:8, rb:None immut, rc:None immut,
           rd:Some SUPPLIER_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:11, rb:8, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:21, rb:None immut,
           rc:None immut, rd:None immut, re:Some SUPPLIER_NATIONKEY,
           rf:Some SUPPLIER_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:10, rb:21, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:20, rb:None immut,
           rc:None immut, rd:None immut, re:Some SUPPLIER_NATIONKEY,
           rf:Some SUPPLIER_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:10, rb:20, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine empty {
      ra:int, rb:int, rc:address } @ { Collection }))))))))))))))))).groupBy
      ((\b1 -> bind b1 as {ra:stmt_id, rb:map_id, rc:ip} in ip)) ((\acc ->
      (\b3 -> bind b3 as {ra:stmt_id, rb:map_id, rc:ip} in 
      (acc.insert {key:stmt_id, value:map_id};acc)))) empty { key:int,
      value:int } @ { Collection }).iterate ((\b1 -> bind b1 as {key:ip,
      value:stmt_map_ids} in 
      (nd_delete_SUPPLIER_rcv_fetch, ip)<- {ra:stmt_map_ids, rb:vid,
      rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
      rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
      ri:SUPPLIER_COMMENT}))))}{None ->
                                 error
                                   (print
                                      "unexpected missing arguments in sw_buf_delete_SUPPLIER")})


declare nd_delete_SUPPLIER_do_complete_s10 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  (((((bind map_REVENUE_mSUPPLIER11_s10_buf as ind __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in re == SUPPLIER_NATIONKEY and rf == SUPPLIER_SUPPKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
      re:map_3, rf:map_4, rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_SUPPKEY,
    rf:__map_ret__18} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__18};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).combine (((bind map_REVENUE_mSUPPLIER12_s10_buf as ind
    __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in re == SUPPLIER_NATIONKEY and rf == SUPPLIER_SUPPKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
      re:map_3, rf:map_4, rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_SUPPKEY,
    rf:__map_ret__19} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__19};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:__map_ret__19} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__19 * -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection })).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:__sum_ret__2} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__sum_ret__2};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_2, rd:map_val} in {ra:map_0, rb:map_1, rc:map_2})) ((\acc -> (\b3 ->
    bind b3 as {ra:map_0, rb:map_1, rc:map_2, rd:map_val} in acc + map_val)))
    0).fold ((\acc -> (\b3 -> bind b3 as {key:g, value:val} in 
    (acc.insert {ra:g.ra, rb:g.rb, rc:g.rc, rd:val};acc)))) empty { ra:string,
    rb:string, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:false, rc:vid,
      rd:delta_values});
   (nd_complete_stmt_cntr_check {key:vid, value:10})))


declare nd_delete_SUPPLIER_do_complete_s11 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  ((((bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s11_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
       SUPPLIER_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:SUPPLIER_SUPPKEY,
    rd:__map_ret__20} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:__map_ret__20};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__map_ret__20} in _accext.combine
    (((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s11_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__21} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__21};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__21} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rf:__map_ret__20 * __map_ret__21};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rf:__prod_ret__9} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rf:__prod_ret__9 * -1};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rf:__prod_ret__10} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__10};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_send_correctives {ra:me, rb:11, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:11}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:11, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_SUPPLIER_do_complete_s12 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  ((((bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s12_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
       SUPPLIER_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY, rc:SUPPLIER_SUPPKEY,
    rd:__map_ret__22} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR,
     rb:REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY, rc:__map_ret__22};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY, rc:__map_ret__22} in 
    _accext.combine (((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s12_buf as ind
    __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__23} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__23};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__23} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR,
     rb:REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY, rc:SHIPPING_SUPP_NATION,
     rd:SHIPPING_CUST_NATION, re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     rf:__map_ret__22 * __map_ret__23};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY, rc:SHIPPING_SUPP_NATION,
    rd:SHIPPING_CUST_NATION, re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rf:__prod_ret__11} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR,
     rb:REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY, rc:SHIPPING_SUPP_NATION,
     rd:SHIPPING_CUST_NATION, re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     rf:__prod_ret__11 * -1};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY, rc:SHIPPING_SUPP_NATION,
    rd:SHIPPING_CUST_NATION, re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rf:__prod_ret__12} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY, rf:__prod_ret__12};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:REVENUE_mCUSTOMER11_mORDERS1, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_mORDERS1_send_correctives {ra:me, rb:12, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:12}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:12, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_SUPPLIER_do_complete_s13 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s13_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__24} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__24};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__24} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__24 * -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__13} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:SUPPLIER_SUPPKEY,
     re:__prod_ret__13};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int
      {ra:REVENUE_mCUSTOMER11_mLINEITEM4, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_mLINEITEM4_send_correctives {ra:me, rb:13, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:13}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:13, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_SUPPLIER_do_complete_s14 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  ((((bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s14_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
       SUPPLIER_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:SUPPLIER_SUPPKEY,
    rd:__map_ret__25} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:__map_ret__25};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__map_ret__25} in _accext.combine
    (((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s14_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__26} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__26};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__26} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rf:__map_ret__25 * __map_ret__26};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rf:__prod_ret__14} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rf:__prod_ret__14 * -1};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rf:__prod_ret__15} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__15};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER12_send_correctives {ra:me, rb:14, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:14}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:14, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_SUPPLIER_do_complete_s15 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  ((((bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s15_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
       SUPPLIER_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY, rc:SUPPLIER_SUPPKEY,
    rd:__map_ret__27} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR,
     rb:REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY, rc:__map_ret__27};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY, rc:__map_ret__27} in 
    _accext.combine (((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s15_buf as ind
    __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__28} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__28};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__28} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR,
     rb:REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY, rc:SHIPPING_SUPP_NATION,
     rd:SHIPPING_CUST_NATION, re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     rf:__map_ret__27 * __map_ret__28};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY, rc:SHIPPING_SUPP_NATION,
    rd:SHIPPING_CUST_NATION, re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rf:__prod_ret__16} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR,
     rb:REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY, rc:SHIPPING_SUPP_NATION,
     rd:SHIPPING_CUST_NATION, re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     rf:__prod_ret__16 * -1};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY, rc:SHIPPING_SUPP_NATION,
    rd:SHIPPING_CUST_NATION, re:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rf:__prod_ret__17} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY, rf:__prod_ret__17};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:REVENUE_mCUSTOMER12_mORDERS1, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER12_mORDERS1_send_correctives {ra:me, rb:15, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:15}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:15, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_SUPPLIER_do_complete_s16 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  ((((bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s16_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
       SUPPLIER_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
    rc:SUPPLIER_SUPPKEY, rd:__map_ret__29} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
     rc:__map_ret__29};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:__map_ret__29} in _accext.combine
    (((bind map_REVENUE_mORDERS11_mSUPPLIER2_s16_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mORDERSORDERS_CUSTKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__30} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__30};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__30} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mORDERSORDERS_CUSTKEY, rf:__map_ret__29 * __map_ret__30};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mORDERSORDERS_CUSTKEY, rf:__prod_ret__18} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mORDERSORDERS_CUSTKEY, rf:__prod_ret__18 * -1};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mORDERSORDERS_CUSTKEY, rf:__prod_ret__19} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_CUSTKEY,
     re:REVENUE_mORDERSORDERS_ORDERKEY, rf:__prod_ret__19};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS11_send_correctives {ra:me, rb:16, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:16}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:16, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_SUPPLIER_do_complete_s17 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  (((bind map_REVENUE_mORDERS11_mSUPPLIER2_s17_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mORDERSORDERS_CUSTKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__31} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__31};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__31} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__31 * -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__prod_ret__20} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:SUPPLIER_SUPPKEY, re:__prod_ret__20};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mORDERS11_mLINEITEM4,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS11_mLINEITEM4_send_correctives {ra:me, rb:17, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:17}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:17, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_SUPPLIER_do_complete_s18 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  ((((bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s18_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
       SUPPLIER_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
    rc:SUPPLIER_SUPPKEY, rd:__map_ret__32} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
     rc:__map_ret__32};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:__map_ret__32} in _accext.combine
    (((bind map_REVENUE_mORDERS11_mSUPPLIER2_s18_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mORDERSORDERS_CUSTKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__33} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__33};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__33} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mORDERSORDERS_CUSTKEY, rf:__map_ret__32 * __map_ret__33};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mORDERSORDERS_CUSTKEY, rf:__prod_ret__21} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mORDERSORDERS_CUSTKEY, rf:__prod_ret__21 * -1};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mORDERSORDERS_CUSTKEY, rf:__prod_ret__22} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_CUSTKEY,
     re:REVENUE_mORDERSORDERS_ORDERKEY, rf:__prod_ret__22};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS12_send_correctives {ra:me, rb:18, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:18}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:18, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_SUPPLIER_do_complete_s19 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string } -> () =
  (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
  rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
  rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in let delta_values =
  (((bind map_REVENUE_mLINEITEM4_mSUPPLIER1_s19_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    rd:SUPPLIER_NATIONKEY, re:__map_ret__34} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEMLINEITEM_ORDERKEY, rd:__map_ret__34};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mLINEITEMLINEITEM_ORDERKEY, rd:__map_ret__34} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEMLINEITEM_ORDERKEY, rd:__map_ret__34 * -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mLINEITEMLINEITEM_ORDERKEY, rd:__prod_ret__23} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEMLINEITEM_ORDERKEY, rd:SUPPLIER_SUPPKEY,
     re:__prod_ret__23};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mLINEITEM4, rb:false,
      rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mLINEITEM4_send_correctives {ra:me, rb:19, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:19}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:19, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare delete_SUPPLIER_do_corrective_s10_m_REVENUE_mSUPPLIER11 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:string, rh:string, ri:int, rj:string, rk:real, rl:string, rm:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS,
  ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL,
  rl:SUPPLIER_COMMENT, rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
    rf:delta_REVENUE_mSUPPLIER11} in _accext.combine (let __prod_ret__1032 =
    ((if SUPPLIER_SUPPKEY == delta_REVENUE_mSUPPLIERSUPPLIER_SUPPKEY 
      then 1 else 0) *
      if SUPPLIER_NATIONKEY == delta_REVENUE_mSUPPLIERSUPPLIER_NATIONKEY 
      then 1 else 0) * delta_REVENUE_mSUPPLIER11 in
    {| ra:string, rb:string, rc:int, rd:real | {ra:delta_SHIPPING_SUPP_NATION,
      rb:delta_SHIPPING_CUST_NATION, rc:delta_SHIPPING_L_YEAR,
      rd:__prod_ret__1032}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare delete_SUPPLIER_do_corrective_s10_m_REVENUE_mSUPPLIER12 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:string, rh:string, ri:int, rj:string, rk:real, rl:string, rm:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS,
  ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL,
  rl:SUPPLIER_COMMENT, rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
    rf:delta_REVENUE_mSUPPLIER12} in _accext.combine (let __prod_ret__1035 =
    ((if SUPPLIER_SUPPKEY == delta_REVENUE_mSUPPLIERSUPPLIER_SUPPKEY 
      then 1 else 0) *
      if SUPPLIER_NATIONKEY == delta_REVENUE_mSUPPLIERSUPPLIER_NATIONKEY 
      then 1 else 0) * -delta_REVENUE_mSUPPLIER12 in
    {| ra:string, rb:string, rc:int, rd:real | {ra:delta_SHIPPING_SUPP_NATION,
      rb:delta_SHIPPING_CUST_NATION, rc:delta_SHIPPING_L_YEAR,
      rd:__prod_ret__1035}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare delete_SUPPLIER_do_corrective_s11_m_REVENUE_mCUSTOMER11_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:int, rb:int, rc:int, rd:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS,
  ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL,
  rl:SUPPLIER_COMMENT, rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:delta_REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER11_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s11_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
         SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      rd:SUPPLIER_NATIONKEY, re:__map_ret__243} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__243};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__243} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__243 *
       if SUPPLIER_SUPPKEY ==
         delta_REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1037} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1037 *
       -delta_REVENUE_mCUSTOMER11_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1038} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__1038};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_SUPPLIER_do_corrective_s12_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 :
  { ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:int, rb:int, rc:int, rd:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS,
  ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL,
  rl:SUPPLIER_COMMENT, rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s12_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
         SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      rd:SUPPLIER_NATIONKEY, re:__map_ret__264} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__264};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__264} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__264 *
       if SUPPLIER_SUPPKEY ==
         delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY 
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1110} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1110 *
       -delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1111} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY,
       rf:__prod_ret__1111};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:REVENUE_mCUSTOMER11_mORDERS1, rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER11_mORDERS1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_SUPPLIER_do_corrective_s14_m_REVENUE_mCUSTOMER12_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:int, rb:int, rc:int, rd:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS,
  ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL,
  rl:SUPPLIER_COMMENT, rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:delta_REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER12_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s14_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
         SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      rd:SUPPLIER_NATIONKEY, re:__map_ret__268} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__268};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__268} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__268 *
       if SUPPLIER_SUPPKEY ==
         delta_REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1122} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1122 *
       -delta_REVENUE_mCUSTOMER12_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1123} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__1123};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_SUPPLIER_do_corrective_s15_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 :
  { ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:int, rb:int, rc:int, rd:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS,
  ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL,
  rl:SUPPLIER_COMMENT, rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s15_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
         SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      rd:SUPPLIER_NATIONKEY, re:__map_ret__269} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__269};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__269} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__269 *
       if SUPPLIER_SUPPKEY ==
         delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY 
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1125} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1125 *
       -delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__prod_ret__1126} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
       rf:__prod_ret__1126};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:REVENUE_mCUSTOMER12_mORDERS1, rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER12_mORDERS1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_SUPPLIER_do_corrective_s16_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 :
  { ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:int, rb:int, rc:int, rd:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS,
  ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL,
  rl:SUPPLIER_COMMENT, rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mORDERS11_mSUPPLIER2_s16_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
         SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:REVENUE_mORDERSORDERS_CUSTKEY,
      rd:SUPPLIER_NATIONKEY, re:__map_ret__265} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__265};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__265} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__265 *
       if SUPPLIER_SUPPKEY ==
         delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY 
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__prod_ret__1113} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__prod_ret__1113 *
       -delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__prod_ret__1114} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_CUSTKEY,
       re:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY,
       rf:__prod_ret__1114};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_SUPPLIER_do_corrective_s16_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:SUPPLIER_SUPPKEY,
  rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY,
  rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT,
  rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mORDERS11_mSUPPLIER2} in _accext.combine (let delta_values
    =
    ((((bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s16_buf as ind __x in
      (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
         SUPPLIER_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
        ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:SUPPLIER_SUPPKEY,
      rd:__map_ret__273} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
       rc:__map_ret__273};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:__map_ret__273} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
       rc:__map_ret__273 *
       if SUPPLIER_NATIONKEY ==
         delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY then 1 else 0};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:__prod_ret__1137} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
       rc:__prod_ret__1137 * -delta_REVENUE_mORDERS11_mSUPPLIER2};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:__prod_ret__1138} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mORDERSORDERS_CUSTKEY,
       re:REVENUE_mORDERSORDERS_ORDERKEY, rf:__prod_ret__1138};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_SUPPLIER_do_corrective_s17_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:SUPPLIER_SUPPKEY,
  rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY,
  rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT,
  rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mORDERS11_mSUPPLIER2} in _accext.combine (let
    __prod_ret__1140 =
    (if SUPPLIER_NATIONKEY ==
       delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY then 1 else 0) *
      -delta_REVENUE_mORDERS11_mSUPPLIER2 in
    {| ra:string, rb:string, rc:int, rd:int, re:int |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:delta_REVENUE_mORDERSORDERS_CUSTKEY, rd:SUPPLIER_SUPPKEY,
      re:__prod_ret__1140}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 0 !=
    map_val)) in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mORDERS11_mLINEITEM4,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS11_mLINEITEM4_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_SUPPLIER_do_corrective_s18_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 :
  { ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:int, rb:int, rc:int, rd:real } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS,
  ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL,
  rl:SUPPLIER_COMMENT, rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mORDERS11_mSUPPLIER2_s18_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
         SUPPLIER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:REVENUE_mORDERSORDERS_CUSTKEY,
      rd:SUPPLIER_NATIONKEY, re:__map_ret__270} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__270};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__270} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__270 *
       if SUPPLIER_SUPPKEY ==
         delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY 
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__prod_ret__1128} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__prod_ret__1128 *
       -delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__prod_ret__1129} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_CUSTKEY,
       re:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
       rf:__prod_ret__1129};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_SUPPLIER_do_corrective_s18_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:SUPPLIER_SUPPKEY,
  rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY,
  rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT,
  rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mORDERS11_mSUPPLIER2} in _accext.combine (let delta_values
    =
    ((((bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s18_buf as ind __x in
      (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
         SUPPLIER_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
        ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:SUPPLIER_SUPPKEY,
      rd:__map_ret__274} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
       rc:__map_ret__274};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:__map_ret__274} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
       rc:__map_ret__274 *
       if SUPPLIER_NATIONKEY ==
         delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY then 1 else 0};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:__prod_ret__1142} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mORDERSORDERS_ORDERKEY,
       rc:__prod_ret__1142 * -delta_REVENUE_mORDERS11_mSUPPLIER2};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mORDERSORDERS_ORDERKEY, rc:__prod_ret__1143} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mORDERSORDERS_CUSTKEY,
       re:REVENUE_mORDERSORDERS_ORDERKEY, rf:__prod_ret__1143};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_SUPPLIER_do_corrective_s19_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:SUPPLIER_SUPPKEY,
  rg:SUPPLIER_NAME, rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY,
  rj:SUPPLIER_PHONE, rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT,
  rm:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    rd:delta_REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mLINEITEM4_mSUPPLIER1} in _accext.combine (let
    __prod_ret__1161 =
    (if SUPPLIER_NATIONKEY ==
       delta_REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY then 1 else 0) *
      -delta_REVENUE_mLINEITEM4_mSUPPLIER1 in
    {| ra:string, rb:string, rc:int, rd:int, re:int |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:delta_REVENUE_mLINEITEMLINEITEM_ORDERKEY, rd:SUPPLIER_SUPPKEY,
      re:__prod_ret__1161}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 0 !=
    map_val)) in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mLINEITEM4, rb:true,
      rc:vid, rd:new_tuples});
   (nd_REVENUE_mLINEITEM4_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare sw_insert_CUSTOMER : { ra:int, rb:string, rc:string, rd:int, re:string,
  rf:real, rg:string, rh:string } -> () = (\args ->
  (sw_buf_insert_CUSTOMER.insert args;
   sw_trig_buf_idx.insert {i:2};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_insert_CUSTOMER_send_fetch : { key:int, value:int } -> () = (\vid ->
  case (sw_buf_insert_CUSTOMER.peek ()) of
  {Some args ->
    (sw_buf_insert_CUSTOMER.erase args;
     bind args as
     {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
     in
     (((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_string_string_int_int_int {ra:3, rb:None immut, rc:None immut,
         rd:None immut, re:Some CUSTOMER_NATIONKEY, rf:Some CUSTOMER_CUSTKEY}).fold
        ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_REVENUE_mCUSTOMER11_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
          rb:None immut, rc:None immut, rd:empty { ra:{ key:int, value:int },
          rb:string, rc:string, rd:int, re:int, rf:int, rg:real
          } @ { Collection }, re:true}).fold ((\_accmap -> (\b3 ->
        bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:20, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_string_string_int_int_int {ra:10, rb:None immut,
           rc:None immut, rd:None immut, re:Some CUSTOMER_NATIONKEY,
           rf:Some CUSTOMER_CUSTKEY}).fold ((\count -> (\b3 ->
          bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_REVENUE_mCUSTOMER12_to_REVENUE_bind_0t0_1t1_2t2
            {ra:None immut, rb:None immut, rc:None immut, rd:empty { ra:{
            key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int,
            rg:real } @ { Collection }, re:true}).fold ((\_accmap -> (\b3 ->
          bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:20, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }).combine (let
          sender_count =
          (route_to_string_string_int_int_int {ra:4, rb:None immut,
             rc:None immut, rd:None immut, re:Some CUSTOMER_NATIONKEY,
             rf:None immut}).fold ((\count -> (\b3 -> bind b3 as {i:ip} in 
            count + 1))) 0 in
          ((shuffle_REVENUE_mCUSTOMER11_mORDERS1_to_REVENUE_mORDERS11_bind_0t0_1t1_2t2_4t4
              {ra:None immut, rb:None immut, rc:None immut,
              rd:Some CUSTOMER_CUSTKEY, re:None immut, rf:empty { ra:{ key:int,
              value:int }, rb:string, rc:string, rd:int, re:int, rf:int,
              rg:real } @ { Collection }, rg:true}).fold ((\_accmap -> (\b3 ->
            bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {ra:ip, rb:21, rc:sender_count};_accmap)))) empty {
            ra:address, rb:int, rc:int } @ { Collection }).combine (let
            sender_count =
            (route_to_string_string_int_int {ra:6, rb:None immut,
               rc:None immut, rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold
              ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
            ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mORDERS11_mLINEITEM4_bind_0t0_1t1_3t3
                {ra:None immut, rb:None immut, rc:Some CUSTOMER_CUSTKEY,
                rd:None immut, re:empty { ra:{ key:int, value:int }, rb:string,
                rc:string, rd:int, re:int, rf:int } @ { Collection }, rf:true}).fold
              ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:22, rc:sender_count};_accmap))))
              empty { ra:address, rb:int, rc:int } @ { Collection }).combine
              (let sender_count =
              (route_to_string_string_int_int {ra:9, rb:None immut,
                 rc:None immut, rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold
                ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
              ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mORDERS11_mSUPPLIER2_bind_0t0_1t1_3t3
                  {ra:None immut, rb:None immut, rc:Some CUSTOMER_CUSTKEY,
                  rd:None immut, re:empty { ra:{ key:int, value:int },
                  rb:string, rc:string, rd:int, re:int, rf:int
                  } @ { Collection }, rf:true}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:23, rc:sender_count};_accmap))))
                empty { ra:address, rb:int, rc:int } @ { Collection }).combine
                (let sender_count =
                (route_to_string_string_int_int_int {ra:11, rb:None immut,
                   rc:None immut, rd:None immut, re:Some CUSTOMER_NATIONKEY,
                   rf:None immut}).fold ((\count -> (\b3 ->
                  bind b3 as {i:ip} in count + 1))) 0 in
                ((shuffle_REVENUE_mCUSTOMER12_mORDERS1_to_REVENUE_mORDERS12_bind_0t0_1t1_2t2_4t4
                    {ra:None immut, rb:None immut, rc:None immut,
                    rd:Some CUSTOMER_CUSTKEY, re:None immut, rf:empty { ra:{
                    key:int, value:int }, rb:string, rc:string, rd:int, re:int,
                    rf:int, rg:real } @ { Collection }, rg:true}).fold
                  ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:24, rc:sender_count};_accmap))))
                  empty { ra:address, rb:int, rc:int
                  } @ { Collection }).combine (let sender_count =
                  (route_to_string_string_int_int {ra:6, rb:None immut,
                     rc:None immut, rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold
                    ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                  ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mLINEITEM4_bind_0t0_1t1_3t3
                      {ra:None immut, rb:None immut, rc:None immut,
                      rd:None immut, re:empty { ra:{ key:int, value:int },
                      rb:string, rc:string, rd:int, re:int, rf:int
                      } @ { Collection }, rf:true}).fold ((\_accmap -> (\b3 ->
                    bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:25, rc:sender_count};_accmap))))
                    empty { ra:address, rb:int, rc:int
                    } @ { Collection }).combine (let sender_count =
                    (route_to_int_int {ra:7, rb:Some CUSTOMER_CUSTKEY,
                       rc:None immut}).fold ((\count -> (\b3 ->
                      bind b3 as {i:ip} in count + 1))) 0 in
                    ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mLINEITEM4_bind_2t1
                        {ra:None immut, rb:None immut, rc:None immut,
                        rd:None immut, re:empty { ra:{ key:int, value:int },
                        rb:int, rc:int, rd:int } @ { Collection }, rf:true}).fold
                      ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                      value:tuples} in 
                      (_accmap.insert {ra:ip, rb:25, rc:sender_count};_accmap))))
                      empty { ra:address, rb:int, rc:int
                      } @ { Collection }).combine (let sender_count =
                      (route_to_int_int {ra:7, rb:Some CUSTOMER_CUSTKEY,
                         rc:None immut}).fold ((\count -> (\b3 ->
                        bind b3 as {i:ip} in count + 1))) 0 in
                      ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_2t1
                          {ra:None immut, rb:None immut, rc:None immut,
                          rd:None immut, re:empty { ra:{ key:int, value:int },
                          rb:int, rc:int, rd:int } @ { Collection }, rf:true}).fold
                        ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                        value:tuples} in 
                        (_accmap.insert {ra:ip, rb:26, rc:sender_count};_accmap))))
                        empty { ra:address, rb:int, rc:int
                        } @ { Collection }).combine (let sender_count =
                        (route_to_string_string_int_int {ra:9, rb:None immut,
                           rc:None immut, rd:Some CUSTOMER_NATIONKEY,
                           re:None immut}).fold ((\count -> (\b3 ->
                          bind b3 as {i:ip} in count + 1))) 0 in
                        ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_0t0_1t1_3t3
                            {ra:None immut, rb:None immut, rc:None immut,
                            rd:None immut, re:empty { ra:{ key:int, value:int
                            }, rb:string, rc:string, rd:int, re:int, rf:int
                            } @ { Collection }, rf:true}).fold ((\_accmap ->
                          (\b3 -> bind b3 as {key:ip, value:tuples} in 
                          (_accmap.insert {ra:ip, rb:26, rc:sender_count};
                           _accmap)))) empty { ra:address, rb:int, rc:int
                          } @ { Collection }).combine (let sender_count =
                          (route_to_int_int_int {ra:8, rb:None immut,
                             rc:Some CUSTOMER_CUSTKEY, rd:None immut}).fold
                            ((\count -> (\b3 -> bind b3 as {i:ip} in count +
                            1))) 0 in
                          ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_2t0_4t2
                              {ra:None immut, rb:None immut, rc:None immut,
                              rd:None immut, re:None immut, rf:empty { ra:{
                              key:int, value:int }, rb:int, rc:int, rd:int,
                              re:real } @ { Collection }, rg:true}).fold
                            ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                            value:tuples} in 
                            (_accmap.insert {ra:ip, rb:27, rc:sender_count};
                             _accmap)))) empty { ra:address, rb:int, rc:int
                            } @ { Collection }).combine (let sender_count =
                            (route_to_string_string_int_int {ra:9,
                               rb:None immut, rc:None immut,
                               rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold
                              ((\count -> (\b3 -> bind b3 as {i:ip} in count +
                              1))) 0 in
                            ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3
                                {ra:None immut, rb:None immut, rc:None immut,
                                rd:None immut, re:None immut, rf:empty { ra:{
                                key:int, value:int }, rb:string, rc:string,
                                rd:int, re:int, rf:int } @ { Collection },
                                rg:true}).fold ((\_accmap -> (\b3 ->
                              bind b3 as {key:ip, value:tuples} in 
                              (_accmap.insert {ra:ip, rb:27, rc:sender_count};
                               _accmap)))) empty { ra:address, rb:int, rc:int
                              } @ { Collection }).combine (let sender_count =
                              (route_to_int_int_int {ra:13, rb:None immut,
                                 rc:Some CUSTOMER_CUSTKEY, rd:None immut}).fold
                                ((\count -> (\b3 -> bind b3 as {i:ip} in count
                                + 1))) 0 in
                              ((shuffle_REVENUE_mCUSTOMER12_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_2t0_4t2
                                  {ra:None immut, rb:None immut, rc:None immut,
                                  rd:None immut, re:None immut, rf:empty { ra:{
                                  key:int, value:int }, rb:int, rc:int, rd:int,
                                  re:real } @ { Collection }, rg:true}).fold
                                ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                value:tuples} in 
                                (_accmap.insert {ra:ip, rb:28, rc:sender_count};
                                 _accmap)))) empty { ra:address, rb:int, rc:int
                                } @ { Collection }).combine (let sender_count =
                                (route_to_string_string_int_int {ra:9,
                                   rb:None immut, rc:None immut,
                                   rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold
                                  ((\count -> (\b3 -> bind b3 as {i:ip} in 
                                  count + 1))) 0 in
                                (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3
                                   {ra:None immut, rb:None immut,
                                   rc:None immut, rd:None immut, re:None immut,
                                   rf:empty { ra:{ key:int, value:int },
                                   rb:string, rc:string, rd:int, re:int, rf:int
                                   } @ { Collection }, rg:true}).fold
                                  ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                  value:tuples} in 
                                  (_accmap.insert {ra:ip, rb:28,
                                   rc:sender_count};
                                   _accmap)))) empty { ra:address, rb:int,
                                  rc:int } @ { Collection }))))))))))))))).groupBy
      ((\b1 -> bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip,
      value:stmt_id})) ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id,
      rc:count} in acc + count))) 0).groupBy ((\b1 -> bind b1 as {key:b2,
      value:count} in bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc ->
      (\b3 -> bind b3 as {key:ip_and_stmt_id, value:count} in bind
      ip_and_stmt_id as {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_insert_CUSTOMER_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid,
       rd:CUSTOMER_CUSTKEY, re:CUSTOMER_NAME, rf:CUSTOMER_ADDRESS,
       rg:CUSTOMER_NATIONKEY, rh:CUSTOMER_PHONE, ri:CUSTOMER_ACCTBAL,
       rj:CUSTOMER_MKTSEGMENT, rk:CUSTOMER_COMMENT};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
            rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:28, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:13, rb:None immut, rc:Some CUSTOMER_CUSTKEY,
           rd:None immut}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:28, rb:13, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
           rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:27, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:8, rb:None immut, rc:Some CUSTOMER_CUSTKEY,
           rd:None immut}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:27, rb:8, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
           rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:26, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:7, rb:Some CUSTOMER_CUSTKEY, rc:None immut}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:26, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:7, rb:Some CUSTOMER_CUSTKEY, rc:None immut}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:25, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:6, rb:None immut, rc:None immut,
           rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:25, rb:6, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:11, rb:None immut,
           rc:None immut, rd:None immut, re:Some CUSTOMER_NATIONKEY,
           rf:None immut}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:24, rb:11, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
           rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:23, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:6, rb:None immut, rc:None immut,
           rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:22, rb:6, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:4, rb:None immut,
           rc:None immut, rd:None immut, re:Some CUSTOMER_NATIONKEY,
           rf:None immut}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:21, rb:4, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:10, rb:None immut,
           rc:None immut, rd:None immut, re:Some CUSTOMER_NATIONKEY,
           rf:Some CUSTOMER_CUSTKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:20, rb:10, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:3, rb:None immut,
           rc:None immut, rd:None immut, re:Some CUSTOMER_NATIONKEY,
           rf:Some CUSTOMER_CUSTKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:20, rb:3, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine empty {
      ra:int, rb:int, rc:address } @ { Collection })))))))))))))).groupBy
      ((\b1 -> bind b1 as {ra:stmt_id, rb:map_id, rc:ip} in ip)) ((\acc ->
      (\b3 -> bind b3 as {ra:stmt_id, rb:map_id, rc:ip} in 
      (acc.insert {key:stmt_id, value:map_id};acc)))) empty { key:int,
      value:int } @ { Collection }).iterate ((\b1 -> bind b1 as {key:ip,
      value:stmt_map_ids} in 
      (nd_insert_CUSTOMER_rcv_fetch, ip)<- {ra:stmt_map_ids, rb:vid,
      rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
      rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
      ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))}{None ->
                                                         error
                                                           (print
                                                              "unexpected missing arguments in sw_buf_insert_CUSTOMER")})


declare nd_insert_CUSTOMER_do_complete_s20 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  ((((((bind map_REVENUE_mCUSTOMER11_s20_buf as ind __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in re == CUSTOMER_NATIONKEY and rf == CUSTOMER_CUSTKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
      re:map_3, rf:map_4, rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_CUSTKEY,
    rf:__map_ret__35} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__35};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:__map_ret__35} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__35 * -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).combine ((bind map_REVENUE_mCUSTOMER12_s20_buf as ind
    __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in re == CUSTOMER_NATIONKEY and rf == CUSTOMER_CUSTKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
      re:map_3, rf:map_4, rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_CUSTKEY,
    rf:__map_ret__36} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__36};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection })).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:__sum_ret__3} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__sum_ret__3};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_2, rd:map_val} in {ra:map_0, rb:map_1, rc:map_2})) ((\acc -> (\b3 ->
    bind b3 as {ra:map_0, rb:map_1, rc:map_2, rd:map_val} in acc + map_val)))
    0).fold ((\acc -> (\b3 -> bind b3 as {key:g, value:val} in 
    (acc.insert {ra:g.ra, rb:g.rb, rc:g.rc, rd:val};acc)))) empty { ra:string,
    rb:string, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:false, rc:vid,
      rd:delta_values});
   (nd_complete_stmt_cntr_check {key:vid, value:20})))


declare nd_insert_CUSTOMER_do_complete_s21 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  ((bind map_REVENUE_mCUSTOMER11_mORDERS1_s21_buf as ind __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in re == CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 ->
      bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
      rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:CUSTOMER_NATIONKEY,
    re:REVENUE_mORDERSORDERS_ORDERKEY, rf:__map_ret__37} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_ORDERKEY, re:__map_ret__37};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_ORDERKEY,
    re:__map_ret__37} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:CUSTOMER_CUSTKEY,
     re:REVENUE_mORDERSORDERS_ORDERKEY, rf:__map_ret__37};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS11_send_correctives {ra:me, rb:21, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:21}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:21, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_CUSTOMER_do_complete_s22 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  ((bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s22_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
    rd:REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY, re:__map_ret__38} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__38};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__38} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:CUSTOMER_CUSTKEY, rd:REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY,
     re:__map_ret__38};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mORDERS11_mLINEITEM4,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS11_mLINEITEM4_send_correctives {ra:me, rb:22, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:22}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:22, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_CUSTOMER_do_complete_s23 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  ((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s23_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
    rd:REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__39} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__39};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__39} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:CUSTOMER_CUSTKEY, rd:REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
     re:__map_ret__39};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mORDERS11_mSUPPLIER2,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS11_mSUPPLIER2_send_correctives {ra:me, rb:23, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:23}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:23, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_CUSTOMER_do_complete_s24 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  ((bind map_REVENUE_mCUSTOMER12_mORDERS1_s24_buf as ind __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in re == CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 ->
      bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
      rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:CUSTOMER_NATIONKEY,
    re:REVENUE_mORDERSORDERS_ORDERKEY, rf:__map_ret__40} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_ORDERKEY, re:__map_ret__40};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_ORDERKEY,
    re:__map_ret__40} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:CUSTOMER_CUSTKEY,
     re:REVENUE_mORDERSORDERS_ORDERKEY, rf:__map_ret__40};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS12_send_correctives {ra:me, rb:24, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:24}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:24, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_CUSTOMER_do_complete_s25 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s25_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
    rd:REVENUE_mLINEITEMLINEITEM_SUPPKEY, re:__map_ret__41} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__41};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accext -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__41} in _accext.combine
    (((bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s25_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:CUSTOMER_CUSTKEY, rb:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    rc:__map_ret__42} in 
    (_accmap.insert {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
     value:__map_ret__42};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    value:__map_ret__42} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY,
     rd:REVENUE_mLINEITEMLINEITEM_ORDERKEY, re:__map_ret__41 * __map_ret__42};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection })))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY,
    rd:REVENUE_mLINEITEMLINEITEM_ORDERKEY, re:__prod_ret__25} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
     rd:REVENUE_mLINEITEMLINEITEM_SUPPKEY, re:__prod_ret__25};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mLINEITEM4, rb:false,
      rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mLINEITEM4_send_correctives {ra:me, rb:25, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:25}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:25, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_CUSTOMER_do_complete_s26 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s26_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:CUSTOMER_CUSTKEY, rb:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    rc:__map_ret__43} in 
    (_accmap.insert {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
     value:__map_ret__43};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    value:__map_ret__43} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mSUPPLIER2_s26_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
    rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__44} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__44};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__44} in 
    (_accmap.insert {ra:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
     rb:SHIPPING_SUPP_NATION, rc:SHIPPING_CUST_NATION,
     rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__43 *
     __map_ret__44};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:REVENUE_mLINEITEMLINEITEM_ORDERKEY, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
    re:__prod_ret__26} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
     rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, re:__prod_ret__26};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int
      {ra:REVENUE_mLINEITEM4_mSUPPLIER1, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mLINEITEM4_mSUPPLIER1_send_correctives {ra:me, rb:26, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:26}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:26, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_CUSTOMER_do_complete_s27 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s27_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
       CUSTOMER_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:CUSTOMER_CUSTKEY,
    rc:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__45} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:__map_ret__45};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__45} in _accext.combine
    (((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s27_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
    rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__46} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__46};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__46} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__map_ret__45 * __map_ret__46};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__prod_ret__27} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rf:__prod_ret__27};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mSUPPLIER11_send_correctives {ra:me, rb:27, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:27}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:27, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_CUSTOMER_do_complete_s28 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s28_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
       CUSTOMER_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:CUSTOMER_CUSTKEY,
    rc:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__47} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:__map_ret__47};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__47} in _accext.combine
    (((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s28_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
    rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__48} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__48};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__48} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__map_ret__47 * __map_ret__48};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__prod_ret__28} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rf:__prod_ret__28};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mSUPPLIER12_send_correctives {ra:me, rb:28, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:28}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:28, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare insert_CUSTOMER_do_corrective_s20_m_REVENUE_mCUSTOMER11 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:string, rh:string, ri:int, rj:string, rk:real, rl:string, rm:string,
  rn:collection { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rf:delta_REVENUE_mCUSTOMER11} in _accext.combine (let __prod_ret__813 =
    ((if CUSTOMER_CUSTKEY == delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY 
      then 1 else 0) *
      if CUSTOMER_NATIONKEY == delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY 
      then 1 else 0) * -delta_REVENUE_mCUSTOMER11 in
    {| ra:string, rb:string, rc:int, rd:real | {ra:delta_SHIPPING_SUPP_NATION,
      rb:delta_SHIPPING_CUST_NATION, rc:delta_SHIPPING_L_YEAR,
      rd:__prod_ret__813}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare insert_CUSTOMER_do_corrective_s20_m_REVENUE_mCUSTOMER12 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:string, rh:string, ri:int, rj:string, rk:real, rl:string, rm:string,
  rn:collection { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rf:delta_REVENUE_mCUSTOMER12} in _accext.combine (let __prod_ret__815 =
    ((if CUSTOMER_CUSTKEY == delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY 
      then 1 else 0) *
      if CUSTOMER_NATIONKEY == delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY 
      then 1 else 0) * delta_REVENUE_mCUSTOMER12 in
    {| ra:string, rb:string, rc:int, rd:real | {ra:delta_SHIPPING_SUPP_NATION,
      rb:delta_SHIPPING_CUST_NATION, rc:delta_SHIPPING_L_YEAR,
      rd:__prod_ret__815}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare insert_CUSTOMER_do_corrective_s21_m_REVENUE_mCUSTOMER11_mORDERS1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:string, rb:string, rc:int, rd:int,
  re:int, rf:real } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS,
  ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL,
  rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT, rn:delta_tuples} in let
  new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY,
    rf:delta_REVENUE_mCUSTOMER11_mORDERS1} in _accext.combine (let
    __prod_ret__816 =
    (if CUSTOMER_NATIONKEY == delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY 
      then 1 else 0) * delta_REVENUE_mCUSTOMER11_mORDERS1 in
    {| ra:string, rb:string, rc:int, rd:int, re:int, rf:real |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:delta_SHIPPING_L_YEAR, rd:CUSTOMER_CUSTKEY,
      re:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY,
      rf:__prod_ret__816}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int, rf:real } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_CUSTOMER_do_corrective_s22_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:string, rb:string, rc:int, rd:int,
  re:int } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mCUSTOMER11_mLINEITEM4} in _accext.combine (let
    __prod_ret__817 =
    (if CUSTOMER_NATIONKEY == delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY 
      then 1 else 0) * delta_REVENUE_mCUSTOMER11_mLINEITEM4 in
    {| ra:string, rb:string, rc:int, rd:int, re:int |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:CUSTOMER_CUSTKEY,
      rd:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY,
      re:__prod_ret__817}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 0 !=
    map_val)) in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mORDERS11_mLINEITEM4,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS11_mLINEITEM4_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_CUSTOMER_do_corrective_s24_m_REVENUE_mCUSTOMER12_mORDERS1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:string, rb:string, rc:int, rd:int,
  re:int, rf:real } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS,
  ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL,
  rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT, rn:delta_tuples} in let
  new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
    rf:delta_REVENUE_mCUSTOMER12_mORDERS1} in _accext.combine (let
    __prod_ret__851 =
    (if CUSTOMER_NATIONKEY == delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY 
      then 1 else 0) * delta_REVENUE_mCUSTOMER12_mORDERS1 in
    {| ra:string, rb:string, rc:int, rd:int, re:int, rf:real |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:delta_SHIPPING_L_YEAR, rd:CUSTOMER_CUSTKEY,
      re:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
      rf:__prod_ret__851}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int, rf:real } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_CUSTOMER_do_corrective_s25_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:string, rb:string, rc:int, rd:int,
  re:int } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mCUSTOMER11_mLINEITEM4} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s25_buf as ind __x in
      (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
        rd:map_val} in (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc))))
        empty { ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:CUSTOMER_CUSTKEY,
      rb:REVENUE_mLINEITEMLINEITEM_ORDERKEY, rc:__map_ret__167} in 
      (_accmap.insert {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
       value:__map_ret__167};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
      value:__map_ret__167} in 
      (_accmap.insert {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
       value:__map_ret__167 *
       if CUSTOMER_NATIONKEY == delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY
       then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
      value:__prod_ret__818} in 
      (_accmap.insert {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
       value:__prod_ret__818 * delta_REVENUE_mCUSTOMER11_mLINEITEM4};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
      value:__prod_ret__819} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
       rd:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY,
       re:__prod_ret__819};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
      } @ { Collection } in delta_values)))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 0 !=
    map_val)) in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mLINEITEM4, rb:true,
      rc:vid, rd:new_tuples});
   (nd_REVENUE_mLINEITEM4_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_CUSTOMER_do_corrective_s25_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:int, rb:int, rc:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mLINEITEM5} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s25_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
         CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
      rd:REVENUE_mLINEITEMLINEITEM_SUPPKEY, re:__map_ret__181} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__181};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__181} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__181 *
       if CUSTOMER_CUSTKEY == delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY 
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__prod_ret__852} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__prod_ret__852 *
       delta_REVENUE_mCUSTOMER11_mLINEITEM5};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__prod_ret__853} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY,
       rd:REVENUE_mLINEITEMLINEITEM_SUPPKEY, re:__prod_ret__853};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
      } @ { Collection } in delta_values)))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 0 !=
    map_val)) in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mLINEITEM4, rb:true,
      rc:vid, rd:new_tuples});
   (nd_REVENUE_mLINEITEM4_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_CUSTOMER_do_corrective_s26_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:int, rb:int, rc:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mLINEITEM5} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s26_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
         CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
      rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__182} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__182};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__182} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__182 *
       if CUSTOMER_CUSTKEY == delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY 
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
      rd:__prod_ret__854} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__854 *
       delta_REVENUE_mCUSTOMER11_mLINEITEM5};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
      rd:__prod_ret__855} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY,
       rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, re:__prod_ret__855};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
      } @ { Collection } in delta_values)))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 0 !=
    map_val)) in
  ((nd_add_delta_to_string_string_int_int_int
      {ra:REVENUE_mLINEITEM4_mSUPPLIER1, rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mLINEITEM4_mSUPPLIER1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_CUSTOMER_do_corrective_s27_m_REVENUE_mCUSTOMER11_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:int, rb:int, rc:int, rd:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:delta_REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER11_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s27_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
         CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
      rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__185} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__185};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__185} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__185 *
       if CUSTOMER_CUSTKEY == delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY 
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__860} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__860 *
       delta_REVENUE_mCUSTOMER11_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__861} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY,
       rf:__prod_ret__861};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mSUPPLIER11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_CUSTOMER_do_corrective_s28_m_REVENUE_mCUSTOMER12_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:int, rb:int, rc:int, rd:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:delta_REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER12_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s28_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
         CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
      rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__186} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__186};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__186} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__186 *
       if CUSTOMER_CUSTKEY == delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY 
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__862} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__862 *
       delta_REVENUE_mCUSTOMER12_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__863} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY,
       rf:__prod_ret__863};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mSUPPLIER12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare sw_delete_CUSTOMER : { ra:int, rb:string, rc:string, rd:int, re:string,
  rf:real, rg:string, rh:string } -> () = (\args ->
  (sw_buf_delete_CUSTOMER.insert args;
   sw_trig_buf_idx.insert {i:3};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_delete_CUSTOMER_send_fetch : { key:int, value:int } -> () = (\vid ->
  case (sw_buf_delete_CUSTOMER.peek ()) of
  {Some args ->
    (sw_buf_delete_CUSTOMER.erase args;
     bind args as
     {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
     in
     (((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_string_string_int_int_int {ra:3, rb:None immut, rc:None immut,
         rd:None immut, re:Some CUSTOMER_NATIONKEY, rf:Some CUSTOMER_CUSTKEY}).fold
        ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_REVENUE_mCUSTOMER11_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
          rb:None immut, rc:None immut, rd:empty { ra:{ key:int, value:int },
          rb:string, rc:string, rd:int, re:int, rf:int, rg:real
          } @ { Collection }, re:true}).fold ((\_accmap -> (\b3 ->
        bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:29, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_string_string_int_int_int {ra:10, rb:None immut,
           rc:None immut, rd:None immut, re:Some CUSTOMER_NATIONKEY,
           rf:Some CUSTOMER_CUSTKEY}).fold ((\count -> (\b3 ->
          bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_REVENUE_mCUSTOMER12_to_REVENUE_bind_0t0_1t1_2t2
            {ra:None immut, rb:None immut, rc:None immut, rd:empty { ra:{
            key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int,
            rg:real } @ { Collection }, re:true}).fold ((\_accmap -> (\b3 ->
          bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:29, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }).combine (let
          sender_count =
          (route_to_string_string_int_int_int {ra:4, rb:None immut,
             rc:None immut, rd:None immut, re:Some CUSTOMER_NATIONKEY,
             rf:None immut}).fold ((\count -> (\b3 -> bind b3 as {i:ip} in 
            count + 1))) 0 in
          ((shuffle_REVENUE_mCUSTOMER11_mORDERS1_to_REVENUE_mORDERS11_bind_0t0_1t1_2t2_4t4
              {ra:None immut, rb:None immut, rc:None immut,
              rd:Some CUSTOMER_CUSTKEY, re:None immut, rf:empty { ra:{ key:int,
              value:int }, rb:string, rc:string, rd:int, re:int, rf:int,
              rg:real } @ { Collection }, rg:true}).fold ((\_accmap -> (\b3 ->
            bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {ra:ip, rb:30, rc:sender_count};_accmap)))) empty {
            ra:address, rb:int, rc:int } @ { Collection }).combine (let
            sender_count =
            (route_to_string_string_int_int {ra:6, rb:None immut,
               rc:None immut, rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold
              ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
            ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mORDERS11_mLINEITEM4_bind_0t0_1t1_3t3
                {ra:None immut, rb:None immut, rc:Some CUSTOMER_CUSTKEY,
                rd:None immut, re:empty { ra:{ key:int, value:int }, rb:string,
                rc:string, rd:int, re:int, rf:int } @ { Collection }, rf:true}).fold
              ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:31, rc:sender_count};_accmap))))
              empty { ra:address, rb:int, rc:int } @ { Collection }).combine
              (let sender_count =
              (route_to_string_string_int_int {ra:9, rb:None immut,
                 rc:None immut, rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold
                ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
              ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mORDERS11_mSUPPLIER2_bind_0t0_1t1_3t3
                  {ra:None immut, rb:None immut, rc:Some CUSTOMER_CUSTKEY,
                  rd:None immut, re:empty { ra:{ key:int, value:int },
                  rb:string, rc:string, rd:int, re:int, rf:int
                  } @ { Collection }, rf:true}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:32, rc:sender_count};_accmap))))
                empty { ra:address, rb:int, rc:int } @ { Collection }).combine
                (let sender_count =
                (route_to_string_string_int_int_int {ra:11, rb:None immut,
                   rc:None immut, rd:None immut, re:Some CUSTOMER_NATIONKEY,
                   rf:None immut}).fold ((\count -> (\b3 ->
                  bind b3 as {i:ip} in count + 1))) 0 in
                ((shuffle_REVENUE_mCUSTOMER12_mORDERS1_to_REVENUE_mORDERS12_bind_0t0_1t1_2t2_4t4
                    {ra:None immut, rb:None immut, rc:None immut,
                    rd:Some CUSTOMER_CUSTKEY, re:None immut, rf:empty { ra:{
                    key:int, value:int }, rb:string, rc:string, rd:int, re:int,
                    rf:int, rg:real } @ { Collection }, rg:true}).fold
                  ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:33, rc:sender_count};_accmap))))
                  empty { ra:address, rb:int, rc:int
                  } @ { Collection }).combine (let sender_count =
                  (route_to_string_string_int_int {ra:6, rb:None immut,
                     rc:None immut, rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold
                    ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                  ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mLINEITEM4_bind_0t0_1t1_3t3
                      {ra:None immut, rb:None immut, rc:None immut,
                      rd:None immut, re:empty { ra:{ key:int, value:int },
                      rb:string, rc:string, rd:int, re:int, rf:int
                      } @ { Collection }, rf:true}).fold ((\_accmap -> (\b3 ->
                    bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:34, rc:sender_count};_accmap))))
                    empty { ra:address, rb:int, rc:int
                    } @ { Collection }).combine (let sender_count =
                    (route_to_int_int {ra:7, rb:Some CUSTOMER_CUSTKEY,
                       rc:None immut}).fold ((\count -> (\b3 ->
                      bind b3 as {i:ip} in count + 1))) 0 in
                    ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mLINEITEM4_bind_2t1
                        {ra:None immut, rb:None immut, rc:None immut,
                        rd:None immut, re:empty { ra:{ key:int, value:int },
                        rb:int, rc:int, rd:int } @ { Collection }, rf:true}).fold
                      ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                      value:tuples} in 
                      (_accmap.insert {ra:ip, rb:34, rc:sender_count};_accmap))))
                      empty { ra:address, rb:int, rc:int
                      } @ { Collection }).combine (let sender_count =
                      (route_to_int_int {ra:7, rb:Some CUSTOMER_CUSTKEY,
                         rc:None immut}).fold ((\count -> (\b3 ->
                        bind b3 as {i:ip} in count + 1))) 0 in
                      ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_2t1
                          {ra:None immut, rb:None immut, rc:None immut,
                          rd:None immut, re:empty { ra:{ key:int, value:int },
                          rb:int, rc:int, rd:int } @ { Collection }, rf:true}).fold
                        ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                        value:tuples} in 
                        (_accmap.insert {ra:ip, rb:35, rc:sender_count};_accmap))))
                        empty { ra:address, rb:int, rc:int
                        } @ { Collection }).combine (let sender_count =
                        (route_to_string_string_int_int {ra:9, rb:None immut,
                           rc:None immut, rd:Some CUSTOMER_NATIONKEY,
                           re:None immut}).fold ((\count -> (\b3 ->
                          bind b3 as {i:ip} in count + 1))) 0 in
                        ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_0t0_1t1_3t3
                            {ra:None immut, rb:None immut, rc:None immut,
                            rd:None immut, re:empty { ra:{ key:int, value:int
                            }, rb:string, rc:string, rd:int, re:int, rf:int
                            } @ { Collection }, rf:true}).fold ((\_accmap ->
                          (\b3 -> bind b3 as {key:ip, value:tuples} in 
                          (_accmap.insert {ra:ip, rb:35, rc:sender_count};
                           _accmap)))) empty { ra:address, rb:int, rc:int
                          } @ { Collection }).combine (let sender_count =
                          (route_to_int_int_int {ra:8, rb:None immut,
                             rc:Some CUSTOMER_CUSTKEY, rd:None immut}).fold
                            ((\count -> (\b3 -> bind b3 as {i:ip} in count +
                            1))) 0 in
                          ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_2t0_4t2
                              {ra:None immut, rb:None immut, rc:None immut,
                              rd:None immut, re:None immut, rf:empty { ra:{
                              key:int, value:int }, rb:int, rc:int, rd:int,
                              re:real } @ { Collection }, rg:true}).fold
                            ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                            value:tuples} in 
                            (_accmap.insert {ra:ip, rb:36, rc:sender_count};
                             _accmap)))) empty { ra:address, rb:int, rc:int
                            } @ { Collection }).combine (let sender_count =
                            (route_to_string_string_int_int {ra:9,
                               rb:None immut, rc:None immut,
                               rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold
                              ((\count -> (\b3 -> bind b3 as {i:ip} in count +
                              1))) 0 in
                            ((shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3
                                {ra:None immut, rb:None immut, rc:None immut,
                                rd:None immut, re:None immut, rf:empty { ra:{
                                key:int, value:int }, rb:string, rc:string,
                                rd:int, re:int, rf:int } @ { Collection },
                                rg:true}).fold ((\_accmap -> (\b3 ->
                              bind b3 as {key:ip, value:tuples} in 
                              (_accmap.insert {ra:ip, rb:36, rc:sender_count};
                               _accmap)))) empty { ra:address, rb:int, rc:int
                              } @ { Collection }).combine (let sender_count =
                              (route_to_int_int_int {ra:13, rb:None immut,
                                 rc:Some CUSTOMER_CUSTKEY, rd:None immut}).fold
                                ((\count -> (\b3 -> bind b3 as {i:ip} in count
                                + 1))) 0 in
                              ((shuffle_REVENUE_mCUSTOMER12_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_2t0_4t2
                                  {ra:None immut, rb:None immut, rc:None immut,
                                  rd:None immut, re:None immut, rf:empty { ra:{
                                  key:int, value:int }, rb:int, rc:int, rd:int,
                                  re:real } @ { Collection }, rg:true}).fold
                                ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                value:tuples} in 
                                (_accmap.insert {ra:ip, rb:37, rc:sender_count};
                                 _accmap)))) empty { ra:address, rb:int, rc:int
                                } @ { Collection }).combine (let sender_count =
                                (route_to_string_string_int_int {ra:9,
                                   rb:None immut, rc:None immut,
                                   rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold
                                  ((\count -> (\b3 -> bind b3 as {i:ip} in 
                                  count + 1))) 0 in
                                (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3
                                   {ra:None immut, rb:None immut,
                                   rc:None immut, rd:None immut, re:None immut,
                                   rf:empty { ra:{ key:int, value:int },
                                   rb:string, rc:string, rd:int, re:int, rf:int
                                   } @ { Collection }, rg:true}).fold
                                  ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                  value:tuples} in 
                                  (_accmap.insert {ra:ip, rb:37,
                                   rc:sender_count};
                                   _accmap)))) empty { ra:address, rb:int,
                                  rc:int } @ { Collection }))))))))))))))).groupBy
      ((\b1 -> bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip,
      value:stmt_id})) ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id,
      rc:count} in acc + count))) 0).groupBy ((\b1 -> bind b1 as {key:b2,
      value:count} in bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc ->
      (\b3 -> bind b3 as {key:ip_and_stmt_id, value:count} in bind
      ip_and_stmt_id as {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_delete_CUSTOMER_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid,
       rd:CUSTOMER_CUSTKEY, re:CUSTOMER_NAME, rf:CUSTOMER_ADDRESS,
       rg:CUSTOMER_NATIONKEY, rh:CUSTOMER_PHONE, ri:CUSTOMER_ACCTBAL,
       rj:CUSTOMER_MKTSEGMENT, rk:CUSTOMER_COMMENT};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
            rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:37, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:13, rb:None immut, rc:Some CUSTOMER_CUSTKEY,
           rd:None immut}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:37, rb:13, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
           rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:36, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:8, rb:None immut, rc:Some CUSTOMER_CUSTKEY,
           rd:None immut}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:36, rb:8, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
           rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:35, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:7, rb:Some CUSTOMER_CUSTKEY, rc:None immut}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:35, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:7, rb:Some CUSTOMER_CUSTKEY, rc:None immut}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:34, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:6, rb:None immut, rc:None immut,
           rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:34, rb:6, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:11, rb:None immut,
           rc:None immut, rd:None immut, re:Some CUSTOMER_NATIONKEY,
           rf:None immut}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:33, rb:11, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:9, rb:None immut, rc:None immut,
           rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:32, rb:9, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:6, rb:None immut, rc:None immut,
           rd:Some CUSTOMER_NATIONKEY, re:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:31, rb:6, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:4, rb:None immut,
           rc:None immut, rd:None immut, re:Some CUSTOMER_NATIONKEY,
           rf:None immut}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:30, rb:4, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:10, rb:None immut,
           rc:None immut, rd:None immut, re:Some CUSTOMER_NATIONKEY,
           rf:Some CUSTOMER_CUSTKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:29, rb:10, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:3, rb:None immut,
           rc:None immut, rd:None immut, re:Some CUSTOMER_NATIONKEY,
           rf:Some CUSTOMER_CUSTKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:29, rb:3, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine empty {
      ra:int, rb:int, rc:address } @ { Collection })))))))))))))).groupBy
      ((\b1 -> bind b1 as {ra:stmt_id, rb:map_id, rc:ip} in ip)) ((\acc ->
      (\b3 -> bind b3 as {ra:stmt_id, rb:map_id, rc:ip} in 
      (acc.insert {key:stmt_id, value:map_id};acc)))) empty { key:int,
      value:int } @ { Collection }).iterate ((\b1 -> bind b1 as {key:ip,
      value:stmt_map_ids} in 
      (nd_delete_CUSTOMER_rcv_fetch, ip)<- {ra:stmt_map_ids, rb:vid,
      rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
      rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
      ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))}{None ->
                                                         error
                                                           (print
                                                              "unexpected missing arguments in sw_buf_delete_CUSTOMER")})


declare nd_delete_CUSTOMER_do_complete_s29 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  (((((bind map_REVENUE_mCUSTOMER11_s29_buf as ind __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in re == CUSTOMER_NATIONKEY and rf == CUSTOMER_CUSTKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
      re:map_3, rf:map_4, rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_CUSTKEY,
    rf:__map_ret__49} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__49};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).combine (((bind map_REVENUE_mCUSTOMER12_s29_buf as ind
    __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in re == CUSTOMER_NATIONKEY and rf == CUSTOMER_CUSTKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
      re:map_3, rf:map_4, rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_CUSTKEY,
    rf:__map_ret__50} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__50};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:__map_ret__50} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__50 * -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection })).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:__sum_ret__4} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__sum_ret__4};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_2, rd:map_val} in {ra:map_0, rb:map_1, rc:map_2})) ((\acc -> (\b3 ->
    bind b3 as {ra:map_0, rb:map_1, rc:map_2, rd:map_val} in acc + map_val)))
    0).fold ((\acc -> (\b3 -> bind b3 as {key:g, value:val} in 
    (acc.insert {ra:g.ra, rb:g.rb, rc:g.rc, rd:val};acc)))) empty { ra:string,
    rb:string, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:false, rc:vid,
      rd:delta_values});
   (nd_complete_stmt_cntr_check {key:vid, value:29})))


declare nd_delete_CUSTOMER_do_complete_s30 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER11_mORDERS1_s30_buf as ind __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in re == CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 ->
      bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
      rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:CUSTOMER_NATIONKEY,
    re:REVENUE_mORDERSORDERS_ORDERKEY, rf:__map_ret__51} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_ORDERKEY, re:__map_ret__51};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_ORDERKEY,
    re:__map_ret__51} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_ORDERKEY, re:__map_ret__51 *
     -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_ORDERKEY,
    re:__prod_ret__30} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:CUSTOMER_CUSTKEY,
     re:REVENUE_mORDERSORDERS_ORDERKEY, rf:__prod_ret__30};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS11_send_correctives {ra:me, rb:30, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:30}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:30, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_CUSTOMER_do_complete_s31 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s31_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
    rd:REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY, re:__map_ret__52} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__52};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__52} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__52 * -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY, rd:__prod_ret__31} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:CUSTOMER_CUSTKEY, rd:REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY,
     re:__prod_ret__31};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mORDERS11_mLINEITEM4,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS11_mLINEITEM4_send_correctives {ra:me, rb:31, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:31}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:31, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_CUSTOMER_do_complete_s32 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s32_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
    rd:REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__53} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__53};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__53} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__53 * -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__32} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:CUSTOMER_CUSTKEY, rd:REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
     re:__prod_ret__32};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mORDERS11_mSUPPLIER2,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS11_mSUPPLIER2_send_correctives {ra:me, rb:32, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:32}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:32, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_CUSTOMER_do_complete_s33 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER12_mORDERS1_s33_buf as ind __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in re == CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 ->
      bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
      rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:CUSTOMER_NATIONKEY,
    re:REVENUE_mORDERSORDERS_ORDERKEY, rf:__map_ret__54} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_ORDERKEY, re:__map_ret__54};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_ORDERKEY,
    re:__map_ret__54} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_ORDERKEY, re:__map_ret__54 *
     -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_ORDERKEY,
    re:__prod_ret__33} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:CUSTOMER_CUSTKEY,
     re:REVENUE_mORDERSORDERS_ORDERKEY, rf:__prod_ret__33};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS12_send_correctives {ra:me, rb:33, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:33}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:33, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_CUSTOMER_do_complete_s34 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  ((((bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s34_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
    rd:REVENUE_mLINEITEMLINEITEM_SUPPKEY, re:__map_ret__55} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__55};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accext -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__55} in _accext.combine
    (((bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s34_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:CUSTOMER_CUSTKEY, rb:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    rc:__map_ret__56} in 
    (_accmap.insert {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
     value:__map_ret__56};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    value:__map_ret__56} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY,
     rd:REVENUE_mLINEITEMLINEITEM_ORDERKEY, re:__map_ret__55 * __map_ret__56};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection })))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY,
    rd:REVENUE_mLINEITEMLINEITEM_ORDERKEY, re:__prod_ret__34} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY,
     rd:REVENUE_mLINEITEMLINEITEM_ORDERKEY, re:__prod_ret__34 * -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY,
    rd:REVENUE_mLINEITEMLINEITEM_ORDERKEY, re:__prod_ret__35} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
     rd:REVENUE_mLINEITEMLINEITEM_SUPPKEY, re:__prod_ret__35};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mLINEITEM4, rb:false,
      rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mLINEITEM4_send_correctives {ra:me, rb:34, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:34}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:34, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_CUSTOMER_do_complete_s35 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  ((((bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s35_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:CUSTOMER_CUSTKEY, rb:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    rc:__map_ret__57} in 
    (_accmap.insert {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
     value:__map_ret__57};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    value:__map_ret__57} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mSUPPLIER2_s35_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
    rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__58} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__58};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__58} in 
    (_accmap.insert {ra:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
     rb:SHIPPING_SUPP_NATION, rc:SHIPPING_CUST_NATION,
     rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__57 *
     __map_ret__58};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:REVENUE_mLINEITEMLINEITEM_ORDERKEY, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
    re:__prod_ret__36} in 
    (_accmap.insert {ra:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
     rb:SHIPPING_SUPP_NATION, rc:SHIPPING_CUST_NATION,
     rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, re:__prod_ret__36 * -1};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:REVENUE_mLINEITEMLINEITEM_ORDERKEY, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
    re:__prod_ret__37} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
     rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, re:__prod_ret__37};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int
      {ra:REVENUE_mLINEITEM4_mSUPPLIER1, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mLINEITEM4_mSUPPLIER1_send_correctives {ra:me, rb:35, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:35}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:35, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_CUSTOMER_do_complete_s36 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  ((((bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s36_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
       CUSTOMER_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:CUSTOMER_CUSTKEY,
    rc:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__59} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:__map_ret__59};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__59} in _accext.combine
    (((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s36_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
    rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__60} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__60};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__60} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__map_ret__59 * __map_ret__60};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__prod_ret__38} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__prod_ret__38 * -1};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__prod_ret__39} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rf:__prod_ret__39};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mSUPPLIER11_send_correctives {ra:me, rb:36, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:36}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:36, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_CUSTOMER_do_complete_s37 : { ra:{ key:int, value:int },
  rb:int, rc:string, rd:string, re:int, rf:string, rg:real, rh:string,
  ri:string } -> () = (\b1 -> bind b1 as {ra:vid, rb:CUSTOMER_CUSTKEY,
  rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
  rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
  ri:CUSTOMER_COMMENT} in let delta_values =
  ((((bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s37_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
       CUSTOMER_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:CUSTOMER_CUSTKEY,
    rc:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__61} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:__map_ret__61};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__61} in _accext.combine
    (((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s37_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
    rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__62} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__62};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__62} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__map_ret__61 * __map_ret__62};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__prod_ret__40} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__prod_ret__40 * -1};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__prod_ret__41} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rf:__prod_ret__41};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mSUPPLIER12_send_correctives {ra:me, rb:37, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:37}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:37, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare delete_CUSTOMER_do_corrective_s29_m_REVENUE_mCUSTOMER11 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:string, rh:string, ri:int, rj:string, rk:real, rl:string, rm:string,
  rn:collection { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rf:delta_REVENUE_mCUSTOMER11} in _accext.combine (let __prod_ret__865 =
    ((if CUSTOMER_CUSTKEY == delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY 
      then 1 else 0) *
      if CUSTOMER_NATIONKEY == delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY 
      then 1 else 0) * delta_REVENUE_mCUSTOMER11 in
    {| ra:string, rb:string, rc:int, rd:real | {ra:delta_SHIPPING_SUPP_NATION,
      rb:delta_SHIPPING_CUST_NATION, rc:delta_SHIPPING_L_YEAR,
      rd:__prod_ret__865}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare delete_CUSTOMER_do_corrective_s29_m_REVENUE_mCUSTOMER12 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:string, rh:string, ri:int, rj:string, rk:real, rl:string, rm:string,
  rn:collection { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rf:delta_REVENUE_mCUSTOMER12} in _accext.combine (let __prod_ret__868 =
    ((if CUSTOMER_CUSTKEY == delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY 
      then 1 else 0) *
      if CUSTOMER_NATIONKEY == delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY 
      then 1 else 0) * -delta_REVENUE_mCUSTOMER12 in
    {| ra:string, rb:string, rc:int, rd:real | {ra:delta_SHIPPING_SUPP_NATION,
      rb:delta_SHIPPING_CUST_NATION, rc:delta_SHIPPING_L_YEAR,
      rd:__prod_ret__868}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare delete_CUSTOMER_do_corrective_s30_m_REVENUE_mCUSTOMER11_mORDERS1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:string, rb:string, rc:int, rd:int,
  re:int, rf:real } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS,
  ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL,
  rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT, rn:delta_tuples} in let
  new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY,
    rf:delta_REVENUE_mCUSTOMER11_mORDERS1} in _accext.combine (let
    __prod_ret__870 =
    (if CUSTOMER_NATIONKEY == delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY 
      then 1 else 0) * -delta_REVENUE_mCUSTOMER11_mORDERS1 in
    {| ra:string, rb:string, rc:int, rd:int, re:int, rf:real |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:delta_SHIPPING_L_YEAR, rd:CUSTOMER_CUSTKEY,
      re:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY,
      rf:__prod_ret__870}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int, rf:real } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_CUSTOMER_do_corrective_s31_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:string, rb:string, rc:int, rd:int,
  re:int } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mCUSTOMER11_mLINEITEM4} in _accext.combine (let
    __prod_ret__872 =
    (if CUSTOMER_NATIONKEY == delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY 
      then 1 else 0) * -delta_REVENUE_mCUSTOMER11_mLINEITEM4 in
    {| ra:string, rb:string, rc:int, rd:int, re:int |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:CUSTOMER_CUSTKEY,
      rd:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY,
      re:__prod_ret__872}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 0 !=
    map_val)) in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mORDERS11_mLINEITEM4,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS11_mLINEITEM4_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_CUSTOMER_do_corrective_s33_m_REVENUE_mCUSTOMER12_mORDERS1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:string, rb:string, rc:int, rd:int,
  re:int, rf:real } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS,
  ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL,
  rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT, rn:delta_tuples} in let
  new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
    rf:delta_REVENUE_mCUSTOMER12_mORDERS1} in _accext.combine (let
    __prod_ret__926 =
    (if CUSTOMER_NATIONKEY == delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY 
      then 1 else 0) * -delta_REVENUE_mCUSTOMER12_mORDERS1 in
    {| ra:string, rb:string, rc:int, rd:int, re:int, rf:real |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:delta_SHIPPING_L_YEAR, rd:CUSTOMER_CUSTKEY,
      re:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
      rf:__prod_ret__926}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int, rf:real } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_CUSTOMER_do_corrective_s34_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:string, rb:string, rc:int, rd:int,
  re:int } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mCUSTOMER11_mLINEITEM4} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s34_buf as ind __x in
      (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
        rd:map_val} in (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc))))
        empty { ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:CUSTOMER_CUSTKEY,
      rb:REVENUE_mLINEITEMLINEITEM_ORDERKEY, rc:__map_ret__187} in 
      (_accmap.insert {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
       value:__map_ret__187};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
      value:__map_ret__187} in 
      (_accmap.insert {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
       value:__map_ret__187 *
       if CUSTOMER_NATIONKEY == delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY
       then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
      value:__prod_ret__874} in 
      (_accmap.insert {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
       value:__prod_ret__874 * -delta_REVENUE_mCUSTOMER11_mLINEITEM4};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
      value:__prod_ret__875} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:REVENUE_mLINEITEMLINEITEM_ORDERKEY,
       rd:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY,
       re:__prod_ret__875};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
      } @ { Collection } in delta_values)))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 0 !=
    map_val)) in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mLINEITEM4, rb:true,
      rc:vid, rd:new_tuples});
   (nd_REVENUE_mLINEITEM4_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_CUSTOMER_do_corrective_s34_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:int, rb:int, rc:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mLINEITEM5} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s34_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
         CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
      rd:REVENUE_mLINEITEMLINEITEM_SUPPKEY, re:__map_ret__201} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__201};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__201} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__201 *
       if CUSTOMER_CUSTKEY == delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY 
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__prod_ret__928} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__prod_ret__928 *
       -delta_REVENUE_mCUSTOMER11_mLINEITEM5};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__prod_ret__929} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY,
       rd:REVENUE_mLINEITEMLINEITEM_SUPPKEY, re:__prod_ret__929};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
      } @ { Collection } in delta_values)))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 0 !=
    map_val)) in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mLINEITEM4, rb:true,
      rc:vid, rd:new_tuples});
   (nd_REVENUE_mLINEITEM4_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_CUSTOMER_do_corrective_s35_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:int, rb:int, rc:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mLINEITEM5} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s35_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
         CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
      rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__202} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__202};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__202} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__202 *
       if CUSTOMER_CUSTKEY == delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY 
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
      rd:__prod_ret__931} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__931 *
       -delta_REVENUE_mCUSTOMER11_mLINEITEM5};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
      rd:__prod_ret__932} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY,
       rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, re:__prod_ret__932};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
      } @ { Collection } in delta_values)))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 0 !=
    map_val)) in
  ((nd_add_delta_to_string_string_int_int_int
      {ra:REVENUE_mLINEITEM4_mSUPPLIER1, rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mLINEITEM4_mSUPPLIER1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_CUSTOMER_do_corrective_s36_m_REVENUE_mCUSTOMER11_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:int, rb:int, rc:int, rd:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:delta_REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER11_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s36_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
         CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
      rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__205} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__205};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__205} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__205 *
       if CUSTOMER_CUSTKEY == delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY 
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__940} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__940 *
       -delta_REVENUE_mCUSTOMER11_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__941} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY,
       rf:__prod_ret__941};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mSUPPLIER11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_CUSTOMER_do_corrective_s37_m_REVENUE_mCUSTOMER12_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:string, rh:string, ri:int, rj:string, rk:real,
  rl:string, rm:string, rn:collection { ra:int, rb:int, rc:int, rd:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:CUSTOMER_CUSTKEY,
  rg:CUSTOMER_NAME, rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY,
  rj:CUSTOMER_PHONE, rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT,
  rm:CUSTOMER_COMMENT, rn:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:delta_REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER12_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s37_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
         CUSTOMER_NATIONKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:CUSTOMER_NATIONKEY,
      rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__206} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__206};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__206} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__206 *
       if CUSTOMER_CUSTKEY == delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY 
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__943} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__943 *
       -delta_REVENUE_mCUSTOMER12_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__944} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY,
       rf:__prod_ret__944};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mSUPPLIER12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare sw_insert_ORDERS : { ra:int, rb:int, rc:string, rd:real, re:int,
  rf:string, rg:string, rh:int, ri:string } -> () = (\args ->
  (sw_buf_insert_ORDERS.insert args;
   sw_trig_buf_idx.insert {i:4};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_insert_ORDERS_send_fetch : { key:int, value:int } -> () = (\vid ->
  case (sw_buf_insert_ORDERS.peek ()) of
  {Some args ->
    (sw_buf_insert_ORDERS.erase args;
     bind args as
     {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
     in
     ((route_to_int_int {ra:7, rb:Some ORDERS_CUSTKEY, rc:Some ORDERS_ORDERKEY}).iterate
      ((\b1 -> bind b1 as {i:ip} in 
      (nd_insert_ORDERS_do_complete_s40_trig, ip)<- {ra:vid,
      rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
      re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
      rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}));
      ((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_string_string_int_int_int {ra:14, rb:None immut, rc:None immut,
         rd:None immut, re:Some ORDERS_CUSTKEY, rf:Some ORDERS_ORDERKEY}).fold
        ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_REVENUE_mORDERS11_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
          rb:None immut, rc:None immut, rd:empty { ra:{ key:int, value:int },
          rb:string, rc:string, rd:int, re:int, rf:int, rg:real
          } @ { Collection }, re:true}).fold ((\_accmap -> (\b3 ->
        bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:38, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_string_string_int_int_int {ra:17, rb:None immut,
           rc:None immut, rd:None immut, re:Some ORDERS_CUSTKEY,
           rf:Some ORDERS_ORDERKEY}).fold ((\count -> (\b3 ->
          bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_REVENUE_mORDERS12_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
            rb:None immut, rc:None immut, rd:empty { ra:{ key:int, value:int },
            rb:string, rc:string, rd:int, re:int, rf:int, rg:real
            } @ { Collection }, re:true}).fold ((\_accmap -> (\b3 ->
          bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:38, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }).combine (let
          sender_count =
          (route_to_string_string_int_int_int {ra:4, rb:None immut,
             rc:None immut, rd:None immut, re:None immut,
             rf:Some ORDERS_ORDERKEY}).fold ((\count -> (\b3 ->
            bind b3 as {i:ip} in count + 1))) 0 in
          ((shuffle_REVENUE_mCUSTOMER11_mORDERS1_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_2t2_3t3
              {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
              re:Some ORDERS_CUSTKEY, rf:empty { ra:{ key:int, value:int },
              rb:string, rc:string, rd:int, re:int, rf:int, rg:real
              } @ { Collection }, rg:true}).fold ((\_accmap -> (\b3 ->
            bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {ra:ip, rb:39, rc:sender_count};_accmap)))) empty {
            ra:address, rb:int, rc:int } @ { Collection }).combine (let
            sender_count =
            (route_to_int_int_int {ra:5, rb:None immut,
               rc:Some ORDERS_ORDERKEY, rd:None immut}).fold ((\count ->
              (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
            ((shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER11_mSUPPLIER1_bind_0t0_2t2
                {ra:None immut, rb:Some ORDERS_CUSTKEY, rc:None immut,
                rd:empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int,
                re:real } @ { Collection }, re:true}).fold ((\_accmap ->
              (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:41, rc:sender_count};_accmap))))
              empty { ra:address, rb:int, rc:int } @ { Collection }).combine
              (let sender_count =
              (route_to_string_string_int_int_int {ra:11, rb:None immut,
                 rc:None immut, rd:None immut, re:None immut,
                 rf:Some ORDERS_ORDERKEY}).fold ((\count -> (\b3 ->
                bind b3 as {i:ip} in count + 1))) 0 in
              ((shuffle_REVENUE_mCUSTOMER12_mORDERS1_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_2t2_3t3
                  {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                  re:Some ORDERS_CUSTKEY, rf:empty { ra:{ key:int, value:int },
                  rb:string, rc:string, rd:int, re:int, rf:int, rg:real
                  } @ { Collection }, rg:true}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:42, rc:sender_count};_accmap))))
                empty { ra:address, rb:int, rc:int } @ { Collection }).combine
                (let sender_count =
                (route_to_int_int_int {ra:12, rb:None immut,
                   rc:Some ORDERS_ORDERKEY, rd:None immut}).fold ((\count ->
                  (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                ((shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER12_mSUPPLIER1_bind_0t0_2t2
                    {ra:None immut, rb:Some ORDERS_CUSTKEY, rc:None immut,
                    rd:empty { ra:{ key:int, value:int }, rb:int, rc:int,
                    rd:int, re:real } @ { Collection }, re:true}).fold
                  ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:43, rc:sender_count};_accmap))))
                  empty { ra:address, rb:int, rc:int
                  } @ { Collection }).combine (let sender_count =
                  (route_to_string_string_int_int {ra:15, rb:None immut,
                     rc:None immut, rd:Some ORDERS_CUSTKEY, re:None immut}).fold
                    ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                  ((shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mLINEITEM4_bind_0t0_1t1_3t3
                      {ra:None immut, rb:None immut, rc:Some ORDERS_ORDERKEY,
                      rd:None immut, re:empty { ra:{ key:int, value:int },
                      rb:string, rc:string, rd:int, re:int, rf:int
                      } @ { Collection }, rf:true}).fold ((\_accmap -> (\b3 ->
                    bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:44, rc:sender_count};_accmap))))
                    empty { ra:address, rb:int, rc:int
                    } @ { Collection }).combine (let sender_count =
                    (route_to_string_string_int_int {ra:16, rb:None immut,
                       rc:None immut, rd:Some ORDERS_CUSTKEY, re:None immut}).fold
                      ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0
                    in
                    ((shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_0t0_1t1_3t3
                        {ra:None immut, rb:None immut, rc:Some ORDERS_ORDERKEY,
                        rd:None immut, re:empty { ra:{ key:int, value:int },
                        rb:string, rc:string, rd:int, re:int, rf:int
                        } @ { Collection }, rf:true}).fold ((\_accmap ->
                      (\b3 -> bind b3 as {key:ip, value:tuples} in 
                      (_accmap.insert {ra:ip, rb:45, rc:sender_count};_accmap))))
                      empty { ra:address, rb:int, rc:int
                      } @ { Collection }).combine (let sender_count =
                      (route_to_int_int_int {ra:5, rb:None immut,
                         rc:Some ORDERS_ORDERKEY, rd:None immut}).fold
                        ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0
                      in
                      ((shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_2t0_4t2
                          {ra:None immut, rb:None immut, rc:None immut,
                          rd:None immut, re:None immut, rf:empty { ra:{
                          key:int, value:int }, rb:int, rc:int, rd:int, re:real
                          } @ { Collection }, rg:true}).fold ((\_accmap ->
                        (\b3 -> bind b3 as {key:ip, value:tuples} in 
                        (_accmap.insert {ra:ip, rb:46, rc:sender_count};_accmap))))
                        empty { ra:address, rb:int, rc:int
                        } @ { Collection }).combine (let sender_count =
                        (route_to_string_string_int_int {ra:16, rb:None immut,
                           rc:None immut, rd:Some ORDERS_CUSTKEY,
                           re:None immut}).fold ((\count -> (\b3 ->
                          bind b3 as {i:ip} in count + 1))) 0 in
                        ((shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3
                            {ra:None immut, rb:None immut, rc:None immut,
                            rd:None immut, re:None immut, rf:empty { ra:{
                            key:int, value:int }, rb:string, rc:string, rd:int,
                            re:int, rf:int } @ { Collection }, rg:true}).fold
                          ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                          value:tuples} in 
                          (_accmap.insert {ra:ip, rb:46, rc:sender_count};
                           _accmap)))) empty { ra:address, rb:int, rc:int
                          } @ { Collection }).combine (let sender_count =
                          (route_to_int_int_int {ra:12, rb:None immut,
                             rc:Some ORDERS_ORDERKEY, rd:None immut}).fold
                            ((\count -> (\b3 -> bind b3 as {i:ip} in count +
                            1))) 0 in
                          ((shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_2t0_4t2
                              {ra:None immut, rb:None immut, rc:None immut,
                              rd:None immut, re:None immut, rf:empty { ra:{
                              key:int, value:int }, rb:int, rc:int, rd:int,
                              re:real } @ { Collection }, rg:true}).fold
                            ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                            value:tuples} in 
                            (_accmap.insert {ra:ip, rb:47, rc:sender_count};
                             _accmap)))) empty { ra:address, rb:int, rc:int
                            } @ { Collection }).combine (let sender_count =
                            (route_to_string_string_int_int {ra:16,
                               rb:None immut, rc:None immut,
                               rd:Some ORDERS_CUSTKEY, re:None immut}).fold
                              ((\count -> (\b3 -> bind b3 as {i:ip} in count +
                              1))) 0 in
                            (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3
                               {ra:None immut, rb:None immut, rc:None immut,
                               rd:None immut, re:None immut, rf:empty { ra:{
                               key:int, value:int }, rb:string, rc:string,
                               rd:int, re:int, rf:int } @ { Collection },
                               rg:true}).fold ((\_accmap -> (\b3 ->
                              bind b3 as {key:ip, value:tuples} in 
                              (_accmap.insert {ra:ip, rb:47, rc:sender_count};
                               _accmap)))) empty { ra:address, rb:int, rc:int
                              } @ { Collection }))))))))))))).groupBy ((\b1 ->
      bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip, value:stmt_id}))
      ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id, rc:count} in acc +
      count))) 0).groupBy ((\b1 -> bind b1 as {key:b2, value:count} in 
      bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc -> (\b3 ->
      bind b3 as {key:ip_and_stmt_id, value:count} in bind ip_and_stmt_id as
      {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_insert_ORDERS_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid,
       rd:ORDERS_ORDERKEY, re:ORDERS_CUSTKEY, rf:ORDERS_ORDERSTATUS,
       rg:ORDERS_TOTALPRICE, rh:ORDERS_ORDERDATE, ri:ORDERS_ORDERPRIORITY,
       rj:ORDERS_CLERK, rk:ORDERS_SHIPPRIORITY, rl:ORDERS_COMMENT};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_string_string_int_int {ra:16, rb:None immut, rc:None immut,
            rd:Some ORDERS_CUSTKEY, re:None immut}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:47, rb:16, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:12, rb:None immut, rc:Some ORDERS_ORDERKEY,
           rd:None immut}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:47, rb:12, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:16, rb:None immut, rc:None immut,
           rd:Some ORDERS_CUSTKEY, re:None immut}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:46, rb:16, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:5, rb:None immut, rc:Some ORDERS_ORDERKEY,
           rd:None immut}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:46, rb:5, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:16, rb:None immut, rc:None immut,
           rd:Some ORDERS_CUSTKEY, re:None immut}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:45, rb:16, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:15, rb:None immut, rc:None immut,
           rd:Some ORDERS_CUSTKEY, re:None immut}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:44, rb:15, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:12, rb:None immut, rc:Some ORDERS_ORDERKEY,
           rd:None immut}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:43, rb:12, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:11, rb:None immut,
           rc:None immut, rd:None immut, re:None immut,
           rf:Some ORDERS_ORDERKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:42, rb:11, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:5, rb:None immut, rc:Some ORDERS_ORDERKEY,
           rd:None immut}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:41, rb:5, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:4, rb:None immut,
           rc:None immut, rd:None immut, re:None immut,
           rf:Some ORDERS_ORDERKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:39, rb:4, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:17, rb:None immut,
           rc:None immut, rd:None immut, re:Some ORDERS_CUSTKEY,
           rf:Some ORDERS_ORDERKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:38, rb:17, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:14, rb:None immut,
           rc:None immut, rd:None immut, re:Some ORDERS_CUSTKEY,
           rf:Some ORDERS_ORDERKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:38, rb:14, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine empty {
      ra:int, rb:int, rc:address } @ { Collection })))))))))))).groupBy
      ((\b1 -> bind b1 as {ra:stmt_id, rb:map_id, rc:ip} in ip)) ((\acc ->
      (\b3 -> bind b3 as {ra:stmt_id, rb:map_id, rc:ip} in 
      (acc.insert {key:stmt_id, value:map_id};acc)))) empty { key:int,
      value:int } @ { Collection }).iterate ((\b1 -> bind b1 as {key:ip,
      value:stmt_map_ids} in 
      (nd_insert_ORDERS_rcv_fetch, ip)<- {ra:stmt_map_ids, rb:vid,
      rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
      rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
      ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))}
  {None ->
    error (print "unexpected missing arguments in sw_buf_insert_ORDERS")})


declare nd_insert_ORDERS_do_complete_s38 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  ((((((bind map_REVENUE_mORDERS11_s38_buf as ind __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in re == ORDERS_CUSTKEY and rf == ORDERS_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
      re:map_3, rf:map_4, rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERKEY,
    rf:__map_ret__63} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__63};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:__map_ret__63} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__63 * -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).combine ((bind map_REVENUE_mORDERS12_s38_buf as ind __x
    in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in re == ORDERS_CUSTKEY and rf == ORDERS_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
      re:map_3, rf:map_4, rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERKEY,
    rf:__map_ret__64} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__64};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection })).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:__sum_ret__5} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__sum_ret__5};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_2, rd:map_val} in {ra:map_0, rb:map_1, rc:map_2})) ((\acc -> (\b3 ->
    bind b3 as {ra:map_0, rb:map_1, rc:map_2, rd:map_val} in acc + map_val)))
    0).fold ((\acc -> (\b3 -> bind b3 as {key:g, value:val} in 
    (acc.insert {ra:g.ra, rb:g.rb, rc:g.rc, rd:val};acc)))) empty { ra:string,
    rb:string, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:false, rc:vid,
      rd:delta_values});
   (nd_complete_stmt_cntr_check {key:vid, value:38})))


declare nd_insert_ORDERS_do_complete_s39 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  ((bind map_REVENUE_mCUSTOMER11_mORDERS1_s39_buf as ind __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in rf == ORDERS_ORDERKEY))}).fold ((\acc -> (\b3 ->
      bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
      rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:ORDERS_ORDERKEY, rf:__map_ret__65} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__map_ret__65};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__map_ret__65} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:ORDERS_CUSTKEY, rf:__map_ret__65};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_send_correctives {ra:me, rb:39, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:39}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:39, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_ORDERS_do_complete_s41 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  ((bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s41_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
       ORDERS_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
      rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:ORDERS_ORDERKEY,
    rc:REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__66} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR,
     rb:REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__66};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__66} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:ORDERS_CUSTKEY,
     rc:REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__66};
     _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_int_int_int_float {ra:REVENUE_mCUSTOMER11_mSUPPLIER1,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_mSUPPLIER1_send_correctives {ra:me, rb:41, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:41}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:41, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_ORDERS_do_complete_s42 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  ((bind map_REVENUE_mCUSTOMER12_mORDERS1_s42_buf as ind __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in rf == ORDERS_ORDERKEY))}).fold ((\acc -> (\b3 ->
      bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
      rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:ORDERS_ORDERKEY, rf:__map_ret__67} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__map_ret__67};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__map_ret__67} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:ORDERS_CUSTKEY, rf:__map_ret__67};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER12_send_correctives {ra:me, rb:42, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:42}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:42, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_ORDERS_do_complete_s43 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  ((bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s43_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
       ORDERS_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
      rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:ORDERS_ORDERKEY,
    rc:REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__68} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR,
     rb:REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__68};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__68} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:ORDERS_CUSTKEY,
     rc:REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__68};
     _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_int_int_int_float {ra:REVENUE_mCUSTOMER12_mSUPPLIER1,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER12_mSUPPLIER1_send_correctives {ra:me, rb:43, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:43}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:43, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_ORDERS_do_complete_s44 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  ((bind map_REVENUE_mORDERS11_mLINEITEM4_s44_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
      rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:ORDERS_CUSTKEY,
    rd:REVENUE_mLINEITEMLINEITEM_SUPPKEY, re:__map_ret__69} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__69};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__69} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:ORDERS_ORDERKEY, rd:REVENUE_mLINEITEMLINEITEM_SUPPKEY,
     re:__map_ret__69};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mLINEITEM4, rb:false,
      rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mLINEITEM4_send_correctives {ra:me, rb:44, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:44}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:44, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_ORDERS_do_complete_s45 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  ((bind map_REVENUE_mORDERS11_mSUPPLIER2_s45_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
      rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:ORDERS_CUSTKEY,
    rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__70} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__70};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__70} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:ORDERS_ORDERKEY, rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
     re:__map_ret__70};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int
      {ra:REVENUE_mLINEITEM4_mSUPPLIER1, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mLINEITEM4_mSUPPLIER1_send_correctives {ra:me, rb:45, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:45}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:45, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_ORDERS_do_complete_s46 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s46_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
       ORDERS_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
      rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:ORDERS_ORDERKEY,
    rc:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__71} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:__map_ret__71};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__71} in _accext.combine
    (((bind map_REVENUE_mORDERS11_mSUPPLIER2_s46_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
      rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:ORDERS_CUSTKEY,
    rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__72} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__72};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__72} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__map_ret__71 * __map_ret__72};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__prod_ret__43} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rf:__prod_ret__43};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mSUPPLIER11_send_correctives {ra:me, rb:46, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:46}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:46, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_ORDERS_do_complete_s47 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s47_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
       ORDERS_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
      rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:ORDERS_ORDERKEY,
    rc:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__73} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:__map_ret__73};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__73} in _accext.combine
    (((bind map_REVENUE_mORDERS11_mSUPPLIER2_s47_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
      rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:ORDERS_CUSTKEY,
    rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__74} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__74};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__74} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__map_ret__73 * __map_ret__74};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__prod_ret__44} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rf:__prod_ret__44};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mSUPPLIER12_send_correctives {ra:me, rb:47, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:47}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:47, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_ORDERS_do_complete_s40 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let __val_ret__23 = 1 in
  ((nd_add_delta_to_int_int_int {ra:REVENUE_mCUSTOMER11_mLINEITEM5, rb:false,
      rc:vid, rd:{| ra:int, rb:int, rc:int | {ra:ORDERS_CUSTKEY,
      rb:ORDERS_ORDERKEY, rc:__val_ret__23}|} @ { Collection }});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_mLINEITEM5_send_correctives {ra:me, rb:40, rc:vid,
     rd:1, re:vid, rf:{| ra:int, rb:int, rc:int | {ra:ORDERS_CUSTKEY,
     rb:ORDERS_ORDERKEY, rc:__val_ret__23}|} @ { Collection }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:40, rc:1, rd:sent_msgs,
         re:true, rf:true}))


declare insert_ORDERS_do_corrective_s38_m_REVENUE_mORDERS11 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:int, rh:string, ri:real, rj:int, rk:string, rl:string, rm:int, rn:string,
  ro:collection { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    re:delta_REVENUE_mORDERSORDERS_ORDERKEY, rf:delta_REVENUE_mORDERS11} in 
    _accext.combine (let __prod_ret__723 =
    ((if ORDERS_ORDERKEY == delta_REVENUE_mORDERSORDERS_ORDERKEY then 1 
      else 0) * if ORDERS_CUSTKEY == delta_REVENUE_mORDERSORDERS_CUSTKEY 
      then 1 else 0) * -delta_REVENUE_mORDERS11 in
    {| ra:string, rb:string, rc:int, rd:real | {ra:delta_SHIPPING_SUPP_NATION,
      rb:delta_SHIPPING_CUST_NATION, rc:delta_SHIPPING_L_YEAR,
      rd:__prod_ret__723}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare insert_ORDERS_do_corrective_s38_m_REVENUE_mORDERS12 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:int, rh:string, ri:real, rj:int, rk:string, rl:string, rm:int, rn:string,
  ro:collection { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    re:delta_REVENUE_mORDERSORDERS_ORDERKEY, rf:delta_REVENUE_mORDERS12} in 
    _accext.combine (let __prod_ret__725 =
    ((if ORDERS_ORDERKEY == delta_REVENUE_mORDERSORDERS_ORDERKEY then 1 
      else 0) * if ORDERS_CUSTKEY == delta_REVENUE_mORDERSORDERS_CUSTKEY 
      then 1 else 0) * delta_REVENUE_mORDERS12 in
    {| ra:string, rb:string, rc:int, rd:real | {ra:delta_SHIPPING_SUPP_NATION,
      rb:delta_SHIPPING_CUST_NATION, rc:delta_SHIPPING_L_YEAR,
      rd:__prod_ret__725}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare insert_ORDERS_do_corrective_s39_m_REVENUE_mCUSTOMER11_mORDERS1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:string, rb:string, rc:int,
  rd:int, re:int, rf:real } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY,
    rf:delta_REVENUE_mCUSTOMER11_mORDERS1} in _accext.combine (let
    __prod_ret__726 =
    (if ORDERS_ORDERKEY == delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY
      then 1 else 0) * delta_REVENUE_mCUSTOMER11_mORDERS1 in
    {| ra:string, rb:string, rc:int, rd:int, re:int, rf:real |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      re:ORDERS_CUSTKEY, rf:__prod_ret__726}|} @ { Collection })))) empty {
    ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_2, rd:map_3, re:map_4, rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_ORDERS_do_corrective_s41_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 :
  { ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:int, rb:int, rc:int, rd:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1} in _accext.combine (let
    __prod_ret__727 =
    (if ORDERS_ORDERKEY == delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY
      then 1 else 0) * delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 in
    {| ra:int, rb:int, rc:int, rd:real | {ra:delta_SHIPPING_L_YEAR,
      rb:ORDERS_CUSTKEY,
      rc:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
      rd:__prod_ret__727}|} @ { Collection })))) empty { ra:int, rb:int,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_int_float {ra:REVENUE_mCUSTOMER11_mSUPPLIER1,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER11_mSUPPLIER1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_ORDERS_do_corrective_s42_m_REVENUE_mCUSTOMER12_mORDERS1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:string, rb:string, rc:int,
  rd:int, re:int, rf:real } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
    rf:delta_REVENUE_mCUSTOMER12_mORDERS1} in _accext.combine (let
    __prod_ret__733 =
    (if ORDERS_ORDERKEY == delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY
      then 1 else 0) * delta_REVENUE_mCUSTOMER12_mORDERS1 in
    {| ra:string, rb:string, rc:int, rd:int, re:int, rf:real |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      re:ORDERS_CUSTKEY, rf:__prod_ret__733}|} @ { Collection })))) empty {
    ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_2, rd:map_3, re:map_4, rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_ORDERS_do_corrective_s43_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 :
  { ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:int, rb:int, rc:int, rd:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1} in _accext.combine (let
    __prod_ret__734 =
    (if ORDERS_ORDERKEY == delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY
      then 1 else 0) * delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 in
    {| ra:int, rb:int, rc:int, rd:real | {ra:delta_SHIPPING_L_YEAR,
      rb:ORDERS_CUSTKEY,
      rc:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
      rd:__prod_ret__734}|} @ { Collection })))) empty { ra:int, rb:int,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_int_float {ra:REVENUE_mCUSTOMER12_mSUPPLIER1,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER12_mSUPPLIER1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_ORDERS_do_corrective_s44_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:string, rb:string, rc:int,
  rd:int, re:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mORDERS11_mLINEITEM4} in _accext.combine (let
    __prod_ret__740 =
    (if ORDERS_CUSTKEY == delta_REVENUE_mORDERSORDERS_CUSTKEY then 1 
      else 0) * delta_REVENUE_mORDERS11_mLINEITEM4 in
    {| ra:string, rb:string, rc:int, rd:int, re:int |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:ORDERS_ORDERKEY, rd:delta_REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY,
      re:__prod_ret__740}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 0 !=
    map_val)) in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mLINEITEM4, rb:true,
      rc:vid, rd:new_tuples});
   (nd_REVENUE_mLINEITEM4_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_ORDERS_do_corrective_s45_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:string, rb:string, rc:int,
  rd:int, re:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mORDERS11_mSUPPLIER2} in _accext.combine (let
    __prod_ret__741 =
    (if ORDERS_CUSTKEY == delta_REVENUE_mORDERSORDERS_CUSTKEY then 1 
      else 0) * delta_REVENUE_mORDERS11_mSUPPLIER2 in
    {| ra:string, rb:string, rc:int, rd:int, re:int |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:ORDERS_ORDERKEY,
      rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
      re:__prod_ret__741}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 0 !=
    map_val)) in
  ((nd_add_delta_to_string_string_int_int_int
      {ra:REVENUE_mLINEITEM4_mSUPPLIER1, rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mLINEITEM4_mSUPPLIER1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_ORDERS_do_corrective_s46_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 :
  { ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:int, rb:int, rc:int, rd:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mORDERS11_mSUPPLIER2_s46_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
         ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:ORDERS_CUSTKEY,
      rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__147} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__147};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__147} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__147 *
       if ORDERS_ORDERKEY == delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__728} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__728 *
       delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__729} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
       rf:__prod_ret__729};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mSUPPLIER11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_ORDERS_do_corrective_s46_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:string, rb:string, rc:int,
  rd:int, re:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mORDERS11_mSUPPLIER2} in _accext.combine (let delta_values
    =
    ((((bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s46_buf as ind __x in
      (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
         ORDERS_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
        ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:ORDERS_ORDERKEY,
      rc:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__151} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__151};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__151} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__151 *
       if ORDERS_CUSTKEY == delta_REVENUE_mORDERSORDERS_CUSTKEY then 1 
       else 0};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__prod_ret__742} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__prod_ret__742 *
       delta_REVENUE_mORDERS11_mSUPPLIER2};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__prod_ret__743} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
       re:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rf:__prod_ret__743};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mSUPPLIER11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_ORDERS_do_corrective_s47_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 :
  { ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:int, rb:int, rc:int, rd:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mORDERS11_mSUPPLIER2_s47_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
         ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:ORDERS_CUSTKEY,
      rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__149} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__149};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__149} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__149 *
       if ORDERS_ORDERKEY == delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__735} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__735 *
       delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__736} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
       rf:__prod_ret__736};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mSUPPLIER12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_ORDERS_do_corrective_s47_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:string, rb:string, rc:int,
  rd:int, re:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mORDERS11_mSUPPLIER2} in _accext.combine (let delta_values
    =
    ((((bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s47_buf as ind __x in
      (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
         ORDERS_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
        ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:ORDERS_ORDERKEY,
      rc:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__152} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__152};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__152} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__152 *
       if ORDERS_CUSTKEY == delta_REVENUE_mORDERSORDERS_CUSTKEY then 1 
       else 0};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__prod_ret__744} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__prod_ret__744 *
       delta_REVENUE_mORDERS11_mSUPPLIER2};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__prod_ret__745} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
       re:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rf:__prod_ret__745};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mSUPPLIER12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare sw_delete_ORDERS : { ra:int, rb:int, rc:string, rd:real, re:int,
  rf:string, rg:string, rh:int, ri:string } -> () = (\args ->
  (sw_buf_delete_ORDERS.insert args;
   sw_trig_buf_idx.insert {i:5};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_delete_ORDERS_send_fetch : { key:int, value:int } -> () = (\vid ->
  case (sw_buf_delete_ORDERS.peek ()) of
  {Some args ->
    (sw_buf_delete_ORDERS.erase args;
     bind args as
     {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
     in
     ((route_to_int_int {ra:7, rb:Some ORDERS_CUSTKEY, rc:Some ORDERS_ORDERKEY}).iterate
      ((\b1 -> bind b1 as {i:ip} in 
      (nd_delete_ORDERS_do_complete_s50_trig, ip)<- {ra:vid,
      rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
      re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
      rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}));
      ((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_string_string_int_int_int {ra:14, rb:None immut, rc:None immut,
         rd:None immut, re:Some ORDERS_CUSTKEY, rf:Some ORDERS_ORDERKEY}).fold
        ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_REVENUE_mORDERS11_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
          rb:None immut, rc:None immut, rd:empty { ra:{ key:int, value:int },
          rb:string, rc:string, rd:int, re:int, rf:int, rg:real
          } @ { Collection }, re:true}).fold ((\_accmap -> (\b3 ->
        bind b3 as {key:ip, value:tuples} in 
        (_accmap.insert {ra:ip, rb:48, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_string_string_int_int_int {ra:17, rb:None immut,
           rc:None immut, rd:None immut, re:Some ORDERS_CUSTKEY,
           rf:Some ORDERS_ORDERKEY}).fold ((\count -> (\b3 ->
          bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_REVENUE_mORDERS12_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
            rb:None immut, rc:None immut, rd:empty { ra:{ key:int, value:int },
            rb:string, rc:string, rd:int, re:int, rf:int, rg:real
            } @ { Collection }, re:true}).fold ((\_accmap -> (\b3 ->
          bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:48, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }).combine (let
          sender_count =
          (route_to_string_string_int_int_int {ra:4, rb:None immut,
             rc:None immut, rd:None immut, re:None immut,
             rf:Some ORDERS_ORDERKEY}).fold ((\count -> (\b3 ->
            bind b3 as {i:ip} in count + 1))) 0 in
          ((shuffle_REVENUE_mCUSTOMER11_mORDERS1_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_2t2_3t3
              {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
              re:Some ORDERS_CUSTKEY, rf:empty { ra:{ key:int, value:int },
              rb:string, rc:string, rd:int, re:int, rf:int, rg:real
              } @ { Collection }, rg:true}).fold ((\_accmap -> (\b3 ->
            bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {ra:ip, rb:49, rc:sender_count};_accmap)))) empty {
            ra:address, rb:int, rc:int } @ { Collection }).combine (let
            sender_count =
            (route_to_int_int_int {ra:5, rb:None immut,
               rc:Some ORDERS_ORDERKEY, rd:None immut}).fold ((\count ->
              (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
            ((shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER11_mSUPPLIER1_bind_0t0_2t2
                {ra:None immut, rb:Some ORDERS_CUSTKEY, rc:None immut,
                rd:empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int,
                re:real } @ { Collection }, re:true}).fold ((\_accmap ->
              (\b3 -> bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:51, rc:sender_count};_accmap))))
              empty { ra:address, rb:int, rc:int } @ { Collection }).combine
              (let sender_count =
              (route_to_string_string_int_int_int {ra:11, rb:None immut,
                 rc:None immut, rd:None immut, re:None immut,
                 rf:Some ORDERS_ORDERKEY}).fold ((\count -> (\b3 ->
                bind b3 as {i:ip} in count + 1))) 0 in
              ((shuffle_REVENUE_mCUSTOMER12_mORDERS1_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_2t2_3t3
                  {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                  re:Some ORDERS_CUSTKEY, rf:empty { ra:{ key:int, value:int },
                  rb:string, rc:string, rd:int, re:int, rf:int, rg:real
                  } @ { Collection }, rg:true}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:52, rc:sender_count};_accmap))))
                empty { ra:address, rb:int, rc:int } @ { Collection }).combine
                (let sender_count =
                (route_to_int_int_int {ra:12, rb:None immut,
                   rc:Some ORDERS_ORDERKEY, rd:None immut}).fold ((\count ->
                  (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                ((shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER12_mSUPPLIER1_bind_0t0_2t2
                    {ra:None immut, rb:Some ORDERS_CUSTKEY, rc:None immut,
                    rd:empty { ra:{ key:int, value:int }, rb:int, rc:int,
                    rd:int, re:real } @ { Collection }, re:true}).fold
                  ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:53, rc:sender_count};_accmap))))
                  empty { ra:address, rb:int, rc:int
                  } @ { Collection }).combine (let sender_count =
                  (route_to_string_string_int_int {ra:15, rb:None immut,
                     rc:None immut, rd:Some ORDERS_CUSTKEY, re:None immut}).fold
                    ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                  ((shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mLINEITEM4_bind_0t0_1t1_3t3
                      {ra:None immut, rb:None immut, rc:Some ORDERS_ORDERKEY,
                      rd:None immut, re:empty { ra:{ key:int, value:int },
                      rb:string, rc:string, rd:int, re:int, rf:int
                      } @ { Collection }, rf:true}).fold ((\_accmap -> (\b3 ->
                    bind b3 as {key:ip, value:tuples} in 
                    (_accmap.insert {ra:ip, rb:54, rc:sender_count};_accmap))))
                    empty { ra:address, rb:int, rc:int
                    } @ { Collection }).combine (let sender_count =
                    (route_to_string_string_int_int {ra:16, rb:None immut,
                       rc:None immut, rd:Some ORDERS_CUSTKEY, re:None immut}).fold
                      ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0
                    in
                    ((shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_0t0_1t1_3t3
                        {ra:None immut, rb:None immut, rc:Some ORDERS_ORDERKEY,
                        rd:None immut, re:empty { ra:{ key:int, value:int },
                        rb:string, rc:string, rd:int, re:int, rf:int
                        } @ { Collection }, rf:true}).fold ((\_accmap ->
                      (\b3 -> bind b3 as {key:ip, value:tuples} in 
                      (_accmap.insert {ra:ip, rb:55, rc:sender_count};_accmap))))
                      empty { ra:address, rb:int, rc:int
                      } @ { Collection }).combine (let sender_count =
                      (route_to_int_int_int {ra:5, rb:None immut,
                         rc:Some ORDERS_ORDERKEY, rd:None immut}).fold
                        ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0
                      in
                      ((shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_2t0_4t2
                          {ra:None immut, rb:None immut, rc:None immut,
                          rd:None immut, re:None immut, rf:empty { ra:{
                          key:int, value:int }, rb:int, rc:int, rd:int, re:real
                          } @ { Collection }, rg:true}).fold ((\_accmap ->
                        (\b3 -> bind b3 as {key:ip, value:tuples} in 
                        (_accmap.insert {ra:ip, rb:56, rc:sender_count};_accmap))))
                        empty { ra:address, rb:int, rc:int
                        } @ { Collection }).combine (let sender_count =
                        (route_to_string_string_int_int {ra:16, rb:None immut,
                           rc:None immut, rd:Some ORDERS_CUSTKEY,
                           re:None immut}).fold ((\count -> (\b3 ->
                          bind b3 as {i:ip} in count + 1))) 0 in
                        ((shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3
                            {ra:None immut, rb:None immut, rc:None immut,
                            rd:None immut, re:None immut, rf:empty { ra:{
                            key:int, value:int }, rb:string, rc:string, rd:int,
                            re:int, rf:int } @ { Collection }, rg:true}).fold
                          ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                          value:tuples} in 
                          (_accmap.insert {ra:ip, rb:56, rc:sender_count};
                           _accmap)))) empty { ra:address, rb:int, rc:int
                          } @ { Collection }).combine (let sender_count =
                          (route_to_int_int_int {ra:12, rb:None immut,
                             rc:Some ORDERS_ORDERKEY, rd:None immut}).fold
                            ((\count -> (\b3 -> bind b3 as {i:ip} in count +
                            1))) 0 in
                          ((shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_2t0_4t2
                              {ra:None immut, rb:None immut, rc:None immut,
                              rd:None immut, re:None immut, rf:empty { ra:{
                              key:int, value:int }, rb:int, rc:int, rd:int,
                              re:real } @ { Collection }, rg:true}).fold
                            ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                            value:tuples} in 
                            (_accmap.insert {ra:ip, rb:57, rc:sender_count};
                             _accmap)))) empty { ra:address, rb:int, rc:int
                            } @ { Collection }).combine (let sender_count =
                            (route_to_string_string_int_int {ra:16,
                               rb:None immut, rc:None immut,
                               rd:Some ORDERS_CUSTKEY, re:None immut}).fold
                              ((\count -> (\b3 -> bind b3 as {i:ip} in count +
                              1))) 0 in
                            (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3
                               {ra:None immut, rb:None immut, rc:None immut,
                               rd:None immut, re:None immut, rf:empty { ra:{
                               key:int, value:int }, rb:string, rc:string,
                               rd:int, re:int, rf:int } @ { Collection },
                               rg:true}).fold ((\_accmap -> (\b3 ->
                              bind b3 as {key:ip, value:tuples} in 
                              (_accmap.insert {ra:ip, rb:57, rc:sender_count};
                               _accmap)))) empty { ra:address, rb:int, rc:int
                              } @ { Collection }))))))))))))).groupBy ((\b1 ->
      bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip, value:stmt_id}))
      ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id, rc:count} in acc +
      count))) 0).groupBy ((\b1 -> bind b1 as {key:b2, value:count} in 
      bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc -> (\b3 ->
      bind b3 as {key:ip_and_stmt_id, value:count} in bind ip_and_stmt_id as
      {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_delete_ORDERS_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid,
       rd:ORDERS_ORDERKEY, re:ORDERS_CUSTKEY, rf:ORDERS_ORDERSTATUS,
       rg:ORDERS_TOTALPRICE, rh:ORDERS_ORDERDATE, ri:ORDERS_ORDERPRIORITY,
       rj:ORDERS_CLERK, rk:ORDERS_SHIPPRIORITY, rl:ORDERS_COMMENT};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_string_string_int_int {ra:16, rb:None immut, rc:None immut,
            rd:Some ORDERS_CUSTKEY, re:None immut}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:57, rb:16, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:12, rb:None immut, rc:Some ORDERS_ORDERKEY,
           rd:None immut}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:57, rb:12, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:16, rb:None immut, rc:None immut,
           rd:Some ORDERS_CUSTKEY, re:None immut}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:56, rb:16, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:5, rb:None immut, rc:Some ORDERS_ORDERKEY,
           rd:None immut}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:56, rb:5, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:16, rb:None immut, rc:None immut,
           rd:Some ORDERS_CUSTKEY, re:None immut}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:55, rb:16, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:15, rb:None immut, rc:None immut,
           rd:Some ORDERS_CUSTKEY, re:None immut}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:54, rb:15, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:12, rb:None immut, rc:Some ORDERS_ORDERKEY,
           rd:None immut}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:53, rb:12, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:11, rb:None immut,
           rc:None immut, rd:None immut, re:None immut,
           rf:Some ORDERS_ORDERKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:52, rb:11, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int_int {ra:5, rb:None immut, rc:Some ORDERS_ORDERKEY,
           rd:None immut}).fold ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:51, rb:5, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:4, rb:None immut,
           rc:None immut, rd:None immut, re:None immut,
           rf:Some ORDERS_ORDERKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:49, rb:4, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:17, rb:None immut,
           rc:None immut, rd:None immut, re:Some ORDERS_CUSTKEY,
           rf:Some ORDERS_ORDERKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:48, rb:17, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int_int {ra:14, rb:None immut,
           rc:None immut, rd:None immut, re:Some ORDERS_CUSTKEY,
           rf:Some ORDERS_ORDERKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:48, rb:14, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine empty {
      ra:int, rb:int, rc:address } @ { Collection })))))))))))).groupBy
      ((\b1 -> bind b1 as {ra:stmt_id, rb:map_id, rc:ip} in ip)) ((\acc ->
      (\b3 -> bind b3 as {ra:stmt_id, rb:map_id, rc:ip} in 
      (acc.insert {key:stmt_id, value:map_id};acc)))) empty { key:int,
      value:int } @ { Collection }).iterate ((\b1 -> bind b1 as {key:ip,
      value:stmt_map_ids} in 
      (nd_delete_ORDERS_rcv_fetch, ip)<- {ra:stmt_map_ids, rb:vid,
      rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
      rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
      ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))}
  {None ->
    error (print "unexpected missing arguments in sw_buf_delete_ORDERS")})


declare nd_delete_ORDERS_do_complete_s48 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  (((((bind map_REVENUE_mORDERS11_s48_buf as ind __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in re == ORDERS_CUSTKEY and rf == ORDERS_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
      re:map_3, rf:map_4, rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERKEY,
    rf:__map_ret__75} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__75};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).combine (((bind map_REVENUE_mORDERS12_s48_buf as ind
    __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in re == ORDERS_CUSTKEY and rf == ORDERS_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
      re:map_3, rf:map_4, rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERKEY,
    rf:__map_ret__76} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__76};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:__map_ret__76} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__map_ret__76 * -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection })).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:__sum_ret__6} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__sum_ret__6};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection }).groupBy ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_2, rd:map_val} in {ra:map_0, rb:map_1, rc:map_2})) ((\acc -> (\b3 ->
    bind b3 as {ra:map_0, rb:map_1, rc:map_2, rd:map_val} in acc + map_val)))
    0).fold ((\acc -> (\b3 -> bind b3 as {key:g, value:val} in 
    (acc.insert {ra:g.ra, rb:g.rb, rc:g.rc, rd:val};acc)))) empty { ra:string,
    rb:string, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:false, rc:vid,
      rd:delta_values});
   (nd_complete_stmt_cntr_check {key:vid, value:48})))


declare nd_delete_ORDERS_do_complete_s49 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER11_mORDERS1_s49_buf as ind __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in rf == ORDERS_ORDERKEY))}).fold ((\acc -> (\b3 ->
      bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
      rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:ORDERS_ORDERKEY, rf:__map_ret__77} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__map_ret__77};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__map_ret__77} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__map_ret__77 * -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__prod_ret__46} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:ORDERS_CUSTKEY, rf:__prod_ret__46};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_send_correctives {ra:me, rb:49, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:49}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:49, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_ORDERS_do_complete_s51 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s51_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
       ORDERS_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
      rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:ORDERS_ORDERKEY,
    rc:REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__78} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR,
     rb:REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__78};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__78} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR,
     rb:REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__78 * -1};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY, rc:__prod_ret__47} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:ORDERS_CUSTKEY,
     rc:REVENUE_mCUSTOMER11_mSUPPLIERSUPPLIER_SUPPKEY, rd:__prod_ret__47};
     _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_int_int_int_float {ra:REVENUE_mCUSTOMER11_mSUPPLIER1,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_mSUPPLIER1_send_correctives {ra:me, rb:51, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:51}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:51, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_ORDERS_do_complete_s52 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER12_mORDERS1_s52_buf as ind __x in
    (frontier_string_string_int_int_int_float {key:vid, value:__x.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf,
       rg:rg} in rf == ORDERS_ORDERKEY))}).fold ((\acc -> (\b3 ->
      bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
      rg:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
       rf:map_val};
       acc)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:ORDERS_ORDERKEY, rf:__map_ret__79} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__map_ret__79};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__map_ret__79} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__map_ret__79 * -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__prod_ret__48} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:ORDERS_CUSTKEY, rf:__prod_ret__48};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER12_send_correctives {ra:me, rb:52, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:52}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:52, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_ORDERS_do_complete_s53 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  (((bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s53_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
       ORDERS_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
      rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:ORDERS_ORDERKEY,
    rc:REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__80} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR,
     rb:REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__80};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__80} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR,
     rb:REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__80 * -1};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY, rc:__prod_ret__49} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:ORDERS_CUSTKEY,
     rc:REVENUE_mCUSTOMER12_mSUPPLIERSUPPLIER_SUPPKEY, rd:__prod_ret__49};
     _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_int_int_int_float {ra:REVENUE_mCUSTOMER12_mSUPPLIER1,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER12_mSUPPLIER1_send_correctives {ra:me, rb:53, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:53}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:53, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_ORDERS_do_complete_s54 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  (((bind map_REVENUE_mORDERS11_mLINEITEM4_s54_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
      rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:ORDERS_CUSTKEY,
    rd:REVENUE_mLINEITEMLINEITEM_SUPPKEY, re:__map_ret__81} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__81};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__81} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__map_ret__81 * -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mLINEITEMLINEITEM_SUPPKEY, rd:__prod_ret__50} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:ORDERS_ORDERKEY, rd:REVENUE_mLINEITEMLINEITEM_SUPPKEY,
     re:__prod_ret__50};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mLINEITEM4, rb:false,
      rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mLINEITEM4_send_correctives {ra:me, rb:54, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:54}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:54, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_ORDERS_do_complete_s55 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  (((bind map_REVENUE_mORDERS11_mSUPPLIER2_s55_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
      rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:ORDERS_CUSTKEY,
    rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__82} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__82};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__82} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__82 * -1};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__51} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:ORDERS_ORDERKEY, rd:REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
     re:__prod_ret__51};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int
      {ra:REVENUE_mLINEITEM4_mSUPPLIER1, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mLINEITEM4_mSUPPLIER1_send_correctives {ra:me, rb:55, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:55}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:55, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_ORDERS_do_complete_s56 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  ((((bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s56_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
       ORDERS_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
      rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:ORDERS_ORDERKEY,
    rc:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__83} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:__map_ret__83};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__83} in _accext.combine
    (((bind map_REVENUE_mORDERS11_mSUPPLIER2_s56_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
      rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:ORDERS_CUSTKEY,
    rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__84} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__84};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__84} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__map_ret__83 * __map_ret__84};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__prod_ret__52} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__prod_ret__52 * -1};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__prod_ret__53} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rf:__prod_ret__53};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mSUPPLIER11_send_correctives {ra:me, rb:56, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:56}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:56, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_ORDERS_do_complete_s57 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let delta_values =
  ((((bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s57_buf as ind __x in
    (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
       ORDERS_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
      rc:map_1, rd:map_2, re:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
      ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:ORDERS_ORDERKEY,
    rc:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__85} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:__map_ret__85};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__85} in _accext.combine
    (((bind map_REVENUE_mORDERS11_mSUPPLIER2_s57_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0,
      rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:ORDERS_CUSTKEY,
    rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__86} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__86};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__86} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__map_ret__85 * __map_ret__86};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection })))) empty { ra:int, rb:int, rc:string, rd:string,
    re:int, rf:real } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__prod_ret__54} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
     rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
     re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__prod_ret__54 * -1};
     _accmap)))) empty { ra:int, rb:int, rc:string, rd:string, re:int, rf:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY,
    rc:SHIPPING_SUPP_NATION, rd:SHIPPING_CUST_NATION,
    re:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rf:__prod_ret__55} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rf:__prod_ret__55};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mSUPPLIER12_send_correctives {ra:me, rb:57, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:57}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:57, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_ORDERS_do_complete_s50 : { ra:{ key:int, value:int }, rb:int,
  rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int, rj:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
  rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
  rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
  rj:ORDERS_COMMENT} in let __val_ret__26 = -1 in
  ((nd_add_delta_to_int_int_int {ra:REVENUE_mCUSTOMER11_mLINEITEM5, rb:false,
      rc:vid, rd:{| ra:int, rb:int, rc:int | {ra:ORDERS_CUSTKEY,
      rb:ORDERS_ORDERKEY, rc:__val_ret__26}|} @ { Collection }});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_mLINEITEM5_send_correctives {ra:me, rb:50, rc:vid,
     rd:1, re:vid, rf:{| ra:int, rb:int, rc:int | {ra:ORDERS_CUSTKEY,
     rb:ORDERS_ORDERKEY, rc:__val_ret__26}|} @ { Collection }} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:50, rc:1, rd:sent_msgs,
         re:true, rf:true}))


declare delete_ORDERS_do_corrective_s48_m_REVENUE_mORDERS11 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:int, rh:string, ri:real, rj:int, rk:string, rl:string, rm:int, rn:string,
  ro:collection { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    re:delta_REVENUE_mORDERSORDERS_ORDERKEY, rf:delta_REVENUE_mORDERS11} in 
    _accext.combine (let __prod_ret__757 =
    ((if ORDERS_ORDERKEY == delta_REVENUE_mORDERSORDERS_ORDERKEY then 1 
      else 0) * if ORDERS_CUSTKEY == delta_REVENUE_mORDERSORDERS_CUSTKEY 
      then 1 else 0) * delta_REVENUE_mORDERS11 in
    {| ra:string, rb:string, rc:int, rd:real | {ra:delta_SHIPPING_SUPP_NATION,
      rb:delta_SHIPPING_CUST_NATION, rc:delta_SHIPPING_L_YEAR,
      rd:__prod_ret__757}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare delete_ORDERS_do_corrective_s48_m_REVENUE_mORDERS12 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:int, rh:string, ri:real, rj:int, rk:string, rl:string, rm:int, rn:string,
  ro:collection { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    re:delta_REVENUE_mORDERSORDERS_ORDERKEY, rf:delta_REVENUE_mORDERS12} in 
    _accext.combine (let __prod_ret__760 =
    ((if ORDERS_ORDERKEY == delta_REVENUE_mORDERSORDERS_ORDERKEY then 1 
      else 0) * if ORDERS_CUSTKEY == delta_REVENUE_mORDERSORDERS_CUSTKEY 
      then 1 else 0) * -delta_REVENUE_mORDERS12 in
    {| ra:string, rb:string, rc:int, rd:real | {ra:delta_SHIPPING_SUPP_NATION,
      rb:delta_SHIPPING_CUST_NATION, rc:delta_SHIPPING_L_YEAR,
      rd:__prod_ret__760}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare delete_ORDERS_do_corrective_s49_m_REVENUE_mCUSTOMER11_mORDERS1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:string, rb:string, rc:int,
  rd:int, re:int, rf:real } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY,
    rf:delta_REVENUE_mCUSTOMER11_mORDERS1} in _accext.combine (let
    __prod_ret__762 =
    (if ORDERS_ORDERKEY == delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY
      then 1 else 0) * -delta_REVENUE_mCUSTOMER11_mORDERS1 in
    {| ra:string, rb:string, rc:int, rd:int, re:int, rf:real |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      re:ORDERS_CUSTKEY, rf:__prod_ret__762}|} @ { Collection })))) empty {
    ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_2, rd:map_3, re:map_4, rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_ORDERS_do_corrective_s51_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 :
  { ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:int, rb:int, rc:int, rd:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1} in _accext.combine (let
    __prod_ret__764 =
    (if ORDERS_ORDERKEY == delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY
      then 1 else 0) * -delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 in
    {| ra:int, rb:int, rc:int, rd:real | {ra:delta_SHIPPING_L_YEAR,
      rb:ORDERS_CUSTKEY,
      rc:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
      rd:__prod_ret__764}|} @ { Collection })))) empty { ra:int, rb:int,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_int_float {ra:REVENUE_mCUSTOMER11_mSUPPLIER1,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER11_mSUPPLIER1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_ORDERS_do_corrective_s52_m_REVENUE_mCUSTOMER12_mORDERS1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:string, rb:string, rc:int,
  rd:int, re:int, rf:real } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
    rf:delta_REVENUE_mCUSTOMER12_mORDERS1} in _accext.combine (let
    __prod_ret__774 =
    (if ORDERS_ORDERKEY == delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY
      then 1 else 0) * -delta_REVENUE_mCUSTOMER12_mORDERS1 in
    {| ra:string, rb:string, rc:int, rd:int, re:int, rf:real |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:delta_SHIPPING_L_YEAR, rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      re:ORDERS_CUSTKEY, rf:__prod_ret__774}|} @ { Collection })))) empty {
    ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_2, rd:map_3, re:map_4, rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_ORDERS_do_corrective_s53_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 :
  { ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:int, rb:int, rc:int, rd:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1} in _accext.combine (let
    __prod_ret__776 =
    (if ORDERS_ORDERKEY == delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY
      then 1 else 0) * -delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 in
    {| ra:int, rb:int, rc:int, rd:real | {ra:delta_SHIPPING_L_YEAR,
      rb:ORDERS_CUSTKEY,
      rc:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
      rd:__prod_ret__776}|} @ { Collection })))) empty { ra:int, rb:int,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_int_float {ra:REVENUE_mCUSTOMER12_mSUPPLIER1,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER12_mSUPPLIER1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_ORDERS_do_corrective_s54_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:string, rb:string, rc:int,
  rd:int, re:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mORDERS11_mLINEITEM4} in _accext.combine (let
    __prod_ret__786 =
    (if ORDERS_CUSTKEY == delta_REVENUE_mORDERSORDERS_CUSTKEY then 1 
      else 0) * -delta_REVENUE_mORDERS11_mLINEITEM4 in
    {| ra:string, rb:string, rc:int, rd:int, re:int |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:ORDERS_ORDERKEY, rd:delta_REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY,
      re:__prod_ret__786}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 0 !=
    map_val)) in
  ((nd_add_delta_to_string_string_int_int_int {ra:REVENUE_mLINEITEM4, rb:true,
      rc:vid, rd:new_tuples});
   (nd_REVENUE_mLINEITEM4_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_ORDERS_do_corrective_s55_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:string, rb:string, rc:int,
  rd:int, re:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mORDERS11_mSUPPLIER2} in _accext.combine (let
    __prod_ret__788 =
    (if ORDERS_CUSTKEY == delta_REVENUE_mORDERSORDERS_CUSTKEY then 1 
      else 0) * -delta_REVENUE_mORDERS11_mSUPPLIER2 in
    {| ra:string, rb:string, rc:int, rd:int, re:int |
      {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
      rc:ORDERS_ORDERKEY,
      rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
      re:__prod_ret__788}|} @ { Collection })))) empty { ra:string, rb:string,
    rc:int, rd:int, re:int } @ { Collection }).filter ((\b1 ->
    bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val} in 0 !=
    map_val)) in
  ((nd_add_delta_to_string_string_int_int_int
      {ra:REVENUE_mLINEITEM4_mSUPPLIER1, rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mLINEITEM4_mSUPPLIER1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_ORDERS_do_corrective_s56_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 :
  { ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:int, rb:int, rc:int, rd:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mORDERS11_mSUPPLIER2_s56_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
         ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:ORDERS_CUSTKEY,
      rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__157} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__157};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__157} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__157 *
       if ORDERS_ORDERKEY == delta_REVENUE_mCUSTOMER11_mORDERSORDERS_ORDERKEY
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__766} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__766 *
       -delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__767} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
       rf:__prod_ret__767};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mSUPPLIER11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_ORDERS_do_corrective_s56_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:string, rb:string, rc:int,
  rd:int, re:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mORDERS11_mSUPPLIER2} in _accext.combine (let delta_values
    =
    ((((bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s56_buf as ind __x in
      (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
         ORDERS_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
        ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:ORDERS_ORDERKEY,
      rc:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__161} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__161};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__161} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__161 *
       if ORDERS_CUSTKEY == delta_REVENUE_mORDERSORDERS_CUSTKEY then 1 
       else 0};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__prod_ret__790} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__prod_ret__790 *
       -delta_REVENUE_mORDERS11_mSUPPLIER2};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__prod_ret__791} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
       re:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rf:__prod_ret__791};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mSUPPLIER11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_ORDERS_do_corrective_s57_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 :
  { ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:int, rb:int, rc:int, rd:real
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:ORDERS_ORDERKEY,
  rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE,
  rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK,
  rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT, ro:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_L_YEAR,
    rb:delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
    rd:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((bind map_REVENUE_mORDERS11_mSUPPLIER2_s57_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
         ORDERS_CUSTKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:ORDERS_CUSTKEY,
      rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__159} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__159};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__159} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__159 *
       if ORDERS_ORDERKEY == delta_REVENUE_mCUSTOMER12_mORDERSORDERS_ORDERKEY
       then 1 else 0};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__778} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__778 *
       -delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__prod_ret__779} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:delta_SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIERSUPPLIER_SUPPKEY,
       rf:__prod_ret__779};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mSUPPLIER12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_ORDERS_do_corrective_s57_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:string, ri:real, rj:int, rk:string,
  rl:string, rm:int, rn:string, ro:collection { ra:string, rb:string, rc:int,
  rd:int, re:int } @ { Collection } } -> int = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
  ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE, rk:ORDERS_ORDERPRIORITY,
  rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY, rn:ORDERS_COMMENT,
  ro:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mORDERS11_mSUPPLIER2} in _accext.combine (let delta_values
    =
    ((((bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s57_buf as ind __x in
      (frontier_int_int_int_float {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
         ORDERS_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_val};acc)))) empty {
        ra:int, rb:int, rc:int, rd:real } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR, rb:ORDERS_ORDERKEY,
      rc:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rd:__map_ret__162} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__162};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__162} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__map_ret__162 *
       if ORDERS_CUSTKEY == delta_REVENUE_mORDERSORDERS_CUSTKEY then 1 
       else 0};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__prod_ret__793} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__prod_ret__793 *
       -delta_REVENUE_mORDERS11_mSUPPLIER2};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rc:__prod_ret__794} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mORDERS11_mSUPPLIERSUPPLIER_NATIONKEY,
       re:REVENUE_mSUPPLIERSUPPLIER_SUPPKEY, rf:__prod_ret__794};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mSUPPLIER12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare sw_insert_LINEITEM : { ra:int, rb:int, rc:int, rd:int, re:real,
  rf:real, rg:real, rh:real, ri:string, rj:string, rk:int, rl:int, rm:int,
  rn:string, ro:string, rp:string } -> () = (\args ->
  (sw_buf_insert_LINEITEM.insert args;
   sw_trig_buf_idx.insert {i:6};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_insert_LINEITEM_send_fetch : { key:int, value:int } -> () = (\vid ->
  case (sw_buf_insert_LINEITEM.peek ()) of
  {Some args ->
    (sw_buf_insert_LINEITEM.erase args;
     bind args as
     {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
     in
     ((route_to_int_int_int {ra:5, rb:None immut, rc:Some LINEITEM_ORDERKEY,
         rd:Some LINEITEM_SUPPKEY}).iterate ((\b1 -> bind b1 as {i:ip} in 
      (nd_insert_LINEITEM_do_complete_s61_trig, ip)<- {ra:vid,
      rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
      re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
      rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
      rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
      rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
      rq:LINEITEM_COMMENT}));
      (route_to_int_int_int {ra:12, rb:None immut, rc:Some LINEITEM_ORDERKEY,
         rd:Some LINEITEM_SUPPKEY}).iterate ((\b1 -> bind b1 as {i:ip} in 
      (nd_insert_LINEITEM_do_complete_s65_trig, ip)<- {ra:vid,
      rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
      re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
      rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
      rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
      rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
      rq:LINEITEM_COMMENT}));
      ((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_string_string_int_int {ra:18, rb:None immut, rc:None immut,
         rd:Some LINEITEM_ORDERKEY, re:Some LINEITEM_SUPPKEY}).fold ((\count ->
        (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_REVENUE_mLINEITEM4_to_REVENUE_bind_0t0_1t1 {ra:None immut,
          rb:None immut, rc:None immut, rd:empty { ra:{ key:int, value:int },
          rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection },
          re:true}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
        value:tuples} in 
        (_accmap.insert {ra:ip, rb:58, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_string_string_int_int {ra:6, rb:None immut, rc:None immut,
           rd:None immut, re:Some LINEITEM_SUPPKEY}).fold ((\count -> (\b3 ->
          bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_3t2
            {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
            re:None immut, rf:empty { ra:{ key:int, value:int }, rb:string,
            rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:true}).fold
          ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:59, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }).combine (let
          sender_count =
          (route_to_int_int {ra:7, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
            ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
          ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER11_bind_4t0
              {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
              re:None immut, rf:empty { ra:{ key:int, value:int }, rb:int,
              rc:int, rd:int } @ { Collection }, rg:true}).fold ((\_accmap ->
            (\b3 -> bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {ra:ip, rb:59, rc:sender_count};_accmap)))) empty {
            ra:address, rb:int, rc:int } @ { Collection }).combine (let
            sender_count =
            (route_to_string_string_int_int {ra:6, rb:None immut,
               rc:None immut, rd:None immut, re:Some LINEITEM_SUPPKEY}).fold
              ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
            ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER11_mORDERS1_bind_0t0_1t1_3t2
                {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                re:Some LINEITEM_ORDERKEY, rf:empty { ra:{ key:int, value:int
                }, rb:string, rc:string, rd:int, re:int, rf:int
                } @ { Collection }, rg:true}).fold ((\_accmap -> (\b3 ->
              bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:60, rc:sender_count};_accmap))))
              empty { ra:address, rb:int, rc:int } @ { Collection }).combine
              (let sender_count =
              (route_to_int_int {ra:7, rb:None immut,
                 rc:Some LINEITEM_ORDERKEY}).fold ((\count -> (\b3 ->
                bind b3 as {i:ip} in count + 1))) 0 in
              ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER11_mSUPPLIER1_bind_1t0
                  {ra:None immut, rb:None immut, rc:Some LINEITEM_SUPPKEY,
                  rd:empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
                  } @ { Collection }, re:true}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:62, rc:sender_count};_accmap))))
                empty { ra:address, rb:int, rc:int } @ { Collection }).combine
                (let sender_count =
                (route_to_string_string_int_int {ra:6, rb:None immut,
                   rc:None immut, rd:None immut, re:Some LINEITEM_SUPPKEY}).fold
                  ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_3t2
                    {ra:None immut, rb:None immut, rc:None immut,
                    rd:None immut, re:None immut, rf:empty { ra:{ key:int,
                    value:int }, rb:string, rc:string, rd:int, re:int, rf:int
                    } @ { Collection }, rg:true}).fold ((\_accmap -> (\b3 ->
                  bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:63, rc:sender_count};_accmap))))
                  empty { ra:address, rb:int, rc:int
                  } @ { Collection }).combine (let sender_count =
                  (route_to_int_int {ra:7, rb:None immut,
                     rc:Some LINEITEM_ORDERKEY}).fold ((\count -> (\b3 ->
                    bind b3 as {i:ip} in count + 1))) 0 in
                  ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER12_bind_4t0
                      {ra:None immut, rb:None immut, rc:None immut,
                      rd:None immut, re:None immut, rf:empty { ra:{ key:int,
                      value:int }, rb:int, rc:int, rd:int } @ { Collection },
                      rg:true}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                    value:tuples} in 
                    (_accmap.insert {ra:ip, rb:63, rc:sender_count};_accmap))))
                    empty { ra:address, rb:int, rc:int
                    } @ { Collection }).combine (let sender_count =
                    (route_to_string_string_int_int {ra:6, rb:None immut,
                       rc:None immut, rd:None immut, re:Some LINEITEM_SUPPKEY}).fold
                      ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0
                    in
                    ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER12_mORDERS1_bind_0t0_1t1_3t2
                        {ra:None immut, rb:None immut, rc:None immut,
                        rd:None immut, re:Some LINEITEM_ORDERKEY, rf:empty {
                        ra:{ key:int, value:int }, rb:string, rc:string,
                        rd:int, re:int, rf:int } @ { Collection }, rg:true}).fold
                      ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                      value:tuples} in 
                      (_accmap.insert {ra:ip, rb:64, rc:sender_count};_accmap))))
                      empty { ra:address, rb:int, rc:int
                      } @ { Collection }).combine (let sender_count =
                      (route_to_int_int {ra:7, rb:None immut,
                         rc:Some LINEITEM_ORDERKEY}).fold ((\count -> (\b3 ->
                        bind b3 as {i:ip} in count + 1))) 0 in
                      ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER12_mSUPPLIER1_bind_1t0
                          {ra:None immut, rb:None immut,
                          rc:Some LINEITEM_SUPPKEY, rd:empty { ra:{ key:int,
                          value:int }, rb:int, rc:int, rd:int
                          } @ { Collection }, re:true}).fold ((\_accmap ->
                        (\b3 -> bind b3 as {key:ip, value:tuples} in 
                        (_accmap.insert {ra:ip, rb:66, rc:sender_count};_accmap))))
                        empty { ra:address, rb:int, rc:int
                        } @ { Collection }).combine (let sender_count =
                        (route_to_string_string_int_int {ra:15, rb:None immut,
                           rc:None immut, rd:None immut,
                           re:Some LINEITEM_SUPPKEY}).fold ((\count -> (\b3 ->
                          bind b3 as {i:ip} in count + 1))) 0 in
                        ((shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mORDERS11_bind_0t0_1t1_3t2
                            {ra:None immut, rb:None immut, rc:None immut,
                            rd:None immut, re:Some LINEITEM_ORDERKEY,
                            rf:empty { ra:{ key:int, value:int }, rb:string,
                            rc:string, rd:int, re:int, rf:int
                            } @ { Collection }, rg:true}).fold ((\_accmap ->
                          (\b3 -> bind b3 as {key:ip, value:tuples} in 
                          (_accmap.insert {ra:ip, rb:67, rc:sender_count};
                           _accmap)))) empty { ra:address, rb:int, rc:int
                          } @ { Collection }).combine (let sender_count =
                          (route_to_string_string_int_int {ra:15,
                             rb:None immut, rc:None immut, rd:None immut,
                             re:Some LINEITEM_SUPPKEY}).fold ((\count ->
                            (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                          ((shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mORDERS12_bind_0t0_1t1_3t2
                              {ra:None immut, rb:None immut, rc:None immut,
                              rd:None immut, re:Some LINEITEM_ORDERKEY,
                              rf:empty { ra:{ key:int, value:int }, rb:string,
                              rc:string, rd:int, re:int, rf:int
                              } @ { Collection }, rg:true}).fold ((\_accmap ->
                            (\b3 -> bind b3 as {key:ip, value:tuples} in 
                            (_accmap.insert {ra:ip, rb:68, rc:sender_count};
                             _accmap)))) empty { ra:address, rb:int, rc:int
                            } @ { Collection }).combine (let sender_count =
                            (route_to_string_string_int_int {ra:19,
                               rb:None immut, rc:None immut,
                               rd:Some LINEITEM_ORDERKEY, re:None immut}).fold
                              ((\count -> (\b3 -> bind b3 as {i:ip} in count +
                              1))) 0 in
                            ((shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3
                                {ra:None immut, rb:None immut, rc:None immut,
                                rd:None immut, re:Some LINEITEM_SUPPKEY,
                                rf:empty { ra:{ key:int, value:int },
                                rb:string, rc:string, rd:int, re:int, rf:int
                                } @ { Collection }, rg:true}).fold
                              ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                              value:tuples} in 
                              (_accmap.insert {ra:ip, rb:69, rc:sender_count};
                               _accmap)))) empty { ra:address, rb:int, rc:int
                              } @ { Collection }).combine (let sender_count =
                              (route_to_string_string_int_int {ra:19,
                                 rb:None immut, rc:None immut,
                                 rd:Some LINEITEM_ORDERKEY, re:None immut}).fold
                                ((\count -> (\b3 -> bind b3 as {i:ip} in count
                                + 1))) 0 in
                              (shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3
                                 {ra:None immut, rb:None immut, rc:None immut,
                                 rd:None immut, re:Some LINEITEM_SUPPKEY,
                                 rf:empty { ra:{ key:int, value:int },
                                 rb:string, rc:string, rd:int, re:int, rf:int
                                 } @ { Collection }, rg:true}).fold
                                ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                value:tuples} in 
                                (_accmap.insert {ra:ip, rb:70, rc:sender_count};
                                 _accmap)))) empty { ra:address, rb:int, rc:int
                                } @ { Collection })))))))))))))).groupBy
      ((\b1 -> bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip,
      value:stmt_id})) ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id,
      rc:count} in acc + count))) 0).groupBy ((\b1 -> bind b1 as {key:b2,
      value:count} in bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc ->
      (\b3 -> bind b3 as {key:ip_and_stmt_id, value:count} in bind
      ip_and_stmt_id as {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_insert_LINEITEM_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid,
       rd:LINEITEM_ORDERKEY, re:LINEITEM_PARTKEY, rf:LINEITEM_SUPPKEY,
       rg:LINEITEM_LINENUMBER, rh:LINEITEM_QUANTITY, ri:LINEITEM_EXTENDEDPRICE,
       rj:LINEITEM_DISCOUNT, rk:LINEITEM_TAX, rl:LINEITEM_RETURNFLAG,
       rm:LINEITEM_LINESTATUS, rn:LINEITEM_SHIPDATE, ro:LINEITEM_COMMITDATE,
       rp:LINEITEM_RECEIPTDATE, rq:LINEITEM_SHIPINSTRUCT, rr:LINEITEM_SHIPMODE,
       rs:LINEITEM_COMMENT};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_string_string_int_int {ra:19, rb:None immut, rc:None immut,
            rd:Some LINEITEM_ORDERKEY, re:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:70, rb:19, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:19, rb:None immut, rc:None immut,
           rd:Some LINEITEM_ORDERKEY, re:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:69, rb:19, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:15, rb:None immut, rc:None immut,
           rd:None immut, re:Some LINEITEM_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:68, rb:15, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:15, rb:None immut, rc:None immut,
           rd:None immut, re:Some LINEITEM_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:67, rb:15, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:7, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:66, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:6, rb:None immut, rc:None immut,
           rd:None immut, re:Some LINEITEM_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:64, rb:6, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:7, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:63, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:6, rb:None immut, rc:None immut,
           rd:None immut, re:Some LINEITEM_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:63, rb:6, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:7, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:62, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:6, rb:None immut, rc:None immut,
           rd:None immut, re:Some LINEITEM_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:60, rb:6, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:7, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:59, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:6, rb:None immut, rc:None immut,
           rd:None immut, re:Some LINEITEM_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:59, rb:6, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:18, rb:None immut, rc:None immut,
           rd:Some LINEITEM_ORDERKEY, re:Some LINEITEM_SUPPKEY}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:58, rb:18, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine empty { ra:int, rb:int, rc:address
      } @ { Collection }))))))))))))).groupBy ((\b1 -> bind b1 as {ra:stmt_id,
      rb:map_id, rc:ip} in ip)) ((\acc -> (\b3 -> bind b3 as {ra:stmt_id,
      rb:map_id, rc:ip} in (acc.insert {key:stmt_id, value:map_id};acc))))
      empty { key:int, value:int } @ { Collection }).iterate ((\b1 ->
      bind b1 as {key:ip, value:stmt_map_ids} in 
      (nd_insert_LINEITEM_rcv_fetch, ip)<- {ra:stmt_map_ids, rb:vid,
      rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
      rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
      ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
      rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
      ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
      rr:LINEITEM_COMMENT}))))}{None ->
                                 error
                                   (print
                                      "unexpected missing arguments in sw_buf_insert_LINEITEM")})


declare nd_insert_LINEITEM_do_complete_s58 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((((({| key:int, value:int | let __val_ret__34 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__34, value:1}|} @ { Collection }).fold ((\_accext -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__1} in _accext.combine
    (((bind map_REVENUE_mLINEITEM4_s58_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       LINEITEM_ORDERKEY and re == LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 ->
      bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
      rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:LINEITEM_ORDERKEY, rd:LINEITEM_SUPPKEY,
    re:__map_ret__87} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:__map_ret__87};
     _accmap)))) empty { ra:string, rb:string, rc:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:__map_ret__87} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:__lift_ret__1 * __map_ret__87};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:__prod_ret__57} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:__prod_ret__57 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:__prod_ret__58} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:__prod_ret__58 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:__prod_ret__59} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:__prod_ret__59 * (-LINEITEM_DISCOUNT + 1)};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:__prod_ret__60} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:__prod_ret__60 * LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:__prod_ret__61} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__prod_ret__61};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:false, rc:vid,
      rd:delta_values});
   (nd_complete_stmt_cntr_check {key:vid, value:58})))


declare nd_insert_LINEITEM_do_complete_s59 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  ((((((({| key:int, value:int | let __val_ret__39 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__39, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__2} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__2 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__62} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__62 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__63} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mLINEITEM4_s59_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:LINEITEM_SUPPKEY, re:__map_ret__88} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__88};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__88} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__prod_ret__63 * __map_ret__88};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accext -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__prod_ret__64} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mLINEITEM5_s59_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rb:LINEITEM_ORDERKEY,
    rc:__map_ret__89} in 
    (_accmap.insert {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     value:__map_ret__89};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    value:__map_ret__89} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__64 * __map_ret__89};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__65} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__65 *
     LINEITEM_DISCOUNT};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int, rf:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__66} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__66 *
     LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int, rf:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__67} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__67};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_send_correctives {ra:me, rb:59, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:59}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:59, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_LINEITEM_do_complete_s60 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((((({| key:int, value:int | let __val_ret__42 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__42, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__3} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__3 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__68} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__68 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__69} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mLINEITEM4_s60_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:LINEITEM_SUPPKEY, re:__map_ret__90} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__90};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__90} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__prod_ret__69 * __map_ret__90};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__prod_ret__70} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__prod_ret__70 * LINEITEM_DISCOUNT};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__prod_ret__71} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__prod_ret__71 * LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__prod_ret__72} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:LINEITEM_ORDERKEY, rf:__prod_ret__72};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:REVENUE_mCUSTOMER11_mORDERS1, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_mORDERS1_send_correctives {ra:me, rb:60, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:60}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:60, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_LINEITEM_do_complete_s62 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((((({| key:int, value:int | let __val_ret__48 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__48, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__5} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__5 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__77} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__77 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__78} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mLINEITEM5_s62_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rb:LINEITEM_ORDERKEY,
    rc:__map_ret__91} in 
    (_accmap.insert {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     value:__map_ret__91};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    value:__map_ret__91} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:__prod_ret__78 * __map_ret__91};
     _accmap)))) empty { ra:int, rb:int, rc:int } @ { Collection })))) empty {
    ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:__prod_ret__79} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:__prod_ret__79 * LINEITEM_DISCOUNT};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__80} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:__prod_ret__80 * LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__81} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:LINEITEM_SUPPKEY, rd:__prod_ret__81};
     _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_int_int_int_float {ra:REVENUE_mCUSTOMER11_mSUPPLIER1,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_mSUPPLIER1_send_correctives {ra:me, rb:62, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:62}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:62, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_LINEITEM_do_complete_s63 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((((({| key:int, value:int | let __val_ret__51 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__51, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__6} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__6 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__82} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__82 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__83} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mLINEITEM4_s63_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:LINEITEM_SUPPKEY, re:__map_ret__92} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__92};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__92} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__prod_ret__83 * __map_ret__92};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accext -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__prod_ret__84} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mLINEITEM5_s63_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rb:LINEITEM_ORDERKEY,
    rc:__map_ret__93} in 
    (_accmap.insert {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     value:__map_ret__93};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    value:__map_ret__93} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__84 * __map_ret__93};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__85} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__85 *
     LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int, rf:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__86} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__86};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER12_send_correctives {ra:me, rb:63, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:63}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:63, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_LINEITEM_do_complete_s64 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  ((((({| key:int, value:int | let __val_ret__53 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__53, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__7} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__7 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__87} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__87 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__88} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mLINEITEM4_s64_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:LINEITEM_SUPPKEY, re:__map_ret__94} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__94};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__94} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__prod_ret__88 * __map_ret__94};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__prod_ret__89} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__prod_ret__89 * LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__prod_ret__90} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:LINEITEM_ORDERKEY, rf:__prod_ret__90};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:REVENUE_mCUSTOMER12_mORDERS1, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER12_mORDERS1_send_correctives {ra:me, rb:64, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:64}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:64, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_LINEITEM_do_complete_s66 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  ((((({| key:int, value:int | let __val_ret__57 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__57, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__9} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__9 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__94} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__94 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__95} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mLINEITEM5_s66_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rb:LINEITEM_ORDERKEY,
    rc:__map_ret__95} in 
    (_accmap.insert {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     value:__map_ret__95};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    value:__map_ret__95} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:__prod_ret__95 * __map_ret__95};
     _accmap)))) empty { ra:int, rb:int, rc:int } @ { Collection })))) empty {
    ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:__prod_ret__96} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:__prod_ret__96 * LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__97} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:LINEITEM_SUPPKEY, rd:__prod_ret__97};
     _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_int_int_int_float {ra:REVENUE_mCUSTOMER12_mSUPPLIER1,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER12_mSUPPLIER1_send_correctives {ra:me, rb:66, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:66}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:66, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_LINEITEM_do_complete_s67 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((((({| key:int, value:int | let __val_ret__59 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__59, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__10} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__10 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__98} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__98 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__99} in _accext.combine (((bind
    map_REVENUE_mORDERS11_mLINEITEM4_s67_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mORDERSORDERS_CUSTKEY,
    rd:LINEITEM_SUPPKEY, re:__map_ret__96} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__96};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__96} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
     re:__prod_ret__99 * __map_ret__96};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
    re:__prod_ret__100} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
     re:__prod_ret__100 * LINEITEM_DISCOUNT};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
    re:__prod_ret__101} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
     re:__prod_ret__101 * LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
    re:__prod_ret__102} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_CUSTKEY,
     re:LINEITEM_ORDERKEY, rf:__prod_ret__102};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS11_send_correctives {ra:me, rb:67, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:67}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:67, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_LINEITEM_do_complete_s68 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  ((((({| key:int, value:int | let __val_ret__62 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__62, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__11} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__11 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__103} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__103 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__104} in _accext.combine (((bind
    map_REVENUE_mORDERS11_mLINEITEM4_s68_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mORDERSORDERS_CUSTKEY,
    rd:LINEITEM_SUPPKEY, re:__map_ret__97} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__97};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__97} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
     re:__prod_ret__104 * __map_ret__97};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
    re:__prod_ret__105} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
     re:__prod_ret__105 * LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
    re:__prod_ret__106} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_CUSTKEY,
     re:LINEITEM_ORDERKEY, rf:__prod_ret__106};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS12_send_correctives {ra:me, rb:68, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:68}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:68, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_LINEITEM_do_complete_s69 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((((({| key:int, value:int | let __val_ret__64 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__64, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__12} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__12 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__107} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__107 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__108} in _accext.combine (((bind
    map_REVENUE_mLINEITEM4_mSUPPLIER1_s69_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       LINEITEM_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:LINEITEM_ORDERKEY,
    rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__98} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__98};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__98} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:__prod_ret__108 * __map_ret__98};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
    re:__prod_ret__109} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:__prod_ret__109 * LINEITEM_DISCOUNT};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
    re:__prod_ret__110} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:__prod_ret__110 * LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
    re:__prod_ret__111} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:LINEITEM_SUPPKEY, rf:__prod_ret__111};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mSUPPLIER11_send_correctives {ra:me, rb:69, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:69}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:69, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_LINEITEM_do_complete_s70 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  ((((({| key:int, value:int | let __val_ret__67 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__67, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__13} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__13 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__112} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__112 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__113} in _accext.combine (((bind
    map_REVENUE_mLINEITEM4_mSUPPLIER1_s70_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       LINEITEM_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:LINEITEM_ORDERKEY,
    rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__99} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__99};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__99} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:__prod_ret__113 * __map_ret__99};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
    re:__prod_ret__114} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:__prod_ret__114 * LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
    re:__prod_ret__115} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:LINEITEM_SUPPKEY, rf:__prod_ret__115};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mSUPPLIER12_send_correctives {ra:me, rb:70, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:70}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:70, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_insert_LINEITEM_do_complete_s61 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  ((((({| key:int, value:int | let __val_ret__45 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__45, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__4} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__4 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__73} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__73 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__74} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__74 *
     LINEITEM_DISCOUNT};
     _accmap)))) empty { key:int, value:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__75} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__75 *
     LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { key:int, value:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__76} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:LINEITEM_ORDERKEY,
     rc:LINEITEM_SUPPKEY, rd:__prod_ret__76};
     _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_int_int_int_float
      {ra:REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1, rb:false, rc:vid,
      rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_send_correctives {ra:me, rb:61,
     rc:vid, rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:61, rc:1, rd:sent_msgs,
         re:true, rf:true}))


declare nd_insert_LINEITEM_do_complete_s65 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((({| key:int, value:int | let __val_ret__55 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__55, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__8} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__8 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__91} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__91 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__92} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__92 *
     LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { key:int, value:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__93} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:LINEITEM_ORDERKEY,
     rc:LINEITEM_SUPPKEY, rd:__prod_ret__93};
     _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_int_int_int_float
      {ra:REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1, rb:false, rc:vid,
      rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_send_correctives {ra:me, rb:65,
     rc:vid, rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:65, rc:1, rd:sent_msgs,
         re:true, rf:true}))


declare insert_LINEITEM_do_corrective_s58_m_REVENUE_mLINEITEM4 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:int, rh:int, ri:int, rj:real, rk:real, rl:real, rm:real, rn:string,
  ro:string, rp:int, rq:int, rr:int, rs:string, rt:string, ru:string,
  rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    rd:delta_REVENUE_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mLINEITEM4} in _accext.combine (let delta_values =
    ((((((({| key:int, value:int | let __val_ret__116 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__116, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__30} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__30 *
       ((if LINEITEM_SUPPKEY == delta_REVENUE_mLINEITEMLINEITEM_SUPPKEY 
       then 1 else 0) *
       if LINEITEM_ORDERKEY == delta_REVENUE_mLINEITEMLINEITEM_ORDERKEY 
       then 1 else 0)};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__196} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__196 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__197} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__197 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__198} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__198 *
       (-LINEITEM_DISCOUNT + 1)};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__199} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__199 *
       delta_REVENUE_mLINEITEM4};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__200} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__200 *
       LINEITEM_EXTENDEDPRICE};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__201} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR, rd:__prod_ret__201};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection } in delta_values)))) empty { ra:string, rb:string,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare insert_LINEITEM_do_corrective_s59_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mCUSTOMER11_mLINEITEM4} in _accext.combine (let
    delta_values =
    (((((((({| key:int, value:int | let __val_ret__122 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__122, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__31} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__31 *
       if LINEITEM_SUPPKEY ==
         delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__202} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__202 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__203} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__203 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__204} in _accext.combine (((bind
      map_REVENUE_mCUSTOMER11_mLINEITEM5_s59_buf as ind __x in
      (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
        rd:map_val} in (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc))))
        empty { ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
      rb:LINEITEM_ORDERKEY, rc:__map_ret__115} in 
      (_accmap.insert {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
       value:__map_ret__115};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
      value:__map_ret__115} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__204 *
       __map_ret__115};
       _accmap)))) empty { ra:int, rb:int, rc:int } @ { Collection }))))
      empty { ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__205} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__205 *
       delta_REVENUE_mCUSTOMER11_mLINEITEM4};
       _accmap)))) empty { ra:int, rb:int, rc:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__206} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__206 *
       LINEITEM_DISCOUNT};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__207} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__207 *
       LINEITEM_EXTENDEDPRICE};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__208} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__208};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_LINEITEM_do_corrective_s59_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:int, rb:int, rc:int } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
  rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
  rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
  rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE,
  rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
  rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mLINEITEM5} in _accext.combine (let
    delta_values =
    (((((((({| key:int, value:int | let __val_ret__178 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__178, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__47} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__47 *
       if LINEITEM_ORDERKEY ==
         delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY then 1 
       else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__298} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__298 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__299} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__299 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__300} in _accext.combine (((bind
      map_REVENUE_mCUSTOMER11_mLINEITEM4_s59_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
         LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      rd:LINEITEM_SUPPKEY, re:__map_ret__123} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__123};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__123} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
       rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:__prod_ret__300 * __map_ret__123};
       _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
      } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int,
      re:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
      rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      re:__prod_ret__301} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
       rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:__prod_ret__301 * delta_REVENUE_mCUSTOMER11_mLINEITEM5};
       _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
      rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      re:__prod_ret__302} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
       rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:__prod_ret__302 * LINEITEM_DISCOUNT};
       _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
      rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      re:__prod_ret__303} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
       rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:__prod_ret__303 * LINEITEM_EXTENDEDPRICE};
       _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
      rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      re:__prod_ret__304} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__304};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_LINEITEM_do_corrective_s60_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mCUSTOMER11_mLINEITEM4} in _accext.combine (let
    delta_values =
    ((((((({| key:int, value:int | let __val_ret__126 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__126, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__32} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__32 *
       if LINEITEM_SUPPKEY ==
         delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__209} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__209 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__210} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__210 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__211} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__211 *
       delta_REVENUE_mCUSTOMER11_mLINEITEM4};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__212} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__212 *
       LINEITEM_DISCOUNT};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__213} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__213 *
       LINEITEM_EXTENDEDPRICE};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__214} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, re:LINEITEM_ORDERKEY,
       rf:__prod_ret__214};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:REVENUE_mCUSTOMER11_mORDERS1, rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER11_mORDERS1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_LINEITEM_do_corrective_s62_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:int, rb:int, rc:int } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
  rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
  rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
  rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE,
  rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
  rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mLINEITEM5} in _accext.combine (let
    delta_values =
    ((((((({| key:int, value:int | let __val_ret__182 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__182, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__48} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__48 *
       if LINEITEM_ORDERKEY ==
         delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY then 1 
       else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__305} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__305 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__306} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__306 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__307} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__307 *
       delta_REVENUE_mCUSTOMER11_mLINEITEM5};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__308} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__308 *
       LINEITEM_DISCOUNT};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__309} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__309 *
       LINEITEM_EXTENDEDPRICE};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__310} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:LINEITEM_SUPPKEY,
       rd:__prod_ret__310};
       _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection }
    in delta_values)))) empty { ra:int, rb:int, rc:int, rd:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_int_float {ra:REVENUE_mCUSTOMER11_mSUPPLIER1,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER11_mSUPPLIER1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_LINEITEM_do_corrective_s63_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mCUSTOMER11_mLINEITEM4} in _accext.combine (let
    delta_values =
    ((((((({| key:int, value:int | let __val_ret__130 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__130, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__33} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__33 *
       if LINEITEM_SUPPKEY ==
         delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__215} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__215 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__216} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__216 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__217} in _accext.combine (((bind
      map_REVENUE_mCUSTOMER11_mLINEITEM5_s63_buf as ind __x in
      (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
        rd:map_val} in (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc))))
        empty { ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
      rb:LINEITEM_ORDERKEY, rc:__map_ret__116} in 
      (_accmap.insert {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
       value:__map_ret__116};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
      value:__map_ret__116} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__217 *
       __map_ret__116};
       _accmap)))) empty { ra:int, rb:int, rc:int } @ { Collection }))))
      empty { ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__218} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__218 *
       delta_REVENUE_mCUSTOMER11_mLINEITEM4};
       _accmap)))) empty { ra:int, rb:int, rc:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__219} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__219 *
       LINEITEM_EXTENDEDPRICE};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__220} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__220};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_LINEITEM_do_corrective_s63_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:int, rb:int, rc:int } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
  rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
  rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
  rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE,
  rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
  rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mLINEITEM5} in _accext.combine (let
    delta_values =
    ((((((({| key:int, value:int | let __val_ret__186 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__186, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__49} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__49 *
       if LINEITEM_ORDERKEY ==
         delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY then 1 
       else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__311} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__311 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__312} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__312 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__313} in _accext.combine (((bind
      map_REVENUE_mCUSTOMER11_mLINEITEM4_s63_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
         LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      rd:LINEITEM_SUPPKEY, re:__map_ret__124} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__124};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__124} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
       rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:__prod_ret__313 * __map_ret__124};
       _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
      } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int,
      re:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
      rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      re:__prod_ret__314} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
       rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:__prod_ret__314 * delta_REVENUE_mCUSTOMER11_mLINEITEM5};
       _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
      rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      re:__prod_ret__315} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
       rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:__prod_ret__315 * LINEITEM_EXTENDEDPRICE};
       _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
      rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      re:__prod_ret__316} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__316};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_LINEITEM_do_corrective_s64_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mCUSTOMER11_mLINEITEM4} in _accext.combine (let
    delta_values =
    (((((({| key:int, value:int | let __val_ret__133 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__133, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__34} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__34 *
       if LINEITEM_SUPPKEY ==
         delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__221} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__221 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__222} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__222 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__223} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__223 *
       delta_REVENUE_mCUSTOMER11_mLINEITEM4};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__224} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__224 *
       LINEITEM_EXTENDEDPRICE};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__225} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, re:LINEITEM_ORDERKEY,
       rf:__prod_ret__225};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:REVENUE_mCUSTOMER12_mORDERS1, rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER12_mORDERS1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_LINEITEM_do_corrective_s66_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:int, rb:int, rc:int } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
  rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
  rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
  rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE,
  rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
  rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mLINEITEM5} in _accext.combine (let
    delta_values =
    (((((({| key:int, value:int | let __val_ret__189 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__189, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__50} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__50 *
       if LINEITEM_ORDERKEY ==
         delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY then 1 
       else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__317} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__317 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__318} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__318 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__319} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__319 *
       delta_REVENUE_mCUSTOMER11_mLINEITEM5};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__320} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__320 *
       LINEITEM_EXTENDEDPRICE};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__321} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:LINEITEM_SUPPKEY,
       rd:__prod_ret__321};
       _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection }
    in delta_values)))) empty { ra:int, rb:int, rc:int, rd:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_int_float {ra:REVENUE_mCUSTOMER12_mSUPPLIER1,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER12_mSUPPLIER1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_LINEITEM_do_corrective_s67_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mORDERS11_mLINEITEM4} in _accext.combine (let delta_values
    =
    ((((((({| key:int, value:int | let __val_ret__234 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__234, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__63} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__63 *
       if LINEITEM_SUPPKEY == delta_REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY
       then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__394} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__394 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__395} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__395 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__396} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__396 *
       delta_REVENUE_mORDERS11_mLINEITEM4};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__397} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__397 *
       LINEITEM_DISCOUNT};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__398} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__398 *
       LINEITEM_EXTENDEDPRICE};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__399} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mORDERSORDERS_CUSTKEY, re:LINEITEM_ORDERKEY,
       rf:__prod_ret__399};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_LINEITEM_do_corrective_s68_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mORDERS11_mLINEITEM4} in _accext.combine (let delta_values
    =
    (((((({| key:int, value:int | let __val_ret__238 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__238, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__64} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__64 *
       if LINEITEM_SUPPKEY == delta_REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY
       then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__400} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__400 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__401} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__401 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__402} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__402 *
       delta_REVENUE_mORDERS11_mLINEITEM4};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__403} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__403 *
       LINEITEM_EXTENDEDPRICE};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__404} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mORDERSORDERS_CUSTKEY, re:LINEITEM_ORDERKEY,
       rf:__prod_ret__404};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_LINEITEM_do_corrective_s69_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    rd:delta_REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mLINEITEM4_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((((({| key:int, value:int | let __val_ret__248 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__248, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__67} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__67 *
       if LINEITEM_ORDERKEY == delta_REVENUE_mLINEITEMLINEITEM_ORDERKEY 
       then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__416} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__416 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__417} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__417 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__418} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__418 *
       delta_REVENUE_mLINEITEM4_mSUPPLIER1};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__419} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__419 *
       LINEITEM_DISCOUNT};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__420} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__420 *
       LINEITEM_EXTENDEDPRICE};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__421} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
       re:LINEITEM_SUPPKEY, rf:__prod_ret__421};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mSUPPLIER11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare insert_LINEITEM_do_corrective_s70_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    rd:delta_REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mLINEITEM4_mSUPPLIER1} in _accext.combine (let
    delta_values =
    (((((({| key:int, value:int | let __val_ret__252 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__252, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__68} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__68 *
       if LINEITEM_ORDERKEY == delta_REVENUE_mLINEITEMLINEITEM_ORDERKEY 
       then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__422} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__422 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__423} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__423 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__424} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__424 *
       delta_REVENUE_mLINEITEM4_mSUPPLIER1};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__425} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__425 *
       LINEITEM_EXTENDEDPRICE};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__426} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
       re:LINEITEM_SUPPKEY, rf:__prod_ret__426};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mSUPPLIER12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare sw_delete_LINEITEM : { ra:int, rb:int, rc:int, rd:int, re:real,
  rf:real, rg:real, rh:real, ri:string, rj:string, rk:int, rl:int, rm:int,
  rn:string, ro:string, rp:string } -> () = (\args ->
  (sw_buf_delete_LINEITEM.insert args;
   sw_trig_buf_idx.insert {i:7};
   sw_need_vid_cntr = sw_need_vid_cntr + 1))


declare sw_delete_LINEITEM_send_fetch : { key:int, value:int } -> () = (\vid ->
  case (sw_buf_delete_LINEITEM.peek ()) of
  {Some args ->
    (sw_buf_delete_LINEITEM.erase args;
     bind args as
     {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
     in
     ((route_to_int_int_int {ra:5, rb:None immut, rc:Some LINEITEM_ORDERKEY,
         rd:Some LINEITEM_SUPPKEY}).iterate ((\b1 -> bind b1 as {i:ip} in 
      (nd_delete_LINEITEM_do_complete_s74_trig, ip)<- {ra:vid,
      rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
      re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
      rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
      rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
      rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
      rq:LINEITEM_COMMENT}));
      (route_to_int_int_int {ra:12, rb:None immut, rc:Some LINEITEM_ORDERKEY,
         rd:Some LINEITEM_SUPPKEY}).iterate ((\b1 -> bind b1 as {i:ip} in 
      (nd_delete_LINEITEM_do_complete_s78_trig, ip)<- {ra:vid,
      rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
      re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
      rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
      rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
      rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
      rq:LINEITEM_COMMENT}));
      ((((empty { ra:address, rb:int, rc:int } @ { Collection }).combine (let
      sender_count =
      (route_to_string_string_int_int {ra:18, rb:None immut, rc:None immut,
         rd:Some LINEITEM_ORDERKEY, re:Some LINEITEM_SUPPKEY}).fold ((\count ->
        (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
      ((shuffle_REVENUE_mLINEITEM4_to_REVENUE_bind_0t0_1t1 {ra:None immut,
          rb:None immut, rc:None immut, rd:empty { ra:{ key:int, value:int },
          rb:string, rc:string, rd:int, re:int, rf:int } @ { Collection },
          re:true}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
        value:tuples} in 
        (_accmap.insert {ra:ip, rb:71, rc:sender_count};_accmap)))) empty {
        ra:address, rb:int, rc:int } @ { Collection }).combine (let
        sender_count =
        (route_to_string_string_int_int {ra:6, rb:None immut, rc:None immut,
           rd:None immut, re:Some LINEITEM_SUPPKEY}).fold ((\count -> (\b3 ->
          bind b3 as {i:ip} in count + 1))) 0 in
        ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_3t2
            {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
            re:None immut, rf:empty { ra:{ key:int, value:int }, rb:string,
            rc:string, rd:int, re:int, rf:int } @ { Collection }, rg:true}).fold
          ((\_accmap -> (\b3 -> bind b3 as {key:ip, value:tuples} in 
          (_accmap.insert {ra:ip, rb:72, rc:sender_count};_accmap)))) empty {
          ra:address, rb:int, rc:int } @ { Collection }).combine (let
          sender_count =
          (route_to_int_int {ra:7, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
            ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
          ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER11_bind_4t0
              {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
              re:None immut, rf:empty { ra:{ key:int, value:int }, rb:int,
              rc:int, rd:int } @ { Collection }, rg:true}).fold ((\_accmap ->
            (\b3 -> bind b3 as {key:ip, value:tuples} in 
            (_accmap.insert {ra:ip, rb:72, rc:sender_count};_accmap)))) empty {
            ra:address, rb:int, rc:int } @ { Collection }).combine (let
            sender_count =
            (route_to_string_string_int_int {ra:6, rb:None immut,
               rc:None immut, rd:None immut, re:Some LINEITEM_SUPPKEY}).fold
              ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
            ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER11_mORDERS1_bind_0t0_1t1_3t2
                {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
                re:Some LINEITEM_ORDERKEY, rf:empty { ra:{ key:int, value:int
                }, rb:string, rc:string, rd:int, re:int, rf:int
                } @ { Collection }, rg:true}).fold ((\_accmap -> (\b3 ->
              bind b3 as {key:ip, value:tuples} in 
              (_accmap.insert {ra:ip, rb:73, rc:sender_count};_accmap))))
              empty { ra:address, rb:int, rc:int } @ { Collection }).combine
              (let sender_count =
              (route_to_int_int {ra:7, rb:None immut,
                 rc:Some LINEITEM_ORDERKEY}).fold ((\count -> (\b3 ->
                bind b3 as {i:ip} in count + 1))) 0 in
              ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER11_mSUPPLIER1_bind_1t0
                  {ra:None immut, rb:None immut, rc:Some LINEITEM_SUPPKEY,
                  rd:empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
                  } @ { Collection }, re:true}).fold ((\_accmap -> (\b3 ->
                bind b3 as {key:ip, value:tuples} in 
                (_accmap.insert {ra:ip, rb:75, rc:sender_count};_accmap))))
                empty { ra:address, rb:int, rc:int } @ { Collection }).combine
                (let sender_count =
                (route_to_string_string_int_int {ra:6, rb:None immut,
                   rc:None immut, rd:None immut, re:Some LINEITEM_SUPPKEY}).fold
                  ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_3t2
                    {ra:None immut, rb:None immut, rc:None immut,
                    rd:None immut, re:None immut, rf:empty { ra:{ key:int,
                    value:int }, rb:string, rc:string, rd:int, re:int, rf:int
                    } @ { Collection }, rg:true}).fold ((\_accmap -> (\b3 ->
                  bind b3 as {key:ip, value:tuples} in 
                  (_accmap.insert {ra:ip, rb:76, rc:sender_count};_accmap))))
                  empty { ra:address, rb:int, rc:int
                  } @ { Collection }).combine (let sender_count =
                  (route_to_int_int {ra:7, rb:None immut,
                     rc:Some LINEITEM_ORDERKEY}).fold ((\count -> (\b3 ->
                    bind b3 as {i:ip} in count + 1))) 0 in
                  ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER12_bind_4t0
                      {ra:None immut, rb:None immut, rc:None immut,
                      rd:None immut, re:None immut, rf:empty { ra:{ key:int,
                      value:int }, rb:int, rc:int, rd:int } @ { Collection },
                      rg:true}).fold ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                    value:tuples} in 
                    (_accmap.insert {ra:ip, rb:76, rc:sender_count};_accmap))))
                    empty { ra:address, rb:int, rc:int
                    } @ { Collection }).combine (let sender_count =
                    (route_to_string_string_int_int {ra:6, rb:None immut,
                       rc:None immut, rd:None immut, re:Some LINEITEM_SUPPKEY}).fold
                      ((\count -> (\b3 -> bind b3 as {i:ip} in count + 1))) 0
                    in
                    ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER12_mORDERS1_bind_0t0_1t1_3t2
                        {ra:None immut, rb:None immut, rc:None immut,
                        rd:None immut, re:Some LINEITEM_ORDERKEY, rf:empty {
                        ra:{ key:int, value:int }, rb:string, rc:string,
                        rd:int, re:int, rf:int } @ { Collection }, rg:true}).fold
                      ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                      value:tuples} in 
                      (_accmap.insert {ra:ip, rb:77, rc:sender_count};_accmap))))
                      empty { ra:address, rb:int, rc:int
                      } @ { Collection }).combine (let sender_count =
                      (route_to_int_int {ra:7, rb:None immut,
                         rc:Some LINEITEM_ORDERKEY}).fold ((\count -> (\b3 ->
                        bind b3 as {i:ip} in count + 1))) 0 in
                      ((shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER12_mSUPPLIER1_bind_1t0
                          {ra:None immut, rb:None immut,
                          rc:Some LINEITEM_SUPPKEY, rd:empty { ra:{ key:int,
                          value:int }, rb:int, rc:int, rd:int
                          } @ { Collection }, re:true}).fold ((\_accmap ->
                        (\b3 -> bind b3 as {key:ip, value:tuples} in 
                        (_accmap.insert {ra:ip, rb:79, rc:sender_count};_accmap))))
                        empty { ra:address, rb:int, rc:int
                        } @ { Collection }).combine (let sender_count =
                        (route_to_string_string_int_int {ra:15, rb:None immut,
                           rc:None immut, rd:None immut,
                           re:Some LINEITEM_SUPPKEY}).fold ((\count -> (\b3 ->
                          bind b3 as {i:ip} in count + 1))) 0 in
                        ((shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mORDERS11_bind_0t0_1t1_3t2
                            {ra:None immut, rb:None immut, rc:None immut,
                            rd:None immut, re:Some LINEITEM_ORDERKEY,
                            rf:empty { ra:{ key:int, value:int }, rb:string,
                            rc:string, rd:int, re:int, rf:int
                            } @ { Collection }, rg:true}).fold ((\_accmap ->
                          (\b3 -> bind b3 as {key:ip, value:tuples} in 
                          (_accmap.insert {ra:ip, rb:80, rc:sender_count};
                           _accmap)))) empty { ra:address, rb:int, rc:int
                          } @ { Collection }).combine (let sender_count =
                          (route_to_string_string_int_int {ra:15,
                             rb:None immut, rc:None immut, rd:None immut,
                             re:Some LINEITEM_SUPPKEY}).fold ((\count ->
                            (\b3 -> bind b3 as {i:ip} in count + 1))) 0 in
                          ((shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mORDERS12_bind_0t0_1t1_3t2
                              {ra:None immut, rb:None immut, rc:None immut,
                              rd:None immut, re:Some LINEITEM_ORDERKEY,
                              rf:empty { ra:{ key:int, value:int }, rb:string,
                              rc:string, rd:int, re:int, rf:int
                              } @ { Collection }, rg:true}).fold ((\_accmap ->
                            (\b3 -> bind b3 as {key:ip, value:tuples} in 
                            (_accmap.insert {ra:ip, rb:81, rc:sender_count};
                             _accmap)))) empty { ra:address, rb:int, rc:int
                            } @ { Collection }).combine (let sender_count =
                            (route_to_string_string_int_int {ra:19,
                               rb:None immut, rc:None immut,
                               rd:Some LINEITEM_ORDERKEY, re:None immut}).fold
                              ((\count -> (\b3 -> bind b3 as {i:ip} in count +
                              1))) 0 in
                            ((shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3
                                {ra:None immut, rb:None immut, rc:None immut,
                                rd:None immut, re:Some LINEITEM_SUPPKEY,
                                rf:empty { ra:{ key:int, value:int },
                                rb:string, rc:string, rd:int, re:int, rf:int
                                } @ { Collection }, rg:true}).fold
                              ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                              value:tuples} in 
                              (_accmap.insert {ra:ip, rb:82, rc:sender_count};
                               _accmap)))) empty { ra:address, rb:int, rc:int
                              } @ { Collection }).combine (let sender_count =
                              (route_to_string_string_int_int {ra:19,
                                 rb:None immut, rc:None immut,
                                 rd:Some LINEITEM_ORDERKEY, re:None immut}).fold
                                ((\count -> (\b3 -> bind b3 as {i:ip} in count
                                + 1))) 0 in
                              (shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3
                                 {ra:None immut, rb:None immut, rc:None immut,
                                 rd:None immut, re:Some LINEITEM_SUPPKEY,
                                 rf:empty { ra:{ key:int, value:int },
                                 rb:string, rc:string, rd:int, re:int, rf:int
                                 } @ { Collection }, rg:true}).fold
                                ((\_accmap -> (\b3 -> bind b3 as {key:ip,
                                value:tuples} in 
                                (_accmap.insert {ra:ip, rb:83, rc:sender_count};
                                 _accmap)))) empty { ra:address, rb:int, rc:int
                                } @ { Collection })))))))))))))).groupBy
      ((\b1 -> bind b1 as {ra:ip, rb:stmt_id, rc:count} in {key:ip,
      value:stmt_id})) ((\acc -> (\b3 -> bind b3 as {ra:ip, rb:stmt_id,
      rc:count} in acc + count))) 0).groupBy ((\b1 -> bind b1 as {key:b2,
      value:count} in bind b2 as {key:ip, value:stmt_id} in ip)) ((\acc ->
      (\b3 -> bind b3 as {key:ip_and_stmt_id, value:count} in bind
      ip_and_stmt_id as {key:ip, value:stmt_id} in
      acc.combine ({| key:int, value:int | {key:stmt_id,
        value:count}|} @ { Collection })))) empty { key:int, value:int
      } @ { Collection }).iterate ((\b1 -> bind b1 as {key:addr,
      value:stmt_cnt_list} in 
      ((nd_delete_LINEITEM_rcv_put, addr)<- {ra:me, rb:stmt_cnt_list, rc:vid,
       rd:LINEITEM_ORDERKEY, re:LINEITEM_PARTKEY, rf:LINEITEM_SUPPKEY,
       rg:LINEITEM_LINENUMBER, rh:LINEITEM_QUANTITY, ri:LINEITEM_EXTENDEDPRICE,
       rj:LINEITEM_DISCOUNT, rk:LINEITEM_TAX, rl:LINEITEM_RETURNFLAG,
       rm:LINEITEM_LINESTATUS, rn:LINEITEM_SHIPDATE, ro:LINEITEM_COMMITDATE,
       rp:LINEITEM_RECEIPTDATE, rq:LINEITEM_SHIPINSTRUCT, rr:LINEITEM_SHIPMODE,
       rs:LINEITEM_COMMENT};
       (sw_num_sent = sw_num_sent + 1;
        (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key,
        value:value} in key == vid))).peek ()) of
        {Some x -> sw_ack_log.update x {key:vid, value:x.value + 1}}{None ->
                                                                    sw_ack_log.insert
                                                                    {key:vid,
                                                                    value:1}})))));
      ((((route_to_string_string_int_int {ra:19, rb:None immut, rc:None immut,
            rd:Some LINEITEM_ORDERKEY, re:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:83, rb:19, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:19, rb:None immut, rc:None immut,
           rd:Some LINEITEM_ORDERKEY, re:None immut}).fold ((\_accmap ->
      (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:82, rb:19, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:15, rb:None immut, rc:None immut,
           rd:None immut, re:Some LINEITEM_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:81, rb:15, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:15, rb:None immut, rc:None immut,
           rd:None immut, re:Some LINEITEM_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:80, rb:15, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:7, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:79, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:6, rb:None immut, rc:None immut,
           rd:None immut, re:Some LINEITEM_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:77, rb:6, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:7, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:76, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:6, rb:None immut, rc:None immut,
           rd:None immut, re:Some LINEITEM_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:76, rb:6, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:7, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:75, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:6, rb:None immut, rc:None immut,
           rd:None immut, re:Some LINEITEM_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:73, rb:6, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_int_int {ra:7, rb:None immut, rc:Some LINEITEM_ORDERKEY}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:72, rb:7, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:6, rb:None immut, rc:None immut,
           rd:None immut, re:Some LINEITEM_SUPPKEY}).fold ((\_accmap -> (\b3 ->
      bind b3 as {i:ip} in (_accmap.insert {ra:72, rb:6, rc:ip};_accmap))))
      empty { ra:int, rb:int, rc:address } @ { Collection }).combine
      (((route_to_string_string_int_int {ra:18, rb:None immut, rc:None immut,
           rd:Some LINEITEM_ORDERKEY, re:Some LINEITEM_SUPPKEY}).fold
      ((\_accmap -> (\b3 -> bind b3 as {i:ip} in 
      (_accmap.insert {ra:71, rb:18, rc:ip};_accmap)))) empty { ra:int, rb:int,
      rc:address } @ { Collection }).combine empty { ra:int, rb:int, rc:address
      } @ { Collection }))))))))))))).groupBy ((\b1 -> bind b1 as {ra:stmt_id,
      rb:map_id, rc:ip} in ip)) ((\acc -> (\b3 -> bind b3 as {ra:stmt_id,
      rb:map_id, rc:ip} in (acc.insert {key:stmt_id, value:map_id};acc))))
      empty { key:int, value:int } @ { Collection }).iterate ((\b1 ->
      bind b1 as {key:ip, value:stmt_map_ids} in 
      (nd_delete_LINEITEM_rcv_fetch, ip)<- {ra:stmt_map_ids, rb:vid,
      rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
      rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
      ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
      rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
      ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
      rr:LINEITEM_COMMENT}))))}{None ->
                                 error
                                   (print
                                      "unexpected missing arguments in sw_buf_delete_LINEITEM")})


declare nd_delete_LINEITEM_do_complete_s71 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((((({| key:int, value:int | let __val_ret__69 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__69, value:1}|} @ { Collection }).fold ((\_accext -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__14} in _accext.combine
    (((bind map_REVENUE_mLINEITEM4_s71_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       LINEITEM_ORDERKEY and re == LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 ->
      bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
      rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:LINEITEM_ORDERKEY, rd:LINEITEM_SUPPKEY,
    re:__map_ret__100} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:__map_ret__100};
     _accmap)))) empty { ra:string, rb:string, rc:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:__map_ret__100} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:__lift_ret__14 * __map_ret__100};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:__prod_ret__116} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:__prod_ret__116 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:__prod_ret__117} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:__prod_ret__117 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:__prod_ret__118} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:__prod_ret__118 * LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:__prod_ret__119} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:__prod_ret__119 * (-1 + LINEITEM_DISCOUNT)};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:__prod_ret__120} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:__prod_ret__120};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:false, rc:vid,
      rd:delta_values});
   (nd_complete_stmt_cntr_check {key:vid, value:71})))


declare nd_delete_LINEITEM_do_complete_s72 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((((({| key:int, value:int | let __val_ret__72 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__72, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__15} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__15 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__123} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__123 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__124} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mLINEITEM4_s72_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:LINEITEM_SUPPKEY, re:__map_ret__101} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__101};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__101} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__prod_ret__124 * __map_ret__101};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accext -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__prod_ret__125} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mLINEITEM5_s72_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rb:LINEITEM_ORDERKEY,
    rc:__map_ret__102} in 
    (_accmap.insert {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     value:__map_ret__102};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    value:__map_ret__102} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__125 * __map_ret__102};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__126} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__126 *
     (-LINEITEM_DISCOUNT * LINEITEM_EXTENDEDPRICE)};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int, rf:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__127} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__127};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_send_correctives {ra:me, rb:72, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:72}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:72, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_LINEITEM_do_complete_s73 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  ((((({| key:int, value:int | let __val_ret__76 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__76, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__16} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__16 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__130} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__130 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__131} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mLINEITEM4_s73_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:LINEITEM_SUPPKEY, re:__map_ret__103} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__103};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__103} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__prod_ret__131 * __map_ret__103};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__prod_ret__132} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__prod_ret__132 * (-LINEITEM_DISCOUNT * LINEITEM_EXTENDEDPRICE)};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__prod_ret__133} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:LINEITEM_ORDERKEY, rf:__prod_ret__133};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:REVENUE_mCUSTOMER11_mORDERS1, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_mORDERS1_send_correctives {ra:me, rb:73, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:73}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:73, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_LINEITEM_do_complete_s75 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  ((((({| key:int, value:int | let __val_ret__84 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__84, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__18} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__18 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__141} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__141 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__142} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mLINEITEM5_s75_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rb:LINEITEM_ORDERKEY,
    rc:__map_ret__104} in 
    (_accmap.insert {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     value:__map_ret__104};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    value:__map_ret__104} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:__prod_ret__142 * __map_ret__104};
     _accmap)))) empty { ra:int, rb:int, rc:int } @ { Collection })))) empty {
    ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:__prod_ret__143} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:__prod_ret__143 * (-LINEITEM_DISCOUNT * LINEITEM_EXTENDEDPRICE)};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__144} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:LINEITEM_SUPPKEY, rd:__prod_ret__144};
     _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_int_int_int_float {ra:REVENUE_mCUSTOMER11_mSUPPLIER1,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_mSUPPLIER1_send_correctives {ra:me, rb:75, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:75}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:75, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_LINEITEM_do_complete_s76 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((((({| key:int, value:int | let __val_ret__88 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__88, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__19} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__19 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__146} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__146 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__147} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mLINEITEM4_s76_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:LINEITEM_SUPPKEY, re:__map_ret__105} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__105};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__105} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__prod_ret__147 * __map_ret__105};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accext -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__prod_ret__148} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mLINEITEM5_s76_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rb:LINEITEM_ORDERKEY,
    rc:__map_ret__106} in 
    (_accmap.insert {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     value:__map_ret__106};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    value:__map_ret__106} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__148 * __map_ret__106};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int, rf:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int,
    re:int, rf:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__149} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__149 *
     -LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int, rf:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__150} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__150};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER12_send_correctives {ra:me, rb:76, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:76}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:76, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_LINEITEM_do_complete_s77 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  ((((({| key:int, value:int | let __val_ret__91 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__91, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__20} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__20 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__152} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__152 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__153} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mLINEITEM4_s77_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:LINEITEM_SUPPKEY, re:__map_ret__107} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__107};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__107} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__prod_ret__153 * __map_ret__107};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__prod_ret__154} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:__prod_ret__154 * -LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    re:__prod_ret__155} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
     re:LINEITEM_ORDERKEY, rf:__prod_ret__155};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:REVENUE_mCUSTOMER12_mORDERS1, rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER12_mORDERS1_send_correctives {ra:me, rb:77, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:77}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:77, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_LINEITEM_do_complete_s79 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  ((((({| key:int, value:int | let __val_ret__97 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__97, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__22} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__22 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__161} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__161 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__162} in _accext.combine (((bind
    map_REVENUE_mCUSTOMER11_mLINEITEM5_s79_buf as ind __x in
    (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
      ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc)))) empty { ra:int,
      rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rb:LINEITEM_ORDERKEY,
    rc:__map_ret__108} in 
    (_accmap.insert {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     value:__map_ret__108};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    value:__map_ret__108} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:__prod_ret__162 * __map_ret__108};
     _accmap)))) empty { ra:int, rb:int, rc:int } @ { Collection })))) empty {
    ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rc:__prod_ret__163} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:__prod_ret__163 * -LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
    rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__164} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
     rc:LINEITEM_SUPPKEY, rd:__prod_ret__164};
     _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_int_int_int_float {ra:REVENUE_mCUSTOMER12_mSUPPLIER1,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER12_mSUPPLIER1_send_correctives {ra:me, rb:79, rc:vid,
     rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:79}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:79, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_LINEITEM_do_complete_s80 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  ((((({| key:int, value:int | let __val_ret__100 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__100, value:1}|} @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__23} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__23 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__167} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__167 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__168} in _accext.combine (((bind
    map_REVENUE_mORDERS11_mLINEITEM4_s80_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mORDERSORDERS_CUSTKEY,
    rd:LINEITEM_SUPPKEY, re:__map_ret__109} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__109};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__109} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
     re:__prod_ret__168 * __map_ret__109};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
    re:__prod_ret__169} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
     re:__prod_ret__169 * (-LINEITEM_DISCOUNT * LINEITEM_EXTENDEDPRICE)};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
    re:__prod_ret__170} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_CUSTKEY,
     re:LINEITEM_ORDERKEY, rf:__prod_ret__170};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS11_send_correctives {ra:me, rb:80, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:80}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:80, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_LINEITEM_do_complete_s81 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  ((((({| key:int, value:int | let __val_ret__104 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__104, value:1}|} @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__24} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__24 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__172} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__172 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__173} in _accext.combine (((bind
    map_REVENUE_mORDERS11_mLINEITEM4_s81_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
       LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:REVENUE_mORDERSORDERS_CUSTKEY,
    rd:LINEITEM_SUPPKEY, re:__map_ret__110} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__110};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mORDERSORDERS_CUSTKEY, rd:__map_ret__110} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
     re:__prod_ret__173 * __map_ret__110};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
    re:__prod_ret__174} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
     re:__prod_ret__174 * -LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mORDERSORDERS_CUSTKEY,
    re:__prod_ret__175} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mORDERSORDERS_CUSTKEY,
     re:LINEITEM_ORDERKEY, rf:__prod_ret__175};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mORDERS12_send_correctives {ra:me, rb:81, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:81}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:81, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_LINEITEM_do_complete_s82 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  ((((({| key:int, value:int | let __val_ret__107 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__107, value:1}|} @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__25} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__25 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__178} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__178 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__179} in _accext.combine (((bind
    map_REVENUE_mLINEITEM4_mSUPPLIER1_s82_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       LINEITEM_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:LINEITEM_ORDERKEY,
    rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__111} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__111};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__111} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:__prod_ret__179 * __map_ret__111};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
    re:__prod_ret__180} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:__prod_ret__180 * (-LINEITEM_DISCOUNT * LINEITEM_EXTENDEDPRICE)};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
    re:__prod_ret__181} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:LINEITEM_SUPPKEY, rf:__prod_ret__181};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER11,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mSUPPLIER11_send_correctives {ra:me, rb:82, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:82}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:82, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_LINEITEM_do_complete_s83 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  ((((({| key:int, value:int | let __val_ret__111 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__111, value:1}|} @ { Collection }).fold ((\_accmap ->
    (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__26} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__26 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__183} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__183 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__184} in _accext.combine (((bind
    map_REVENUE_mLINEITEM4_mSUPPLIER1_s83_buf as ind __x in
    (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
       LINEITEM_ORDERKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
      rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
      (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
      empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
    rb:SHIPPING_CUST_NATION, rc:LINEITEM_ORDERKEY,
    rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, re:__map_ret__112} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__112};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
    rc:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY, rd:__map_ret__112} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:__prod_ret__184 * __map_ret__112};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int, re:int
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
    re:__prod_ret__185} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
     rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:__prod_ret__185 * -LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
    } @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
    rc:SHIPPING_CUST_NATION, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
    re:__prod_ret__186} in 
    (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
     rc:SHIPPING_L_YEAR, rd:REVENUE_mSUPPLIERSUPPLIER_NATIONKEY,
     re:LINEITEM_SUPPKEY, rf:__prod_ret__186};
     _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int, rf:real
    } @ { Collection } in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER12,
      rb:false, rc:vid, rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mSUPPLIER12_send_correctives {ra:me, rb:83, rc:vid, rd:1, re:vid,
     rf:delta_values} in
   if sent_msgs == 0 then nd_complete_stmt_cntr_check {key:vid, value:83}
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:83, rc:1, rd:sent_msgs,
         re:true, rf:false}))


declare nd_delete_LINEITEM_do_complete_s74 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((({| key:int, value:int | let __val_ret__80 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__80, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__17} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__17 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__136} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__136 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__137} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__137 *
     (-LINEITEM_DISCOUNT * LINEITEM_EXTENDEDPRICE)};
     _accmap)))) empty { key:int, value:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__138} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:LINEITEM_ORDERKEY,
     rc:LINEITEM_SUPPKEY, rd:__prod_ret__138};
     _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_int_int_int_float
      {ra:REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1, rb:false, rc:vid,
      rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_send_correctives {ra:me, rb:74,
     rc:vid, rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:74, rc:1, rd:sent_msgs,
         re:true, rf:true}))


declare nd_delete_LINEITEM_do_complete_s78 : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } -> () = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in let
  delta_values =
  (((({| key:int, value:int | let __val_ret__94 =
    date_part {key:"year", value:LINEITEM_SHIPDATE} in
    {key:__val_ret__94, value:1}|} @ { Collection }).fold ((\_accmap -> (\b3 ->
    bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__21} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__21 *
     if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__157} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__157 *
     if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
     _accmap)))) empty { key:int, value:int } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__158} in 
    (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__158 *
     -LINEITEM_EXTENDEDPRICE};
     _accmap)))) empty { key:int, value:real } @ { Collection }).fold
    ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
    value:__prod_ret__159} in 
    (_accmap.insert {ra:SHIPPING_L_YEAR, rb:LINEITEM_ORDERKEY,
     rc:LINEITEM_SUPPKEY, rd:__prod_ret__159};
     _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection } in
  ((nd_add_delta_to_int_int_int_float
      {ra:REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1, rb:false, rc:vid,
      rd:delta_values});
   let sent_msgs =
   nd_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_send_correctives {ra:me, rb:78,
     rc:vid, rd:1, re:vid, rf:delta_values} in
   if sent_msgs == 0 then ()
     else
       nd_update_stmt_cntr_corr_map {ra:vid, rb:78, rc:1, rd:sent_msgs,
         re:true, rf:true}))


declare delete_LINEITEM_do_corrective_s71_m_REVENUE_mLINEITEM4 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int }, rf:int,
  rg:int, rh:int, ri:int, rj:real, rk:real, rl:real, rm:real, rn:string,
  ro:string, rp:int, rq:int, rr:int, rs:string, rt:string, ru:string,
  rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    rd:delta_REVENUE_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mLINEITEM4} in _accext.combine (let delta_values =
    ((((((({| key:int, value:int | let __val_ret__262 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__262, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__71} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__71 *
       ((if LINEITEM_SUPPKEY == delta_REVENUE_mLINEITEMLINEITEM_SUPPKEY 
       then 1 else 0) *
       if LINEITEM_ORDERKEY == delta_REVENUE_mLINEITEMLINEITEM_ORDERKEY 
       then 1 else 0)};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__439} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__439 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__440} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__440 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__441} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__441 *
       delta_REVENUE_mLINEITEM4};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__442} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__442 *
       LINEITEM_EXTENDEDPRICE};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__443} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__443 * (-1 +
       LINEITEM_DISCOUNT)};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__444} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR, rd:__prod_ret__444};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:real
      } @ { Collection } in delta_values)))) empty { ra:string, rb:string,
    rc:int, rd:real } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0,
    rb:map_1, rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_float {ra:REVENUE, rb:true, rc:vid,
      rd:new_tuples});
   0))


declare delete_LINEITEM_do_corrective_s72_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mCUSTOMER11_mLINEITEM4} in _accext.combine (let
    delta_values =
    (((((({| key:int, value:int | let __val_ret__266 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__266, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__72} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__72 *
       if LINEITEM_SUPPKEY ==
         delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__448} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__448 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__449} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__449 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__450} in _accext.combine (((bind
      map_REVENUE_mCUSTOMER11_mLINEITEM5_s72_buf as ind __x in
      (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
        rd:map_val} in (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc))))
        empty { ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
      rb:LINEITEM_ORDERKEY, rc:__map_ret__131} in 
      (_accmap.insert {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
       value:__map_ret__131};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
      value:__map_ret__131} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__450 *
       __map_ret__131};
       _accmap)))) empty { ra:int, rb:int, rc:int } @ { Collection }))))
      empty { ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__451} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__451 *
       ((-delta_REVENUE_mCUSTOMER11_mLINEITEM4 * LINEITEM_DISCOUNT) *
       LINEITEM_EXTENDEDPRICE)};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__452} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__452};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_LINEITEM_do_corrective_s72_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:int, rb:int, rc:int } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
  rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
  rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
  rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE,
  rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
  rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mLINEITEM5} in _accext.combine (let
    delta_values =
    (((((({| key:int, value:int | let __val_ret__338 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__338, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__88} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__88 *
       if LINEITEM_ORDERKEY ==
         delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY then 1 
       else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__560} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__560 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__561} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__561 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__562} in _accext.combine (((bind
      map_REVENUE_mCUSTOMER11_mLINEITEM4_s72_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
         LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      rd:LINEITEM_SUPPKEY, re:__map_ret__139} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__139};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__139} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
       rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:__prod_ret__562 * __map_ret__139};
       _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
      } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int,
      re:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
      rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      re:__prod_ret__563} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
       rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:__prod_ret__563 * ((-delta_REVENUE_mCUSTOMER11_mLINEITEM5 *
       LINEITEM_DISCOUNT) * LINEITEM_EXTENDEDPRICE)};
       _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
      rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      re:__prod_ret__564} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__564};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_LINEITEM_do_corrective_s73_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mCUSTOMER11_mLINEITEM4} in _accext.combine (let
    delta_values =
    ((((({| key:int, value:int | let __val_ret__271 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__271, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__73} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__73 *
       if LINEITEM_SUPPKEY ==
         delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__456} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__456 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__457} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__457 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__458} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__458 *
       ((-delta_REVENUE_mCUSTOMER11_mLINEITEM4 * LINEITEM_DISCOUNT) *
       LINEITEM_EXTENDEDPRICE)};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__459} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, re:LINEITEM_ORDERKEY,
       rf:__prod_ret__459};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:REVENUE_mCUSTOMER11_mORDERS1, rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER11_mORDERS1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_LINEITEM_do_corrective_s75_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:int, rb:int, rc:int } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
  rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
  rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
  rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE,
  rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
  rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mLINEITEM5} in _accext.combine (let
    delta_values =
    ((((({| key:int, value:int | let __val_ret__343 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__343, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__89} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__89 *
       if LINEITEM_ORDERKEY ==
         delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY then 1 
       else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__568} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__568 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__569} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__569 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__570} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__570 *
       ((-delta_REVENUE_mCUSTOMER11_mLINEITEM5 * LINEITEM_DISCOUNT) *
       LINEITEM_EXTENDEDPRICE)};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__571} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:LINEITEM_SUPPKEY,
       rd:__prod_ret__571};
       _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection }
    in delta_values)))) empty { ra:int, rb:int, rc:int, rd:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_int_float {ra:REVENUE_mCUSTOMER11_mSUPPLIER1,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER11_mSUPPLIER1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_LINEITEM_do_corrective_s76_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mCUSTOMER11_mLINEITEM4} in _accext.combine (let
    delta_values =
    (((((({| key:int, value:int | let __val_ret__276 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__276, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__74} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__74 *
       if LINEITEM_SUPPKEY ==
         delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__462} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__462 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__463} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__463 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__464} in _accext.combine (((bind
      map_REVENUE_mCUSTOMER11_mLINEITEM5_s76_buf as ind __x in
      (frontier_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc == LINEITEM_ORDERKEY))}).fold
        ((\acc -> (\b3 -> bind b3 as {ra:vid, rb:map_0, rc:map_1,
        rd:map_val} in (acc.insert {ra:map_0, rb:map_1, rc:map_val};acc))))
        empty { ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
      rb:LINEITEM_ORDERKEY, rc:__map_ret__132} in 
      (_accmap.insert {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
       value:__map_ret__132};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
      value:__map_ret__132} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__464 *
       __map_ret__132};
       _accmap)))) empty { ra:int, rb:int, rc:int } @ { Collection }))))
      empty { ra:int, rb:int, rc:int } @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__465} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__465 *
       (-delta_REVENUE_mCUSTOMER11_mLINEITEM4 * LINEITEM_EXTENDEDPRICE)};
       _accmap)))) empty { ra:int, rb:int, rc:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_L_YEAR,
      rb:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:__prod_ret__466} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__466};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_LINEITEM_do_corrective_s76_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:int, rb:int, rc:int } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
  rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
  rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
  rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE,
  rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
  rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mLINEITEM5} in _accext.combine (let
    delta_values =
    (((((({| key:int, value:int | let __val_ret__348 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__348, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__90} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__90 *
       if LINEITEM_ORDERKEY ==
         delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY then 1 
       else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__574} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__574 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__575} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__575 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accext -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__576} in _accext.combine (((bind
      map_REVENUE_mCUSTOMER11_mLINEITEM4_s76_buf as ind __x in
      (frontier_string_string_int_int_int {key:vid, value:__x.filter ((\b1 ->
         bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
         LINEITEM_SUPPKEY))}).fold ((\acc -> (\b3 -> bind b3 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        (acc.insert {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_val};acc))))
        empty { ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {ra:SHIPPING_SUPP_NATION,
      rb:SHIPPING_CUST_NATION, rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      rd:LINEITEM_SUPPKEY, re:__map_ret__140} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__140};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
      rc:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, rd:__map_ret__140} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
       rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:__prod_ret__576 * __map_ret__140};
       _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:int
      } @ { Collection })))) empty { ra:int, rb:string, rc:string, rd:int,
      re:int } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
      rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      re:__prod_ret__577} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
       rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:__prod_ret__577 * (-delta_REVENUE_mCUSTOMER11_mLINEITEM5 *
       LINEITEM_EXTENDEDPRICE)};
       _accmap)))) empty { ra:int, rb:string, rc:string, rd:int, re:real
      } @ { Collection }).fold ((\_accmap -> (\b3 ->
      bind b3 as {ra:SHIPPING_L_YEAR, rb:SHIPPING_SUPP_NATION,
      rc:SHIPPING_CUST_NATION, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
      re:__prod_ret__578} in 
      (_accmap.insert {ra:SHIPPING_SUPP_NATION, rb:SHIPPING_CUST_NATION,
       rc:SHIPPING_L_YEAR, rd:REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
       re:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rf:__prod_ret__578};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mCUSTOMER12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_LINEITEM_do_corrective_s77_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY,
    rd:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mCUSTOMER11_mLINEITEM4} in _accext.combine (let
    delta_values =
    ((((({| key:int, value:int | let __val_ret__280 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__280, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__75} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__75 *
       if LINEITEM_SUPPKEY ==
         delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_SUPPKEY then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__469} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__469 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__470} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__470 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__471} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__471 *
       (-delta_REVENUE_mCUSTOMER11_mLINEITEM4 * LINEITEM_EXTENDEDPRICE)};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__472} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mCUSTOMERCUSTOMER_NATIONKEY, re:LINEITEM_ORDERKEY,
       rf:__prod_ret__472};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:REVENUE_mCUSTOMER12_mORDERS1, rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER12_mORDERS1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_LINEITEM_do_corrective_s79_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:int, rb:int, rc:int } @ { Collection }
  } -> int = (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid,
  rd:hop, re:vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
  rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
  rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
  rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS, rp:LINEITEM_SHIPDATE,
  rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
  rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples} in let new_tuples
  =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY,
    rb:delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY,
    rc:delta_REVENUE_mCUSTOMER11_mLINEITEM5} in _accext.combine (let
    delta_values =
    ((((({| key:int, value:int | let __val_ret__352 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__352, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__91} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__91 *
       if LINEITEM_ORDERKEY ==
         delta_REVENUE_mCUSTOMER11_mLINEITEMLINEITEM_ORDERKEY then 1 
       else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__581} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__581 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__582} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__582 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__583} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__583 *
       (-delta_REVENUE_mCUSTOMER11_mLINEITEM5 * LINEITEM_EXTENDEDPRICE)};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__584} in 
      (_accmap.insert {ra:SHIPPING_L_YEAR,
       rb:delta_REVENUE_mCUSTOMERCUSTOMER_CUSTKEY, rc:LINEITEM_SUPPKEY,
       rd:__prod_ret__584};
       _accmap)))) empty { ra:int, rb:int, rc:int, rd:real } @ { Collection }
    in delta_values)))) empty { ra:int, rb:int, rc:int, rd:real
    } @ { Collection }).filter ((\b1 -> bind b1 as {ra:map_0, rb:map_1,
    rc:map_2, rd:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_int_int_int_float {ra:REVENUE_mCUSTOMER12_mSUPPLIER1,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mCUSTOMER12_mSUPPLIER1_send_correctives {ra:orig_addr,
      rb:orig_stmt_id, rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_LINEITEM_do_corrective_s80_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mORDERS11_mLINEITEM4} in _accext.combine (let delta_values
    =
    ((((({| key:int, value:int | let __val_ret__410 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__410, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__104} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__104 *
       if LINEITEM_SUPPKEY == delta_REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY
       then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__672} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__672 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__673} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__673 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__674} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__674 *
       ((-delta_REVENUE_mORDERS11_mLINEITEM4 * LINEITEM_DISCOUNT) *
       LINEITEM_EXTENDEDPRICE)};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__675} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mORDERSORDERS_CUSTKEY, re:LINEITEM_ORDERKEY,
       rf:__prod_ret__675};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_LINEITEM_do_corrective_s81_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mORDERSORDERS_CUSTKEY,
    rd:delta_REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY,
    re:delta_REVENUE_mORDERS11_mLINEITEM4} in _accext.combine (let delta_values
    =
    ((((({| key:int, value:int | let __val_ret__415 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__415, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__105} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__105 *
       if LINEITEM_SUPPKEY == delta_REVENUE_mORDERS11_mLINEITEMLINEITEM_SUPPKEY
       then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__678} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__678 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__679} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__679 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__680} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__680 *
       (-delta_REVENUE_mORDERS11_mLINEITEM4 * LINEITEM_EXTENDEDPRICE)};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__681} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mORDERSORDERS_CUSTKEY, re:LINEITEM_ORDERKEY,
       rf:__prod_ret__681};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mORDERS12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mORDERS12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_LINEITEM_do_corrective_s82_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    rd:delta_REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mLINEITEM4_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((({| key:int, value:int | let __val_ret__428 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__428, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__108} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__108 *
       if LINEITEM_ORDERKEY == delta_REVENUE_mLINEITEMLINEITEM_ORDERKEY 
       then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__698} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__698 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__699} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__699 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__700} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__700 *
       ((-delta_REVENUE_mLINEITEM4_mSUPPLIER1 * LINEITEM_DISCOUNT) *
       LINEITEM_EXTENDEDPRICE)};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__701} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
       re:LINEITEM_SUPPKEY, rf:__prod_ret__701};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER11,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mSUPPLIER11_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


declare delete_LINEITEM_do_corrective_s83_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:int, rg:int, rh:int, ri:int, rj:real, rk:real, rl:real,
  rm:real, rn:string, ro:string, rp:int, rq:int, rr:int, rs:string, rt:string,
  ru:string, rv:collection { ra:string, rb:string, rc:int, rd:int, re:int
  } @ { Collection } } -> int = (\b1 -> bind b1 as {ra:orig_addr,
  rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid, rf:LINEITEM_ORDERKEY,
  rg:LINEITEM_PARTKEY, rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER,
  rj:LINEITEM_QUANTITY, rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT,
  rm:LINEITEM_TAX, rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
  rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE, rr:LINEITEM_RECEIPTDATE,
  rs:LINEITEM_SHIPINSTRUCT, rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT,
  rv:delta_tuples} in let new_tuples =
  (delta_tuples.fold ((\_accext -> (\b3 ->
    bind b3 as {ra:delta_SHIPPING_SUPP_NATION, rb:delta_SHIPPING_CUST_NATION,
    rc:delta_REVENUE_mLINEITEMLINEITEM_ORDERKEY,
    rd:delta_REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
    re:delta_REVENUE_mLINEITEM4_mSUPPLIER1} in _accext.combine (let
    delta_values =
    ((((({| key:int, value:int | let __val_ret__433 =
      date_part {key:"year", value:LINEITEM_SHIPDATE} in
      {key:__val_ret__433, value:1}|} @ { Collection }).fold ((\_accmap ->
      (\b3 -> bind b3 as {key:SHIPPING_L_YEAR, value:__lift_ret__109} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__lift_ret__109 *
       if LINEITEM_ORDERKEY == delta_REVENUE_mLINEITEMLINEITEM_ORDERKEY 
       then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__704} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__704 *
       if 19950101 <= LINEITEM_SHIPDATE then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__705} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__705 *
       if LINEITEM_SHIPDATE <= 19961231 then 1 else 0};
       _accmap)))) empty { key:int, value:int } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__706} in 
      (_accmap.insert {key:SHIPPING_L_YEAR, value:__prod_ret__706 *
       (-delta_REVENUE_mLINEITEM4_mSUPPLIER1 * LINEITEM_EXTENDEDPRICE)};
       _accmap)))) empty { key:int, value:real } @ { Collection }).fold
      ((\_accmap -> (\b3 -> bind b3 as {key:SHIPPING_L_YEAR,
      value:__prod_ret__707} in 
      (_accmap.insert {ra:delta_SHIPPING_SUPP_NATION,
       rb:delta_SHIPPING_CUST_NATION, rc:SHIPPING_L_YEAR,
       rd:delta_REVENUE_mLINEITEM4_mSUPPLIERSUPPLIER_NATIONKEY,
       re:LINEITEM_SUPPKEY, rf:__prod_ret__707};
       _accmap)))) empty { ra:string, rb:string, rc:int, rd:int, re:int,
      rf:real } @ { Collection } in delta_values)))) empty { ra:string,
    rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection }).filter
    ((\b1 -> bind b1 as {ra:map_0, rb:map_1, rc:map_2, rd:map_3, re:map_4,
    rf:map_val} in 0 != map_val)) in
  ((nd_add_delta_to_string_string_int_int_int_float {ra:REVENUE_mSUPPLIER12,
      rb:true, rc:vid, rd:new_tuples});
   (nd_REVENUE_mSUPPLIER12_send_correctives {ra:orig_addr, rb:orig_stmt_id,
      rc:orig_vid, rd:1 + hop, re:vid, rf:new_tuples})))


trigger ms_rcv_sw_init_ack : () = (\_u ->
  (ms_rcv_sw_init_ack_cnt = ms_rcv_sw_init_ack_cnt + 1;
   (if ms_rcv_sw_init_ack_cnt == num_switches
   then
     (ms_start_time = now_int ();
      (sw_rcv_token, sw_next_switch_addr)<- g_start_vid;
      (tm_insert_timer, timer_addr)<- {ra:ms_gc_interval, rb:0, rc:me})
   else ())))
trigger sw_rcv_init : () = (\_u ->
  (sw_init = true;
   (sw_driver_trig, me)<- ();
   (ms_rcv_sw_init_ack, master_addr)<- ()))
trigger ms_rcv_jobs_ack : () = (\_u ->
  (ms_rcv_jobs_ack_cnt = ms_rcv_jobs_ack_cnt + 1;
   (if ms_rcv_jobs_ack_cnt == num_peers
   then
     (switches.iterate ((\b1 -> bind b1 as {i:addr} in 
      (sw_rcv_init, addr)<- ()))) else ())))
trigger rcv_jobs : collection { key:address, value:int } @ { Map } =
  (\jobs_in ->
  (jobs = jobs_in;
   timer_addr = case ((jobs.filter ((\b1 -> bind b1 as {key:addr,
   value:job} in job == job_timer))).peek ()) of
   {Some timer -> timer.key}{None -> error (print "no timer peer found")};
   nodes = (jobs.filter ((\b1 -> bind b1 as {key:addr, value:job} in job ==
   job_node))).fold ((\_accmap -> (\x ->
   (_accmap.insert ({i:x.key});_accmap)))) empty {i:address} @ { Collection };
   num_nodes = nodes.size ();
   switches = (jobs.filter ((\b1 -> bind b1 as {key:addr, value:job} in job ==
   job_switch))).fold ((\_accmap -> (\x ->
   (_accmap.insert ({i:x.key});_accmap)))) empty {i:address} @ { Collection };
   num_switches = switches.size ();
   (if job <= job_switch
   then sw_next_switch_addr = let addr_list =
     (switches.fold ((\acc_conv -> (\b3 -> bind b3 as {i:x} in 
       (acc_conv.insert {i:x};acc_conv)))) empty {i:address} @ { Seq }).sort
       ((\b2 -> (\b3 -> bind b2 as {i:addr1} in bind b3 as {i:addr2} in 
       if addr1 < addr2 then -1 else 1))) in
     case (addr_list.peek ()) of
       {Some first_addr -> (addr_list.fold ((\b2 -> (\b5 ->
         bind b2 as {key:take, value:result} in bind b5 as {i:x} in if take
         then {key:false, value:x}
         else if x == me then {key:true, value:result}
           else {key:take, value:result}))) {key:false,
         value:first_addr.i}).value}{None ->
                                      error (print "no addresses in addr_list")}
   else ());
   nodes.iterate ((\b1 -> bind b1 as {i:addr} in add_node addr));
   (ms_rcv_jobs_ack, master_addr)<- ()))
trigger ms_rcv_job : { key:address, value:int } = (\b1 -> bind b1 as {key:addr,
  value:job} in 
  (jobs.insert {key:addr, value:job};
   ms_rcv_job_cnt = ms_rcv_job_cnt + 1;
   (if ms_rcv_job_cnt == num_peers
   then my_peers.iterate ((\b1 -> bind b1 as {i:addr} in 
     (rcv_jobs, addr)<- jobs)) else ())))
trigger rcv_master_addr : address = (\addr ->
  (master_addr = addr;(ms_rcv_job, addr)<- {key:me, value:job}))
trigger ms_send_addr_self : () = (\_u -> my_peers.iterate ((\b1 ->
  bind b1 as {i:addr} in (rcv_master_addr, addr)<- me)))
trigger shutdown_trig : () = (\_u -> haltEngine ())
trigger ms_shutdown : () = (\_u -> if ms_rcv_node_done_cnt == num_nodes
  then my_peers.iterate ((\b1 -> bind b1 as {i:addr} in 
    (shutdown_trig, addr)<- ())) else ())
trigger ms_rcv_node_done : bool = (\done -> if done
  then
    (ms_rcv_node_done_cnt = ms_rcv_node_done_cnt + 1;
     (if ms_rcv_node_done_cnt == num_nodes
     then (ms_end_time = now_int ();(ms_shutdown, me)<- ()) else ()))
  else ms_rcv_node_done_cnt = ms_rcv_node_done_cnt - 1)
trigger nd_rcv_done : () = (\_u ->
  (nd_rcvd_sys_done = true;
   (if not nd_sent_done and nd_stmt_cntrs.size () == 0
   then ((ms_rcv_node_done, master_addr)<- true;nd_sent_done = true) 
   else ())))
trigger ms_rcv_switch_done : () = (\_u ->
  (ms_rcv_switch_done_cnt = ms_rcv_switch_done_cnt + 1;
   (if ms_rcv_switch_done_cnt == num_switches
   then nodes.iterate ((\b1 -> bind b1 as {i:addr} in 
     (nd_rcv_done, addr)<- ())) else ())))
trigger sw_ack_rcv : { key:address, value:{ key:int, value:int } } = (\b1 ->
  bind b1 as {key:addr, value:vid} in 
  (sw_num_ack = sw_num_ack + 1;
   (case ((sw_ack_log.filter ((\b1 -> bind b1 as {key:key, value:value} in key
   == vid))).peek ()) of
   {Some x -> if x.value == 0 then sw_ack_log.erase x
     else sw_ack_log.update x {key:vid, value:x.value - 1}}{None -> ()});
   (if not sw_sent_done and (sw_trig_buf_idx.size () == 0 and (sw_num_ack ==
      sw_num_sent and sw_seen_sentry == true))
   then ((ms_rcv_switch_done, master_addr)<- ();sw_sent_done = true) 
   else ())))
trigger ms_rcv_gc_vid : { key:address, value:{ key:int, value:int } } =
  (\data ->
  (ms_gc_vid_map.insert data;
   ms_gc_vid_ctr = ms_gc_vid_ctr + 1;
   (if ms_gc_vid_ctr >= ms_num_gc_expected
   then let min_vid =
     ms_gc_vid_map.fold ((\min_vid -> (\b3 -> bind b3 as {key:addr,
       value:vid} in if min_vid < vid then min_vid else vid))) g_min_vid in
     (ms_gc_vid_ctr = 0;
      ms_gc_vid_map = empty { key:address, value:{ key:int, value:int }
      } @ { Map };
      my_peers.iterate ((\b1 -> bind b1 as {i:addr} in 
      (do_gc, addr)<- min_vid));
      (tm_insert_timer, timer_addr)<- {ra:ms_gc_interval, rb:0, rc:me})
   else ())))
trigger rcv_req_gc_vid : () = (\_u -> if job == job_switch or job == job_master
  then (ms_rcv_gc_vid, master_addr)<- {key:me, value:sw_ack_log.fold
    ((\min_vid -> (\b3 -> bind b3 as {key:vid, value:count} in if min_vid < vid
    then min_vid else vid))) sw_highest_vid}
  else if job == job_node
    then (ms_rcv_gc_vid, master_addr)<- {key:me, value:nd_stmt_cntrs.fold
      ((\min_vid -> (\b3 -> bind b3 as {key:vid_stmt_id, value:ctr_corrs} in 
      if min_vid < vid_stmt_id.key then min_vid else vid_stmt_id.key)))
      g_max_vid} else ())
trigger ms_send_gc_req : () = (\_u -> my_peers.iterate ((\b1 ->
  bind b1 as {i:addr} in (rcv_req_gc_vid, addr)<- ())))
trigger do_gc : { key:int, value:int } = (\min_gc_vid ->
  (let temp = empty { key:{ key:int, value:int }, value:int } @ { Set } in
   (nd_log_master.iterate ((\b1 -> bind b1 as {key:vid, value:stmt_id} in 
    if vid < min_gc_vid then temp.insert {key:vid, value:stmt_id} else ()));
    temp.iterate ((\val -> nd_log_master.erase val)));
   let temp =
   empty { key:{ key:int, value:int }, value:{ ra:int, rb:string, rc:string,
     rd:int, re:string, rf:real, rg:string } } @ { Map } in
   (nd_log_insert_SUPPLIER.iterate ((\b1 -> bind b1 as {key:vid,
    value:args} in if vid < min_gc_vid then temp.insert {key:vid, value:args}
    else ()));
    temp.iterate ((\val -> nd_log_insert_SUPPLIER.erase val)));
   let temp =
   empty { key:{ key:int, value:int }, value:{ ra:int, rb:string, rc:string,
     rd:int, re:string, rf:real, rg:string } } @ { Map } in
   (nd_log_delete_SUPPLIER.iterate ((\b1 -> bind b1 as {key:vid,
    value:args} in if vid < min_gc_vid then temp.insert {key:vid, value:args}
    else ()));
    temp.iterate ((\val -> nd_log_delete_SUPPLIER.erase val)));
   let temp =
   empty { key:{ key:int, value:int }, value:{ ra:int, rb:string, rc:string,
     rd:int, re:string, rf:real, rg:string, rh:string } } @ { Map } in
   (nd_log_insert_CUSTOMER.iterate ((\b1 -> bind b1 as {key:vid,
    value:args} in if vid < min_gc_vid then temp.insert {key:vid, value:args}
    else ()));
    temp.iterate ((\val -> nd_log_insert_CUSTOMER.erase val)));
   let temp =
   empty { key:{ key:int, value:int }, value:{ ra:int, rb:string, rc:string,
     rd:int, re:string, rf:real, rg:string, rh:string } } @ { Map } in
   (nd_log_delete_CUSTOMER.iterate ((\b1 -> bind b1 as {key:vid,
    value:args} in if vid < min_gc_vid then temp.insert {key:vid, value:args}
    else ()));
    temp.iterate ((\val -> nd_log_delete_CUSTOMER.erase val)));
   let temp =
   empty { key:{ key:int, value:int }, value:{ ra:int, rb:int, rc:string,
     rd:real, re:int, rf:string, rg:string, rh:int, ri:string } } @ { Map } in
   (nd_log_insert_ORDERS.iterate ((\b1 -> bind b1 as {key:vid, value:args} in 
    if vid < min_gc_vid then temp.insert {key:vid, value:args} else ()));
    temp.iterate ((\val -> nd_log_insert_ORDERS.erase val)));
   let temp =
   empty { key:{ key:int, value:int }, value:{ ra:int, rb:int, rc:string,
     rd:real, re:int, rf:string, rg:string, rh:int, ri:string } } @ { Map } in
   (nd_log_delete_ORDERS.iterate ((\b1 -> bind b1 as {key:vid, value:args} in 
    if vid < min_gc_vid then temp.insert {key:vid, value:args} else ()));
    temp.iterate ((\val -> nd_log_delete_ORDERS.erase val)));
   let temp =
   empty { key:{ key:int, value:int }, value:{ ra:int, rb:int, rc:int, rd:int,
     re:real, rf:real, rg:real, rh:real, ri:string, rj:string, rk:int, rl:int,
     rm:int, rn:string, ro:string, rp:string } } @ { Map } in
   (nd_log_insert_LINEITEM.iterate ((\b1 -> bind b1 as {key:vid,
    value:args} in if vid < min_gc_vid then temp.insert {key:vid, value:args}
    else ()));
    temp.iterate ((\val -> nd_log_insert_LINEITEM.erase val)));
   let temp =
   empty { key:{ key:int, value:int }, value:{ ra:int, rb:int, rc:int, rd:int,
     re:real, rf:real, rg:real, rh:real, ri:string, rj:string, rk:int, rl:int,
     rm:int, rn:string, ro:string, rp:string } } @ { Map } in
   (nd_log_delete_LINEITEM.iterate ((\b1 -> bind b1 as {key:vid,
    value:args} in if vid < min_gc_vid then temp.insert {key:vid, value:args}
    else ()));
    temp.iterate ((\val -> nd_log_delete_LINEITEM.erase val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mSUPPLIER11_s0_buf as ind
     map_REVENUE_mSUPPLIER11_s0_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mSUPPLIER11_s0_buf_unwrap} in
       (map_REVENUE_mSUPPLIER11_s0_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> map_REVENUE_mSUPPLIER11_s0_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_REVENUE_mSUPPLIER11_s0_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mSUPPLIER12_s0_buf as ind
     map_REVENUE_mSUPPLIER12_s0_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mSUPPLIER12_s0_buf_unwrap} in
       (map_REVENUE_mSUPPLIER12_s0_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> map_REVENUE_mSUPPLIER12_s0_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_REVENUE_mSUPPLIER12_s0_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s1_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s1_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s1_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s1_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s1_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s1_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s1_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s1_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s1_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s1_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s1_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s1_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s2_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s2_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s2_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s2_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s2_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s2_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s2_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s2_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s2_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s2_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s2_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s2_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s3_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s3_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s3_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s3_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s3_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s3_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s4_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s4_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s4_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s4_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s4_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s4_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s4_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s4_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s4_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s4_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s4_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s4_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s5_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s5_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s5_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s5_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s5_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s5_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s5_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s5_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s5_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s5_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s5_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s5_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s6_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s6_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s6_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s6_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s6_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s6_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s6_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s6_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s6_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s6_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s6_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s6_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s7_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s7_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s7_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s7_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s7_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s7_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s8_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s8_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s8_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s8_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s8_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s8_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s8_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s8_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s8_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s8_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s8_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s8_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mLINEITEM4_mSUPPLIER1_s9_buf as ind
     map_REVENUE_mLINEITEM4_mSUPPLIER1_s9_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mLINEITEM4_mSUPPLIER1_s9_buf_unwrap} in
       (map_REVENUE_mLINEITEM4_mSUPPLIER1_s9_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mLINEITEM4_mSUPPLIER1_s9_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mLINEITEM4_mSUPPLIER1_s9_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mSUPPLIER11_s10_buf as ind
     map_REVENUE_mSUPPLIER11_s10_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mSUPPLIER11_s10_buf_unwrap} in
       (map_REVENUE_mSUPPLIER11_s10_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> map_REVENUE_mSUPPLIER11_s10_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_REVENUE_mSUPPLIER11_s10_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mSUPPLIER12_s10_buf as ind
     map_REVENUE_mSUPPLIER12_s10_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mSUPPLIER12_s10_buf_unwrap} in
       (map_REVENUE_mSUPPLIER12_s10_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> map_REVENUE_mSUPPLIER12_s10_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_REVENUE_mSUPPLIER12_s10_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s11_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s11_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s11_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s11_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s11_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s11_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s11_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s11_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s11_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s11_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s11_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s11_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s12_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s12_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s12_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s12_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s12_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s12_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s12_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s12_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s12_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s12_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s12_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s12_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s13_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s13_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s13_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s13_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s13_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s13_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s14_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s14_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s14_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s14_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s14_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s14_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s14_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s14_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s14_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s14_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s14_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s14_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s15_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s15_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s15_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s15_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s15_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s15_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s15_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s15_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s15_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s15_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s15_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s15_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s16_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s16_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s16_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s16_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s16_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s16_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s16_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s16_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s16_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s16_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s16_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s16_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s17_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s17_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s17_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s17_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s17_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s17_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s18_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s18_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s18_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s18_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s18_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s18_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s18_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s18_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s18_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s18_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s18_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s18_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mLINEITEM4_mSUPPLIER1_s19_buf as ind
     map_REVENUE_mLINEITEM4_mSUPPLIER1_s19_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mLINEITEM4_mSUPPLIER1_s19_buf_unwrap} in
       (map_REVENUE_mLINEITEM4_mSUPPLIER1_s19_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mLINEITEM4_mSUPPLIER1_s19_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mLINEITEM4_mSUPPLIER1_s19_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_s20_buf as ind
     map_REVENUE_mCUSTOMER11_s20_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_s20_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_s20_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> map_REVENUE_mCUSTOMER11_s20_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_s20_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_s20_buf as ind
     map_REVENUE_mCUSTOMER12_s20_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_s20_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_s20_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> map_REVENUE_mCUSTOMER12_s20_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_s20_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_s21_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_s21_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_s21_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_s21_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_s21_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_s21_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s22_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s22_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s22_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s22_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s22_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s22_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s23_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s23_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s23_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s23_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s23_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s23_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_s24_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_s24_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_s24_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_s24_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_s24_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_s24_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s25_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s25_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s25_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s25_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s25_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s25_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s25_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s25_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s25_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s25_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s25_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s25_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s26_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s26_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s26_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s26_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s26_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s26_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s26_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s26_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s26_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s26_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s26_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s26_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s27_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s27_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s27_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s27_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s27_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s27_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s27_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s27_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s27_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s27_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s27_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s27_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s28_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s28_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s28_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s28_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s28_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s28_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s28_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s28_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s28_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s28_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s28_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s28_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_s29_buf as ind
     map_REVENUE_mCUSTOMER11_s29_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_s29_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_s29_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> map_REVENUE_mCUSTOMER11_s29_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_s29_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_s29_buf as ind
     map_REVENUE_mCUSTOMER12_s29_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_s29_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_s29_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> map_REVENUE_mCUSTOMER12_s29_buf_unwrap.erase
        val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_s29_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_s30_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_s30_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_s30_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_s30_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_s30_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_s30_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s31_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s31_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s31_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s31_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s31_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s31_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s32_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s32_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s32_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s32_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s32_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s32_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_s33_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_s33_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_s33_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_s33_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_s33_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_s33_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s34_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s34_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s34_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s34_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s34_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s34_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s34_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s34_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s34_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s34_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s34_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s34_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s35_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s35_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s35_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s35_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s35_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s35_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s35_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s35_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s35_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s35_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s35_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s35_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s36_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s36_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s36_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s36_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s36_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s36_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s36_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s36_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s36_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s36_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s36_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s36_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s37_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s37_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s37_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s37_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s37_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s37_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s37_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s37_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s37_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s37_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s37_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s37_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mORDERS11_s38_buf as ind
     map_REVENUE_mORDERS11_s38_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_s38_buf_unwrap} in
       (map_REVENUE_mORDERS11_s38_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> map_REVENUE_mORDERS11_s38_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_REVENUE_mORDERS11_s38_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mORDERS12_s38_buf as ind
     map_REVENUE_mORDERS12_s38_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mORDERS12_s38_buf_unwrap} in
       (map_REVENUE_mORDERS12_s38_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> map_REVENUE_mORDERS12_s38_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_REVENUE_mORDERS12_s38_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_s39_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_s39_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_s39_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_s39_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_s39_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_s39_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s41_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s41_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s41_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s41_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s41_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s41_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_s42_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_s42_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_s42_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_s42_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_s42_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_s42_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s43_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s43_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s43_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s43_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s43_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s43_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mLINEITEM4_s44_buf as ind
     map_REVENUE_mORDERS11_mLINEITEM4_s44_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mLINEITEM4_s44_buf_unwrap} in
       (map_REVENUE_mORDERS11_mLINEITEM4_s44_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mLINEITEM4_s44_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mLINEITEM4_s44_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s45_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s45_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s45_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s45_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s45_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s45_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s46_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s46_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s46_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s46_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s46_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s46_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s46_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s46_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s46_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s46_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s46_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s46_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s47_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s47_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s47_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s47_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s47_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s47_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s47_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s47_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s47_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s47_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s47_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s47_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mORDERS11_s48_buf as ind
     map_REVENUE_mORDERS11_s48_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_s48_buf_unwrap} in
       (map_REVENUE_mORDERS11_s48_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> map_REVENUE_mORDERS11_s48_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_REVENUE_mORDERS11_s48_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mORDERS12_s48_buf as ind
     map_REVENUE_mORDERS12_s48_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mORDERS12_s48_buf_unwrap} in
       (map_REVENUE_mORDERS12_s48_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> map_REVENUE_mORDERS12_s48_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_REVENUE_mORDERS12_s48_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_s49_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_s49_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_s49_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_s49_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_s49_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_s49_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s51_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s51_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s51_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s51_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s51_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s51_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_s52_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_s52_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_s52_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_s52_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_s52_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_s52_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s53_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s53_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s53_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s53_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s53_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s53_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mLINEITEM4_s54_buf as ind
     map_REVENUE_mORDERS11_mLINEITEM4_s54_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mLINEITEM4_s54_buf_unwrap} in
       (map_REVENUE_mORDERS11_mLINEITEM4_s54_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mLINEITEM4_s54_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mLINEITEM4_s54_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s55_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s55_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s55_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s55_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s55_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s55_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s56_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s56_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s56_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s56_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s56_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s56_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s56_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s56_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s56_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s56_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s56_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s56_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s57_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s57_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s57_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s57_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s57_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s57_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s57_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s57_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s57_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s57_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s57_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s57_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mLINEITEM4_s58_buf as ind
     map_REVENUE_mLINEITEM4_s58_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mLINEITEM4_s58_buf_unwrap} in
       (map_REVENUE_mLINEITEM4_s58_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val -> map_REVENUE_mLINEITEM4_s58_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_REVENUE_mLINEITEM4_s58_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s59_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s59_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s59_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s59_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s59_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s59_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s59_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s59_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s59_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s59_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s59_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s59_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s60_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s60_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s60_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s60_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s60_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s60_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s62_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s62_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s62_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s62_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s62_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s62_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s63_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s63_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s63_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s63_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s63_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s63_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s63_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s63_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s63_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s63_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s63_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s63_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s64_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s64_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s64_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s64_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s64_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s64_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s66_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s66_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s66_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s66_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s66_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s66_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mLINEITEM4_s67_buf as ind
     map_REVENUE_mORDERS11_mLINEITEM4_s67_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mLINEITEM4_s67_buf_unwrap} in
       (map_REVENUE_mORDERS11_mLINEITEM4_s67_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mLINEITEM4_s67_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mLINEITEM4_s67_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mLINEITEM4_s68_buf as ind
     map_REVENUE_mORDERS11_mLINEITEM4_s68_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mLINEITEM4_s68_buf_unwrap} in
       (map_REVENUE_mORDERS11_mLINEITEM4_s68_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mLINEITEM4_s68_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mLINEITEM4_s68_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mLINEITEM4_mSUPPLIER1_s69_buf as ind
     map_REVENUE_mLINEITEM4_mSUPPLIER1_s69_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mLINEITEM4_mSUPPLIER1_s69_buf_unwrap} in
       (map_REVENUE_mLINEITEM4_mSUPPLIER1_s69_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mLINEITEM4_mSUPPLIER1_s69_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mLINEITEM4_mSUPPLIER1_s69_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mLINEITEM4_mSUPPLIER1_s70_buf as ind
     map_REVENUE_mLINEITEM4_mSUPPLIER1_s70_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mLINEITEM4_mSUPPLIER1_s70_buf_unwrap} in
       (map_REVENUE_mLINEITEM4_mSUPPLIER1_s70_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mLINEITEM4_mSUPPLIER1_s70_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mLINEITEM4_mSUPPLIER1_s70_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mLINEITEM4_s71_buf as ind
     map_REVENUE_mLINEITEM4_s71_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mLINEITEM4_s71_buf_unwrap} in
       (map_REVENUE_mLINEITEM4_s71_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val -> map_REVENUE_mLINEITEM4_s71_buf_unwrap.erase
        val));
        frontier.iterate ((\val -> map_REVENUE_mLINEITEM4_s71_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s72_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s72_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s72_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s72_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s72_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s72_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s72_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s72_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s72_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s72_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s72_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s72_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s73_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s73_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s73_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s73_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s73_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s73_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s75_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s75_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s75_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s75_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s75_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s75_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s76_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s76_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s76_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s76_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s76_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s76_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s76_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s76_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s76_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s76_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s76_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s76_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s77_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s77_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s77_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s77_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s77_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s77_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s79_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s79_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s79_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s79_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s79_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s79_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mLINEITEM4_s80_buf as ind
     map_REVENUE_mORDERS11_mLINEITEM4_s80_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mLINEITEM4_s80_buf_unwrap} in
       (map_REVENUE_mORDERS11_mLINEITEM4_s80_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mLINEITEM4_s80_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mLINEITEM4_s80_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mLINEITEM4_s81_buf as ind
     map_REVENUE_mORDERS11_mLINEITEM4_s81_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mLINEITEM4_s81_buf_unwrap} in
       (map_REVENUE_mORDERS11_mLINEITEM4_s81_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mLINEITEM4_s81_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mLINEITEM4_s81_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mLINEITEM4_mSUPPLIER1_s82_buf as ind
     map_REVENUE_mLINEITEM4_mSUPPLIER1_s82_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mLINEITEM4_mSUPPLIER1_s82_buf_unwrap} in
       (map_REVENUE_mLINEITEM4_mSUPPLIER1_s82_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mLINEITEM4_mSUPPLIER1_s82_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mLINEITEM4_mSUPPLIER1_s82_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mLINEITEM4_mSUPPLIER1_s83_buf as ind
     map_REVENUE_mLINEITEM4_mSUPPLIER1_s83_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mLINEITEM4_mSUPPLIER1_s83_buf_unwrap} in
       (map_REVENUE_mLINEITEM4_mSUPPLIER1_s83_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mLINEITEM4_mSUPPLIER1_s83_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mLINEITEM4_mSUPPLIER1_s83_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:string, rd:int, re:string,
     rf:int } @ { Set } in
   bind map_NATION_s84_buf as ind map_NATION_s84_buf_unwrap in
     let frontier =
       frontier_int_string_int_string_int {key:min_gc_vid,
         value:map_NATION_s84_buf_unwrap} in
       (map_NATION_s84_buf_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val -> map_NATION_s84_buf_unwrap.erase val));
        frontier.iterate ((\val -> map_NATION_s84_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s86_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s86_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s86_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s86_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s86_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s86_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s88_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s88_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s88_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s88_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s88_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s88_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s90_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s90_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s90_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s90_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s90_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s90_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s92_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s92_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s92_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s92_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s92_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s92_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s94_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s94_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s94_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s94_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s94_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s94_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s96_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s96_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s96_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s96_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s96_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s96_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s98_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s98_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s98_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s98_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s98_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s98_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s100_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s100_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s100_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s100_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s100_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s100_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s102_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s102_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s102_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s102_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s102_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s102_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s104_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s104_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s104_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s104_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s104_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s104_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s106_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s106_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s106_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s106_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s106_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s106_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s108_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s108_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s108_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s108_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s108_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s108_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s110_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s110_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s110_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s110_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s110_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s110_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s112_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s112_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s112_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s112_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s112_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s112_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s114_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s114_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s114_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s114_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s114_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s114_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s116_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s116_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s116_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s116_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s116_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s116_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s127_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s127_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s127_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s127_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s127_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s127_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s129_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s129_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s129_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s129_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s129_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s129_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s131_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s131_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s131_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s131_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s131_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s131_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s133_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s133_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s133_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s133_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s133_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s133_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s135_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s135_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s135_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s135_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s135_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s135_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s137_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s137_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s137_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s137_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s137_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s137_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s139_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s139_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s139_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s139_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s139_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s139_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s141_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s141_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s141_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s141_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s141_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s141_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s143_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s143_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s143_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s143_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s143_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s143_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s145_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s145_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s145_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s145_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s145_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s145_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s147_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s147_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s147_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s147_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s147_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s147_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s149_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s149_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s149_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s149_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s149_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s149_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s151_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s151_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s151_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s151_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s151_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s151_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s153_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s153_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s153_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s153_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s153_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s153_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s155_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s155_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s155_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s155_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s155_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s155_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s157_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s157_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s157_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s157_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s157_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s157_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s171_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s171_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s171_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s171_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s171_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s171_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s173_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s173_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s173_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s173_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s173_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s173_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s176_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s176_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s176_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s176_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s176_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s176_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s178_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s178_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s178_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s178_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s178_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s178_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s181_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s181_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s181_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s181_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s181_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s181_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s182_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s182_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s182_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s182_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s182_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s182_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s184_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s184_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s184_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s184_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s184_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s184_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s185_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s185_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s185_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s185_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s185_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s185_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s187_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s187_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s187_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s187_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s187_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s187_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s188_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s188_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s188_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s188_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s188_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s188_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s193_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s193_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s193_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s193_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s193_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s193_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s195_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s195_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s195_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s195_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s195_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s195_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s198_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s198_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s198_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s198_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s198_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s198_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s200_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s200_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s200_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s200_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s200_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s200_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s203_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s203_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s203_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s203_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s203_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s203_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s204_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s204_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s204_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s204_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s204_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s204_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s206_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s206_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s206_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s206_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s206_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s206_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s207_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s207_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s207_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s207_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s207_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s207_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s209_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s209_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s209_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s209_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s209_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s209_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s210_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s210_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s210_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s210_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s210_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s210_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s215_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s215_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s215_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s215_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s215_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s215_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s217_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s217_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s217_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s217_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s217_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s217_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s219_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s219_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s219_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s219_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s219_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s219_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s220_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s220_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s220_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s220_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s220_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s220_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s221_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s221_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s221_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s221_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s221_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s221_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s223_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s223_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s223_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s223_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s223_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s223_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s224_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s224_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s224_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s224_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s224_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s224_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s225_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s225_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s225_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s225_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s225_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s225_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s227_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s227_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s227_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s227_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s227_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s227_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s228_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s228_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s228_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s228_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s228_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s228_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s229_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s229_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s229_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s229_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s229_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s229_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s231_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s231_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s231_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s231_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s231_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s231_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s232_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s232_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s232_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s232_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s232_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s232_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s233_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s233_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s233_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s233_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s233_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s233_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s235_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s235_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s235_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s235_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s235_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s235_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s236_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s236_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s236_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s236_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s236_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s236_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s237_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s237_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s237_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s237_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s237_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s237_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s238_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s238_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s238_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s238_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s238_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s238_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s239_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s239_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s239_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s239_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s239_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s239_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s240_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s240_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s240_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s240_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s240_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s240_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s245_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s245_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s245_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s245_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s245_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s245_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s247_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s247_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s247_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s247_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s247_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s247_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s249_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s249_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s249_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s249_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s249_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s249_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s250_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s250_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s250_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s250_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s250_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s250_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s251_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s251_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s251_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s251_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s251_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s251_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s253_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s253_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s253_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s253_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s253_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s253_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s254_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s254_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s254_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s254_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s254_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s254_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s255_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s255_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s255_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s255_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s255_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s255_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s257_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s257_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s257_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s257_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s257_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s257_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s258_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s258_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s258_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s258_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s258_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s258_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s259_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s259_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s259_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s259_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s259_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s259_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s261_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM5_s261_buf_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM5_s261_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM5_s261_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s261_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM5_s261_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s262_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s262_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s262_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s262_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s262_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s262_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s263_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s263_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s263_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s263_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s263_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s263_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s265_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s265_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s265_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s265_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s265_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s265_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s266_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s266_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s266_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s266_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s266_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s266_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s267_buf as ind
     map_REVENUE_mCUSTOMER11_mLINEITEM4_s267_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mLINEITEM4_s267_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mLINEITEM4_s267_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s267_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mLINEITEM4_s267_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s268_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s268_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s268_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s268_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s268_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s268_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s269_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s269_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s269_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s269_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s269_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s269_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s270_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s270_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s270_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s270_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s270_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s270_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s273_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s273_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s273_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s273_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s273_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s273_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s274_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s274_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s274_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s274_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s274_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s274_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s275_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s275_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s275_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s275_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s275_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s275_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s277_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s277_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s277_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s277_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s277_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s277_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s278_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s278_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s278_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s278_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s278_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s278_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s279_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s279_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s279_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s279_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s279_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s279_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s280_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s280_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s280_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s280_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s280_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s280_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s282_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s282_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s282_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s282_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s282_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s282_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s283_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s283_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s283_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s283_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s283_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s283_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s284_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s284_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s284_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s284_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s284_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s284_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s285_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s285_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s285_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s285_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s285_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s285_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s287_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s287_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s287_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s287_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s287_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s287_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s288_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s288_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s288_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s288_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s288_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s288_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s289_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s289_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s289_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s289_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s289_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s289_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s290_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s290_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s290_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s290_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s290_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s290_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s292_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s292_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s292_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s292_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s292_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s292_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s293_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s293_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s293_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s293_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s293_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s293_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s294_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s294_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s294_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s294_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s294_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s294_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s295_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s295_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s295_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s295_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s295_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s295_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s297_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s297_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s297_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s297_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s297_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s297_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s298_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s298_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s298_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s298_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s298_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s298_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s299_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s299_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s299_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s299_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s299_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s299_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s300_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s300_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s300_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s300_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s300_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s300_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s301_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s301_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s301_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s301_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s301_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s301_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s302_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s302_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s302_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s302_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s302_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s302_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s303_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s303_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s303_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s303_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s303_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s303_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s304_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s304_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s304_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s304_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s304_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s304_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s305_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s305_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s305_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s305_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s305_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s305_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s306_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s306_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s306_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s306_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s306_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s306_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s307_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s307_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s307_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s307_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s307_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s307_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s308_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s308_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s308_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s308_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s308_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s308_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s310_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s310_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s310_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s310_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s310_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s310_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s311_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s311_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s311_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s311_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s311_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s311_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s313_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s313_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s313_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s313_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s313_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s313_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s314_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s314_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s314_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s314_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s314_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s314_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s316_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s316_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s316_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s316_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s316_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s316_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s320_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s320_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s320_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s320_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s320_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s320_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s321_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s321_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s321_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s321_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s321_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s321_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s322_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s322_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s322_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s322_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s322_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s322_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s324_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s324_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s324_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s324_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s324_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s324_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s325_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s325_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s325_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s325_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s325_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s325_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s326_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s326_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s326_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s326_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s326_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s326_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s327_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s327_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s327_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s327_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s327_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s327_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s329_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s329_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s329_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s329_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s329_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s329_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s330_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s330_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s330_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s330_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s330_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s330_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s331_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s331_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s331_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s331_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s331_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s331_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s332_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s332_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s332_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s332_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s332_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s332_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s334_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s334_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s334_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s334_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s334_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s334_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s335_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s335_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s335_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s335_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s335_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s335_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s336_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s336_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s336_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s336_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s336_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s336_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s337_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s337_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s337_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s337_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s337_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s337_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s339_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s339_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s339_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s339_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s339_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s339_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s340_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s340_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s340_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s340_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s340_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s340_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s341_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER1_s341_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s341_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER1_s341_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s341_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER1_s341_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s342_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s342_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s342_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s342_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s342_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s342_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s344_buf as ind
     map_REVENUE_mCUSTOMER12_mSUPPLIER1_s344_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s344_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mSUPPLIER1_s344_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s344_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mSUPPLIER1_s344_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s345_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s345_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s345_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s345_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s345_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s345_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s346_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s346_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s346_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s346_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s346_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s346_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s347_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s347_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s347_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s347_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s347_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s347_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s348_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s348_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s348_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s348_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s348_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s348_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s349_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s349_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s349_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s349_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s349_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s349_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s350_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s350_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s350_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s350_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s350_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s350_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s351_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s351_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s351_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s351_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s351_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s351_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s352_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s352_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s352_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s352_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s352_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s352_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s353_buf as ind
     map_REVENUE_mCUSTOMER11_mSUPPLIER2_s353_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mSUPPLIER2_s353_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mSUPPLIER2_s353_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s353_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mSUPPLIER2_s353_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind map_REVENUE_mORDERS11_mSUPPLIER2_s354_buf as ind
     map_REVENUE_mORDERS11_mSUPPLIER2_s354_buf_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:map_REVENUE_mORDERS11_mSUPPLIER2_s354_buf_unwrap} in
       (map_REVENUE_mORDERS11_mSUPPLIER2_s354_buf_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s354_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mORDERS11_mSUPPLIER2_s354_buf_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s355_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s355_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s355_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s355_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s355_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s355_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s357_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s357_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s357_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s357_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s357_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s357_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s358_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s358_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s358_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s358_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s358_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s358_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s360_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s360_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s360_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s360_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s360_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s360_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s361_buf as ind
     map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s361_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s361_buf_unwrap} in
       (map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s361_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s361_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s361_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s363_buf as ind
     map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s363_buf_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s363_buf_unwrap} in
       (map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s363_buf_unwrap.iterate
        ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2,
        re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s363_buf_unwrap.erase val));
        frontier.iterate ((\val ->
        map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s363_buf_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:string, rd:int, re:string,
     rf:int } @ { Set } in
   bind NATION as ind NATION_unwrap in
     let frontier =
       frontier_int_string_int_string_int {key:min_gc_vid, value:NATION_unwrap}
       in
       (NATION_unwrap.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1,
        rd:map_2, re:map_3, rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val -> NATION_unwrap.erase val));
        frontier.iterate ((\val -> NATION_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:real
     } @ { Set } in
   bind REVENUE as ind REVENUE_unwrap in
     let frontier =
       frontier_string_string_int_float {key:min_gc_vid, value:REVENUE_unwrap}
       in
       (REVENUE_unwrap.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0, rc:map_1,
        rd:map_2, re:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val -> REVENUE_unwrap.erase val));
        frontier.iterate ((\val -> REVENUE_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind REVENUE_mCUSTOMER11 as ind REVENUE_mCUSTOMER11_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:REVENUE_mCUSTOMER11_unwrap} in
       (REVENUE_mCUSTOMER11_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4, rg:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> REVENUE_mCUSTOMER11_unwrap.erase val));
        frontier.iterate ((\val -> REVENUE_mCUSTOMER11_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind REVENUE_mCUSTOMER11_mORDERS1 as ind REVENUE_mCUSTOMER11_mORDERS1_unwrap
     in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:REVENUE_mCUSTOMER11_mORDERS1_unwrap} in
       (REVENUE_mCUSTOMER11_mORDERS1_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> REVENUE_mCUSTOMER11_mORDERS1_unwrap.erase val));
        frontier.iterate ((\val -> REVENUE_mCUSTOMER11_mORDERS1_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 as ind
     REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_unwrap} in
       (REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_unwrap.erase val));
        frontier.iterate ((\val ->
        REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind REVENUE_mCUSTOMER11_mLINEITEM4 as ind
     REVENUE_mCUSTOMER11_mLINEITEM4_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:REVENUE_mCUSTOMER11_mLINEITEM4_unwrap} in
       (REVENUE_mCUSTOMER11_mLINEITEM4_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val -> REVENUE_mCUSTOMER11_mLINEITEM4_unwrap.erase
        val));
        frontier.iterate ((\val -> REVENUE_mCUSTOMER11_mLINEITEM4_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int } @ { Set } in
   bind REVENUE_mCUSTOMER11_mLINEITEM5 as ind
     REVENUE_mCUSTOMER11_mLINEITEM5_unwrap in
     let frontier =
       frontier_int_int_int {key:min_gc_vid,
         value:REVENUE_mCUSTOMER11_mLINEITEM5_unwrap} in
       (REVENUE_mCUSTOMER11_mLINEITEM5_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_val} else ()));
        temp.iterate ((\val -> REVENUE_mCUSTOMER11_mLINEITEM5_unwrap.erase
        val));
        frontier.iterate ((\val -> REVENUE_mCUSTOMER11_mLINEITEM5_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind REVENUE_mCUSTOMER11_mSUPPLIER1 as ind
     REVENUE_mCUSTOMER11_mSUPPLIER1_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:REVENUE_mCUSTOMER11_mSUPPLIER1_unwrap} in
       (REVENUE_mCUSTOMER11_mSUPPLIER1_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val -> REVENUE_mCUSTOMER11_mSUPPLIER1_unwrap.erase
        val));
        frontier.iterate ((\val -> REVENUE_mCUSTOMER11_mSUPPLIER1_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind REVENUE_mCUSTOMER11_mSUPPLIER2 as ind
     REVENUE_mCUSTOMER11_mSUPPLIER2_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:REVENUE_mCUSTOMER11_mSUPPLIER2_unwrap} in
       (REVENUE_mCUSTOMER11_mSUPPLIER2_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val -> REVENUE_mCUSTOMER11_mSUPPLIER2_unwrap.erase
        val));
        frontier.iterate ((\val -> REVENUE_mCUSTOMER11_mSUPPLIER2_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind REVENUE_mCUSTOMER12 as ind REVENUE_mCUSTOMER12_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:REVENUE_mCUSTOMER12_unwrap} in
       (REVENUE_mCUSTOMER12_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4, rg:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> REVENUE_mCUSTOMER12_unwrap.erase val));
        frontier.iterate ((\val -> REVENUE_mCUSTOMER12_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind REVENUE_mCUSTOMER12_mORDERS1 as ind REVENUE_mCUSTOMER12_mORDERS1_unwrap
     in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:REVENUE_mCUSTOMER12_mORDERS1_unwrap} in
       (REVENUE_mCUSTOMER12_mORDERS1_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4,
        rg:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> REVENUE_mCUSTOMER12_mORDERS1_unwrap.erase val));
        frontier.iterate ((\val -> REVENUE_mCUSTOMER12_mORDERS1_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 as ind
     REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_unwrap} in
       (REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val ->
        REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_unwrap.erase val));
        frontier.iterate ((\val ->
        REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
     } @ { Set } in
   bind REVENUE_mCUSTOMER12_mSUPPLIER1 as ind
     REVENUE_mCUSTOMER12_mSUPPLIER1_unwrap in
     let frontier =
       frontier_int_int_int_float {key:min_gc_vid,
         value:REVENUE_mCUSTOMER12_mSUPPLIER1_unwrap} in
       (REVENUE_mCUSTOMER12_mSUPPLIER1_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_val}
        else ()));
        temp.iterate ((\val -> REVENUE_mCUSTOMER12_mSUPPLIER1_unwrap.erase
        val));
        frontier.iterate ((\val -> REVENUE_mCUSTOMER12_mSUPPLIER1_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind REVENUE_mORDERS11 as ind REVENUE_mORDERS11_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:REVENUE_mORDERS11_unwrap} in
       (REVENUE_mORDERS11_unwrap.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0,
        rc:map_1, rd:map_2, re:map_3, rf:map_4, rg:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> REVENUE_mORDERS11_unwrap.erase val));
        frontier.iterate ((\val -> REVENUE_mORDERS11_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind REVENUE_mORDERS11_mLINEITEM4 as ind REVENUE_mORDERS11_mLINEITEM4_unwrap
     in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:REVENUE_mORDERS11_mLINEITEM4_unwrap} in
       (REVENUE_mORDERS11_mLINEITEM4_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val -> REVENUE_mORDERS11_mLINEITEM4_unwrap.erase val));
        frontier.iterate ((\val -> REVENUE_mORDERS11_mLINEITEM4_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind REVENUE_mORDERS11_mSUPPLIER2 as ind REVENUE_mORDERS11_mSUPPLIER2_unwrap
     in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:REVENUE_mORDERS11_mSUPPLIER2_unwrap} in
       (REVENUE_mORDERS11_mSUPPLIER2_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val -> REVENUE_mORDERS11_mSUPPLIER2_unwrap.erase val));
        frontier.iterate ((\val -> REVENUE_mORDERS11_mSUPPLIER2_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind REVENUE_mORDERS12 as ind REVENUE_mORDERS12_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:REVENUE_mORDERS12_unwrap} in
       (REVENUE_mORDERS12_unwrap.iterate ((\b1 -> bind b1 as {ra:vid, rb:map_0,
        rc:map_1, rd:map_2, re:map_3, rf:map_4, rg:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> REVENUE_mORDERS12_unwrap.erase val));
        frontier.iterate ((\val -> REVENUE_mORDERS12_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind REVENUE_mLINEITEM4 as ind REVENUE_mLINEITEM4_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:REVENUE_mLINEITEM4_unwrap} in
       (REVENUE_mLINEITEM4_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val -> REVENUE_mLINEITEM4_unwrap.erase val));
        frontier.iterate ((\val -> REVENUE_mLINEITEM4_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int } @ { Set } in
   bind REVENUE_mLINEITEM4_mSUPPLIER1 as ind
     REVENUE_mLINEITEM4_mSUPPLIER1_unwrap in
     let frontier =
       frontier_string_string_int_int_int {key:min_gc_vid,
         value:REVENUE_mLINEITEM4_mSUPPLIER1_unwrap} in
       (REVENUE_mLINEITEM4_mSUPPLIER1_unwrap.iterate ((\b1 ->
        bind b1 as {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
        rf:map_val} in if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_val} else ()));
        temp.iterate ((\val -> REVENUE_mLINEITEM4_mSUPPLIER1_unwrap.erase val));
        frontier.iterate ((\val -> REVENUE_mLINEITEM4_mSUPPLIER1_unwrap.insert
        val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind REVENUE_mSUPPLIER11 as ind REVENUE_mSUPPLIER11_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:REVENUE_mSUPPLIER11_unwrap} in
       (REVENUE_mSUPPLIER11_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4, rg:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> REVENUE_mSUPPLIER11_unwrap.erase val));
        frontier.iterate ((\val -> REVENUE_mSUPPLIER11_unwrap.insert val)));
   let temp =
   empty { ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int,
     rf:int, rg:real } @ { Set } in
   bind REVENUE_mSUPPLIER12 as ind REVENUE_mSUPPLIER12_unwrap in
     let frontier =
       frontier_string_string_int_int_int_float {key:min_gc_vid,
         value:REVENUE_mSUPPLIER12_unwrap} in
       (REVENUE_mSUPPLIER12_unwrap.iterate ((\b1 -> bind b1 as {ra:vid,
        rb:map_0, rc:map_1, rd:map_2, re:map_3, rf:map_4, rg:map_val} in 
        if vid < min_gc_vid
        then temp.insert {ra:vid, rb:map_0, rc:map_1, rd:map_2, re:map_3,
          rf:map_4, rg:map_val} else ()));
        temp.iterate ((\val -> REVENUE_mSUPPLIER12_unwrap.erase val));
        frontier.iterate ((\val -> REVENUE_mSUPPLIER12_unwrap.insert val)))))
trigger sw_rcv_token : { key:int, value:int } = (\vid ->
  if sw_need_vid_cntr > 0
  then let next_vid = {key:vid.key, value:vid.value + sw_need_vid_cntr} in
    ((sw_rcv_token, sw_next_switch_addr)<- next_vid;
     sw_token_vid_list.insert {key:vid, value:sw_need_vid_cntr};
     sw_need_vid_cntr = 0;
     sw_highest_vid = next_vid;
     (if not sw_sent_done and (sw_trig_buf_idx.size () == 0 and (sw_num_ack ==
        sw_num_sent and sw_seen_sentry == true))
     then ((ms_rcv_switch_done, master_addr)<- ();sw_sent_done = true) 
     else ());
     (sw_driver_trig, me)<- ()) else (sw_rcv_token, sw_next_switch_addr)<- vid)
trigger tm_insert_timer : { ra:int, rb:int, rc:address } = (\b1 ->
  bind b1 as {ra:time, rb:trig_id, rc:addr} in 
  (tm_timer_list.insert {ra:time + now_int (), rb:trig_id, rc:addr};
   tm_timer_list = tm_timer_list.sort ((\b2 -> (\b6 -> bind b2 as {ra:time1,
   rb:trig_id1, rc:addr1} in bind b6 as {ra:time2, rb:trig_id2, rc:addr2} in 
   if time1 < time2 then -1 else 1)));
   (tm_check_time, me)<- ()))
trigger tm_check_time : () = (\_u -> case (tm_timer_list.peek ()) of
  {Some timer -> if now_int () >= timer.ra
    then
      (tm_timer_list.erase timer;
       bind timer as {ra:time, rb:trig_id, rc:addr} in
       if trig_id == 0 then (ms_send_gc_req, addr)<- () else ();
       (tm_check_time, me)<- ()) else ((tm_check_time, me)<- ();(sleep 1000))}
  {None -> ()})
trigger sw_demux : { ra:string, rb:int, rc:real, rd:string, re:int, rf:string,
  rg:string, rh:string, ri:string, rj:string, rk:int, rl:real, rm:real, rn:int,
  ro:string, rp:string, rq:string, rr:string, rs:int, rt:string, ru:int,
  rv:string, rw:string, rx:int, ry:string, rz:real, rza:string, rzb:int,
  rzc:real, rzd:string, rze:string, rzf:string, rzg:string, rzh:int, rzi:int,
  rzj:int, rzk:real, rzl:real, rzm:real, rzn:string } = (\args ->
  if args.ra == "SUPPLIER"
  then if args.rb == 1
    then
      sw_insert_SUPPLIER {ra:args.rzj, rb:args.rr, rc:args.rd, rd:args.rs,
        re:args.ry, rf:args.rc, rg:args.rh}
    else
      sw_delete_SUPPLIER {ra:args.rzj, rb:args.rr, rc:args.rd, rd:args.rs,
        re:args.ry, rf:args.rc, rg:args.rh}
  else if args.ra == "ORDERS"
    then if args.rb == 1
      then
        sw_insert_ORDERS {ra:args.ru, rb:args.rk, rc:args.rw, rd:args.rzm,
          re:tpch_date (args.rt), rf:args.rv, rg:args.rg, rh:args.rzh,
          ri:args.rh}
      else
        sw_delete_ORDERS {ra:args.ru, rb:args.rk, rc:args.rw, rd:args.rzm,
          re:tpch_date (args.rt), rf:args.rv, rg:args.rg, rh:args.rzh,
          ri:args.rh}
    else if args.ra == "LINEITEM"
      then if args.rb == 1
        then
          sw_insert_LINEITEM {ra:args.ru, rb:args.rx, rc:args.rzj, rd:args.rn,
            re:args.rz, rf:args.rm, rg:args.rl, rh:args.rzl, ri:args.rzd,
            rj:args.ro, rk:tpch_date (args.rze), rl:tpch_date (args.ri),
            rm:tpch_date (args.rza), rn:args.rzf, ro:args.rzg, rp:args.rh}
        else
          sw_delete_LINEITEM {ra:args.ru, rb:args.rx, rc:args.rzj, rd:args.rn,
            re:args.rz, rf:args.rm, rg:args.rl, rh:args.rzl, ri:args.rzd,
            rj:args.ro, rk:tpch_date (args.rze), rl:tpch_date (args.ri),
            rm:tpch_date (args.rza), rn:args.rzf, ro:args.rzg, rp:args.rh}
      else if args.ra == "CUSTOMER"
        then if args.rb == 1
          then
            sw_insert_CUSTOMER {ra:args.rk, rb:args.rr, rc:args.rd, rd:args.rs,
              re:args.ry, rf:args.rc, rg:args.rq, rh:args.rh}
          else
            sw_delete_CUSTOMER {ra:args.rk, rb:args.rr, rc:args.rd, rd:args.rs,
              re:args.ry, rf:args.rc, rg:args.rq, rh:args.rh}
        else if args.ra == ""
          then
            (sw_trig_buf_idx.insert ({i:-1});
             sw_need_vid_cntr = sw_need_vid_cntr + 1)
          else error (print "unidentified trig id"))
trigger sw_driver_trig : () = (\_u ->
  if sw_init and sw_trig_buf_idx.size () > 0
  then case sw_gen_vid () of
    {Some vid -> case (sw_trig_buf_idx.peek ()) of
      {Some trig_id ->
        (sw_trig_buf_idx.erase {i:trig_id.i};
         (if trig_id.i == -1
         then
           (sw_seen_sentry = true;
            (if not sw_sent_done and (sw_trig_buf_idx.size () == 0 and
               (sw_num_ack == sw_num_sent and sw_seen_sentry == true))
            then ((ms_rcv_switch_done, master_addr)<- ();sw_sent_done = true)
            else ()))
         else
           ((if trig_id.i == 7 then sw_delete_LINEITEM_send_fetch vid
            else if trig_id.i == 6 then sw_insert_LINEITEM_send_fetch vid
              else if trig_id.i == 5 then sw_delete_ORDERS_send_fetch vid
                else if trig_id.i == 4 then sw_insert_ORDERS_send_fetch vid
                  else if trig_id.i == 3 then sw_delete_CUSTOMER_send_fetch vid
                    else if trig_id.i == 2
                      then sw_insert_CUSTOMER_send_fetch vid
                      else if trig_id.i == 1
                        then sw_delete_SUPPLIER_send_fetch vid
                        else if trig_id.i == 0
                          then sw_insert_SUPPLIER_send_fetch vid
                          else error (print "mismatch on trigger id"));
            (sw_driver_trig, me)<- ())))}{None -> ()}}{None -> ()} else ())
trigger nd_rcv_corr_done : { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } = (\b1 -> bind b1 as {ra:vid, rb:stmt_id, rc:hop, rd:count} in 
  ((nd_update_stmt_cntr_corr_map {ra:vid, rb:stmt_id, rc:hop, rd:count,
      re:false, rf:false});
   (case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
   key == {key:vid, value:stmt_id}))).peek ()) of
   {Some lkup -> if 0 == ((lkup.value).value).size ()
     then
       (nd_stmt_cntrs.erase lkup;
        (if nd_rcvd_sys_done
        then if not nd_sent_done and nd_stmt_cntrs.size () == 0
          then ((ms_rcv_node_done, master_addr)<- true;nd_sent_done = true)
          else () else ())) else ()}{None ->
                                      error
                                        (print
                                           "nd_rcv_corr_done: expected stmt_cntr value")})))
  
trigger nd_insert_SUPPLIER_rcv_put : { ra:address, rb:collection { key:int,
  value:int } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:string,
  rf:string, rg:int, rh:string, ri:real, rj:string } = (\b1 ->
  bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid, rd:SUPPLIER_SUPPKEY,
  re:SUPPLIER_NAME, rf:SUPPLIER_ADDRESS, rg:SUPPLIER_NATIONKEY,
  rh:SUPPLIER_PHONE, ri:SUPPLIER_ACCTBAL, rj:SUPPLIER_COMMENT} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 9
     then
       nd_insert_SUPPLIER_do_complete_s9 {ra:vid, rb:SUPPLIER_SUPPKEY,
         rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
         rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
     else if stmt_id == 8
       then
         nd_insert_SUPPLIER_do_complete_s8 {ra:vid, rb:SUPPLIER_SUPPKEY,
           rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
           rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
       else if stmt_id == 7
         then
           nd_insert_SUPPLIER_do_complete_s7 {ra:vid, rb:SUPPLIER_SUPPKEY,
             rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
             rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
         else if stmt_id == 6
           then
             nd_insert_SUPPLIER_do_complete_s6 {ra:vid, rb:SUPPLIER_SUPPKEY,
               rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
               rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
           else if stmt_id == 5
             then
               nd_insert_SUPPLIER_do_complete_s5 {ra:vid, rb:SUPPLIER_SUPPKEY,
                 rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                 rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
             else if stmt_id == 4
               then
                 nd_insert_SUPPLIER_do_complete_s4 {ra:vid,
                   rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS,
                   re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
                   rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
               else if stmt_id == 3
                 then
                   nd_insert_SUPPLIER_do_complete_s3 {ra:vid,
                     rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                     rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                     rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
                     rh:SUPPLIER_COMMENT}
                 else if stmt_id == 2
                   then
                     nd_insert_SUPPLIER_do_complete_s2 {ra:vid,
                       rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                       rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
                       rh:SUPPLIER_COMMENT}
                   else if stmt_id == 1
                     then
                       nd_insert_SUPPLIER_do_complete_s1 {ra:vid,
                         rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                         rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                         rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
                         rh:SUPPLIER_COMMENT}
                     else if stmt_id == 0
                       then
                         nd_insert_SUPPLIER_do_complete_s0 {ra:vid,
                           rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                           rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                           rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
                           rh:SUPPLIER_COMMENT} else () else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_insert_SUPPLIER_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 0
   then if map_id == 20
     then
       (nd_insert_SUPPLIER_send_push_s0_m_REVENUE_mSUPPLIER11, me)<- {ra:vid,
       rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS,
       re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
       rh:SUPPLIER_COMMENT}
     else if map_id == 21
       then
         (nd_insert_SUPPLIER_send_push_s0_m_REVENUE_mSUPPLIER12, me)<- {ra:vid,
         rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS,
         re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
         rh:SUPPLIER_COMMENT} else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 1
     then if map_id == 8
       then
         (nd_insert_SUPPLIER_send_push_s1_m_REVENUE_mCUSTOMER11_mSUPPLIER1, me)<- {ra:vid,
         rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS,
         re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
         rh:SUPPLIER_COMMENT}
       else if map_id == 9
         then
           (nd_insert_SUPPLIER_send_push_s1_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
             me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
           rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
           rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 2
       then if map_id == 5
         then
           (nd_insert_SUPPLIER_send_push_s2_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
             me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
           rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
           rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
         else if map_id == 9
           then
             (nd_insert_SUPPLIER_send_push_s2_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
               me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
             rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
             rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
           else error (print "nd_rcv_fetch: invalid map id")
       else if stmt_id == 3
         then if map_id == 9
           then
             (nd_insert_SUPPLIER_send_push_s3_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
               me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
             rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
             rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
           else error (print "nd_rcv_fetch: invalid map id")
         else if stmt_id == 4
           then if map_id == 13
             then
               (nd_insert_SUPPLIER_send_push_s4_m_REVENUE_mCUSTOMER12_mSUPPLIER1,
                 me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
               rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
               rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
             else if map_id == 9
               then
                 (nd_insert_SUPPLIER_send_push_s4_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
                   me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                 rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
                 rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
               else error (print "nd_rcv_fetch: invalid map id")
           else if stmt_id == 5
             then if map_id == 12
               then
                 (nd_insert_SUPPLIER_send_push_s5_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
                   me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                 rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
                 rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
               else if map_id == 9
                 then
                   (nd_insert_SUPPLIER_send_push_s5_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
                     me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                   rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                   rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
                 else error (print "nd_rcv_fetch: invalid map id")
             else if stmt_id == 6
               then if map_id == 5
                 then
                   (nd_insert_SUPPLIER_send_push_s6_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
                     me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                   rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                   rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
                 else if map_id == 16
                   then
                     (nd_insert_SUPPLIER_send_push_s6_m_REVENUE_mORDERS11_mSUPPLIER2,
                       me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                     rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                     rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
                     rh:SUPPLIER_COMMENT}
                   else error (print "nd_rcv_fetch: invalid map id")
               else if stmt_id == 7
                 then if map_id == 16
                   then
                     (nd_insert_SUPPLIER_send_push_s7_m_REVENUE_mORDERS11_mSUPPLIER2,
                       me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                     rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                     rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
                     rh:SUPPLIER_COMMENT}
                   else error (print "nd_rcv_fetch: invalid map id")
                 else if stmt_id == 8
                   then if map_id == 12
                     then
                       (nd_insert_SUPPLIER_send_push_s8_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
                         me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                       rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
                       rh:SUPPLIER_COMMENT}
                     else if map_id == 16
                       then
                         (nd_insert_SUPPLIER_send_push_s8_m_REVENUE_mORDERS11_mSUPPLIER2,
                           me)<- {ra:vid, rb:SUPPLIER_SUPPKEY,
                         rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS,
                         re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
                         rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
                       else error (print "nd_rcv_fetch: invalid map id")
                   else if stmt_id == 9
                     then if map_id == 19
                       then
                         (nd_insert_SUPPLIER_send_push_s9_m_REVENUE_mLINEITEM4_mSUPPLIER1,
                           me)<- {ra:vid, rb:SUPPLIER_SUPPKEY,
                         rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS,
                         re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
                         rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
                       else error (print "nd_rcv_fetch: invalid map id")
                     else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_insert_SUPPLIER_send_push_s0_m_REVENUE_mSUPPLIER11 : { ra:{ key:int,
  value:int }, rb:int, rc:string, rd:string, re:int, rf:string, rg:real,
  rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mSUPPLIER11 as ind REVENUE_mSUPPLIER11_deref in
  ((nd_log_master_write {key:vid, value:0});
   (shuffle_REVENUE_mSUPPLIER11_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
      rb:None immut, rc:None immut,
      rd:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mSUPPLIER11_deref.filter ((\b1 -> bind b1 as {ra:ra,
           rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in re ==
           SUPPLIER_NATIONKEY and rf == SUPPLIER_SUPPKEY))}, re:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_SUPPLIER_rcv_push_s0_m_REVENUE_mSUPPLIER11, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_insert_SUPPLIER_send_push_s0_m_REVENUE_mSUPPLIER12 : { ra:{ key:int,
  value:int }, rb:int, rc:string, rd:string, re:int, rf:string, rg:real,
  rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mSUPPLIER12 as ind REVENUE_mSUPPLIER12_deref in
  ((nd_log_master_write {key:vid, value:0});
   (shuffle_REVENUE_mSUPPLIER12_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
      rb:None immut, rc:None immut,
      rd:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mSUPPLIER12_deref.filter ((\b1 -> bind b1 as {ra:ra,
           rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in re ==
           SUPPLIER_NATIONKEY and rf == SUPPLIER_SUPPKEY))}, re:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_SUPPLIER_rcv_push_s0_m_REVENUE_mSUPPLIER12, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_insert_SUPPLIER_send_push_s1_m_REVENUE_mCUSTOMER11_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER1 as ind REVENUE_mCUSTOMER11_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:1});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER1_to_REVENUE_mCUSTOMER11_bind_2t0_4t1
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
           SUPPLIER_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_SUPPLIER_rcv_push_s1_m_REVENUE_mCUSTOMER11_mSUPPLIER1, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_insert_SUPPLIER_send_push_s1_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:1});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_SUPPLIER_rcv_push_s1_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_insert_SUPPLIER_send_push_s2_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 as ind
  REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:2});
   (shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER11_mORDERS1_bind_2t0_4t1
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
           SUPPLIER_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_SUPPLIER_rcv_push_s2_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
     ip)<- {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
   re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
   rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT}))))
trigger nd_insert_SUPPLIER_send_push_s2_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:2});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER11_mORDERS1_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_SUPPLIER_rcv_push_s2_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_insert_SUPPLIER_send_push_s3_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:3});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER11_mLINEITEM4_bind_0t0_1t1_2t2
      {ra:None immut, rb:None immut, rc:None immut, rd:Some SUPPLIER_SUPPKEY,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rf:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_SUPPLIER_rcv_push_s3_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_insert_SUPPLIER_send_push_s4_m_REVENUE_mCUSTOMER12_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER12_mSUPPLIER1 as ind REVENUE_mCUSTOMER12_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:4});
   (shuffle_REVENUE_mCUSTOMER12_mSUPPLIER1_to_REVENUE_mCUSTOMER12_bind_2t0_4t1
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
           SUPPLIER_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_SUPPLIER_rcv_push_s4_m_REVENUE_mCUSTOMER12_mSUPPLIER1, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_insert_SUPPLIER_send_push_s4_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:4});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_SUPPLIER_rcv_push_s4_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_insert_SUPPLIER_send_push_s5_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 as ind
  REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:5});
   (shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER12_mORDERS1_bind_2t0_4t1
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
           SUPPLIER_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_SUPPLIER_rcv_push_s5_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
     ip)<- {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
   re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
   rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT}))))
trigger nd_insert_SUPPLIER_send_push_s5_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:5});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER12_mORDERS1_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_SUPPLIER_rcv_push_s5_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_insert_SUPPLIER_send_push_s6_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 as ind
  REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:6});
   (shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mORDERS11_bind_2t0_4t1
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
           SUPPLIER_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_SUPPLIER_rcv_push_s6_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
     ip)<- {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
   re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
   rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT}))))
trigger nd_insert_SUPPLIER_send_push_s6_m_REVENUE_mORDERS11_mSUPPLIER2 : { ra:{
  key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mORDERS11_mSUPPLIER2 as ind REVENUE_mORDERS11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:6});
   (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS11_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_SUPPLIER_rcv_push_s6_m_REVENUE_mORDERS11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_insert_SUPPLIER_send_push_s7_m_REVENUE_mORDERS11_mSUPPLIER2 : { ra:{
  key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mORDERS11_mSUPPLIER2 as ind REVENUE_mORDERS11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:7});
   (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS11_mLINEITEM4_bind_0t0_1t1_2t2
      {ra:None immut, rb:None immut, rc:None immut, rd:Some SUPPLIER_SUPPKEY,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rf:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_SUPPLIER_rcv_push_s7_m_REVENUE_mORDERS11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_insert_SUPPLIER_send_push_s8_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 as ind
  REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:8});
   (shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mORDERS12_bind_2t0_4t1
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
           SUPPLIER_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_SUPPLIER_rcv_push_s8_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
     ip)<- {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
   re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
   rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT}))))
trigger nd_insert_SUPPLIER_send_push_s8_m_REVENUE_mORDERS11_mSUPPLIER2 : { ra:{
  key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mORDERS11_mSUPPLIER2 as ind REVENUE_mORDERS11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:8});
   (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS12_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_SUPPLIER_rcv_push_s8_m_REVENUE_mORDERS11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_insert_SUPPLIER_send_push_s9_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mLINEITEM4_mSUPPLIER1 as ind REVENUE_mLINEITEM4_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:9});
   (shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mLINEITEM4_bind_0t0_1t1_2t2
      {ra:None immut, rb:None immut, rc:None immut, rd:Some SUPPLIER_SUPPKEY,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mLINEITEM4_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rf:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_SUPPLIER_rcv_push_s9_m_REVENUE_mLINEITEM4_mSUPPLIER1, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_insert_SUPPLIER_rcv_push_s0_m_REVENUE_mSUPPLIER11 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int, rg:real } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:string, re:string, rf:int, rg:string, rh:real, ri:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mSUPPLIER11_s0_buf as ind
   map_REVENUE_mSUPPLIER11_s0_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mSUPPLIER11_s0_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra == _tup0 and rf ==
       _tup5) and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mSUPPLIER11_s0_buf_d.update vals tuple}
       {None -> map_REVENUE_mSUPPLIER11_s0_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:0, rc:-1}
   then
     nd_insert_SUPPLIER_do_complete_s0 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_insert_SUPPLIER_rcv_push_s0_m_REVENUE_mSUPPLIER12 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int, rg:real } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:string, re:string, rf:int, rg:string, rh:real, ri:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mSUPPLIER12_s0_buf as ind
   map_REVENUE_mSUPPLIER12_s0_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mSUPPLIER12_s0_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra == _tup0 and rf ==
       _tup5) and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mSUPPLIER12_s0_buf_d.update vals tuple}
       {None -> map_REVENUE_mSUPPLIER12_s0_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:0, rc:-1}
   then
     nd_insert_SUPPLIER_do_complete_s0 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_insert_SUPPLIER_rcv_push_s1_m_REVENUE_mCUSTOMER11_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
  rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
  ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s1_buf as
   ind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s1_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER1_s1_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0 and rd
       == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER1_s1_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER1_s1_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:1, rc:-1}
   then
     nd_insert_SUPPLIER_do_complete_s1 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_insert_SUPPLIER_rcv_push_s1_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s1_buf as
   ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s1_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s1_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s1_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s1_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:1, rc:-1}
   then
     nd_insert_SUPPLIER_do_complete_s1 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_insert_SUPPLIER_rcv_push_s2_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
  rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
  ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind
   map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s2_buf as ind
   map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s2_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s2_buf_d.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals ->
         map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s2_buf_d.update vals
         tuple}{None ->
                 map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s2_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:2, rc:-1}
   then
     nd_insert_SUPPLIER_do_complete_s2 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_insert_SUPPLIER_rcv_push_s2_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s2_buf as
   ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s2_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s2_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s2_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s2_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:2, rc:-1}
   then
     nd_insert_SUPPLIER_do_complete_s2 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_insert_SUPPLIER_rcv_push_s3_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s3_buf as
   ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s3_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s3_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s3_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s3_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:3, rc:-1}
   then
     nd_insert_SUPPLIER_do_complete_s3 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_insert_SUPPLIER_rcv_push_s4_m_REVENUE_mCUSTOMER12_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
  rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
  ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s4_buf as
   ind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s4_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER12_mSUPPLIER1_s4_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0 and rd
       == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER12_mSUPPLIER1_s4_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER12_mSUPPLIER1_s4_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:4, rc:-1}
   then
     nd_insert_SUPPLIER_do_complete_s4 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_insert_SUPPLIER_rcv_push_s4_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s4_buf as
   ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s4_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s4_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s4_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s4_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:4, rc:-1}
   then
     nd_insert_SUPPLIER_do_complete_s4 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_insert_SUPPLIER_rcv_push_s5_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
  rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
  ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind
   map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s5_buf as ind
   map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s5_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s5_buf_d.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals ->
         map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s5_buf_d.update vals
         tuple}{None ->
                 map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s5_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:5, rc:-1}
   then
     nd_insert_SUPPLIER_do_complete_s5 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_insert_SUPPLIER_rcv_push_s5_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s5_buf as
   ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s5_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s5_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s5_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s5_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:5, rc:-1}
   then
     nd_insert_SUPPLIER_do_complete_s5 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_insert_SUPPLIER_rcv_push_s6_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
  rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
  ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind
   map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s6_buf as ind
   map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s6_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s6_buf_d.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals ->
         map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s6_buf_d.update vals
         tuple}{None ->
                 map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s6_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:6, rc:-1}
   then
     nd_insert_SUPPLIER_do_complete_s6 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_insert_SUPPLIER_rcv_push_s6_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mSUPPLIER2_s6_buf as
   ind map_REVENUE_mORDERS11_mSUPPLIER2_s6_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mSUPPLIER2_s6_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mSUPPLIER2_s6_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mSUPPLIER2_s6_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:6, rc:-1}
   then
     nd_insert_SUPPLIER_do_complete_s6 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_insert_SUPPLIER_rcv_push_s7_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mSUPPLIER2_s7_buf as
   ind map_REVENUE_mORDERS11_mSUPPLIER2_s7_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mSUPPLIER2_s7_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mSUPPLIER2_s7_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mSUPPLIER2_s7_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:7, rc:-1}
   then
     nd_insert_SUPPLIER_do_complete_s7 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_insert_SUPPLIER_rcv_push_s8_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
  rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
  ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind
   map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s8_buf as ind
   map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s8_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s8_buf_d.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals ->
         map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s8_buf_d.update vals
         tuple}{None ->
                 map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s8_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:8, rc:-1}
   then
     nd_insert_SUPPLIER_do_complete_s8 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_insert_SUPPLIER_rcv_push_s8_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mSUPPLIER2_s8_buf as
   ind map_REVENUE_mORDERS11_mSUPPLIER2_s8_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mSUPPLIER2_s8_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mSUPPLIER2_s8_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mSUPPLIER2_s8_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:8, rc:-1}
   then
     nd_insert_SUPPLIER_do_complete_s8 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_insert_SUPPLIER_rcv_push_s9_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_insert_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mLINEITEM4_mSUPPLIER1_s9_buf as
   ind map_REVENUE_mLINEITEM4_mSUPPLIER1_s9_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mLINEITEM4_mSUPPLIER1_s9_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mLINEITEM4_mSUPPLIER1_s9_buf_d.update vals
         tuple}{None -> map_REVENUE_mLINEITEM4_mSUPPLIER1_s9_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:9, rc:-1}
   then
     nd_insert_SUPPLIER_do_complete_s9 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger insert_SUPPLIER_rcv_corrective_s0_m_REVENUE_mSUPPLIER11 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { ra:string,
  rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mSUPPLIER11_s0_buf, rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:0}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           insert_SUPPLIER_do_corrective_s0_m_REVENUE_mSUPPLIER11
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_SUPPLIER_rcv_corrective_s0_m_REVENUE_mSUPPLIER12 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { ra:string,
  rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mSUPPLIER12_s0_buf, rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:0}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           insert_SUPPLIER_do_corrective_s0_m_REVENUE_mSUPPLIER12
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_SUPPLIER_rcv_corrective_s1_m_REVENUE_mCUSTOMER11_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s1_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:1}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           insert_SUPPLIER_do_corrective_s1_m_REVENUE_mCUSTOMER11_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_SUPPLIER_rcv_corrective_s2_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s2_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:2}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           insert_SUPPLIER_do_corrective_s2_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_SUPPLIER_rcv_corrective_s4_m_REVENUE_mCUSTOMER12_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s4_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:4}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           insert_SUPPLIER_do_corrective_s4_m_REVENUE_mCUSTOMER12_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_SUPPLIER_rcv_corrective_s5_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s5_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:5}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           insert_SUPPLIER_do_corrective_s5_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_SUPPLIER_rcv_corrective_s6_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s6_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:6}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           insert_SUPPLIER_do_corrective_s6_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_SUPPLIER_rcv_corrective_s6_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mSUPPLIER2_s6_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:6}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           insert_SUPPLIER_do_corrective_s6_m_REVENUE_mORDERS11_mSUPPLIER2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_SUPPLIER_rcv_corrective_s7_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mSUPPLIER2_s7_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:7}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           insert_SUPPLIER_do_corrective_s7_m_REVENUE_mORDERS11_mSUPPLIER2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_SUPPLIER_rcv_corrective_s8_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s8_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:8}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           insert_SUPPLIER_do_corrective_s8_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_SUPPLIER_rcv_corrective_s8_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mSUPPLIER2_s8_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:8}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           insert_SUPPLIER_do_corrective_s8_m_REVENUE_mORDERS11_mSUPPLIER2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_SUPPLIER_rcv_corrective_s9_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mLINEITEM4_mSUPPLIER1_s9_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:9}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           insert_SUPPLIER_do_corrective_s9_m_REVENUE_mLINEITEM4_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger nd_delete_SUPPLIER_rcv_put : { ra:address, rb:collection { key:int,
  value:int } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:string,
  rf:string, rg:int, rh:string, ri:real, rj:string } = (\b1 ->
  bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid, rd:SUPPLIER_SUPPKEY,
  re:SUPPLIER_NAME, rf:SUPPLIER_ADDRESS, rg:SUPPLIER_NATIONKEY,
  rh:SUPPLIER_PHONE, ri:SUPPLIER_ACCTBAL, rj:SUPPLIER_COMMENT} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 19
     then
       nd_delete_SUPPLIER_do_complete_s19 {ra:vid, rb:SUPPLIER_SUPPKEY,
         rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
         rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
     else if stmt_id == 18
       then
         nd_delete_SUPPLIER_do_complete_s18 {ra:vid, rb:SUPPLIER_SUPPKEY,
           rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
           rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
       else if stmt_id == 17
         then
           nd_delete_SUPPLIER_do_complete_s17 {ra:vid, rb:SUPPLIER_SUPPKEY,
             rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
             rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
         else if stmt_id == 16
           then
             nd_delete_SUPPLIER_do_complete_s16 {ra:vid, rb:SUPPLIER_SUPPKEY,
               rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
               rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
           else if stmt_id == 15
             then
               nd_delete_SUPPLIER_do_complete_s15 {ra:vid, rb:SUPPLIER_SUPPKEY,
                 rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                 rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
             else if stmt_id == 14
               then
                 nd_delete_SUPPLIER_do_complete_s14 {ra:vid,
                   rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS,
                   re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
                   rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
               else if stmt_id == 13
                 then
                   nd_delete_SUPPLIER_do_complete_s13 {ra:vid,
                     rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                     rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                     rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
                     rh:SUPPLIER_COMMENT}
                 else if stmt_id == 12
                   then
                     nd_delete_SUPPLIER_do_complete_s12 {ra:vid,
                       rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                       rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
                       rh:SUPPLIER_COMMENT}
                   else if stmt_id == 11
                     then
                       nd_delete_SUPPLIER_do_complete_s11 {ra:vid,
                         rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                         rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                         rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
                         rh:SUPPLIER_COMMENT}
                     else if stmt_id == 10
                       then
                         nd_delete_SUPPLIER_do_complete_s10 {ra:vid,
                           rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                           rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                           rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
                           rh:SUPPLIER_COMMENT} else () else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_delete_SUPPLIER_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 10
   then if map_id == 20
     then
       (nd_delete_SUPPLIER_send_push_s10_m_REVENUE_mSUPPLIER11, me)<- {ra:vid,
       rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS,
       re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
       rh:SUPPLIER_COMMENT}
     else if map_id == 21
       then
         (nd_delete_SUPPLIER_send_push_s10_m_REVENUE_mSUPPLIER12, me)<- {ra:vid,
         rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS,
         re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
         rh:SUPPLIER_COMMENT} else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 11
     then if map_id == 8
       then
         (nd_delete_SUPPLIER_send_push_s11_m_REVENUE_mCUSTOMER11_mSUPPLIER1,
           me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
         rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
         rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
       else if map_id == 9
         then
           (nd_delete_SUPPLIER_send_push_s11_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
             me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
           rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
           rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 12
       then if map_id == 5
         then
           (nd_delete_SUPPLIER_send_push_s12_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
             me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
           rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
           rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
         else if map_id == 9
           then
             (nd_delete_SUPPLIER_send_push_s12_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
               me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
             rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
             rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
           else error (print "nd_rcv_fetch: invalid map id")
       else if stmt_id == 13
         then if map_id == 9
           then
             (nd_delete_SUPPLIER_send_push_s13_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
               me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
             rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
             rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
           else error (print "nd_rcv_fetch: invalid map id")
         else if stmt_id == 14
           then if map_id == 13
             then
               (nd_delete_SUPPLIER_send_push_s14_m_REVENUE_mCUSTOMER12_mSUPPLIER1,
                 me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
               rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
               rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
             else if map_id == 9
               then
                 (nd_delete_SUPPLIER_send_push_s14_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
                   me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                 rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
                 rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
               else error (print "nd_rcv_fetch: invalid map id")
           else if stmt_id == 15
             then if map_id == 12
               then
                 (nd_delete_SUPPLIER_send_push_s15_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
                   me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                 rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
                 rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
               else if map_id == 9
                 then
                   (nd_delete_SUPPLIER_send_push_s15_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
                     me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                   rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                   rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
                 else error (print "nd_rcv_fetch: invalid map id")
             else if stmt_id == 16
               then if map_id == 5
                 then
                   (nd_delete_SUPPLIER_send_push_s16_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
                     me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                   rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                   rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
                 else if map_id == 16
                   then
                     (nd_delete_SUPPLIER_send_push_s16_m_REVENUE_mORDERS11_mSUPPLIER2,
                       me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                     rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                     rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
                     rh:SUPPLIER_COMMENT}
                   else error (print "nd_rcv_fetch: invalid map id")
               else if stmt_id == 17
                 then if map_id == 16
                   then
                     (nd_delete_SUPPLIER_send_push_s17_m_REVENUE_mORDERS11_mSUPPLIER2,
                       me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                     rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                     rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
                     rh:SUPPLIER_COMMENT}
                   else error (print "nd_rcv_fetch: invalid map id")
                 else if stmt_id == 18
                   then if map_id == 12
                     then
                       (nd_delete_SUPPLIER_send_push_s18_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
                         me)<- {ra:vid, rb:SUPPLIER_SUPPKEY, rc:SUPPLIER_NAME,
                       rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
                       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL,
                       rh:SUPPLIER_COMMENT}
                     else if map_id == 16
                       then
                         (nd_delete_SUPPLIER_send_push_s18_m_REVENUE_mORDERS11_mSUPPLIER2,
                           me)<- {ra:vid, rb:SUPPLIER_SUPPKEY,
                         rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS,
                         re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
                         rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
                       else error (print "nd_rcv_fetch: invalid map id")
                   else if stmt_id == 19
                     then if map_id == 19
                       then
                         (nd_delete_SUPPLIER_send_push_s19_m_REVENUE_mLINEITEM4_mSUPPLIER1,
                           me)<- {ra:vid, rb:SUPPLIER_SUPPKEY,
                         rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS,
                         re:SUPPLIER_NATIONKEY, rf:SUPPLIER_PHONE,
                         rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT}
                       else error (print "nd_rcv_fetch: invalid map id")
                     else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_delete_SUPPLIER_send_push_s10_m_REVENUE_mSUPPLIER11 : { ra:{
  key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mSUPPLIER11 as ind REVENUE_mSUPPLIER11_deref in
  ((nd_log_master_write {key:vid, value:10});
   (shuffle_REVENUE_mSUPPLIER11_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
      rb:None immut, rc:None immut,
      rd:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mSUPPLIER11_deref.filter ((\b1 -> bind b1 as {ra:ra,
           rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in re ==
           SUPPLIER_NATIONKEY and rf == SUPPLIER_SUPPKEY))}, re:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_SUPPLIER_rcv_push_s10_m_REVENUE_mSUPPLIER11, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_delete_SUPPLIER_send_push_s10_m_REVENUE_mSUPPLIER12 : { ra:{
  key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mSUPPLIER12 as ind REVENUE_mSUPPLIER12_deref in
  ((nd_log_master_write {key:vid, value:10});
   (shuffle_REVENUE_mSUPPLIER12_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
      rb:None immut, rc:None immut,
      rd:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mSUPPLIER12_deref.filter ((\b1 -> bind b1 as {ra:ra,
           rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in re ==
           SUPPLIER_NATIONKEY and rf == SUPPLIER_SUPPKEY))}, re:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_SUPPLIER_rcv_push_s10_m_REVENUE_mSUPPLIER12, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_delete_SUPPLIER_send_push_s11_m_REVENUE_mCUSTOMER11_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER1 as ind REVENUE_mCUSTOMER11_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:11});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER1_to_REVENUE_mCUSTOMER11_bind_2t0_4t1
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
           SUPPLIER_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_SUPPLIER_rcv_push_s11_m_REVENUE_mCUSTOMER11_mSUPPLIER1, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_delete_SUPPLIER_send_push_s11_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:11});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_SUPPLIER_rcv_push_s11_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_delete_SUPPLIER_send_push_s12_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 as ind
  REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:12});
   (shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER11_mORDERS1_bind_2t0_4t1
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
           SUPPLIER_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_SUPPLIER_rcv_push_s12_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
     ip)<- {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
   re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
   rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT}))))
trigger nd_delete_SUPPLIER_send_push_s12_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:12});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER11_mORDERS1_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_SUPPLIER_rcv_push_s12_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_delete_SUPPLIER_send_push_s13_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:13});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER11_mLINEITEM4_bind_0t0_1t1_2t2
      {ra:None immut, rb:None immut, rc:None immut, rd:Some SUPPLIER_SUPPKEY,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rf:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_SUPPLIER_rcv_push_s13_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_delete_SUPPLIER_send_push_s14_m_REVENUE_mCUSTOMER12_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER12_mSUPPLIER1 as ind REVENUE_mCUSTOMER12_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:14});
   (shuffle_REVENUE_mCUSTOMER12_mSUPPLIER1_to_REVENUE_mCUSTOMER12_bind_2t0_4t1
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
           SUPPLIER_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_SUPPLIER_rcv_push_s14_m_REVENUE_mCUSTOMER12_mSUPPLIER1, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_delete_SUPPLIER_send_push_s14_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:14});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_SUPPLIER_rcv_push_s14_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_delete_SUPPLIER_send_push_s15_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 as ind
  REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:15});
   (shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER12_mORDERS1_bind_2t0_4t1
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
           SUPPLIER_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_SUPPLIER_rcv_push_s15_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
     ip)<- {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
   re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
   rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT}))))
trigger nd_delete_SUPPLIER_send_push_s15_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:15});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mCUSTOMER12_mORDERS1_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_SUPPLIER_rcv_push_s15_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_delete_SUPPLIER_send_push_s16_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 as ind
  REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:16});
   (shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mORDERS11_bind_2t0_4t1
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
           SUPPLIER_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_SUPPLIER_rcv_push_s16_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
     ip)<- {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
   re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
   rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT}))))
trigger nd_delete_SUPPLIER_send_push_s16_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mORDERS11_mSUPPLIER2 as ind REVENUE_mORDERS11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:16});
   (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS11_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_SUPPLIER_rcv_push_s16_m_REVENUE_mORDERS11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_delete_SUPPLIER_send_push_s17_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mORDERS11_mSUPPLIER2 as ind REVENUE_mORDERS11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:17});
   (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS11_mLINEITEM4_bind_0t0_1t1_2t2
      {ra:None immut, rb:None immut, rc:None immut, rd:Some SUPPLIER_SUPPKEY,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rf:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_SUPPLIER_rcv_push_s17_m_REVENUE_mORDERS11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_delete_SUPPLIER_send_push_s18_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 as ind
  REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:18});
   (shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mORDERS12_bind_2t0_4t1
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rd ==
           SUPPLIER_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_SUPPLIER_rcv_push_s18_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
     ip)<- {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
   re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
   rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT}))))
trigger nd_delete_SUPPLIER_send_push_s18_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mORDERS11_mSUPPLIER2 as ind REVENUE_mORDERS11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:18});
   (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mORDERS12_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_SUPPLIER_rcv_push_s18_m_REVENUE_mORDERS11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_delete_SUPPLIER_send_push_s19_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string } = (\b1 -> bind b1 as {ra:vid, rb:SUPPLIER_SUPPKEY,
  rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
  rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} in bind
  REVENUE_mLINEITEM4_mSUPPLIER1 as ind REVENUE_mLINEITEM4_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:19});
   (shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mLINEITEM4_bind_0t0_1t1_2t2
      {ra:None immut, rb:None immut, rc:None immut, rd:Some SUPPLIER_SUPPKEY,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mLINEITEM4_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           SUPPLIER_NATIONKEY))}, rf:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_SUPPLIER_rcv_push_s19_m_REVENUE_mLINEITEM4_mSUPPLIER1, ip)<- {ra:tuples,
   rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
   rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
   ri:SUPPLIER_COMMENT}))))
trigger nd_delete_SUPPLIER_rcv_push_s10_m_REVENUE_mSUPPLIER11 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int, rg:real } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:string, re:string, rf:int, rg:string, rh:real, ri:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mSUPPLIER11_s10_buf as ind
   map_REVENUE_mSUPPLIER11_s10_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mSUPPLIER11_s10_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra
       == _tup0 and rf == _tup5) and re == _tup4) and rd == _tup3) and rc ==
       _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mSUPPLIER11_s10_buf_d.update vals tuple}
       {None -> map_REVENUE_mSUPPLIER11_s10_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:10, rc:-1}
   then
     nd_delete_SUPPLIER_do_complete_s10 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_delete_SUPPLIER_rcv_push_s10_m_REVENUE_mSUPPLIER12 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int, rg:real } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:string, re:string, rf:int, rg:string, rh:real, ri:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mSUPPLIER12_s10_buf as ind
   map_REVENUE_mSUPPLIER12_s10_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mSUPPLIER12_s10_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra
       == _tup0 and rf == _tup5) and re == _tup4) and rd == _tup3) and rc ==
       _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mSUPPLIER12_s10_buf_d.update vals tuple}
       {None -> map_REVENUE_mSUPPLIER12_s10_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:10, rc:-1}
   then
     nd_delete_SUPPLIER_do_complete_s10 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_delete_SUPPLIER_rcv_push_s11_m_REVENUE_mCUSTOMER11_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
  rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
  ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s11_buf
   as ind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s11_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER1_s11_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0 and rd
       == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER1_s11_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER1_s11_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:11, rc:-1}
   then
     nd_delete_SUPPLIER_do_complete_s11 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_delete_SUPPLIER_rcv_push_s11_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s11_buf
   as ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s11_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s11_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s11_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s11_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:11, rc:-1}
   then
     nd_delete_SUPPLIER_do_complete_s11 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_delete_SUPPLIER_rcv_push_s12_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
  rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
  ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind
   map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s12_buf as ind
   map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s12_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s12_buf_d.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals ->
         map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s12_buf_d.update vals
         tuple}{None ->
                 map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s12_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:12, rc:-1}
   then
     nd_delete_SUPPLIER_do_complete_s12 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_delete_SUPPLIER_rcv_push_s12_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s12_buf
   as ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s12_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s12_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s12_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s12_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:12, rc:-1}
   then
     nd_delete_SUPPLIER_do_complete_s12 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_delete_SUPPLIER_rcv_push_s13_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s13_buf
   as ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s13_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s13_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s13_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s13_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:13, rc:-1}
   then
     nd_delete_SUPPLIER_do_complete_s13 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_delete_SUPPLIER_rcv_push_s14_m_REVENUE_mCUSTOMER12_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
  rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
  ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s14_buf
   as ind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s14_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER12_mSUPPLIER1_s14_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0 and rd
       == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER12_mSUPPLIER1_s14_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER12_mSUPPLIER1_s14_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:14, rc:-1}
   then
     nd_delete_SUPPLIER_do_complete_s14 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_delete_SUPPLIER_rcv_push_s14_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s14_buf
   as ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s14_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s14_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s14_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s14_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:14, rc:-1}
   then
     nd_delete_SUPPLIER_do_complete_s14 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_delete_SUPPLIER_rcv_push_s15_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
  rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
  ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind
   map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s15_buf as ind
   map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s15_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s15_buf_d.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals ->
         map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s15_buf_d.update vals
         tuple}{None ->
                 map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s15_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:15, rc:-1}
   then
     nd_delete_SUPPLIER_do_complete_s15 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_delete_SUPPLIER_rcv_push_s15_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s15_buf
   as ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s15_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s15_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s15_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s15_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:15, rc:-1}
   then
     nd_delete_SUPPLIER_do_complete_s15 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_delete_SUPPLIER_rcv_push_s16_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
  rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
  ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind
   map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s16_buf as ind
   map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s16_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s16_buf_d.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals ->
         map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s16_buf_d.update vals
         tuple}{None ->
                 map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s16_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:16, rc:-1}
   then
     nd_delete_SUPPLIER_do_complete_s16 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_delete_SUPPLIER_rcv_push_s16_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mSUPPLIER2_s16_buf as
   ind map_REVENUE_mORDERS11_mSUPPLIER2_s16_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mSUPPLIER2_s16_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mSUPPLIER2_s16_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mSUPPLIER2_s16_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:16, rc:-1}
   then
     nd_delete_SUPPLIER_do_complete_s16 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_delete_SUPPLIER_rcv_push_s17_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mSUPPLIER2_s17_buf as
   ind map_REVENUE_mORDERS11_mSUPPLIER2_s17_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mSUPPLIER2_s17_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mSUPPLIER2_s17_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mSUPPLIER2_s17_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:17, rc:-1}
   then
     nd_delete_SUPPLIER_do_complete_s17 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_delete_SUPPLIER_rcv_push_s18_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string } = (\b1 -> bind b1 as {ra:tuples,
  rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME, re:SUPPLIER_ADDRESS,
  rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE, rh:SUPPLIER_ACCTBAL,
  ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind
   map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s18_buf as ind
   map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s18_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s18_buf_d.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals ->
         map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s18_buf_d.update vals
         tuple}{None ->
                 map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s18_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:18, rc:-1}
   then
     nd_delete_SUPPLIER_do_complete_s18 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_delete_SUPPLIER_rcv_push_s18_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mSUPPLIER2_s18_buf as
   ind map_REVENUE_mORDERS11_mSUPPLIER2_s18_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mSUPPLIER2_s18_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mSUPPLIER2_s18_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mSUPPLIER2_s18_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:18, rc:-1}
   then
     nd_delete_SUPPLIER_do_complete_s18 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger nd_delete_SUPPLIER_rcv_push_s19_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:SUPPLIER_SUPPKEY, rd:SUPPLIER_NAME,
  re:SUPPLIER_ADDRESS, rf:SUPPLIER_NATIONKEY, rg:SUPPLIER_PHONE,
  rh:SUPPLIER_ACCTBAL, ri:SUPPLIER_COMMENT} in 
  ((nd_log_write_delete_SUPPLIER {ra:vid, rb:SUPPLIER_SUPPKEY,
      rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
      rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mLINEITEM4_mSUPPLIER1_s19_buf as
   ind map_REVENUE_mLINEITEM4_mSUPPLIER1_s19_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mLINEITEM4_mSUPPLIER1_s19_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mLINEITEM4_mSUPPLIER1_s19_buf_d.update vals
         tuple}{None -> map_REVENUE_mLINEITEM4_mSUPPLIER1_s19_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:19, rc:-1}
   then
     nd_delete_SUPPLIER_do_complete_s19 {ra:vid, rb:SUPPLIER_SUPPKEY,
       rc:SUPPLIER_NAME, rd:SUPPLIER_ADDRESS, re:SUPPLIER_NATIONKEY,
       rf:SUPPLIER_PHONE, rg:SUPPLIER_ACCTBAL, rh:SUPPLIER_COMMENT} else ())))
trigger delete_SUPPLIER_rcv_corrective_s10_m_REVENUE_mSUPPLIER11 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mSUPPLIER11_s10_buf, rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:10}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           delete_SUPPLIER_do_corrective_s10_m_REVENUE_mSUPPLIER11
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_SUPPLIER_rcv_corrective_s10_m_REVENUE_mSUPPLIER12 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mSUPPLIER12_s10_buf, rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:10}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           delete_SUPPLIER_do_corrective_s10_m_REVENUE_mSUPPLIER12
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_SUPPLIER_rcv_corrective_s11_m_REVENUE_mCUSTOMER11_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s11_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:11}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           delete_SUPPLIER_do_corrective_s11_m_REVENUE_mCUSTOMER11_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_SUPPLIER_rcv_corrective_s12_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s12_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:12}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           delete_SUPPLIER_do_corrective_s12_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_SUPPLIER_rcv_corrective_s14_m_REVENUE_mCUSTOMER12_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s14_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:14}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           delete_SUPPLIER_do_corrective_s14_m_REVENUE_mCUSTOMER12_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_SUPPLIER_rcv_corrective_s15_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s15_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:15}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           delete_SUPPLIER_do_corrective_s15_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_SUPPLIER_rcv_corrective_s16_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s16_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:16}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           delete_SUPPLIER_do_corrective_s16_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_SUPPLIER_rcv_corrective_s16_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mSUPPLIER2_s16_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:16}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           delete_SUPPLIER_do_corrective_s16_m_REVENUE_mORDERS11_mSUPPLIER2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_SUPPLIER_rcv_corrective_s17_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mSUPPLIER2_s17_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:17}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           delete_SUPPLIER_do_corrective_s17_m_REVENUE_mORDERS11_mSUPPLIER2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_SUPPLIER_rcv_corrective_s18_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s18_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:18}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           delete_SUPPLIER_do_corrective_s18_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_SUPPLIER_rcv_corrective_s18_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mSUPPLIER2_s18_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:18}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           delete_SUPPLIER_do_corrective_s18_m_REVENUE_mORDERS11_mSUPPLIER2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_SUPPLIER_rcv_corrective_s19_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mLINEITEM4_mSUPPLIER1_s19_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:19}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_SUPPLIER compute_vid as
         {ra:SUPPLIER_SUPPKEY, rb:SUPPLIER_NAME, rc:SUPPLIER_ADDRESS, rd:SUPPLIER_NATIONKEY, re:SUPPLIER_PHONE, rf:SUPPLIER_ACCTBAL, rg:SUPPLIER_COMMENT}
         in
         acc_count +
           delete_SUPPLIER_do_corrective_s19_m_REVENUE_mLINEITEM4_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:SUPPLIER_SUPPKEY, rg:SUPPLIER_NAME,
             rh:SUPPLIER_ADDRESS, ri:SUPPLIER_NATIONKEY, rj:SUPPLIER_PHONE,
             rk:SUPPLIER_ACCTBAL, rl:SUPPLIER_COMMENT, rm:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger nd_insert_CUSTOMER_rcv_put : { ra:address, rb:collection { key:int,
  value:int } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:string,
  rf:string, rg:int, rh:string, ri:real, rj:string, rk:string } = (\b1 ->
  bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid, rd:CUSTOMER_CUSTKEY,
  re:CUSTOMER_NAME, rf:CUSTOMER_ADDRESS, rg:CUSTOMER_NATIONKEY,
  rh:CUSTOMER_PHONE, ri:CUSTOMER_ACCTBAL, rj:CUSTOMER_MKTSEGMENT,
  rk:CUSTOMER_COMMENT} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 28
     then
       nd_insert_CUSTOMER_do_complete_s28 {ra:vid, rb:CUSTOMER_CUSTKEY,
         rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
         rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
         ri:CUSTOMER_COMMENT}
     else if stmt_id == 27
       then
         nd_insert_CUSTOMER_do_complete_s27 {ra:vid, rb:CUSTOMER_CUSTKEY,
           rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
           rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
           ri:CUSTOMER_COMMENT}
       else if stmt_id == 26
         then
           nd_insert_CUSTOMER_do_complete_s26 {ra:vid, rb:CUSTOMER_CUSTKEY,
             rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
             rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
             ri:CUSTOMER_COMMENT}
         else if stmt_id == 25
           then
             nd_insert_CUSTOMER_do_complete_s25 {ra:vid, rb:CUSTOMER_CUSTKEY,
               rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
               rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
               ri:CUSTOMER_COMMENT}
           else if stmt_id == 24
             then
               nd_insert_CUSTOMER_do_complete_s24 {ra:vid, rb:CUSTOMER_CUSTKEY,
                 rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                 rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                 rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
             else if stmt_id == 23
               then
                 nd_insert_CUSTOMER_do_complete_s23 {ra:vid,
                   rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
                   re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE,
                   rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
                   ri:CUSTOMER_COMMENT}
               else if stmt_id == 22
                 then
                   nd_insert_CUSTOMER_do_complete_s22 {ra:vid,
                     rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                     rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                     rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                     rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
                 else if stmt_id == 21
                   then
                     nd_insert_CUSTOMER_do_complete_s21 {ra:vid,
                       rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                       rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                       rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
                   else if stmt_id == 20
                     then
                       nd_insert_CUSTOMER_do_complete_s20 {ra:vid,
                         rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                         rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                         rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                         rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} 
                     else () else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_insert_CUSTOMER_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string, rj:string } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 20
   then if map_id == 3
     then
       (nd_insert_CUSTOMER_send_push_s20_m_REVENUE_mCUSTOMER11, me)<- {ra:vid,
       rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
       re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
       rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
     else if map_id == 10
       then
         (nd_insert_CUSTOMER_send_push_s20_m_REVENUE_mCUSTOMER12, me)<- {ra:vid,
         rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
         re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
         rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 21
     then if map_id == 4
       then
         (nd_insert_CUSTOMER_send_push_s21_m_REVENUE_mCUSTOMER11_mORDERS1, me)<- {ra:vid,
         rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
         re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
         rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 22
       then if map_id == 6
         then
           (nd_insert_CUSTOMER_send_push_s22_m_REVENUE_mCUSTOMER11_mLINEITEM4,
             me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
           rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE,
           rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
       else if stmt_id == 23
         then if map_id == 9
           then
             (nd_insert_CUSTOMER_send_push_s23_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
               me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
             rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE,
             rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
           else error (print "nd_rcv_fetch: invalid map id")
         else if stmt_id == 24
           then if map_id == 11
             then
               (nd_insert_CUSTOMER_send_push_s24_m_REVENUE_mCUSTOMER12_mORDERS1,
                 me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
               rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE,
               rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
               ri:CUSTOMER_COMMENT}
             else error (print "nd_rcv_fetch: invalid map id")
           else if stmt_id == 25
             then if map_id == 6
               then
                 (nd_insert_CUSTOMER_send_push_s25_m_REVENUE_mCUSTOMER11_mLINEITEM4,
                   me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                 rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE,
                 rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
                 ri:CUSTOMER_COMMENT}
               else if map_id == 7
                 then
                   (nd_insert_CUSTOMER_send_push_s25_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                     me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                   rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                   rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                   rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
                 else error (print "nd_rcv_fetch: invalid map id")
             else if stmt_id == 26
               then if map_id == 7
                 then
                   (nd_insert_CUSTOMER_send_push_s26_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                     me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                   rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                   rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                   rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
                 else if map_id == 9
                   then
                     (nd_insert_CUSTOMER_send_push_s26_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
                       me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                     rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                     rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                     rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
                   else error (print "nd_rcv_fetch: invalid map id")
               else if stmt_id == 27
                 then if map_id == 8
                   then
                     (nd_insert_CUSTOMER_send_push_s27_m_REVENUE_mCUSTOMER11_mSUPPLIER1,
                       me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                     rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                     rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                     rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
                   else if map_id == 9
                     then
                       (nd_insert_CUSTOMER_send_push_s27_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
                         me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                       rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                       rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
                     else error (print "nd_rcv_fetch: invalid map id")
                 else if stmt_id == 28
                   then if map_id == 13
                     then
                       (nd_insert_CUSTOMER_send_push_s28_m_REVENUE_mCUSTOMER12_mSUPPLIER1,
                         me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                       rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                       rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
                     else if map_id == 9
                       then
                         (nd_insert_CUSTOMER_send_push_s28_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
                           me)<- {ra:vid, rb:CUSTOMER_CUSTKEY,
                         rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
                         re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE,
                         rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
                         ri:CUSTOMER_COMMENT}
                       else error (print "nd_rcv_fetch: invalid map id")
                   else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_insert_CUSTOMER_send_push_s20_m_REVENUE_mCUSTOMER11 : { ra:{
  key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind REVENUE_mCUSTOMER11 as
  ind REVENUE_mCUSTOMER11_deref in
  ((nd_log_master_write {key:vid, value:20});
   (shuffle_REVENUE_mCUSTOMER11_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
      rb:None immut, rc:None immut,
      rd:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_deref.filter ((\b1 -> bind b1 as {ra:ra,
           rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in re ==
           CUSTOMER_NATIONKEY and rf == CUSTOMER_CUSTKEY))}, re:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s20_m_REVENUE_mCUSTOMER11, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s20_m_REVENUE_mCUSTOMER12 : { ra:{
  key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind REVENUE_mCUSTOMER12 as
  ind REVENUE_mCUSTOMER12_deref in
  ((nd_log_master_write {key:vid, value:20});
   (shuffle_REVENUE_mCUSTOMER12_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
      rb:None immut, rc:None immut,
      rd:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_deref.filter ((\b1 -> bind b1 as {ra:ra,
           rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in re ==
           CUSTOMER_NATIONKEY and rf == CUSTOMER_CUSTKEY))}, re:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s20_m_REVENUE_mCUSTOMER12, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s21_m_REVENUE_mCUSTOMER11_mORDERS1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mORDERS1 as ind REVENUE_mCUSTOMER11_mORDERS1_deref in
  ((nd_log_master_write {key:vid, value:21});
   (shuffle_REVENUE_mCUSTOMER11_mORDERS1_to_REVENUE_mORDERS11_bind_0t0_1t1_2t2_4t4
      {ra:None immut, rb:None immut, rc:None immut, rd:Some CUSTOMER_CUSTKEY,
      re:None immut,
      rf:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_mORDERS1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in re
           == CUSTOMER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s21_m_REVENUE_mCUSTOMER11_mORDERS1, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s22_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM4 as ind REVENUE_mCUSTOMER11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:22});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mORDERS11_mLINEITEM4_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:Some CUSTOMER_CUSTKEY, rd:None immut,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           CUSTOMER_NATIONKEY))}, rf:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s22_m_REVENUE_mCUSTOMER11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s23_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:23});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mORDERS11_mSUPPLIER2_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:Some CUSTOMER_CUSTKEY, rd:None immut,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           CUSTOMER_NATIONKEY))}, rf:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s23_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s24_m_REVENUE_mCUSTOMER12_mORDERS1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER12_mORDERS1 as ind REVENUE_mCUSTOMER12_mORDERS1_deref in
  ((nd_log_master_write {key:vid, value:24});
   (shuffle_REVENUE_mCUSTOMER12_mORDERS1_to_REVENUE_mORDERS12_bind_0t0_1t1_2t2_4t4
      {ra:None immut, rb:None immut, rc:None immut, rd:Some CUSTOMER_CUSTKEY,
      re:None immut,
      rf:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_mORDERS1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in re
           == CUSTOMER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s24_m_REVENUE_mCUSTOMER12_mORDERS1, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s25_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM4 as ind REVENUE_mCUSTOMER11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:25});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mLINEITEM4_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           CUSTOMER_NATIONKEY))}, rf:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s25_m_REVENUE_mCUSTOMER11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s25_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM5 as ind REVENUE_mCUSTOMER11_mLINEITEM5_deref in
  ((nd_log_master_write {key:vid, value:25});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mLINEITEM4_bind_2t1
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:frontier_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM5_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))},
      rf:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s25_m_REVENUE_mCUSTOMER11_mLINEITEM5, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s26_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM5 as ind REVENUE_mCUSTOMER11_mLINEITEM5_deref in
  ((nd_log_master_write {key:vid, value:26});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_2t1
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:frontier_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM5_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))},
      rf:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s26_m_REVENUE_mCUSTOMER11_mLINEITEM5, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s26_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:26});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           CUSTOMER_NATIONKEY))}, rf:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s26_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s27_m_REVENUE_mCUSTOMER11_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER1 as ind REVENUE_mCUSTOMER11_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:27});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_2t0_4t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
           CUSTOMER_CUSTKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s27_m_REVENUE_mCUSTOMER11_mSUPPLIER1, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s27_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:27});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           CUSTOMER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s27_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s28_m_REVENUE_mCUSTOMER12_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER12_mSUPPLIER1 as ind REVENUE_mCUSTOMER12_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:28});
   (shuffle_REVENUE_mCUSTOMER12_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_2t0_4t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
           CUSTOMER_CUSTKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s28_m_REVENUE_mCUSTOMER12_mSUPPLIER1, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_send_push_s28_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:28});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           CUSTOMER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_CUSTOMER_rcv_push_s28_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_insert_CUSTOMER_rcv_push_s20_m_REVENUE_mCUSTOMER11 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int, rg:real } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:string, re:string, rf:int, rg:string, rh:real, ri:string,
  rj:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY,
  rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY,
  rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT,
  rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_s20_buf as ind
   map_REVENUE_mCUSTOMER11_s20_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mCUSTOMER11_s20_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra
       == _tup0 and rf == _tup5) and re == _tup4) and rd == _tup3) and rc ==
       _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_s20_buf_d.update vals tuple}
       {None -> map_REVENUE_mCUSTOMER11_s20_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:20, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s20 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s20_m_REVENUE_mCUSTOMER12 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int, rg:real } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:string, re:string, rf:int, rg:string, rh:real, ri:string,
  rj:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY,
  rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY,
  rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT,
  rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER12_s20_buf as ind
   map_REVENUE_mCUSTOMER12_s20_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mCUSTOMER12_s20_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra
       == _tup0 and rf == _tup5) and re == _tup4) and rd == _tup3) and rc ==
       _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER12_s20_buf_d.update vals tuple}
       {None -> map_REVENUE_mCUSTOMER12_s20_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:20, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s20 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s21_m_REVENUE_mCUSTOMER11_mORDERS1 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int, rg:real } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:string, re:string, rf:int, rg:string, rh:real, ri:string,
  rj:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY,
  rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY,
  rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT,
  rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mORDERS1_s21_buf as
   ind map_REVENUE_mCUSTOMER11_mORDERS1_s21_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mCUSTOMER11_mORDERS1_s21_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra
       == _tup0 and rf == _tup5) and re == _tup4) and rd == _tup3) and rc ==
       _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mORDERS1_s21_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mORDERS1_s21_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:21, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s21 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s22_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string, rj:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s22_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM4_s22_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM4_s22_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s22_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s22_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:22, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s22 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s23_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string, rj:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s23_buf
   as ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s23_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s23_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s23_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s23_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:23, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s23 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s24_m_REVENUE_mCUSTOMER12_mORDERS1 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int, rg:real } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:string, re:string, rf:int, rg:string, rh:real, ri:string,
  rj:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY,
  rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY,
  rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT,
  rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER12_mORDERS1_s24_buf as
   ind map_REVENUE_mCUSTOMER12_mORDERS1_s24_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mCUSTOMER12_mORDERS1_s24_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra
       == _tup0 and rf == _tup5) and re == _tup4) and rd == _tup3) and rc ==
       _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER12_mORDERS1_s24_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER12_mORDERS1_s24_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:24, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s24 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s25_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string, rj:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s25_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM4_s25_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM4_s25_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s25_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s25_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:25, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s25 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s25_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string, rj:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s25_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM5_s25_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM5_s25_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2)
       and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s25_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s25_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:25, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s25 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s26_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string, rj:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s26_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM5_s26_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM5_s26_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2)
       and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s26_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s26_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:26, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s26 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s26_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string, rj:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s26_buf
   as ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s26_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s26_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s26_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s26_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:26, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s26 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s27_m_REVENUE_mCUSTOMER11_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string, rj:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s27_buf
   as ind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s27_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER1_s27_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0 and rd
       == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER1_s27_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER1_s27_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:27, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s27 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s27_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string, rj:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s27_buf
   as ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s27_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s27_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s27_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s27_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:27, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s27 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s28_m_REVENUE_mCUSTOMER12_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string, rj:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s28_buf
   as ind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s28_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER12_mSUPPLIER1_s28_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0 and rd
       == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER12_mSUPPLIER1_s28_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER12_mSUPPLIER1_s28_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:28, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s28 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_insert_CUSTOMER_rcv_push_s28_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string, rj:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_insert_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s28_buf
   as ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s28_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s28_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s28_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s28_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:28, rc:-1}
   then
     nd_insert_CUSTOMER_do_complete_s28 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger insert_CUSTOMER_rcv_corrective_s20_m_REVENUE_mCUSTOMER11 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_s20_buf, rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:20}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s20_m_REVENUE_mCUSTOMER11
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_CUSTOMER_rcv_corrective_s20_m_REVENUE_mCUSTOMER12 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_s20_buf, rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:20}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s20_m_REVENUE_mCUSTOMER12
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_CUSTOMER_rcv_corrective_s21_m_REVENUE_mCUSTOMER11_mORDERS1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_mORDERS1_s21_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:21}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s21_m_REVENUE_mCUSTOMER11_mORDERS1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_CUSTOMER_rcv_corrective_s22_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mCUSTOMER11_mLINEITEM4_s22_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:22}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s22_m_REVENUE_mCUSTOMER11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_CUSTOMER_rcv_corrective_s24_m_REVENUE_mCUSTOMER12_mORDERS1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_mORDERS1_s24_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:24}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s24_m_REVENUE_mCUSTOMER12_mORDERS1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_CUSTOMER_rcv_corrective_s25_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mCUSTOMER11_mLINEITEM4_s25_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:25}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s25_m_REVENUE_mCUSTOMER11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_CUSTOMER_rcv_corrective_s25_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_REVENUE_mCUSTOMER11_mLINEITEM5_s25_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:25}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s25_m_REVENUE_mCUSTOMER11_mLINEITEM5
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_CUSTOMER_rcv_corrective_s26_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_REVENUE_mCUSTOMER11_mLINEITEM5_s26_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:26}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s26_m_REVENUE_mCUSTOMER11_mLINEITEM5
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_CUSTOMER_rcv_corrective_s27_m_REVENUE_mCUSTOMER11_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s27_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:27}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s27_m_REVENUE_mCUSTOMER11_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_CUSTOMER_rcv_corrective_s28_m_REVENUE_mCUSTOMER12_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s28_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:28}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           insert_CUSTOMER_do_corrective_s28_m_REVENUE_mCUSTOMER12_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger nd_delete_CUSTOMER_rcv_put : { ra:address, rb:collection { key:int,
  value:int } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:string,
  rf:string, rg:int, rh:string, ri:real, rj:string, rk:string } = (\b1 ->
  bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid, rd:CUSTOMER_CUSTKEY,
  re:CUSTOMER_NAME, rf:CUSTOMER_ADDRESS, rg:CUSTOMER_NATIONKEY,
  rh:CUSTOMER_PHONE, ri:CUSTOMER_ACCTBAL, rj:CUSTOMER_MKTSEGMENT,
  rk:CUSTOMER_COMMENT} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 37
     then
       nd_delete_CUSTOMER_do_complete_s37 {ra:vid, rb:CUSTOMER_CUSTKEY,
         rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
         rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
         ri:CUSTOMER_COMMENT}
     else if stmt_id == 36
       then
         nd_delete_CUSTOMER_do_complete_s36 {ra:vid, rb:CUSTOMER_CUSTKEY,
           rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
           rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
           ri:CUSTOMER_COMMENT}
       else if stmt_id == 35
         then
           nd_delete_CUSTOMER_do_complete_s35 {ra:vid, rb:CUSTOMER_CUSTKEY,
             rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
             rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
             ri:CUSTOMER_COMMENT}
         else if stmt_id == 34
           then
             nd_delete_CUSTOMER_do_complete_s34 {ra:vid, rb:CUSTOMER_CUSTKEY,
               rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
               rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
               ri:CUSTOMER_COMMENT}
           else if stmt_id == 33
             then
               nd_delete_CUSTOMER_do_complete_s33 {ra:vid, rb:CUSTOMER_CUSTKEY,
                 rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                 rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                 rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
             else if stmt_id == 32
               then
                 nd_delete_CUSTOMER_do_complete_s32 {ra:vid,
                   rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
                   re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE,
                   rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
                   ri:CUSTOMER_COMMENT}
               else if stmt_id == 31
                 then
                   nd_delete_CUSTOMER_do_complete_s31 {ra:vid,
                     rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                     rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                     rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                     rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
                 else if stmt_id == 30
                   then
                     nd_delete_CUSTOMER_do_complete_s30 {ra:vid,
                       rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                       rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                       rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
                   else if stmt_id == 29
                     then
                       nd_delete_CUSTOMER_do_complete_s29 {ra:vid,
                         rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                         rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                         rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                         rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} 
                     else () else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_delete_CUSTOMER_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string, rj:string } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 29
   then if map_id == 3
     then
       (nd_delete_CUSTOMER_send_push_s29_m_REVENUE_mCUSTOMER11, me)<- {ra:vid,
       rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
       re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
       rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
     else if map_id == 10
       then
         (nd_delete_CUSTOMER_send_push_s29_m_REVENUE_mCUSTOMER12, me)<- {ra:vid,
         rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
         re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
         rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 30
     then if map_id == 4
       then
         (nd_delete_CUSTOMER_send_push_s30_m_REVENUE_mCUSTOMER11_mORDERS1, me)<- {ra:vid,
         rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
         re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
         rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 31
       then if map_id == 6
         then
           (nd_delete_CUSTOMER_send_push_s31_m_REVENUE_mCUSTOMER11_mLINEITEM4,
             me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
           rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE,
           rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
       else if stmt_id == 32
         then if map_id == 9
           then
             (nd_delete_CUSTOMER_send_push_s32_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
               me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
             rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE,
             rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
           else error (print "nd_rcv_fetch: invalid map id")
         else if stmt_id == 33
           then if map_id == 11
             then
               (nd_delete_CUSTOMER_send_push_s33_m_REVENUE_mCUSTOMER12_mORDERS1,
                 me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
               rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE,
               rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
               ri:CUSTOMER_COMMENT}
             else error (print "nd_rcv_fetch: invalid map id")
           else if stmt_id == 34
             then if map_id == 6
               then
                 (nd_delete_CUSTOMER_send_push_s34_m_REVENUE_mCUSTOMER11_mLINEITEM4,
                   me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                 rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE,
                 rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
                 ri:CUSTOMER_COMMENT}
               else if map_id == 7
                 then
                   (nd_delete_CUSTOMER_send_push_s34_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                     me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                   rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                   rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                   rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
                 else error (print "nd_rcv_fetch: invalid map id")
             else if stmt_id == 35
               then if map_id == 7
                 then
                   (nd_delete_CUSTOMER_send_push_s35_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                     me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                   rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                   rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                   rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
                 else if map_id == 9
                   then
                     (nd_delete_CUSTOMER_send_push_s35_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
                       me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                     rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                     rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                     rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
                   else error (print "nd_rcv_fetch: invalid map id")
               else if stmt_id == 36
                 then if map_id == 8
                   then
                     (nd_delete_CUSTOMER_send_push_s36_m_REVENUE_mCUSTOMER11_mSUPPLIER1,
                       me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                     rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                     rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                     rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
                   else if map_id == 9
                     then
                       (nd_delete_CUSTOMER_send_push_s36_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
                         me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                       rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                       rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
                     else error (print "nd_rcv_fetch: invalid map id")
                 else if stmt_id == 37
                   then if map_id == 13
                     then
                       (nd_delete_CUSTOMER_send_push_s37_m_REVENUE_mCUSTOMER12_mSUPPLIER1,
                         me)<- {ra:vid, rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME,
                       rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
                       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
                       rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT}
                     else if map_id == 9
                       then
                         (nd_delete_CUSTOMER_send_push_s37_m_REVENUE_mCUSTOMER11_mSUPPLIER2,
                           me)<- {ra:vid, rb:CUSTOMER_CUSTKEY,
                         rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
                         re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE,
                         rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
                         ri:CUSTOMER_COMMENT}
                       else error (print "nd_rcv_fetch: invalid map id")
                   else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_delete_CUSTOMER_send_push_s29_m_REVENUE_mCUSTOMER11 : { ra:{
  key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind REVENUE_mCUSTOMER11 as
  ind REVENUE_mCUSTOMER11_deref in
  ((nd_log_master_write {key:vid, value:29});
   (shuffle_REVENUE_mCUSTOMER11_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
      rb:None immut, rc:None immut,
      rd:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_deref.filter ((\b1 -> bind b1 as {ra:ra,
           rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in re ==
           CUSTOMER_NATIONKEY and rf == CUSTOMER_CUSTKEY))}, re:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s29_m_REVENUE_mCUSTOMER11, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_send_push_s29_m_REVENUE_mCUSTOMER12 : { ra:{
  key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind REVENUE_mCUSTOMER12 as
  ind REVENUE_mCUSTOMER12_deref in
  ((nd_log_master_write {key:vid, value:29});
   (shuffle_REVENUE_mCUSTOMER12_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
      rb:None immut, rc:None immut,
      rd:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_deref.filter ((\b1 -> bind b1 as {ra:ra,
           rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in re ==
           CUSTOMER_NATIONKEY and rf == CUSTOMER_CUSTKEY))}, re:true}).iterate
   ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s29_m_REVENUE_mCUSTOMER12, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_send_push_s30_m_REVENUE_mCUSTOMER11_mORDERS1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mORDERS1 as ind REVENUE_mCUSTOMER11_mORDERS1_deref in
  ((nd_log_master_write {key:vid, value:30});
   (shuffle_REVENUE_mCUSTOMER11_mORDERS1_to_REVENUE_mORDERS11_bind_0t0_1t1_2t2_4t4
      {ra:None immut, rb:None immut, rc:None immut, rd:Some CUSTOMER_CUSTKEY,
      re:None immut,
      rf:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_mORDERS1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in re
           == CUSTOMER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s30_m_REVENUE_mCUSTOMER11_mORDERS1, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_send_push_s31_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM4 as ind REVENUE_mCUSTOMER11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:31});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mORDERS11_mLINEITEM4_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:Some CUSTOMER_CUSTKEY, rd:None immut,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           CUSTOMER_NATIONKEY))}, rf:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s31_m_REVENUE_mCUSTOMER11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_send_push_s32_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:32});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mORDERS11_mSUPPLIER2_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:Some CUSTOMER_CUSTKEY, rd:None immut,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           CUSTOMER_NATIONKEY))}, rf:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s32_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_send_push_s33_m_REVENUE_mCUSTOMER12_mORDERS1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER12_mORDERS1 as ind REVENUE_mCUSTOMER12_mORDERS1_deref in
  ((nd_log_master_write {key:vid, value:33});
   (shuffle_REVENUE_mCUSTOMER12_mORDERS1_to_REVENUE_mORDERS12_bind_0t0_1t1_2t2_4t4
      {ra:None immut, rb:None immut, rc:None immut, rd:Some CUSTOMER_CUSTKEY,
      re:None immut,
      rf:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_mORDERS1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in re
           == CUSTOMER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s33_m_REVENUE_mCUSTOMER12_mORDERS1, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_send_push_s34_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM4 as ind REVENUE_mCUSTOMER11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:34});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mLINEITEM4_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           CUSTOMER_NATIONKEY))}, rf:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s34_m_REVENUE_mCUSTOMER11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_send_push_s34_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM5 as ind REVENUE_mCUSTOMER11_mLINEITEM5_deref in
  ((nd_log_master_write {key:vid, value:34});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mLINEITEM4_bind_2t1
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:frontier_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM5_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))},
      rf:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s34_m_REVENUE_mCUSTOMER11_mLINEITEM5, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_send_push_s35_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM5 as ind REVENUE_mCUSTOMER11_mLINEITEM5_deref in
  ((nd_log_master_write {key:vid, value:35});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_2t1
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:frontier_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM5_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rb == CUSTOMER_CUSTKEY))},
      rf:true}).iterate ((\b1 -> bind b1 as {key:ip, value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s35_m_REVENUE_mCUSTOMER11_mLINEITEM5, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_send_push_s35_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:35});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           CUSTOMER_NATIONKEY))}, rf:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s35_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_send_push_s36_m_REVENUE_mCUSTOMER11_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER1 as ind REVENUE_mCUSTOMER11_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:36});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_2t0_4t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
           CUSTOMER_CUSTKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s36_m_REVENUE_mCUSTOMER11_mSUPPLIER1, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_send_push_s36_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:36});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           CUSTOMER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s36_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_send_push_s37_m_REVENUE_mCUSTOMER12_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER12_mSUPPLIER1 as ind REVENUE_mCUSTOMER12_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:37});
   (shuffle_REVENUE_mCUSTOMER12_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_2t0_4t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
           CUSTOMER_CUSTKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s37_m_REVENUE_mCUSTOMER12_mSUPPLIER1, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_send_push_s37_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:{ key:int, value:int }, rb:int, rc:string, rd:string, re:int, rf:string,
  rg:real, rh:string, ri:string } = (\b1 -> bind b1 as {ra:vid,
  rb:CUSTOMER_CUSTKEY, rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS,
  re:CUSTOMER_NATIONKEY, rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL,
  rh:CUSTOMER_MKTSEGMENT, ri:CUSTOMER_COMMENT} in bind
  REVENUE_mCUSTOMER11_mSUPPLIER2 as ind REVENUE_mCUSTOMER11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:37});
   (shuffle_REVENUE_mCUSTOMER11_mSUPPLIER2_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           CUSTOMER_NATIONKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_CUSTOMER_rcv_push_s37_m_REVENUE_mCUSTOMER11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS,
   rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL,
   ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT}))))
trigger nd_delete_CUSTOMER_rcv_push_s29_m_REVENUE_mCUSTOMER11 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int, rg:real } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:string, re:string, rf:int, rg:string, rh:real, ri:string,
  rj:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY,
  rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY,
  rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT,
  rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_s29_buf as ind
   map_REVENUE_mCUSTOMER11_s29_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mCUSTOMER11_s29_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra
       == _tup0 and rf == _tup5) and re == _tup4) and rd == _tup3) and rc ==
       _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_s29_buf_d.update vals tuple}
       {None -> map_REVENUE_mCUSTOMER11_s29_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:29, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s29 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_rcv_push_s29_m_REVENUE_mCUSTOMER12 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int, rg:real } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:string, re:string, rf:int, rg:string, rh:real, ri:string,
  rj:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY,
  rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY,
  rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT,
  rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER12_s29_buf as ind
   map_REVENUE_mCUSTOMER12_s29_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mCUSTOMER12_s29_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra
       == _tup0 and rf == _tup5) and re == _tup4) and rd == _tup3) and rc ==
       _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER12_s29_buf_d.update vals tuple}
       {None -> map_REVENUE_mCUSTOMER12_s29_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:29, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s29 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_rcv_push_s30_m_REVENUE_mCUSTOMER11_mORDERS1 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int, rg:real } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:string, re:string, rf:int, rg:string, rh:real, ri:string,
  rj:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY,
  rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY,
  rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT,
  rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mORDERS1_s30_buf as
   ind map_REVENUE_mCUSTOMER11_mORDERS1_s30_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mCUSTOMER11_mORDERS1_s30_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra
       == _tup0 and rf == _tup5) and re == _tup4) and rd == _tup3) and rc ==
       _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mORDERS1_s30_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mORDERS1_s30_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:30, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s30 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_rcv_push_s31_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string, rj:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s31_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM4_s31_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM4_s31_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s31_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s31_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:31, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s31 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_rcv_push_s32_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string, rj:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s32_buf
   as ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s32_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s32_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s32_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s32_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:32, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s32 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_rcv_push_s33_m_REVENUE_mCUSTOMER12_mORDERS1 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int, rg:real } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:string, re:string, rf:int, rg:string, rh:real, ri:string,
  rj:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY,
  rd:CUSTOMER_NAME, re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY,
  rg:CUSTOMER_PHONE, rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT,
  rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER12_mORDERS1_s33_buf as
   ind map_REVENUE_mCUSTOMER12_mORDERS1_s33_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mCUSTOMER12_mORDERS1_s33_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra
       == _tup0 and rf == _tup5) and re == _tup4) and rd == _tup3) and rc ==
       _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER12_mORDERS1_s33_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER12_mORDERS1_s33_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:33, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s33 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_rcv_push_s34_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string, rj:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s34_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM4_s34_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM4_s34_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s34_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s34_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:34, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s34 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_rcv_push_s34_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string, rj:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s34_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM5_s34_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM5_s34_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2)
       and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s34_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s34_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:34, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s34 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_rcv_push_s35_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string, rj:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s35_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM5_s35_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM5_s35_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2)
       and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s35_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s35_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:35, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s35 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_rcv_push_s35_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string, rj:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s35_buf
   as ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s35_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s35_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s35_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s35_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:35, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s35 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_rcv_push_s36_m_REVENUE_mCUSTOMER11_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string, rj:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s36_buf
   as ind map_REVENUE_mCUSTOMER11_mSUPPLIER1_s36_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER1_s36_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0 and rd
       == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER1_s36_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER1_s36_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:36, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s36 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_rcv_push_s36_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string, rj:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s36_buf
   as ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s36_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s36_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s36_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s36_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:36, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s36 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_rcv_push_s37_m_REVENUE_mCUSTOMER12_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:string, re:string,
  rf:int, rg:string, rh:real, ri:string, rj:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s37_buf
   as ind map_REVENUE_mCUSTOMER12_mSUPPLIER1_s37_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER12_mSUPPLIER1_s37_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0 and rd
       == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER12_mSUPPLIER1_s37_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER12_mSUPPLIER1_s37_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:37, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s37 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger nd_delete_CUSTOMER_rcv_push_s37_m_REVENUE_mCUSTOMER11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int,
  rd:string, re:string, rf:int, rg:string, rh:real, ri:string, rj:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:CUSTOMER_CUSTKEY, rd:CUSTOMER_NAME,
  re:CUSTOMER_ADDRESS, rf:CUSTOMER_NATIONKEY, rg:CUSTOMER_PHONE,
  rh:CUSTOMER_ACCTBAL, ri:CUSTOMER_MKTSEGMENT, rj:CUSTOMER_COMMENT} in 
  ((nd_log_write_delete_CUSTOMER {ra:vid, rb:CUSTOMER_CUSTKEY,
      rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
      rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
      ri:CUSTOMER_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s37_buf
   as ind map_REVENUE_mCUSTOMER11_mSUPPLIER2_s37_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mSUPPLIER2_s37_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s37_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mSUPPLIER2_s37_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:37, rc:-1}
   then
     nd_delete_CUSTOMER_do_complete_s37 {ra:vid, rb:CUSTOMER_CUSTKEY,
       rc:CUSTOMER_NAME, rd:CUSTOMER_ADDRESS, re:CUSTOMER_NATIONKEY,
       rf:CUSTOMER_PHONE, rg:CUSTOMER_ACCTBAL, rh:CUSTOMER_MKTSEGMENT,
       ri:CUSTOMER_COMMENT} else ())))
trigger delete_CUSTOMER_rcv_corrective_s29_m_REVENUE_mCUSTOMER11 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_s29_buf, rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:29}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           delete_CUSTOMER_do_corrective_s29_m_REVENUE_mCUSTOMER11
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_CUSTOMER_rcv_corrective_s29_m_REVENUE_mCUSTOMER12 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_s29_buf, rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:29}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           delete_CUSTOMER_do_corrective_s29_m_REVENUE_mCUSTOMER12
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_CUSTOMER_rcv_corrective_s30_m_REVENUE_mCUSTOMER11_mORDERS1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_mORDERS1_s30_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:30}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           delete_CUSTOMER_do_corrective_s30_m_REVENUE_mCUSTOMER11_mORDERS1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_CUSTOMER_rcv_corrective_s31_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mCUSTOMER11_mLINEITEM4_s31_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:31}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           delete_CUSTOMER_do_corrective_s31_m_REVENUE_mCUSTOMER11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_CUSTOMER_rcv_corrective_s33_m_REVENUE_mCUSTOMER12_mORDERS1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_mORDERS1_s33_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:33}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           delete_CUSTOMER_do_corrective_s33_m_REVENUE_mCUSTOMER12_mORDERS1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_CUSTOMER_rcv_corrective_s34_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mCUSTOMER11_mLINEITEM4_s34_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:34}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           delete_CUSTOMER_do_corrective_s34_m_REVENUE_mCUSTOMER11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_CUSTOMER_rcv_corrective_s34_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_REVENUE_mCUSTOMER11_mLINEITEM5_s34_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:34}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           delete_CUSTOMER_do_corrective_s34_m_REVENUE_mCUSTOMER11_mLINEITEM5
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_CUSTOMER_rcv_corrective_s35_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_REVENUE_mCUSTOMER11_mLINEITEM5_s35_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:35}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           delete_CUSTOMER_do_corrective_s35_m_REVENUE_mCUSTOMER11_mLINEITEM5
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_CUSTOMER_rcv_corrective_s36_m_REVENUE_mCUSTOMER11_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_mSUPPLIER1_s36_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:36}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           delete_CUSTOMER_do_corrective_s36_m_REVENUE_mCUSTOMER11_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_CUSTOMER_rcv_corrective_s37_m_REVENUE_mCUSTOMER12_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_mSUPPLIER1_s37_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:37}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_CUSTOMER compute_vid as
         {ra:CUSTOMER_CUSTKEY, rb:CUSTOMER_NAME, rc:CUSTOMER_ADDRESS, rd:CUSTOMER_NATIONKEY, re:CUSTOMER_PHONE, rf:CUSTOMER_ACCTBAL, rg:CUSTOMER_MKTSEGMENT, rh:CUSTOMER_COMMENT}
         in
         acc_count +
           delete_CUSTOMER_do_corrective_s37_m_REVENUE_mCUSTOMER12_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:CUSTOMER_CUSTKEY, rg:CUSTOMER_NAME,
             rh:CUSTOMER_ADDRESS, ri:CUSTOMER_NATIONKEY, rj:CUSTOMER_PHONE,
             rk:CUSTOMER_ACCTBAL, rl:CUSTOMER_MKTSEGMENT, rm:CUSTOMER_COMMENT,
             rn:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger nd_insert_ORDERS_rcv_put : { ra:address, rb:collection { key:int,
  value:int } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:int,
  rf:string, rg:real, rh:int, ri:string, rj:string, rk:int, rl:string } =
  (\b1 -> bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid,
  rd:ORDERS_ORDERKEY, re:ORDERS_CUSTKEY, rf:ORDERS_ORDERSTATUS,
  rg:ORDERS_TOTALPRICE, rh:ORDERS_ORDERDATE, ri:ORDERS_ORDERPRIORITY,
  rj:ORDERS_CLERK, rk:ORDERS_SHIPPRIORITY, rl:ORDERS_COMMENT} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 47
     then
       nd_insert_ORDERS_do_complete_s47 {ra:vid, rb:ORDERS_ORDERKEY,
         rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
         rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
         ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
     else if stmt_id == 46
       then
         nd_insert_ORDERS_do_complete_s46 {ra:vid, rb:ORDERS_ORDERKEY,
           rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
           rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
           ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
       else if stmt_id == 45
         then
           nd_insert_ORDERS_do_complete_s45 {ra:vid, rb:ORDERS_ORDERKEY,
             rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
             rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
             ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
         else if stmt_id == 44
           then
             nd_insert_ORDERS_do_complete_s44 {ra:vid, rb:ORDERS_ORDERKEY,
               rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
               rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
               ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
           else if stmt_id == 43
             then
               nd_insert_ORDERS_do_complete_s43 {ra:vid, rb:ORDERS_ORDERKEY,
                 rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
                 re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
                 rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
                 ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
             else if stmt_id == 42
               then
                 nd_insert_ORDERS_do_complete_s42 {ra:vid, rb:ORDERS_ORDERKEY,
                   rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
                   re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
                   rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
                   ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
               else if stmt_id == 41
                 then
                   nd_insert_ORDERS_do_complete_s41 {ra:vid,
                     rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                     rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                     rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
                     rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
                     rj:ORDERS_COMMENT}
                 else if stmt_id == 40
                   then
                     nd_insert_ORDERS_do_complete_s40 {ra:vid,
                       rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                       rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
                       rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
                       rj:ORDERS_COMMENT}
                   else if stmt_id == 39
                     then
                       nd_insert_ORDERS_do_complete_s39 {ra:vid,
                         rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                         rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                         rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
                         rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
                         rj:ORDERS_COMMENT}
                     else if stmt_id == 38
                       then
                         nd_insert_ORDERS_do_complete_s38 {ra:vid,
                           rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                           rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                           rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
                           rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
                           rj:ORDERS_COMMENT} else () else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_insert_ORDERS_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 38
   then if map_id == 14
     then (nd_insert_ORDERS_send_push_s38_m_REVENUE_mORDERS11, me)<- {ra:vid,
       rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
       re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
       rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
     else if map_id == 17
       then (nd_insert_ORDERS_send_push_s38_m_REVENUE_mORDERS12, me)<- {ra:vid,
         rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
         re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
         rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 39
     then if map_id == 4
       then
         (nd_insert_ORDERS_send_push_s39_m_REVENUE_mCUSTOMER11_mORDERS1, me)<- {ra:vid,
         rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
         re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
         rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 41
       then if map_id == 5
         then
           (nd_insert_ORDERS_send_push_s41_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
             me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
           rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
           rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
           rj:ORDERS_COMMENT} else error (print "nd_rcv_fetch: invalid map id")
       else if stmt_id == 42
         then if map_id == 11
           then
             (nd_insert_ORDERS_send_push_s42_m_REVENUE_mCUSTOMER12_mORDERS1,
               me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
             rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
             rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
             rj:ORDERS_COMMENT}
           else error (print "nd_rcv_fetch: invalid map id")
         else if stmt_id == 43
           then if map_id == 12
             then
               (nd_insert_ORDERS_send_push_s43_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
                 me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
               rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
               rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
               ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
             else error (print "nd_rcv_fetch: invalid map id")
           else if stmt_id == 44
             then if map_id == 15
               then
                 (nd_insert_ORDERS_send_push_s44_m_REVENUE_mORDERS11_mLINEITEM4,
                   me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                 rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                 rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
                 ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
               else error (print "nd_rcv_fetch: invalid map id")
             else if stmt_id == 45
               then if map_id == 16
                 then
                   (nd_insert_ORDERS_send_push_s45_m_REVENUE_mORDERS11_mSUPPLIER2,
                     me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                   rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                   rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
                   rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
                 else error (print "nd_rcv_fetch: invalid map id")
               else if stmt_id == 46
                 then if map_id == 5
                   then
                     (nd_insert_ORDERS_send_push_s46_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
                       me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                     rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                     rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
                     rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
                     rj:ORDERS_COMMENT}
                   else if map_id == 16
                     then
                       (nd_insert_ORDERS_send_push_s46_m_REVENUE_mORDERS11_mSUPPLIER2,
                         me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                       rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
                       rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
                       rj:ORDERS_COMMENT}
                     else error (print "nd_rcv_fetch: invalid map id")
                 else if stmt_id == 47
                   then if map_id == 12
                     then
                       (nd_insert_ORDERS_send_push_s47_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
                         me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                       rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
                       rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
                       rj:ORDERS_COMMENT}
                     else if map_id == 16
                       then
                         (nd_insert_ORDERS_send_push_s47_m_REVENUE_mORDERS11_mSUPPLIER2,
                           me)<- {ra:vid, rb:ORDERS_ORDERKEY,
                         rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
                         re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
                         rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
                         ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
                       else error (print "nd_rcv_fetch: invalid map id")
                   else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_insert_ORDERS_send_push_s38_m_REVENUE_mORDERS11 : { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mORDERS11 as ind REVENUE_mORDERS11_deref in
  ((nd_log_master_write {key:vid, value:38});
   (shuffle_REVENUE_mORDERS11_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
      rb:None immut, rc:None immut,
      rd:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mORDERS11_deref.filter ((\b1 -> bind b1 as {ra:ra,
           rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in re == ORDERS_CUSTKEY
           and rf == ORDERS_ORDERKEY))}, re:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s38_m_REVENUE_mORDERS11, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s38_m_REVENUE_mORDERS12 : { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mORDERS12 as ind REVENUE_mORDERS12_deref in
  ((nd_log_master_write {key:vid, value:38});
   (shuffle_REVENUE_mORDERS12_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
      rb:None immut, rc:None immut,
      rd:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mORDERS12_deref.filter ((\b1 -> bind b1 as {ra:ra,
           rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in re == ORDERS_CUSTKEY
           and rf == ORDERS_ORDERKEY))}, re:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s38_m_REVENUE_mORDERS12, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s39_m_REVENUE_mCUSTOMER11_mORDERS1 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mCUSTOMER11_mORDERS1 as ind REVENUE_mCUSTOMER11_mORDERS1_deref in
  ((nd_log_master_write {key:vid, value:39});
   (shuffle_REVENUE_mCUSTOMER11_mORDERS1_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_2t2_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:Some ORDERS_CUSTKEY,
      rf:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_mORDERS1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in rf
           == ORDERS_ORDERKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s39_m_REVENUE_mCUSTOMER11_mORDERS1, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s41_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int,
  rg:string, rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 as ind
  REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:41});
   (shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER11_mSUPPLIER1_bind_0t0_2t2
      {ra:None immut, rb:Some ORDERS_CUSTKEY, rc:None immut,
      rd:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
           ORDERS_ORDERKEY))}, re:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s41_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
     ip)<- {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
   re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
   rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
   rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s42_m_REVENUE_mCUSTOMER12_mORDERS1 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mCUSTOMER12_mORDERS1 as ind REVENUE_mCUSTOMER12_mORDERS1_deref in
  ((nd_log_master_write {key:vid, value:42});
   (shuffle_REVENUE_mCUSTOMER12_mORDERS1_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_2t2_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:Some ORDERS_CUSTKEY,
      rf:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_mORDERS1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in rf
           == ORDERS_ORDERKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s42_m_REVENUE_mCUSTOMER12_mORDERS1, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s43_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int,
  rg:string, rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 as ind
  REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:43});
   (shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER12_mSUPPLIER1_bind_0t0_2t2
      {ra:None immut, rb:Some ORDERS_CUSTKEY, rc:None immut,
      rd:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
           ORDERS_ORDERKEY))}, re:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s43_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
     ip)<- {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
   re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
   rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
   rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s44_m_REVENUE_mORDERS11_mLINEITEM4 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mORDERS11_mLINEITEM4 as ind REVENUE_mORDERS11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:44});
   (shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mLINEITEM4_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:Some ORDERS_ORDERKEY, rd:None immut,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           ORDERS_CUSTKEY))}, rf:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s44_m_REVENUE_mORDERS11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s45_m_REVENUE_mORDERS11_mSUPPLIER2 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mORDERS11_mSUPPLIER2 as ind REVENUE_mORDERS11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:45});
   (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:Some ORDERS_ORDERKEY, rd:None immut,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           ORDERS_CUSTKEY))}, rf:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s45_m_REVENUE_mORDERS11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s46_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int,
  rg:string, rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 as ind
  REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:46});
   (shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_2t0_4t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
           ORDERS_ORDERKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s46_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
     ip)<- {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
   re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
   rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
   rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s46_m_REVENUE_mORDERS11_mSUPPLIER2 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mORDERS11_mSUPPLIER2 as ind REVENUE_mORDERS11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:46});
   (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           ORDERS_CUSTKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s46_m_REVENUE_mORDERS11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s47_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int,
  rg:string, rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 as ind
  REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:47});
   (shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_2t0_4t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
           ORDERS_ORDERKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s47_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
     ip)<- {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
   re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
   rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
   rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_send_push_s47_m_REVENUE_mORDERS11_mSUPPLIER2 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mORDERS11_mSUPPLIER2 as ind REVENUE_mORDERS11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:47});
   (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           ORDERS_CUSTKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_ORDERS_rcv_push_s47_m_REVENUE_mORDERS11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_insert_ORDERS_rcv_push_s38_m_REVENUE_mORDERS11 : { ra:collection {
  ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int,
  rg:real } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:string, rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_s38_buf as ind
   map_REVENUE_mORDERS11_s38_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mORDERS11_s38_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra == _tup0 and rf ==
       _tup5) and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_s38_buf_d.update vals tuple}
       {None -> map_REVENUE_mORDERS11_s38_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:38, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s38 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s38_m_REVENUE_mORDERS12 : { ra:collection {
  ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int,
  rg:real } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:string, rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS12_s38_buf as ind
   map_REVENUE_mORDERS12_s38_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mORDERS12_s38_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra == _tup0 and rf ==
       _tup5) and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS12_s38_buf_d.update vals tuple}
       {None -> map_REVENUE_mORDERS12_s38_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:38, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s38 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s39_m_REVENUE_mCUSTOMER11_mORDERS1 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int, rg:real } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:int, re:string, rf:real, rg:int, rh:string, ri:string, rj:int,
  rk:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY,
  rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE,
  rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK,
  rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mORDERS1_s39_buf as
   ind map_REVENUE_mCUSTOMER11_mORDERS1_s39_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mCUSTOMER11_mORDERS1_s39_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra
       == _tup0 and rf == _tup5) and re == _tup4) and rd == _tup3) and rc ==
       _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mORDERS1_s39_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mORDERS1_s39_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:39, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s39 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s41_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind
   map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s41_buf as ind
   map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s41_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s41_buf_d.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals ->
         map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s41_buf_d.update vals
         tuple}{None ->
                 map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s41_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:41, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s41 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s42_m_REVENUE_mCUSTOMER12_mORDERS1 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int, rg:real } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:int, re:string, rf:real, rg:int, rh:string, ri:string, rj:int,
  rk:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY,
  rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE,
  rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK,
  rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER12_mORDERS1_s42_buf as
   ind map_REVENUE_mCUSTOMER12_mORDERS1_s42_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mCUSTOMER12_mORDERS1_s42_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra
       == _tup0 and rf == _tup5) and re == _tup4) and rd == _tup3) and rc ==
       _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER12_mORDERS1_s42_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER12_mORDERS1_s42_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:42, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s42 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s43_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind
   map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s43_buf as ind
   map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s43_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s43_buf_d.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals ->
         map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s43_buf_d.update vals
         tuple}{None ->
                 map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s43_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:43, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s43 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s44_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:string, rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mLINEITEM4_s44_buf as
   ind map_REVENUE_mORDERS11_mLINEITEM4_s44_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mLINEITEM4_s44_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mLINEITEM4_s44_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mLINEITEM4_s44_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:44, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s44 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s45_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:string, rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mSUPPLIER2_s45_buf as
   ind map_REVENUE_mORDERS11_mSUPPLIER2_s45_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mSUPPLIER2_s45_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mSUPPLIER2_s45_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mSUPPLIER2_s45_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:45, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s45 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s46_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind
   map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s46_buf as ind
   map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s46_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s46_buf_d.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals ->
         map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s46_buf_d.update vals
         tuple}{None ->
                 map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s46_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:46, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s46 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s46_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:string, rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mSUPPLIER2_s46_buf as
   ind map_REVENUE_mORDERS11_mSUPPLIER2_s46_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mSUPPLIER2_s46_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mSUPPLIER2_s46_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mSUPPLIER2_s46_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:46, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s46 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s47_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind
   map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s47_buf as ind
   map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s47_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s47_buf_d.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals ->
         map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s47_buf_d.update vals
         tuple}{None ->
                 map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s47_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:47, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s47 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_rcv_push_s47_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:string, rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_insert_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mSUPPLIER2_s47_buf as
   ind map_REVENUE_mORDERS11_mSUPPLIER2_s47_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mSUPPLIER2_s47_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mSUPPLIER2_s47_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mSUPPLIER2_s47_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:47, rc:-1}
   then
     nd_insert_ORDERS_do_complete_s47 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_insert_ORDERS_do_complete_s40_trig : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int,
  rj:string } = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY,
  rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
  rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
  ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in 
  nd_insert_ORDERS_do_complete_s40 {ra:vid, rb:ORDERS_ORDERKEY,
    rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
    rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
    ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT})
trigger insert_ORDERS_rcv_corrective_s38_m_REVENUE_mORDERS11 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { ra:string,
  rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mORDERS11_s38_buf, rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:38}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s38_m_REVENUE_mORDERS11 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid,
             rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
             ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s38_m_REVENUE_mORDERS12 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { ra:string,
  rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mORDERS12_s38_buf, rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:38}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s38_m_REVENUE_mORDERS12 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid,
             rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
             ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s39_m_REVENUE_mCUSTOMER11_mORDERS1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_mORDERS1_s39_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:39}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s39_m_REVENUE_mCUSTOMER11_mORDERS1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s41_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s41_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:41}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s41_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s42_m_REVENUE_mCUSTOMER12_mORDERS1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_mORDERS1_s42_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:42}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s42_m_REVENUE_mCUSTOMER12_mORDERS1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s43_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s43_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:43}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s43_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s44_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mLINEITEM4_s44_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:44}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s44_m_REVENUE_mORDERS11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s45_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mSUPPLIER2_s45_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:45}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s45_m_REVENUE_mORDERS11_mSUPPLIER2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s46_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s46_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:46}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s46_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s46_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mSUPPLIER2_s46_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:46}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s46_m_REVENUE_mORDERS11_mSUPPLIER2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s47_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s47_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:47}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s47_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_ORDERS_rcv_corrective_s47_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mSUPPLIER2_s47_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:47}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           insert_ORDERS_do_corrective_s47_m_REVENUE_mORDERS11_mSUPPLIER2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger nd_delete_ORDERS_rcv_put : { ra:address, rb:collection { key:int,
  value:int } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:int,
  rf:string, rg:real, rh:int, ri:string, rj:string, rk:int, rl:string } =
  (\b1 -> bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid,
  rd:ORDERS_ORDERKEY, re:ORDERS_CUSTKEY, rf:ORDERS_ORDERSTATUS,
  rg:ORDERS_TOTALPRICE, rh:ORDERS_ORDERDATE, ri:ORDERS_ORDERPRIORITY,
  rj:ORDERS_CLERK, rk:ORDERS_SHIPPRIORITY, rl:ORDERS_COMMENT} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 57
     then
       nd_delete_ORDERS_do_complete_s57 {ra:vid, rb:ORDERS_ORDERKEY,
         rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
         rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
         ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
     else if stmt_id == 56
       then
         nd_delete_ORDERS_do_complete_s56 {ra:vid, rb:ORDERS_ORDERKEY,
           rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
           rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
           ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
       else if stmt_id == 55
         then
           nd_delete_ORDERS_do_complete_s55 {ra:vid, rb:ORDERS_ORDERKEY,
             rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
             rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
             ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
         else if stmt_id == 54
           then
             nd_delete_ORDERS_do_complete_s54 {ra:vid, rb:ORDERS_ORDERKEY,
               rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
               rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
               ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
           else if stmt_id == 53
             then
               nd_delete_ORDERS_do_complete_s53 {ra:vid, rb:ORDERS_ORDERKEY,
                 rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
                 re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
                 rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
                 ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
             else if stmt_id == 52
               then
                 nd_delete_ORDERS_do_complete_s52 {ra:vid, rb:ORDERS_ORDERKEY,
                   rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
                   re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
                   rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
                   ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
               else if stmt_id == 51
                 then
                   nd_delete_ORDERS_do_complete_s51 {ra:vid,
                     rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                     rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                     rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
                     rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
                     rj:ORDERS_COMMENT}
                 else if stmt_id == 50
                   then
                     nd_delete_ORDERS_do_complete_s50 {ra:vid,
                       rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                       rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
                       rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
                       rj:ORDERS_COMMENT}
                   else if stmt_id == 49
                     then
                       nd_delete_ORDERS_do_complete_s49 {ra:vid,
                         rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                         rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                         rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
                         rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
                         rj:ORDERS_COMMENT}
                     else if stmt_id == 48
                       then
                         nd_delete_ORDERS_do_complete_s48 {ra:vid,
                           rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                           rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                           rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
                           rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
                           rj:ORDERS_COMMENT} else () else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_delete_ORDERS_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 48
   then if map_id == 14
     then (nd_delete_ORDERS_send_push_s48_m_REVENUE_mORDERS11, me)<- {ra:vid,
       rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
       re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
       rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
     else if map_id == 17
       then (nd_delete_ORDERS_send_push_s48_m_REVENUE_mORDERS12, me)<- {ra:vid,
         rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
         re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
         rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 49
     then if map_id == 4
       then
         (nd_delete_ORDERS_send_push_s49_m_REVENUE_mCUSTOMER11_mORDERS1, me)<- {ra:vid,
         rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
         re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
         rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
       else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 51
       then if map_id == 5
         then
           (nd_delete_ORDERS_send_push_s51_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
             me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
           rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
           rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
           rj:ORDERS_COMMENT} else error (print "nd_rcv_fetch: invalid map id")
       else if stmt_id == 52
         then if map_id == 11
           then
             (nd_delete_ORDERS_send_push_s52_m_REVENUE_mCUSTOMER12_mORDERS1,
               me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
             rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
             rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
             rj:ORDERS_COMMENT}
           else error (print "nd_rcv_fetch: invalid map id")
         else if stmt_id == 53
           then if map_id == 12
             then
               (nd_delete_ORDERS_send_push_s53_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
                 me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
               rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
               rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
               ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
             else error (print "nd_rcv_fetch: invalid map id")
           else if stmt_id == 54
             then if map_id == 15
               then
                 (nd_delete_ORDERS_send_push_s54_m_REVENUE_mORDERS11_mLINEITEM4,
                   me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                 rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                 rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
                 ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
               else error (print "nd_rcv_fetch: invalid map id")
             else if stmt_id == 55
               then if map_id == 16
                 then
                   (nd_delete_ORDERS_send_push_s55_m_REVENUE_mORDERS11_mSUPPLIER2,
                     me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                   rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                   rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
                   rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
                 else error (print "nd_rcv_fetch: invalid map id")
               else if stmt_id == 56
                 then if map_id == 5
                   then
                     (nd_delete_ORDERS_send_push_s56_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
                       me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                     rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                     rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
                     rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
                     rj:ORDERS_COMMENT}
                   else if map_id == 16
                     then
                       (nd_delete_ORDERS_send_push_s56_m_REVENUE_mORDERS11_mSUPPLIER2,
                         me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                       rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
                       rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
                       rj:ORDERS_COMMENT}
                     else error (print "nd_rcv_fetch: invalid map id")
                 else if stmt_id == 57
                   then if map_id == 12
                     then
                       (nd_delete_ORDERS_send_push_s57_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
                         me)<- {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
                       rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
                       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
                       rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
                       rj:ORDERS_COMMENT}
                     else if map_id == 16
                       then
                         (nd_delete_ORDERS_send_push_s57_m_REVENUE_mORDERS11_mSUPPLIER2,
                           me)<- {ra:vid, rb:ORDERS_ORDERKEY,
                         rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
                         re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
                         rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
                         ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT}
                       else error (print "nd_rcv_fetch: invalid map id")
                   else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_delete_ORDERS_send_push_s48_m_REVENUE_mORDERS11 : { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mORDERS11 as ind REVENUE_mORDERS11_deref in
  ((nd_log_master_write {key:vid, value:48});
   (shuffle_REVENUE_mORDERS11_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
      rb:None immut, rc:None immut,
      rd:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mORDERS11_deref.filter ((\b1 -> bind b1 as {ra:ra,
           rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in re == ORDERS_CUSTKEY
           and rf == ORDERS_ORDERKEY))}, re:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s48_m_REVENUE_mORDERS11, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_send_push_s48_m_REVENUE_mORDERS12 : { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mORDERS12 as ind REVENUE_mORDERS12_deref in
  ((nd_log_master_write {key:vid, value:48});
   (shuffle_REVENUE_mORDERS12_to_REVENUE_bind_0t0_1t1_2t2 {ra:None immut,
      rb:None immut, rc:None immut,
      rd:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mORDERS12_deref.filter ((\b1 -> bind b1 as {ra:ra,
           rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in re == ORDERS_CUSTKEY
           and rf == ORDERS_ORDERKEY))}, re:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s48_m_REVENUE_mORDERS12, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_send_push_s49_m_REVENUE_mCUSTOMER11_mORDERS1 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mCUSTOMER11_mORDERS1 as ind REVENUE_mCUSTOMER11_mORDERS1_deref in
  ((nd_log_master_write {key:vid, value:49});
   (shuffle_REVENUE_mCUSTOMER11_mORDERS1_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_2t2_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:Some ORDERS_CUSTKEY,
      rf:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_mORDERS1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in rf
           == ORDERS_ORDERKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s49_m_REVENUE_mCUSTOMER11_mORDERS1, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_send_push_s51_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int,
  rg:string, rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 as ind
  REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:51});
   (shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER11_mSUPPLIER1_bind_0t0_2t2
      {ra:None immut, rb:Some ORDERS_CUSTKEY, rc:None immut,
      rd:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
           ORDERS_ORDERKEY))}, re:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s51_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
     ip)<- {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
   re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
   rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
   rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_send_push_s52_m_REVENUE_mCUSTOMER12_mORDERS1 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mCUSTOMER12_mORDERS1 as ind REVENUE_mCUSTOMER12_mORDERS1_deref in
  ((nd_log_master_write {key:vid, value:52});
   (shuffle_REVENUE_mCUSTOMER12_mORDERS1_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_2t2_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:Some ORDERS_CUSTKEY,
      rf:frontier_string_string_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_mORDERS1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in rf
           == ORDERS_ORDERKEY))}, rg:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s52_m_REVENUE_mCUSTOMER12_mORDERS1, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_send_push_s53_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int,
  rg:string, rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 as ind
  REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:53});
   (shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mCUSTOMER12_mSUPPLIER1_bind_0t0_2t2
      {ra:None immut, rb:Some ORDERS_CUSTKEY, rc:None immut,
      rd:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
           ORDERS_ORDERKEY))}, re:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s53_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
     ip)<- {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
   re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
   rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
   rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_send_push_s54_m_REVENUE_mORDERS11_mLINEITEM4 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mORDERS11_mLINEITEM4 as ind REVENUE_mORDERS11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:54});
   (shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mLINEITEM4_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:Some ORDERS_ORDERKEY, rd:None immut,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           ORDERS_CUSTKEY))}, rf:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s54_m_REVENUE_mORDERS11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_send_push_s55_m_REVENUE_mORDERS11_mSUPPLIER2 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mORDERS11_mSUPPLIER2 as ind REVENUE_mORDERS11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:55});
   (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mLINEITEM4_mSUPPLIER1_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:Some ORDERS_ORDERKEY, rd:None immut,
      re:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           ORDERS_CUSTKEY))}, rf:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s55_m_REVENUE_mORDERS11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_send_push_s56_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int,
  rg:string, rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 as ind
  REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:56});
   (shuffle_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_2t0_4t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
           ORDERS_ORDERKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s56_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1,
     ip)<- {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
   re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
   rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
   rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_send_push_s56_m_REVENUE_mORDERS11_mSUPPLIER2 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mORDERS11_mSUPPLIER2 as ind REVENUE_mORDERS11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:56});
   (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           ORDERS_CUSTKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s56_m_REVENUE_mORDERS11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_send_push_s57_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int,
  rg:string, rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 as ind
  REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:57});
   (shuffle_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_2t0_4t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int_float {key:vid,
           value:REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in rc ==
           ORDERS_ORDERKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s57_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1,
     ip)<- {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
   re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
   rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
   rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_send_push_s57_m_REVENUE_mORDERS11_mSUPPLIER2 : { ra:{
  key:int, value:int }, rb:int, rc:int, rd:string, re:real, rf:int, rg:string,
  rh:string, ri:int, rj:string } = (\b1 -> bind b1 as {ra:vid,
  rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS,
  re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY,
  rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in bind
  REVENUE_mORDERS11_mSUPPLIER2 as ind REVENUE_mORDERS11_mSUPPLIER2_deref in
  ((nd_log_master_write {key:vid, value:57});
   (shuffle_REVENUE_mORDERS11_mSUPPLIER2_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mSUPPLIER2_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           ORDERS_CUSTKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_ORDERS_rcv_push_s57_m_REVENUE_mORDERS11_mSUPPLIER2, ip)<- {ra:tuples,
   rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS,
   rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY,
   ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT}))))
trigger nd_delete_ORDERS_rcv_push_s48_m_REVENUE_mORDERS11 : { ra:collection {
  ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int,
  rg:real } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:string, rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_s48_buf as ind
   map_REVENUE_mORDERS11_s48_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mORDERS11_s48_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra == _tup0 and rf ==
       _tup5) and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_s48_buf_d.update vals tuple}
       {None -> map_REVENUE_mORDERS11_s48_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:48, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s48 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_rcv_push_s48_m_REVENUE_mORDERS12 : { ra:collection {
  ra:{ key:int, value:int }, rb:string, rc:string, rd:int, re:int, rf:int,
  rg:real } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:string, rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS12_s48_buf as ind
   map_REVENUE_mORDERS12_s48_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mORDERS12_s48_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra == _tup0 and rf ==
       _tup5) and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS12_s48_buf_d.update vals tuple}
       {None -> map_REVENUE_mORDERS12_s48_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:48, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s48 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_rcv_push_s49_m_REVENUE_mCUSTOMER11_mORDERS1 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int, rg:real } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:int, re:string, rf:real, rg:int, rh:string, ri:string, rj:int,
  rk:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY,
  rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE,
  rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK,
  rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mORDERS1_s49_buf as
   ind map_REVENUE_mCUSTOMER11_mORDERS1_s49_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mCUSTOMER11_mORDERS1_s49_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra
       == _tup0 and rf == _tup5) and re == _tup4) and rd == _tup3) and rc ==
       _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mORDERS1_s49_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mORDERS1_s49_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:49, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s49 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_rcv_push_s51_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind
   map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s51_buf as ind
   map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s51_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s51_buf_d.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals ->
         map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s51_buf_d.update vals
         tuple}{None ->
                 map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s51_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:51, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s51 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_rcv_push_s52_m_REVENUE_mCUSTOMER12_mORDERS1 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int, rg:real } @ { Collection }, rb:{ key:int, value:int },
  rc:int, rd:int, re:string, rf:real, rg:int, rh:string, ri:string, rj:int,
  rk:string } = (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY,
  rd:ORDERS_CUSTKEY, re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE,
  rg:ORDERS_ORDERDATE, rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK,
  rj:ORDERS_SHIPPRIORITY, rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER12_mORDERS1_s52_buf as
   ind map_REVENUE_mCUSTOMER12_mORDERS1_s52_buf_d in
   bind tuple as
     {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5, rg:_tup6} in
     case ((map_REVENUE_mCUSTOMER12_mORDERS1_s52_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf, rg:rg} in ((((ra
       == _tup0 and rf == _tup5) and re == _tup4) and rd == _tup3) and rc ==
       _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER12_mORDERS1_s52_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER12_mORDERS1_s52_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:52, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s52 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_rcv_push_s53_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind
   map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s53_buf as ind
   map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s53_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s53_buf_d.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals ->
         map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s53_buf_d.update vals
         tuple}{None ->
                 map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s53_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:53, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s53 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_rcv_push_s54_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:string, rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mLINEITEM4_s54_buf as
   ind map_REVENUE_mORDERS11_mLINEITEM4_s54_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mLINEITEM4_s54_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mLINEITEM4_s54_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mLINEITEM4_s54_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:54, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s54 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_rcv_push_s55_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:string, rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mSUPPLIER2_s55_buf as
   ind map_REVENUE_mORDERS11_mSUPPLIER2_s55_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mSUPPLIER2_s55_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mSUPPLIER2_s55_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mSUPPLIER2_s55_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:55, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s55 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_rcv_push_s56_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind
   map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s56_buf as ind
   map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s56_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s56_buf_d.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals ->
         map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s56_buf_d.update vals
         tuple}{None ->
                 map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s56_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:56, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s56 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_rcv_push_s56_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:string, rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mSUPPLIER2_s56_buf as
   ind map_REVENUE_mORDERS11_mSUPPLIER2_s56_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mSUPPLIER2_s56_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mSUPPLIER2_s56_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mSUPPLIER2_s56_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:56, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s56 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_rcv_push_s57_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:real
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:string,
  rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind
   map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s57_buf as ind
   map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s57_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4} in
     case ((map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s57_buf_d.filter
       ((\b1 -> bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re} in ((ra == _tup0
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals ->
         map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s57_buf_d.update vals
         tuple}{None ->
                 map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s57_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:57, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s57 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_rcv_push_s57_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:string, rf:real, rg:int, rh:string, ri:string, rj:int, rk:string } =
  (\b1 -> bind b1 as {ra:tuples, rb:vid, rc:ORDERS_ORDERKEY, rd:ORDERS_CUSTKEY,
  re:ORDERS_ORDERSTATUS, rf:ORDERS_TOTALPRICE, rg:ORDERS_ORDERDATE,
  rh:ORDERS_ORDERPRIORITY, ri:ORDERS_CLERK, rj:ORDERS_SHIPPRIORITY,
  rk:ORDERS_COMMENT} in 
  ((nd_log_write_delete_ORDERS {ra:vid, rb:ORDERS_ORDERKEY, rc:ORDERS_CUSTKEY,
      rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE, rf:ORDERS_ORDERDATE,
      rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK, ri:ORDERS_SHIPPRIORITY,
      rj:ORDERS_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mSUPPLIER2_s57_buf as
   ind map_REVENUE_mORDERS11_mSUPPLIER2_s57_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mSUPPLIER2_s57_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mSUPPLIER2_s57_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mSUPPLIER2_s57_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:57, rc:-1}
   then
     nd_delete_ORDERS_do_complete_s57 {ra:vid, rb:ORDERS_ORDERKEY,
       rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
       rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
       ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} else ())))
trigger nd_delete_ORDERS_do_complete_s50_trig : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:string, re:real, rf:int, rg:string, rh:string, ri:int,
  rj:string } = (\b1 -> bind b1 as {ra:vid, rb:ORDERS_ORDERKEY,
  rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
  rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
  ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT} in 
  nd_delete_ORDERS_do_complete_s50 {ra:vid, rb:ORDERS_ORDERKEY,
    rc:ORDERS_CUSTKEY, rd:ORDERS_ORDERSTATUS, re:ORDERS_TOTALPRICE,
    rf:ORDERS_ORDERDATE, rg:ORDERS_ORDERPRIORITY, rh:ORDERS_CLERK,
    ri:ORDERS_SHIPPRIORITY, rj:ORDERS_COMMENT})
trigger delete_ORDERS_rcv_corrective_s48_m_REVENUE_mORDERS11 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { ra:string,
  rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mORDERS11_s48_buf, rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:48}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s48_m_REVENUE_mORDERS11 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid,
             rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
             ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_ORDERS_rcv_corrective_s48_m_REVENUE_mORDERS12 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { ra:string,
  rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mORDERS12_s48_buf, rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:48}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s48_m_REVENUE_mORDERS12 {ra:orig_addr,
             rb:orig_stmt_id, rc:orig_vid, rd:hop, re:compute_vid,
             rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY, rh:ORDERS_ORDERSTATUS,
             ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_ORDERS_rcv_corrective_s49_m_REVENUE_mCUSTOMER11_mORDERS1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_mORDERS1_s49_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:49}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s49_m_REVENUE_mCUSTOMER11_mORDERS1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_ORDERS_rcv_corrective_s51_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s51_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:51}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s51_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_ORDERS_rcv_corrective_s52_m_REVENUE_mCUSTOMER12_mORDERS1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int, rf:real } @ { Collection } } =
  (\b1 -> bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
  re:vid, rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_mORDERS1_s52_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:52}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s52_m_REVENUE_mCUSTOMER12_mORDERS1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_ORDERS_rcv_corrective_s53_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s53_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:53}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s53_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_ORDERS_rcv_corrective_s54_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mLINEITEM4_s54_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:54}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s54_m_REVENUE_mORDERS11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_ORDERS_rcv_corrective_s55_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mSUPPLIER2_s55_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:55}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s55_m_REVENUE_mORDERS11_mSUPPLIER2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_ORDERS_rcv_corrective_s56_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1_s56_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:56}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s56_m_REVENUE_mCUSTOMER11_mORDERS1_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_ORDERS_rcv_corrective_s56_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mSUPPLIER2_s56_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:56}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s56_m_REVENUE_mORDERS11_mSUPPLIER2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_ORDERS_rcv_corrective_s57_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int, rd:real } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int_float
      {ra:map_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1_s57_buf, rb:false,
      rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:57}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s57_m_REVENUE_mCUSTOMER12_mORDERS1_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_ORDERS_rcv_corrective_s57_m_REVENUE_mORDERS11_mSUPPLIER2 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mSUPPLIER2_s57_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:57}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_ORDERS compute_vid as
         {ra:ORDERS_ORDERKEY, rb:ORDERS_CUSTKEY, rc:ORDERS_ORDERSTATUS, rd:ORDERS_TOTALPRICE, re:ORDERS_ORDERDATE, rf:ORDERS_ORDERPRIORITY, rg:ORDERS_CLERK, rh:ORDERS_SHIPPRIORITY, ri:ORDERS_COMMENT}
         in
         acc_count +
           delete_ORDERS_do_corrective_s57_m_REVENUE_mORDERS11_mSUPPLIER2
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:ORDERS_ORDERKEY, rg:ORDERS_CUSTKEY,
             rh:ORDERS_ORDERSTATUS, ri:ORDERS_TOTALPRICE, rj:ORDERS_ORDERDATE,
             rk:ORDERS_ORDERPRIORITY, rl:ORDERS_CLERK, rm:ORDERS_SHIPPRIORITY,
             rn:ORDERS_COMMENT, ro:delta_tuples} else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger nd_insert_LINEITEM_rcv_put : { ra:address, rb:collection { key:int,
  value:int } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:int,
  rf:int, rg:int, rh:real, ri:real, rj:real, rk:real, rl:string, rm:string,
  rn:int, ro:int, rp:int, rq:string, rr:string, rs:string } = (\b1 ->
  bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid, rd:LINEITEM_ORDERKEY,
  re:LINEITEM_PARTKEY, rf:LINEITEM_SUPPKEY, rg:LINEITEM_LINENUMBER,
  rh:LINEITEM_QUANTITY, ri:LINEITEM_EXTENDEDPRICE, rj:LINEITEM_DISCOUNT,
  rk:LINEITEM_TAX, rl:LINEITEM_RETURNFLAG, rm:LINEITEM_LINESTATUS,
  rn:LINEITEM_SHIPDATE, ro:LINEITEM_COMMITDATE, rp:LINEITEM_RECEIPTDATE,
  rq:LINEITEM_SHIPINSTRUCT, rr:LINEITEM_SHIPMODE, rs:LINEITEM_COMMENT} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 70
     then
       nd_insert_LINEITEM_do_complete_s70 {ra:vid, rb:LINEITEM_ORDERKEY,
         rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
         rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
         ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
         rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
         ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
     else if stmt_id == 69
       then
         nd_insert_LINEITEM_do_complete_s69 {ra:vid, rb:LINEITEM_ORDERKEY,
           rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
           rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
           rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
           rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
           rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
           ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
       else if stmt_id == 68
         then
           nd_insert_LINEITEM_do_complete_s68 {ra:vid, rb:LINEITEM_ORDERKEY,
             rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
             rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
             rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
             rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
             rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
             ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
             rq:LINEITEM_COMMENT}
         else if stmt_id == 67
           then
             nd_insert_LINEITEM_do_complete_s67 {ra:vid, rb:LINEITEM_ORDERKEY,
               rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
               re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
               rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
               ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
               rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
               rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
               rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
           else if stmt_id == 66
             then
               nd_insert_LINEITEM_do_complete_s66 {ra:vid,
                 rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                 rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                 rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                 rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
                 rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                 rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
                 ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                 rq:LINEITEM_COMMENT}
             else if stmt_id == 65
               then
                 nd_insert_LINEITEM_do_complete_s65 {ra:vid,
                   rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                   rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                   rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                   rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                   rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
                   rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
                   rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
                   rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
               else if stmt_id == 64
                 then
                   nd_insert_LINEITEM_do_complete_s64 {ra:vid,
                     rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                     rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                     rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                     rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                     rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
                     rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
                     rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
                     rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
                 else if stmt_id == 63
                   then
                     nd_insert_LINEITEM_do_complete_s63 {ra:vid,
                       rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                       rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                       rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                       rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
                       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
                       rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
                       rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
                   else if stmt_id == 62
                     then
                       nd_insert_LINEITEM_do_complete_s62 {ra:vid,
                         rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                         rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                         rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                         rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                         rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
                         rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
                         rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
                         rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
                     else if stmt_id == 61
                       then
                         nd_insert_LINEITEM_do_complete_s61 {ra:vid,
                           rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                           rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                           rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                           rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                           rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
                           rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
                           rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
                           rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
                       else if stmt_id == 60
                         then
                           nd_insert_LINEITEM_do_complete_s60 {ra:vid,
                             rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                             rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                             rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                             rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                             rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
                             rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
                             rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
                             rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
                         else if stmt_id == 59
                           then
                             nd_insert_LINEITEM_do_complete_s59 {ra:vid,
                               rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                               rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                               rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                               rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                               rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
                               rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
                               rn:LINEITEM_RECEIPTDATE,
                               ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                               rq:LINEITEM_COMMENT}
                           else if stmt_id == 58
                             then
                               nd_insert_LINEITEM_do_complete_s58 {ra:vid,
                                 rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                                 rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                                 rf:LINEITEM_QUANTITY,
                                 rg:LINEITEM_EXTENDEDPRICE,
                                 rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                                 rj:LINEITEM_RETURNFLAG,
                                 rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                                 rm:LINEITEM_COMMITDATE,
                                 rn:LINEITEM_RECEIPTDATE,
                                 ro:LINEITEM_SHIPINSTRUCT,
                                 rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
                             else () else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_insert_LINEITEM_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:LINEITEM_ORDERKEY,
  rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER,
  rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT,
  rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS,
  rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE,
  rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 58
   then if map_id == 18
     then
       (nd_insert_LINEITEM_send_push_s58_m_REVENUE_mLINEITEM4, me)<- {ra:vid,
       rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
       re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
       rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
       rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
       rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
       rq:LINEITEM_COMMENT} else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 59
     then if map_id == 6
       then
         (nd_insert_LINEITEM_send_push_s59_m_REVENUE_mCUSTOMER11_mLINEITEM4,
           me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
         rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
         rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
         rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
         rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
         ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
       else if map_id == 7
         then
           (nd_insert_LINEITEM_send_push_s59_m_REVENUE_mCUSTOMER11_mLINEITEM5,
             me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
           rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
           rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
           rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
           rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
           rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
           rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 60
       then if map_id == 6
         then
           (nd_insert_LINEITEM_send_push_s60_m_REVENUE_mCUSTOMER11_mLINEITEM4,
             me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
           rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
           rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
           rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
           rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
           rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
           rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
       else if stmt_id == 62
         then if map_id == 7
           then
             (nd_insert_LINEITEM_send_push_s62_m_REVENUE_mCUSTOMER11_mLINEITEM5,
               me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
             rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
             rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
             rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
             rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
             rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
             rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
           else error (print "nd_rcv_fetch: invalid map id")
         else if stmt_id == 63
           then if map_id == 6
             then
               (nd_insert_LINEITEM_send_push_s63_m_REVENUE_mCUSTOMER11_mLINEITEM4,
                 me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
               rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
               rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
               rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
               rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
               rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
               ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
               rq:LINEITEM_COMMENT}
             else if map_id == 7
               then
                 (nd_insert_LINEITEM_send_push_s63_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                   me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                 rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                 rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                 rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
                 rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                 rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
                 ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                 rq:LINEITEM_COMMENT}
               else error (print "nd_rcv_fetch: invalid map id")
           else if stmt_id == 64
             then if map_id == 6
               then
                 (nd_insert_LINEITEM_send_push_s64_m_REVENUE_mCUSTOMER11_mLINEITEM4,
                   me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                 rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                 rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                 rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
                 rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                 rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
                 ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                 rq:LINEITEM_COMMENT}
               else error (print "nd_rcv_fetch: invalid map id")
             else if stmt_id == 66
               then if map_id == 7
                 then
                   (nd_insert_LINEITEM_send_push_s66_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                     me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                   rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                   rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                   rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                   rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
                   rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
                   rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
                   rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
                 else error (print "nd_rcv_fetch: invalid map id")
               else if stmt_id == 67
                 then if map_id == 15
                   then
                     (nd_insert_LINEITEM_send_push_s67_m_REVENUE_mORDERS11_mLINEITEM4,
                       me)<- {ra:vid, rb:LINEITEM_ORDERKEY,
                     rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
                     re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
                     rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
                     ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
                     rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                     rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
                     ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                     rq:LINEITEM_COMMENT}
                   else error (print "nd_rcv_fetch: invalid map id")
                 else if stmt_id == 68
                   then if map_id == 15
                     then
                       (nd_insert_LINEITEM_send_push_s68_m_REVENUE_mORDERS11_mLINEITEM4,
                         me)<- {ra:vid, rb:LINEITEM_ORDERKEY,
                       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
                       re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
                       rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
                       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
                       rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                       rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
                       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                       rq:LINEITEM_COMMENT}
                     else error (print "nd_rcv_fetch: invalid map id")
                   else if stmt_id == 69
                     then if map_id == 19
                       then
                         (nd_insert_LINEITEM_send_push_s69_m_REVENUE_mLINEITEM4_mSUPPLIER1,
                           me)<- {ra:vid, rb:LINEITEM_ORDERKEY,
                         rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
                         re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
                         rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
                         ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
                         rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                         rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
                         ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                         rq:LINEITEM_COMMENT}
                       else error (print "nd_rcv_fetch: invalid map id")
                     else if stmt_id == 70
                       then if map_id == 19
                         then
                           (nd_insert_LINEITEM_send_push_s70_m_REVENUE_mLINEITEM4_mSUPPLIER1,
                             me)<- {ra:vid, rb:LINEITEM_ORDERKEY,
                           rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
                           re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
                           rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
                           ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
                           rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                           rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
                           ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                           rq:LINEITEM_COMMENT}
                         else error (print "nd_rcv_fetch: invalid map id")
                       else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_insert_LINEITEM_send_push_s58_m_REVENUE_mLINEITEM4 : { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real,
  ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string,
  rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mLINEITEM4 as ind REVENUE_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:58});
   (shuffle_REVENUE_mLINEITEM4_to_REVENUE_bind_0t0_1t1 {ra:None immut,
      rb:None immut, rc:None immut,
      rd:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mLINEITEM4_deref.filter ((\b1 -> bind b1 as {ra:ra,
           rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd == LINEITEM_ORDERKEY and re
           == LINEITEM_SUPPKEY))}, re:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s58_m_REVENUE_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s59_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM4 as ind REVENUE_mCUSTOMER11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:59});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           LINEITEM_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s59_m_REVENUE_mCUSTOMER11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s59_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM5 as ind REVENUE_mCUSTOMER11_mLINEITEM5_deref in
  ((nd_log_master_write {key:vid, value:59});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER11_bind_4t0
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM5_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc ==
           LINEITEM_ORDERKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s59_m_REVENUE_mCUSTOMER11_mLINEITEM5, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s60_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM4 as ind REVENUE_mCUSTOMER11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:60});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER11_mORDERS1_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:Some LINEITEM_ORDERKEY,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           LINEITEM_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s60_m_REVENUE_mCUSTOMER11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s62_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM5 as ind REVENUE_mCUSTOMER11_mLINEITEM5_deref in
  ((nd_log_master_write {key:vid, value:62});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER11_mSUPPLIER1_bind_1t0
      {ra:None immut, rb:None immut, rc:Some LINEITEM_SUPPKEY,
      rd:frontier_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM5_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc ==
           LINEITEM_ORDERKEY))}, re:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s62_m_REVENUE_mCUSTOMER11_mLINEITEM5, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s63_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM4 as ind REVENUE_mCUSTOMER11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:63});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           LINEITEM_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s63_m_REVENUE_mCUSTOMER11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s63_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM5 as ind REVENUE_mCUSTOMER11_mLINEITEM5_deref in
  ((nd_log_master_write {key:vid, value:63});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER12_bind_4t0
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM5_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc ==
           LINEITEM_ORDERKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s63_m_REVENUE_mCUSTOMER11_mLINEITEM5, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s64_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM4 as ind REVENUE_mCUSTOMER11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:64});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER12_mORDERS1_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:Some LINEITEM_ORDERKEY,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           LINEITEM_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s64_m_REVENUE_mCUSTOMER11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s66_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM5 as ind REVENUE_mCUSTOMER11_mLINEITEM5_deref in
  ((nd_log_master_write {key:vid, value:66});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER12_mSUPPLIER1_bind_1t0
      {ra:None immut, rb:None immut, rc:Some LINEITEM_SUPPKEY,
      rd:frontier_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM5_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc ==
           LINEITEM_ORDERKEY))}, re:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s66_m_REVENUE_mCUSTOMER11_mLINEITEM5, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s67_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mORDERS11_mLINEITEM4 as ind REVENUE_mORDERS11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:67});
   (shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mORDERS11_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:Some LINEITEM_ORDERKEY,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           LINEITEM_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s67_m_REVENUE_mORDERS11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s68_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mORDERS11_mLINEITEM4 as ind REVENUE_mORDERS11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:68});
   (shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mORDERS12_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:Some LINEITEM_ORDERKEY,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           LINEITEM_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s68_m_REVENUE_mORDERS11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s69_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mLINEITEM4_mSUPPLIER1 as ind REVENUE_mLINEITEM4_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:69});
   (shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:Some LINEITEM_SUPPKEY,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mLINEITEM4_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           LINEITEM_ORDERKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s69_m_REVENUE_mLINEITEM4_mSUPPLIER1, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_send_push_s70_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mLINEITEM4_mSUPPLIER1 as ind REVENUE_mLINEITEM4_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:70});
   (shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:Some LINEITEM_SUPPKEY,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mLINEITEM4_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           LINEITEM_ORDERKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_insert_LINEITEM_rcv_push_s70_m_REVENUE_mLINEITEM4_mSUPPLIER1, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_insert_LINEITEM_rcv_push_s58_m_REVENUE_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mLINEITEM4_s58_buf as ind
   map_REVENUE_mLINEITEM4_s58_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mLINEITEM4_s58_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0 and re == _tup4)
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mLINEITEM4_s58_buf_d.update vals tuple}
       {None -> map_REVENUE_mLINEITEM4_s58_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:58, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s58 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_rcv_push_s59_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s59_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM4_s59_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM4_s59_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s59_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s59_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:59, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s59 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_rcv_push_s59_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s59_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM5_s59_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM5_s59_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2)
       and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s59_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s59_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:59, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s59 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_rcv_push_s60_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s60_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM4_s60_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM4_s60_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s60_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s60_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:60, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s60 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_rcv_push_s62_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s62_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM5_s62_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM5_s62_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2)
       and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s62_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s62_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:62, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s62 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_rcv_push_s63_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s63_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM4_s63_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM4_s63_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s63_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s63_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:63, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s63 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_rcv_push_s63_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s63_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM5_s63_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM5_s63_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2)
       and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s63_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s63_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:63, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s63 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_rcv_push_s64_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s64_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM4_s64_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM4_s64_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s64_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s64_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:64, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s64 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_rcv_push_s66_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s66_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM5_s66_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM5_s66_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2)
       and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s66_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s66_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:66, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s66 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_rcv_push_s67_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mLINEITEM4_s67_buf as
   ind map_REVENUE_mORDERS11_mLINEITEM4_s67_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mLINEITEM4_s67_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mLINEITEM4_s67_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mLINEITEM4_s67_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:67, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s67 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_rcv_push_s68_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mLINEITEM4_s68_buf as
   ind map_REVENUE_mORDERS11_mLINEITEM4_s68_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mLINEITEM4_s68_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mLINEITEM4_s68_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mLINEITEM4_s68_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:68, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s68 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_rcv_push_s69_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mLINEITEM4_mSUPPLIER1_s69_buf as
   ind map_REVENUE_mLINEITEM4_mSUPPLIER1_s69_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mLINEITEM4_mSUPPLIER1_s69_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mLINEITEM4_mSUPPLIER1_s69_buf_d.update vals
         tuple}{None -> map_REVENUE_mLINEITEM4_mSUPPLIER1_s69_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:69, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s69 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_rcv_push_s70_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_insert_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mLINEITEM4_mSUPPLIER1_s70_buf as
   ind map_REVENUE_mLINEITEM4_mSUPPLIER1_s70_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mLINEITEM4_mSUPPLIER1_s70_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mLINEITEM4_mSUPPLIER1_s70_buf_d.update vals
         tuple}{None -> map_REVENUE_mLINEITEM4_mSUPPLIER1_s70_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:70, rc:-1}
   then
     nd_insert_LINEITEM_do_complete_s70 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_insert_LINEITEM_do_complete_s61_trig : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
  rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
  rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
  rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
  rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
  rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in 
  nd_insert_LINEITEM_do_complete_s61 {ra:vid, rb:LINEITEM_ORDERKEY,
    rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
    rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
    ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
    rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
    ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT})
trigger nd_insert_LINEITEM_do_complete_s65_trig : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
  rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
  rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
  rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
  rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
  rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in 
  nd_insert_LINEITEM_do_complete_s65 {ra:vid, rb:LINEITEM_ORDERKEY,
    rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
    rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
    ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
    rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
    ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT})
trigger insert_LINEITEM_rcv_corrective_s58_m_REVENUE_mLINEITEM4 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { ra:string,
  rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mLINEITEM4_s58_buf, rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:58}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s58_m_REVENUE_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s59_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mCUSTOMER11_mLINEITEM4_s59_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:59}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s59_m_REVENUE_mCUSTOMER11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s59_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_REVENUE_mCUSTOMER11_mLINEITEM5_s59_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:59}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s59_m_REVENUE_mCUSTOMER11_mLINEITEM5
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s60_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mCUSTOMER11_mLINEITEM4_s60_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:60}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s60_m_REVENUE_mCUSTOMER11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s62_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_REVENUE_mCUSTOMER11_mLINEITEM5_s62_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:62}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s62_m_REVENUE_mCUSTOMER11_mLINEITEM5
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s63_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mCUSTOMER11_mLINEITEM4_s63_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:63}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s63_m_REVENUE_mCUSTOMER11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s63_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_REVENUE_mCUSTOMER11_mLINEITEM5_s63_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:63}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s63_m_REVENUE_mCUSTOMER11_mLINEITEM5
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s64_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mCUSTOMER11_mLINEITEM4_s64_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:64}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s64_m_REVENUE_mCUSTOMER11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s66_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_REVENUE_mCUSTOMER11_mLINEITEM5_s66_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:66}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s66_m_REVENUE_mCUSTOMER11_mLINEITEM5
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s67_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mLINEITEM4_s67_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:67}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s67_m_REVENUE_mORDERS11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s68_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mLINEITEM4_s68_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:68}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s68_m_REVENUE_mORDERS11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s69_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mLINEITEM4_mSUPPLIER1_s69_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:69}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s69_m_REVENUE_mLINEITEM4_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger insert_LINEITEM_rcv_corrective_s70_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mLINEITEM4_mSUPPLIER1_s70_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:70}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_insert_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           insert_LINEITEM_do_corrective_s70_m_REVENUE_mLINEITEM4_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger nd_delete_LINEITEM_rcv_put : { ra:address, rb:collection { key:int,
  value:int } @ { Collection }, rc:{ key:int, value:int }, rd:int, re:int,
  rf:int, rg:int, rh:real, ri:real, rj:real, rk:real, rl:string, rm:string,
  rn:int, ro:int, rp:int, rq:string, rr:string, rs:string } = (\b1 ->
  bind b1 as {ra:sender_ip, rb:stmt_cnt_list, rc:vid, rd:LINEITEM_ORDERKEY,
  re:LINEITEM_PARTKEY, rf:LINEITEM_SUPPKEY, rg:LINEITEM_LINENUMBER,
  rh:LINEITEM_QUANTITY, ri:LINEITEM_EXTENDEDPRICE, rj:LINEITEM_DISCOUNT,
  rk:LINEITEM_TAX, rl:LINEITEM_RETURNFLAG, rm:LINEITEM_LINESTATUS,
  rn:LINEITEM_SHIPDATE, ro:LINEITEM_COMMITDATE, rp:LINEITEM_RECEIPTDATE,
  rq:LINEITEM_SHIPINSTRUCT, rr:LINEITEM_SHIPMODE, rs:LINEITEM_COMMENT} in 
  (stmt_cnt_list.iterate ((\b1 -> bind b1 as {key:stmt_id, value:count} in 
   if nd_check_stmt_cntr_index {ra:vid, rb:stmt_id, rc:count}
   then if stmt_id == 83
     then
       nd_delete_LINEITEM_do_complete_s83 {ra:vid, rb:LINEITEM_ORDERKEY,
         rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
         rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
         ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
         rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
         ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
     else if stmt_id == 82
       then
         nd_delete_LINEITEM_do_complete_s82 {ra:vid, rb:LINEITEM_ORDERKEY,
           rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
           rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
           rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
           rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
           rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
           ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
       else if stmt_id == 81
         then
           nd_delete_LINEITEM_do_complete_s81 {ra:vid, rb:LINEITEM_ORDERKEY,
             rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
             rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
             rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
             rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
             rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
             ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
             rq:LINEITEM_COMMENT}
         else if stmt_id == 80
           then
             nd_delete_LINEITEM_do_complete_s80 {ra:vid, rb:LINEITEM_ORDERKEY,
               rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
               re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
               rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
               ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
               rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
               rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
               rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
           else if stmt_id == 79
             then
               nd_delete_LINEITEM_do_complete_s79 {ra:vid,
                 rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                 rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                 rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                 rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
                 rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                 rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
                 ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                 rq:LINEITEM_COMMENT}
             else if stmt_id == 78
               then
                 nd_delete_LINEITEM_do_complete_s78 {ra:vid,
                   rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                   rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                   rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                   rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                   rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
                   rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
                   rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
                   rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
               else if stmt_id == 77
                 then
                   nd_delete_LINEITEM_do_complete_s77 {ra:vid,
                     rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                     rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                     rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                     rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                     rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
                     rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
                     rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
                     rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
                 else if stmt_id == 76
                   then
                     nd_delete_LINEITEM_do_complete_s76 {ra:vid,
                       rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                       rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                       rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                       rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
                       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
                       rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
                       rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
                   else if stmt_id == 75
                     then
                       nd_delete_LINEITEM_do_complete_s75 {ra:vid,
                         rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                         rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                         rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                         rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                         rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
                         rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
                         rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
                         rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
                     else if stmt_id == 74
                       then
                         nd_delete_LINEITEM_do_complete_s74 {ra:vid,
                           rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                           rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                           rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                           rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                           rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
                           rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
                           rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
                           rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
                       else if stmt_id == 73
                         then
                           nd_delete_LINEITEM_do_complete_s73 {ra:vid,
                             rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                             rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                             rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                             rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                             rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
                             rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
                             rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
                             rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
                         else if stmt_id == 72
                           then
                             nd_delete_LINEITEM_do_complete_s72 {ra:vid,
                               rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                               rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                               rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                               rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                               rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
                               rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
                               rn:LINEITEM_RECEIPTDATE,
                               ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                               rq:LINEITEM_COMMENT}
                           else if stmt_id == 71
                             then
                               nd_delete_LINEITEM_do_complete_s71 {ra:vid,
                                 rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                                 rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                                 rf:LINEITEM_QUANTITY,
                                 rg:LINEITEM_EXTENDEDPRICE,
                                 rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                                 rj:LINEITEM_RETURNFLAG,
                                 rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                                 rm:LINEITEM_COMMITDATE,
                                 rn:LINEITEM_RECEIPTDATE,
                                 ro:LINEITEM_SHIPINSTRUCT,
                                 rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
                             else () else ()));
   (sw_ack_rcv, sender_ip)<- {key:me, value:vid}))
trigger nd_delete_LINEITEM_rcv_fetch : { ra:collection { key:int, value:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:stmt_map_ids, rb:vid, rc:LINEITEM_ORDERKEY,
  rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER,
  rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT,
  rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS,
  rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE,
  rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   stmt_map_ids.iterate ((\b1 -> bind b1 as {key:stmt_id, value:map_id} in 
   if stmt_id == 71
   then if map_id == 18
     then
       (nd_delete_LINEITEM_send_push_s71_m_REVENUE_mLINEITEM4, me)<- {ra:vid,
       rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
       re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
       rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
       rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
       rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
       rq:LINEITEM_COMMENT} else error (print "nd_rcv_fetch: invalid map id")
   else if stmt_id == 72
     then if map_id == 6
       then
         (nd_delete_LINEITEM_send_push_s72_m_REVENUE_mCUSTOMER11_mLINEITEM4,
           me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
         rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
         rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
         rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
         rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
         ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
       else if map_id == 7
         then
           (nd_delete_LINEITEM_send_push_s72_m_REVENUE_mCUSTOMER11_mLINEITEM5,
             me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
           rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
           rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
           rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
           rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
           rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
           rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
     else if stmt_id == 73
       then if map_id == 6
         then
           (nd_delete_LINEITEM_send_push_s73_m_REVENUE_mCUSTOMER11_mLINEITEM4,
             me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
           rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
           rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
           rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
           rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
           rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
           rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
         else error (print "nd_rcv_fetch: invalid map id")
       else if stmt_id == 75
         then if map_id == 7
           then
             (nd_delete_LINEITEM_send_push_s75_m_REVENUE_mCUSTOMER11_mLINEITEM5,
               me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
             rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
             rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
             rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
             rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
             rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
             rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
           else error (print "nd_rcv_fetch: invalid map id")
         else if stmt_id == 76
           then if map_id == 6
             then
               (nd_delete_LINEITEM_send_push_s76_m_REVENUE_mCUSTOMER11_mLINEITEM4,
                 me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
               rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
               rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
               rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
               rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
               rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
               ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
               rq:LINEITEM_COMMENT}
             else if map_id == 7
               then
                 (nd_delete_LINEITEM_send_push_s76_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                   me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                 rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                 rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                 rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
                 rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                 rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
                 ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                 rq:LINEITEM_COMMENT}
               else error (print "nd_rcv_fetch: invalid map id")
           else if stmt_id == 77
             then if map_id == 6
               then
                 (nd_delete_LINEITEM_send_push_s77_m_REVENUE_mCUSTOMER11_mLINEITEM4,
                   me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                 rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                 rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                 rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
                 rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                 rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
                 ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                 rq:LINEITEM_COMMENT}
               else error (print "nd_rcv_fetch: invalid map id")
             else if stmt_id == 79
               then if map_id == 7
                 then
                   (nd_delete_LINEITEM_send_push_s79_m_REVENUE_mCUSTOMER11_mLINEITEM5,
                     me)<- {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
                   rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
                   rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE,
                   rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
                   rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
                   rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE,
                   rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
                   rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
                 else error (print "nd_rcv_fetch: invalid map id")
               else if stmt_id == 80
                 then if map_id == 15
                   then
                     (nd_delete_LINEITEM_send_push_s80_m_REVENUE_mORDERS11_mLINEITEM4,
                       me)<- {ra:vid, rb:LINEITEM_ORDERKEY,
                     rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
                     re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
                     rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
                     ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
                     rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                     rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
                     ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                     rq:LINEITEM_COMMENT}
                   else error (print "nd_rcv_fetch: invalid map id")
                 else if stmt_id == 81
                   then if map_id == 15
                     then
                       (nd_delete_LINEITEM_send_push_s81_m_REVENUE_mORDERS11_mLINEITEM4,
                         me)<- {ra:vid, rb:LINEITEM_ORDERKEY,
                       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
                       re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
                       rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
                       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
                       rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                       rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
                       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                       rq:LINEITEM_COMMENT}
                     else error (print "nd_rcv_fetch: invalid map id")
                   else if stmt_id == 82
                     then if map_id == 19
                       then
                         (nd_delete_LINEITEM_send_push_s82_m_REVENUE_mLINEITEM4_mSUPPLIER1,
                           me)<- {ra:vid, rb:LINEITEM_ORDERKEY,
                         rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
                         re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
                         rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
                         ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
                         rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                         rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
                         ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                         rq:LINEITEM_COMMENT}
                       else error (print "nd_rcv_fetch: invalid map id")
                     else if stmt_id == 83
                       then if map_id == 19
                         then
                           (nd_delete_LINEITEM_send_push_s83_m_REVENUE_mLINEITEM4_mSUPPLIER1,
                             me)<- {ra:vid, rb:LINEITEM_ORDERKEY,
                           rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY,
                           re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
                           rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
                           ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG,
                           rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
                           rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
                           ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE,
                           rq:LINEITEM_COMMENT}
                         else error (print "nd_rcv_fetch: invalid map id")
                       else error (print "nd_rcv_fetch: invalid stmt id")))))
trigger nd_delete_LINEITEM_send_push_s71_m_REVENUE_mLINEITEM4 : { ra:{ key:int,
  value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real,
  ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string,
  rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mLINEITEM4 as ind REVENUE_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:71});
   (shuffle_REVENUE_mLINEITEM4_to_REVENUE_bind_0t0_1t1 {ra:None immut,
      rb:None immut, rc:None immut,
      rd:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mLINEITEM4_deref.filter ((\b1 -> bind b1 as {ra:ra,
           rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd == LINEITEM_ORDERKEY and re
           == LINEITEM_SUPPKEY))}, re:true}).iterate ((\b1 ->
   bind b1 as {key:ip, value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s71_m_REVENUE_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_send_push_s72_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM4 as ind REVENUE_mCUSTOMER11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:72});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER11_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           LINEITEM_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s72_m_REVENUE_mCUSTOMER11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_send_push_s72_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM5 as ind REVENUE_mCUSTOMER11_mLINEITEM5_deref in
  ((nd_log_master_write {key:vid, value:72});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER11_bind_4t0
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM5_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc ==
           LINEITEM_ORDERKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s72_m_REVENUE_mCUSTOMER11_mLINEITEM5, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_send_push_s73_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM4 as ind REVENUE_mCUSTOMER11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:73});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER11_mORDERS1_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:Some LINEITEM_ORDERKEY,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           LINEITEM_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s73_m_REVENUE_mCUSTOMER11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_send_push_s75_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM5 as ind REVENUE_mCUSTOMER11_mLINEITEM5_deref in
  ((nd_log_master_write {key:vid, value:75});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER11_mSUPPLIER1_bind_1t0
      {ra:None immut, rb:None immut, rc:Some LINEITEM_SUPPKEY,
      rd:frontier_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM5_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc ==
           LINEITEM_ORDERKEY))}, re:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s75_m_REVENUE_mCUSTOMER11_mLINEITEM5, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_send_push_s76_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM4 as ind REVENUE_mCUSTOMER11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:76});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER12_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           LINEITEM_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s76_m_REVENUE_mCUSTOMER11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_send_push_s76_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM5 as ind REVENUE_mCUSTOMER11_mLINEITEM5_deref in
  ((nd_log_master_write {key:vid, value:76});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER12_bind_4t0
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:None immut,
      rf:frontier_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM5_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc ==
           LINEITEM_ORDERKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s76_m_REVENUE_mCUSTOMER11_mLINEITEM5, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_send_push_s77_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM4 as ind REVENUE_mCUSTOMER11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:77});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM4_to_REVENUE_mCUSTOMER12_mORDERS1_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:Some LINEITEM_ORDERKEY,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           LINEITEM_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s77_m_REVENUE_mCUSTOMER11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_send_push_s79_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mCUSTOMER11_mLINEITEM5 as ind REVENUE_mCUSTOMER11_mLINEITEM5_deref in
  ((nd_log_master_write {key:vid, value:79});
   (shuffle_REVENUE_mCUSTOMER11_mLINEITEM5_to_REVENUE_mCUSTOMER12_mSUPPLIER1_bind_1t0
      {ra:None immut, rb:None immut, rc:Some LINEITEM_SUPPKEY,
      rd:frontier_int_int_int {key:vid,
           value:REVENUE_mCUSTOMER11_mLINEITEM5_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in rc ==
           LINEITEM_ORDERKEY))}, re:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s79_m_REVENUE_mCUSTOMER11_mLINEITEM5, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_send_push_s80_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mORDERS11_mLINEITEM4 as ind REVENUE_mORDERS11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:80});
   (shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mORDERS11_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:Some LINEITEM_ORDERKEY,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           LINEITEM_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s80_m_REVENUE_mORDERS11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_send_push_s81_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mORDERS11_mLINEITEM4 as ind REVENUE_mORDERS11_mLINEITEM4_deref in
  ((nd_log_master_write {key:vid, value:81});
   (shuffle_REVENUE_mORDERS11_mLINEITEM4_to_REVENUE_mORDERS12_bind_0t0_1t1_3t2
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:Some LINEITEM_ORDERKEY,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mORDERS11_mLINEITEM4_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in re ==
           LINEITEM_SUPPKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s81_m_REVENUE_mORDERS11_mLINEITEM4, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_send_push_s82_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mLINEITEM4_mSUPPLIER1 as ind REVENUE_mLINEITEM4_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:82});
   (shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mSUPPLIER11_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:Some LINEITEM_SUPPKEY,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mLINEITEM4_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           LINEITEM_ORDERKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s82_m_REVENUE_mLINEITEM4_mSUPPLIER1, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_send_push_s83_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:{ key:int, value:int }, rb:int, rc:int, rd:int, re:int, rf:real, rg:real,
  rh:real, ri:real, rj:string, rk:string, rl:int, rm:int, rn:int, ro:string,
  rp:string, rq:string } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY,
  rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
  rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
  ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
  rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
  ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in bind
  REVENUE_mLINEITEM4_mSUPPLIER1 as ind REVENUE_mLINEITEM4_mSUPPLIER1_deref in
  ((nd_log_master_write {key:vid, value:83});
   (shuffle_REVENUE_mLINEITEM4_mSUPPLIER1_to_REVENUE_mSUPPLIER12_bind_0t0_1t1_3t3
      {ra:None immut, rb:None immut, rc:None immut, rd:None immut,
      re:Some LINEITEM_SUPPKEY,
      rf:frontier_string_string_int_int_int {key:vid,
           value:REVENUE_mLINEITEM4_mSUPPLIER1_deref.filter ((\b1 ->
           bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in rd ==
           LINEITEM_ORDERKEY))}, rg:true}).iterate ((\b1 -> bind b1 as {key:ip,
   value:tuples} in 
   (nd_delete_LINEITEM_rcv_push_s83_m_REVENUE_mLINEITEM4_mSUPPLIER1, ip)<- {ra:tuples,
   rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY, re:LINEITEM_SUPPKEY,
   rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY, rh:LINEITEM_EXTENDEDPRICE,
   ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX, rk:LINEITEM_RETURNFLAG,
   rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE, rn:LINEITEM_COMMITDATE,
   ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT, rq:LINEITEM_SHIPMODE,
   rr:LINEITEM_COMMENT}))))
trigger nd_delete_LINEITEM_rcv_push_s71_m_REVENUE_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mLINEITEM4_s71_buf as ind
   map_REVENUE_mLINEITEM4_s71_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mLINEITEM4_s71_buf_d.filter ((\b1 -> bind b1 as {ra:ra,
       rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0 and re == _tup4)
       and rd == _tup3) and rc == _tup2) and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mLINEITEM4_s71_buf_d.update vals tuple}
       {None -> map_REVENUE_mLINEITEM4_s71_buf_d.insert tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:71, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s71 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_rcv_push_s72_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s72_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM4_s72_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM4_s72_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s72_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s72_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:72, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s72 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_rcv_push_s72_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s72_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM5_s72_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM5_s72_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2)
       and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s72_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s72_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:72, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s72 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_rcv_push_s73_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s73_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM4_s73_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM4_s73_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s73_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s73_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:73, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s73 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_rcv_push_s75_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s75_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM5_s75_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM5_s75_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2)
       and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s75_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s75_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:75, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s75 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_rcv_push_s76_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s76_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM4_s76_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM4_s76_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s76_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s76_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:76, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s76 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_rcv_push_s76_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s76_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM5_s76_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM5_s76_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2)
       and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s76_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s76_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:76, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s76 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_rcv_push_s77_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM4_s77_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM4_s77_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM4_s77_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s77_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM4_s77_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:77, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s77 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_rcv_push_s79_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:collection { ra:{ key:int, value:int }, rb:int, rc:int, rd:int
  } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int, re:int,
  rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string, rm:int,
  rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mCUSTOMER11_mLINEITEM5_s79_buf
   as ind map_REVENUE_mCUSTOMER11_mLINEITEM5_s79_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3} in
     case ((map_REVENUE_mCUSTOMER11_mLINEITEM5_s79_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd} in (ra == _tup0 and rc == _tup2)
       and rb == _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s79_buf_d.update vals
         tuple}{None -> map_REVENUE_mCUSTOMER11_mLINEITEM5_s79_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:79, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s79 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_rcv_push_s80_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mLINEITEM4_s80_buf as
   ind map_REVENUE_mORDERS11_mLINEITEM4_s80_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mLINEITEM4_s80_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mLINEITEM4_s80_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mLINEITEM4_s80_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:80, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s80 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_rcv_push_s81_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mORDERS11_mLINEITEM4_s81_buf as
   ind map_REVENUE_mORDERS11_mLINEITEM4_s81_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mORDERS11_mLINEITEM4_s81_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mORDERS11_mLINEITEM4_s81_buf_d.update vals
         tuple}{None -> map_REVENUE_mORDERS11_mLINEITEM4_s81_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:81, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s81 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_rcv_push_s82_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mLINEITEM4_mSUPPLIER1_s82_buf as
   ind map_REVENUE_mLINEITEM4_mSUPPLIER1_s82_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mLINEITEM4_mSUPPLIER1_s82_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mLINEITEM4_mSUPPLIER1_s82_buf_d.update vals
         tuple}{None -> map_REVENUE_mLINEITEM4_mSUPPLIER1_s82_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:82, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s82 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_rcv_push_s83_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:collection { ra:{ key:int, value:int }, rb:string, rc:string, rd:int,
  re:int, rf:int } @ { Collection }, rb:{ key:int, value:int }, rc:int, rd:int,
  re:int, rf:int, rg:real, rh:real, ri:real, rj:real, rk:string, rl:string,
  rm:int, rn:int, ro:int, rp:string, rq:string, rr:string } = (\b1 ->
  bind b1 as {ra:tuples, rb:vid, rc:LINEITEM_ORDERKEY, rd:LINEITEM_PARTKEY,
  re:LINEITEM_SUPPKEY, rf:LINEITEM_LINENUMBER, rg:LINEITEM_QUANTITY,
  rh:LINEITEM_EXTENDEDPRICE, ri:LINEITEM_DISCOUNT, rj:LINEITEM_TAX,
  rk:LINEITEM_RETURNFLAG, rl:LINEITEM_LINESTATUS, rm:LINEITEM_SHIPDATE,
  rn:LINEITEM_COMMITDATE, ro:LINEITEM_RECEIPTDATE, rp:LINEITEM_SHIPINSTRUCT,
  rq:LINEITEM_SHIPMODE, rr:LINEITEM_COMMENT} in 
  ((nd_log_write_delete_LINEITEM {ra:vid, rb:LINEITEM_ORDERKEY,
      rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
      rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
      ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
      rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
      ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT});
   tuples.iterate ((\tuple -> bind map_REVENUE_mLINEITEM4_mSUPPLIER1_s83_buf as
   ind map_REVENUE_mLINEITEM4_mSUPPLIER1_s83_buf_d in
   bind tuple as {ra:_tup0, rb:_tup1, rc:_tup2, rd:_tup3, re:_tup4, rf:_tup5}
     in
     case ((map_REVENUE_mLINEITEM4_mSUPPLIER1_s83_buf_d.filter ((\b1 ->
       bind b1 as {ra:ra, rb:rb, rc:rc, rd:rd, re:re, rf:rf} in (((ra == _tup0
       and re == _tup4) and rd == _tup3) and rc == _tup2) and rb ==
       _tup1))).peek ()) of
       {Some vals -> map_REVENUE_mLINEITEM4_mSUPPLIER1_s83_buf_d.update vals
         tuple}{None -> map_REVENUE_mLINEITEM4_mSUPPLIER1_s83_buf_d.insert
                 tuple}));
   (if nd_check_stmt_cntr_index {ra:vid, rb:83, rc:-1}
   then
     nd_delete_LINEITEM_do_complete_s83 {ra:vid, rb:LINEITEM_ORDERKEY,
       rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
       rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
       ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
       rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
       ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT}
   else ())))
trigger nd_delete_LINEITEM_do_complete_s74_trig : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
  rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
  rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
  rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
  rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
  rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in 
  nd_delete_LINEITEM_do_complete_s74 {ra:vid, rb:LINEITEM_ORDERKEY,
    rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
    rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
    ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
    rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
    ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT})
trigger nd_delete_LINEITEM_do_complete_s78_trig : { ra:{ key:int, value:int },
  rb:int, rc:int, rd:int, re:int, rf:real, rg:real, rh:real, ri:real,
  rj:string, rk:string, rl:int, rm:int, rn:int, ro:string, rp:string, rq:string
  } = (\b1 -> bind b1 as {ra:vid, rb:LINEITEM_ORDERKEY, rc:LINEITEM_PARTKEY,
  rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER, rf:LINEITEM_QUANTITY,
  rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT, ri:LINEITEM_TAX,
  rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS, rl:LINEITEM_SHIPDATE,
  rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE, ro:LINEITEM_SHIPINSTRUCT,
  rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT} in 
  nd_delete_LINEITEM_do_complete_s78 {ra:vid, rb:LINEITEM_ORDERKEY,
    rc:LINEITEM_PARTKEY, rd:LINEITEM_SUPPKEY, re:LINEITEM_LINENUMBER,
    rf:LINEITEM_QUANTITY, rg:LINEITEM_EXTENDEDPRICE, rh:LINEITEM_DISCOUNT,
    ri:LINEITEM_TAX, rj:LINEITEM_RETURNFLAG, rk:LINEITEM_LINESTATUS,
    rl:LINEITEM_SHIPDATE, rm:LINEITEM_COMMITDATE, rn:LINEITEM_RECEIPTDATE,
    ro:LINEITEM_SHIPINSTRUCT, rp:LINEITEM_SHIPMODE, rq:LINEITEM_COMMENT})
trigger delete_LINEITEM_rcv_corrective_s71_m_REVENUE_mLINEITEM4 : { ra:address,
  rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int, value:int },
  rf:collection { key:int, value:int } @ { Seq }, rg:collection { ra:string,
  rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mLINEITEM4_s71_buf, rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:71}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s71_m_REVENUE_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_LINEITEM_rcv_corrective_s72_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mCUSTOMER11_mLINEITEM4_s72_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:72}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s72_m_REVENUE_mCUSTOMER11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_LINEITEM_rcv_corrective_s72_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_REVENUE_mCUSTOMER11_mLINEITEM5_s72_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:72}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s72_m_REVENUE_mCUSTOMER11_mLINEITEM5
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_LINEITEM_rcv_corrective_s73_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mCUSTOMER11_mLINEITEM4_s73_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:73}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s73_m_REVENUE_mCUSTOMER11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_LINEITEM_rcv_corrective_s75_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_REVENUE_mCUSTOMER11_mLINEITEM5_s75_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:75}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s75_m_REVENUE_mCUSTOMER11_mLINEITEM5
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_LINEITEM_rcv_corrective_s76_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mCUSTOMER11_mLINEITEM4_s76_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:76}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s76_m_REVENUE_mCUSTOMER11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_LINEITEM_rcv_corrective_s76_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_REVENUE_mCUSTOMER11_mLINEITEM5_s76_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:76}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s76_m_REVENUE_mCUSTOMER11_mLINEITEM5
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_LINEITEM_rcv_corrective_s77_m_REVENUE_mCUSTOMER11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mCUSTOMER11_mLINEITEM4_s77_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:77}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s77_m_REVENUE_mCUSTOMER11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_LINEITEM_rcv_corrective_s79_m_REVENUE_mCUSTOMER11_mLINEITEM5 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:int, rb:int, rc:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_int_int_int {ra:map_REVENUE_mCUSTOMER11_mLINEITEM5_s79_buf,
      rb:false, rc:vid, rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:79}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s79_m_REVENUE_mCUSTOMER11_mLINEITEM5
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_LINEITEM_rcv_corrective_s80_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mLINEITEM4_s80_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:80}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s80_m_REVENUE_mORDERS11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_LINEITEM_rcv_corrective_s81_m_REVENUE_mORDERS11_mLINEITEM4 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mORDERS11_mLINEITEM4_s81_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:81}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s81_m_REVENUE_mORDERS11_mLINEITEM4
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_LINEITEM_rcv_corrective_s82_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mLINEITEM4_mSUPPLIER1_s82_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:82}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s82_m_REVENUE_mLINEITEM4_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))
trigger delete_LINEITEM_rcv_corrective_s83_m_REVENUE_mLINEITEM4_mSUPPLIER1 : {
  ra:address, rb:int, rc:{ key:int, value:int }, rd:int, re:{ key:int,
  value:int }, rf:collection { key:int, value:int } @ { Seq }, rg:collection {
  ra:string, rb:string, rc:int, rd:int, re:int } @ { Collection } } = (\b1 ->
  bind b1 as {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop, re:vid,
  rf:compute_vids, rg:delta_tuples} in 
  ((nd_add_delta_to_string_string_int_int_int
      {ra:map_REVENUE_mLINEITEM4_mSUPPLIER1_s83_buf, rb:false, rc:vid,
      rd:delta_tuples});
   let sent_msgs =
   compute_vids.fold ((\acc_count -> (\compute_vid -> let cntr =
     case ((nd_stmt_cntrs.filter ((\b1 -> bind b1 as {key:key, value:value} in 
       key == {key:compute_vid, value:83}))).peek ()) of
       {Some lkup -> (lkup.value).key}{None -> 0} in
     if cntr == 0
       then bind nd_log_get_bound_delete_LINEITEM compute_vid as
         {ra:LINEITEM_ORDERKEY, rb:LINEITEM_PARTKEY, rc:LINEITEM_SUPPKEY, rd:LINEITEM_LINENUMBER, re:LINEITEM_QUANTITY, rf:LINEITEM_EXTENDEDPRICE, rg:LINEITEM_DISCOUNT, rh:LINEITEM_TAX, ri:LINEITEM_RETURNFLAG, rj:LINEITEM_LINESTATUS, rk:LINEITEM_SHIPDATE, rl:LINEITEM_COMMITDATE, rm:LINEITEM_RECEIPTDATE, rn:LINEITEM_SHIPINSTRUCT, ro:LINEITEM_SHIPMODE, rp:LINEITEM_COMMENT}
         in
         acc_count +
           delete_LINEITEM_do_corrective_s83_m_REVENUE_mLINEITEM4_mSUPPLIER1
             {ra:orig_addr, rb:orig_stmt_id, rc:orig_vid, rd:hop,
             re:compute_vid, rf:LINEITEM_ORDERKEY, rg:LINEITEM_PARTKEY,
             rh:LINEITEM_SUPPKEY, ri:LINEITEM_LINENUMBER, rj:LINEITEM_QUANTITY,
             rk:LINEITEM_EXTENDEDPRICE, rl:LINEITEM_DISCOUNT, rm:LINEITEM_TAX,
             rn:LINEITEM_RETURNFLAG, ro:LINEITEM_LINESTATUS,
             rp:LINEITEM_SHIPDATE, rq:LINEITEM_COMMITDATE,
             rr:LINEITEM_RECEIPTDATE, rs:LINEITEM_SHIPINSTRUCT,
             rt:LINEITEM_SHIPMODE, ru:LINEITEM_COMMENT, rv:delta_tuples}
       else acc_count))) 0 in
   (nd_rcv_corr_done, orig_addr)<- {ra:orig_vid, rb:orig_stmt_id, rc:hop,
     rd:sent_msgs}))


source master : () = value(())feed master |> ms_send_addr_self


source switch : { ra:string, rb:int, rc:real, rd:string, re:int, rf:string,
rg:string, rh:string, ri:string, rj:string, rk:int, rl:real, rm:real, rn:int,
ro:string, rp:string, rq:string, rr:string, rs:int, rt:string, ru:int,
rv:string, rw:string, rx:int, ry:string, rz:real, rza:string, rzb:int,
rzc:real, rzd:string, rze:string, rzf:string, rzg:string, rzh:int, rzi:int,
rzj:int, rzk:real, rzl:real, rzm:real, rzn:string
} = file "/k3/K3/temp/tpch7.csv" psvfeed switch |> sw_demux








