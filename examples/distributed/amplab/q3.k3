include "Annotation/Collection.k3"
include "Annotation/Map.k3"
include "Core/CppBuiltins.k3"

declare peer_by_hash: string -> address

// Raw Data

declare user_visits: collection {
    sourceIP: string,
    destURL: string,
    visitDate: int,
    adRevenue: real,
    userAgent: string,
    countryCode: string,
    languageCode: string,
    searchWord: string,
    duration: int
} @ { Collection }

declare rankings: collection {
    pageURL: string,
    pageRank: int,
    avgDuration: int
} @ { Collection }

// Phase #1: Partition data items by join key.

declare uv_partitions: collection {
    key: string,
    value: collection {
        destURL: string,
        sourceIP: string,
        adRevenue: real
    } @ { Collection }
} @ { Map }

trigger uv_partition: () = \_ -> (
    // Partition `user_vists' by destURL, store partitions in `uv_partitions'.
    // Also project out attributes not necessary for further computation.
    (user_visits.iterate (
        \u -> (case lookup uv_partitions u.destURL of
                { Some v -> v.insert { destURL: u.destURL, sourceIP: u.sourceIP, adRevenue: u.adRevenue }}
                { None -> let v = empty {destURL: string, sourceIP: string, adRevenue: real} @ { Collection }
                          in ((v.insert {destURL: u.destURL, sourceIP: u.sourceIP, adRevenue: u.adRevenue});
                              (uv_partitions.insert { key: u.destURL, value: v }))}
              )
    ));

    // Send partitions to peers by hashing `destURL'.
    (uv_partitions.iterate (
        \up -> (uv_partition_receive, peer_by_hash up.key) <- up.value
    ))
)

declare rk_partitions: collection {
    key: string,
    value: collection {
        pageURL: string,
        pageRank: real
    } @ { Collection }
} @ { Map }

trigger rk_partition: () = \_ -> (
    // Partition `rankings' by `pageURL', store partitions in `rk_partitions'.
    // Also project out attributes not necessary for further computation.
    (rankings.iterate (
        \r -> (case lookup rk_partitions r.pageURL of
                { Some v -> v.insert { pageURL: r.pageURL, pageRank: r.pageRank }}
                { None -> let v = empty { pageURL: string, pageRank: real } @ { Collection }
                          in ((v.insert { pageURL: r.pageURL, pageRank: r.pageRank });
                              (rk_partitions.insert { key: r.pageRank, value: v }))}
              )
    ));

    // Send partitions to peers by hashing `pageURL'.
    (rk_partitions.iterate (
        \rp -> (rk_partition_receive, peer_by_hash rp.key) <- rp.value
    ))
)

// Receive `user_visit' partition.
trigger uv_partition_receive:
    collection { key: string, value: { destURL: string, sourceIP: string, adRevenue: real } } @ { Map } = \c -> ()

// Receive `rankings' partition.
trigger rk_partition_receive:
    collection { key: string, value: { pageURL: string, pageRank: real } } @ { Map } = \c -> ()
