include "Annotation/Collection.k3"
include "Annotation/Map.k3"
include "Core/CppBuiltins.k3"

declare peer_by_hash: string -> address

declare insert_with: forall a, b. collection { key: a, value: b } @ { Map } -> a -> b -> (b -> b) -> ()
declare modify_with: forall a, b. collection { key: a, value: b } @ { Map } -> a -> b -> (b -> ()) -> ()

declare getAt: forall a, b. collection { key: a, value: b } @ { Map } -> a -> (b -> ()) -> () = \c -> \a -> \f ->
    case lookup c a of
        { Some k -> f k }
        { None -> () }

// Raw Data

declare user_visits: collection {
    sourceIP: string,
    destURL: string,
    visitDate: int,
    adRevenue: real,
    userAgent: string,
    countryCode: string,
    languageCode: string,
    searchWord: string,
    duration: int
} @ { Collection }

declare rankings: collection {
    pageURL: string,
    pageRank: int,
    avgDuration: int
} @ { Collection }

// Phase #1: Partition data items by join key.

declare uv_partitions: collection {
    key: string,
    value: collection {
        key: string,
        value: real
    } @ { Map }
} @ { Map }

trigger uv_partition: () = \_ -> (
    // Partition `user_vists' by destURL, store partitions in `uv_partitions'.
    // Also project out attributes not necessary for further computation.
    (user_visits.iterate (
        \u -> modify_with uv_partitions u.destURL
                (empty { key: string, value: real } @ { Map })
                (\v -> modify_with v u.sourceIP
                        ({ key: u.sourceIP, value: 0.0 })
                        (\w -> { key: w.sourceIP, value: w.value + u.adRevenue }))
    ));

    // Send partitions to peers by hashing `destURL'.
    (uv_partitions.iterate (
        \up -> (uv_partition_receive, peer_by_hash up.key) <- up
    ));

    // Notify all peers that we've sent out all user_visits partitions.
    (peers.iterate (\a -> (uv_partitions_received, a.addr) <- ()))
)

declare rk_partitions: collection {
    key: string,
    value: {
        pageRank_total: real,
        pageRank_count: real
    }
} @ { Map }

trigger rk_partition: () = \_ -> (
    // Partition `rankings' by `pageURL', store partitions in `rk_partitions'.
    // Also project out attributes not necessary for further computation.
    (rankings.iterate (
        \r -> modify_with rk_partitions r.pageURL
                (empty { pageURL: string, pageRank: real } @ { Collection })
                (\v -> v.insert {pageRank_total: v.pageRank_total + r.pageRank,
                                 pageRank_count: v.pageRank_count + 1})
    ));

    // Send partitions to peers by hashing `pageURL'.
    (rk_partitions.iterate (
        \rp -> (rk_partition_receive, peer_by_hash rp.key) <- rp
    ));

    // Notify all peers that we've sent out all rankings partitions.
    (peers.iterate (\a -> (rk_partitions_received, a.addr) <- ()))
)

declare uv_candidates: collection {
    key: string,
    value: collection {
        key: string,
        value: real
    } @ { Map }
} @ { Map }

// Receive `user_visit' partition.
trigger uv_partition_receive: {
    key: string,
    value: collection {
        key: string,
        value: real
    } @ { Map }
} = \up ->
    modify_with uv_candidates up.key
        (empty { key: string, value: real })
        (\v -> modify_with v up.value.sourceIP
                { key: up.value.key, value: 0 }
                (\w -> { key: w.key, value: w.value + up.value.value }))

declare uv_received: mut int = 0
trigger uv_partitions_received: () = \_ ->
    ((uv_received = uv_received + 1);
     (if uv_received == peer_count and rk_received == peer_count then (do_groupBy, me) <- () else ()))

trigger rk_partition_receive: {
    key: string,
    value: {
        pageRank_total: real,
        pageRank_count: real
    }
} = \rp ->
    modify_with rk_candidates rk.key
        { pageRank_total: 0, pageRank_count: 0 }
        (\v -> {pageRank_total: v.pageRank_total + rk.value.pageRank_total,
                pageRank_count: v.pageRank_count + 1})

declare rk_received: mut int = 0
trigger rk_partitions_received: () = \_ ->
    ((rk_received = rk_received + 1);
     (if uv_received == peer_count and rk_received == peer_count then (do_groupBy, me) <- () else ()))

declare local_group: collection {
    key: string,
    value: {
        pageRank_total: real,
        pageRank_count: real,
        adRevenue_total: real
    }
} @ { Map }

// Local groupBy computation
trigger do_groupBy: () = \_ -> (
    (uv_candidates.iterate (\uc ->
        let rk = case lookup rk_candidates uc.key of
                    { Some r -> r }
                    { None -> { pageRank_total: 0, pageRank_count: 0 } }
        in uc.value.iterate (
            \sar -> local_group.insert
                        {key: sar.key,
                         value: {pageRank_total: rk.pageRank_total,
                                 pageRank_count: rk.pageRank_count,
                                 adRevenue_total: sar.value}}
        )));

    (local_group.iterate (\g -> (global_group, peer_by_host g.key) <- g));
    (peers.iterate (\p -> (global_group_receive, p.addr) <- ()));

declare global_received: mut int = 0
trigger global_group_receive: () = \_ -> (
    (global_received = global_received + 1);
    (if global_received == peer_count then do_global_groupBy else ())
)

declare global_groupBy_result: collection {
    key: string,
    value: {
        pageRank_total: real,
        pageRank_count: real,
        adRevenue_total: real
    }
} @ { Map }

trigger do_global_groupBy: {
    key: string,
    value: {
        pageRank_total: real,
        pageRank_count: real,
        adRevenue_total: real
    }
} = \r -> (
    (modify_with global_groupBy_result r.key
        { pageRank_total: 0.0, pageRank_count: 0.0, adRevenue_total: 0.0 }
        (\w -> {pageRank_total: w.pageRank_total + r.value.pageRank_total,
                pageRank_count: w.pageRank_count + r.value.pageRank_count,
                adRevenue_total: w.adRevenue_total + r.value.adRevenue_total}));

    ((global_max, master) <- global_groupBy_result.fold
        (\a -> \r -> if r.value.adRevenue_total > a.adRevenue_total
                        then {sourceIP: r.key,
                              pageRank_avg: r.value.pageRank_total / r.value.pageRank_count,
                              adRevenue_total: r.value.adRevenue_total}
                        else a)
        { sourceIP: "", pageRank_avg: 0.0, adRevenue_total: 0.0})
)

// Final global max aggregation.
declare max_result: mut { key: string, value: {pageRank_avg: real, adRevenue_total: real }}
    = { key: "", value: {pageRank_avg: 0, adRevenue_total: 0 }}
trigger global_max: { key: string, value: {pageRank_avg: real, adRevenue_total: real }} = \r ->
    if r.value.adRevenue_total > max_result.adRevenue_total
        then max_result = r
        else ()
