include "Annotation/Collection.k3"
include "Annotation/Map.k3"
include "Core/CppBuiltins.k3"

declare dataLoader : string -> collection {
    adRevenue: real,
    countryCode: string,
    destURL: string,
    duration: int,
    languageCode: string,
    searchWord: string,
    sourceIP: string,
    userAgent: string,
    visitDate: string
    } @ { Collection } -> ()

// Constants
declare master: address = 127.0.0.1:40000
declare index_by_hash: string -> int
declare peer_by_index: int -> address
declare x: mut int = 3
declare num_peers: int = 2
declare data_file : string = "/k3/data/amplab/rankings_10.k3"

// Globals
declare peers_ready: mut int = 0
declare peers_finished: mut int = 0
declare master_peers_finished: mut int = 0

// Data
declare local_uservisits: collection {
    adRevenue: real,
    countryCode: string,
    destURL: string,
    duration: int,
    languageCode: string,
    searchWord: string,
    sourceIP: string,
    userAgent: string,
    visitDate: string
    } @ { Collection }

declare local_q2_results: mut collection {key: string, value: real} @ { Map }

// Time
declare start_ms : mut int = 0
declare end_ms : mut int = 0
declare elapsed_ms : mut int = 0

declare agg_vals : mut collection {key:string, value:real} @ {Collection}
declare peer_aggs : mut collection {key: int, value:
                   collection {key: string, value: real} @ {Collection}
                   } @ {Collection}

// Perform the query on the local dataset. (Filter and project.)
// Store the results in memory.
trigger q2_local : () = \_ -> (
  agg_vals =
    local_uservisits.groupBy
      (\r -> substring r.sourceIP 0 x) //TODO index by 0 or 1?
      (\acc -> \r ->
        acc + r.adRevenue)
      0.0;
  // Group by destination peer address
  peer_aggs =
    agg_vals.groupBy
      (\v -> index_by_hash v.key)
      (\acc -> \v -> (acc.insert(v); acc))
      (empty {key: string, value: real} @ {Collection});
  peer_aggs.iterate (\v ->
    (aggregate, peer_by_index v.key) <- v.value
  );
  // Send punctuation: we're done
  peers.iterate(\p -> (peer_barrier, p.addr) <- ())
)

declare merge_results: collection { key: string, value: real } @ { Collection } -> () = \vals -> (
    vals.iterate (
        \v -> case local_q2_results.lookup {key: v.key, value: 0.0}  of
            { Some kv -> local_q2_results.insert { key: v.key, value: kv.value + v.value } }
            { None -> local_q2_results.insert v }
    )
)

trigger aggregate : collection { key: string, value: real } @ {Collection} = \vals -> (
  merge_results vals
)

trigger peer_barrier : () = \_ -> (
  peers_finished = peers_finished + 1;
  if peers_finished == num_peers
  then (master_done, master) <- ()
  else ()
)

trigger master_done : () = \_ -> (
  master_peers_finished = master_peers_finished + 1;
  if master_peers_finished == num_peers
  then end_ms = now ();
       elapsed_ms = end_ms - start_ms;
       printLine (itos elapsed_ms);
       peers.iterate (\p -> (shutdown, p.addr) <- ())
  else ()
)


trigger shutdown : () = \_ -> (
  haltEngine ()
)

// Signal to the master that a peer is ready.
// Once all peers are ready, the master will start the query.
trigger ready : () = \_ -> (
  peers_ready = peers_ready + 1;
  if peers_ready == num_peers
  then start_ms = now (); peers.iterate (\p -> (q2_local, p.addr) <- ())
  else ()
)

trigger load_all : () = \_ -> (
  (dataLoader data_file local_uservisits);
  ((ready, master) <- ())
)

source rows : () = value ()
feed rows |> load_all
