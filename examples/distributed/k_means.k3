include "Annotation/Vector.k3"
include "Annotation/Map.k3"
include "Core/CppBuiltins.k3"

// Constants
declare k : int = 3
declare dimensionality : int = 3
declare master : address
declare data_file: string

// Global vars
declare iterations_remaining : mut int = 5
declare peers_ready : mut int = 0
declare requests : mut int = 0

// Collection of data points. Each point represented as a vector
declare data :collection {
  elem: collection {elem: real} @ {Vector}
} @ {Collection}

// Collection of (k) means. Each mean has an integer key, and a value represented as a vector.
declare means : mut collection {
  key: int,
  value: collection {elem: real} @ {Vector}
} @ {Collection}


// Collection of partial aggregates for each mean.
declare aggregates : mut collection {
  key: int,
  value: {
    count: int,
    sum : collection {elem: real} @ {Vector}
  }
} @ {Map}

// Utility functions
// Send the current means to each peer for the assignment (E) step
declare broadcastMeans : () -> () = \_ -> (
  peers.iterate \p -> (
    requests = requests + 1;
    (assign, p.addr) <- means
  )
)

// TODO switch to use range() and randomVector()
// Initialize the means and send out the initial broadcast
declare start : () -> () = \_ -> (
  // initialize means
  let ignore = data.fold
    (\a -> (\p -> (
      if a == 0
        then a
        else (
          (means.insert {key: a, value: p.elem});
          (a - 1)
        )
    )))
    k
  // broadcast initial means
  in broadcastMeans ()
)

// Returns the key of the nearest current mean for the provided point
declare nearest_mean : collection {elem: real} @ {Vector} -> int = (\p ->
  case means.peek() of
    { Some first_mean ->
        let nearest = means.fold (\acc -> \curr_mean ->
          let dist = p.distance curr_mean.value
          in
            if dist < acc.distance
            then {mean: curr_mean, distance: dist}
            else acc
        ) {mean: first_mean, distance: p.distance first_mean.value}
        in
          nearest.mean.key
    }
    { None -> (-1) } // Error
)

// Merge a collection of partial aggregates into the global state
declare merge_results : collection {key: int, value: {count: int, sum: collection {elem: real} @ {Vector} }} @ {Collection} -> () = \peer_aggs -> (
  requests = requests -1;
  peer_aggs.iterate (\v ->
    case aggregates.lookup v of
     { Some a ->
         aggregates.insert
          { key: v.key,
            value: { count: v.value.count + a.value.count,
                     sum:   v.value.sum.add a.value.sum
                   }
          }
     }
     { None -> aggregates.insert v }
  )
)

// Triggers
// Load data into global variable, then notify master.
trigger load : () = \_ -> (
  loadVector data_file data;
  (ready, master) <- ()
)

// Increment the count of peers who are ready to start
trigger ready : () = \_ -> (
  peers_ready = peers_ready + 1;
  if (peers_ready == peers.size())
    then start ()
    else ()
)

// Given the new means, assign each data point to the nearest.
// Keeping a running aggregate of the sum and count for each mean.
trigger assign : collection { key: int, value: collection {elem: real} @ {Vector}} @ {Collection} = \new_means -> (
  // update state
  means = new_means;
  // compute aggregate statistics:
  let aggs = data.groupBy
    (\p -> nearest_mean p.elem)
    (\sc -> \p ->
      {count: sc.count + 1, sum: sc.sum.add p.elem}
    )
    {count: 0, sum: zeroVector dimensionality}
  // return results to master
  in (aggregate, master) <- aggs
)

trigger aggregate : collection {key: int, value: {count: int, sum: collection {elem: real} @ {Vector} }} @ {Collection} = \peer_aggs -> (
  merge_results peer_aggs;
  if requests == 0
    then (maximize, master) <- ()
    else ()
)

trigger maximize : () = \_ -> (
  means = empty {key: int, value: collection {elem: real} @ {Vector}} @ {Collection};
  aggregates.iterate (\x ->
    means.insert
      {  key: x.key
      ,  value: x.value.sum.map (\e -> (1.0 / x.value.count) * e.elem)  // scalar * vector
      }
  );
  iterations_remaining = iterations_remaining - 1;
  if iterations_remaining == 0
    then (
      peers.iterate (\p -> (shutdown, p.addr) <- () )
    )
    else (
      aggregates = empty {key:int, value: {count: int, sum: collection {elem: real} @ {Vector}}} @ {Map};
      peers.iterate \p -> (
        requests = requests + 1;
        (assign, p.addr) <- means
      )
    )
)

trigger shutdown : () = \_ -> haltEngine ()


source s1 : () = value ()
feed s1 |> load
