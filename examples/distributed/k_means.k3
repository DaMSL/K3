include "Annotation/Collection.k3"

declare master: address = 127.0.0.1:40000

declare k: int = 1
declare iterations_remaining: int = 100

declare means: collection { key: int, value: collection { key: int, value: real } @ { Collection } } @ { Collection }
declare aggregates: collection { key: int, value: { sum: collection { key: int, value: real } @ { Collection }, count: int } } @ { Collection }

declare data: collection { elem: collection { key: int, value: real } @ { Collection } } @ { Collection }

declare vector_zip: (real -> real -> real) -> collection { key: int, value: real } @ { Collection } -> collection { key: int, value: real } @ { Collection } -> collection { key: int, value: real } @ { Collection } = \f -> \v -> \w ->
    let c = v.combine w in c.groupBy (\i -> i.key) (\a -> \e -> f a e.value) 0.0

declare vector_add : collection { key: int, value: real } @ { Collection } -> collection { key: int, value: real } @ { Collection } -> collection { key: int, value: real } @ { Collection } = vector_zip (\acc -> \elem -> acc + elem)

declare vector_sub : collection { key: int, value: real } @ { Collection } -> collection { key: int, value: real } @ { Collection } -> collection { key: int, value: real } @ { Collection } = \c1 -> \c2 ->
    vector_zip (\acc -> \e -> (-1 * acc) + e) c2 c1

declare squared_distance: collection { key: int, value: real } @ { Collection } -> collection { key: int, value: real } @ { Collection } -> real = \p -> \q ->
    let diff = vector_sub p q in diff.fold (\a -> \x -> a + (x.value * x.value)) 0.0

declare nearest_neighbor: collection { key: int, value: real } -> collection { key: int, value: collection { key: int, value: real } @ { Collection } } @ { Collection } -> int = \p -> \means -> (
    case means.peek () of
        { Some first_mean ->
            (means.erase first_mean); // Necessary/Correct?
            let nearest = means.fold (\acc -> \next ->
                let next_dist = squared_distance p next.value in
                if next_dist < acc.distance
                    then {mean: next, distance: next_dist}
                    else acc
            ) {mean: first_mean, distance: squared_distance p first_mean.value} in nearest.key
        }
        { None -> (-1) } // Error
)

trigger assign: collection { key: int, value: collection { key: int, value: real } @ { Collection } } @ { Collection } = \current_means -> (
        (aggregate, master) <-
            data.groupBy (\p -> nearest_neighbor p.elem current_means) (\sc -> \p -> { sum: vector_zip (\a -> \b -> a + b) sc.sum p.elem, count: sc.count + 1 }) { sum: empty { key: int, value: real } @ { Collection }, count: 0 }
)

trigger aggregate: collection { key: int, value: { sum: collection { key: int, value: real } @ { Collection }, count: int } } @ { Collection } = \_ -> ()

trigger maximize: () = \_ -> ()

trigger start: () = \_ ->
    let initial_means = (data.fold (\a -> \p -> if a.remaining == 0 then a else { remaining: a.remaining - 1, means: ((a.means.insert p.elem); a.means) })
                                   ({remaining: k, means: empty { key: int, value: collection { key: int, value: real } @ { Collection } } @ { Collection }})).means
    in peers.iterate (\p -> (assign, p.addr) <- initial_means)
