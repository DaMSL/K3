include "Annotation/Vector.k3"
include "Annotation/Map.k3"
include "Core/CppBuiltins.k3"

// Constants
declare k : int = 3
declare dimensionality : int = 3
declare master : address


declare iterations_remaining : mut int = 5

// Outstanding requests for partial aggregation
declare requests : mut int = 0

declare foo : collection {elem: real} @ {Vector}


// Collection of data points. Each point represented as a vector
declare data:
  collection {
    elem: collection {elem: real} @ {Vector}
  } @ {Collection}

// Collection of (k) means. Each mean has an integer key, and a value represented as a vector.
declare means :
  mut collection {
    key: int
  , value: collection {elem: real} @ {Vector}
  } @ {Collection}


declare aggregates :
  mut collection {
    key: int
  , value: {
      count: int
    , sum : collection {elem: real} @ {Vector}
    }
  } @ {Map}



trigger start : () = \_ -> (
  let ignore = data.fold
    (\a -> (\p -> (
      if a == 0
        then a
        else (
          (means.insert {key: a, value: p.elem});
          (a - 1)
        )
    )))
    k
  in peers.iterate \p -> (
    requests = requests + 1;
    (assign, p.addr) <- means
  )
)


// Function that returns the key of nearest mean (in the global variable means)
declare nearest_mean : collection {elem: real} @ {Vector} -> int = (\p ->
  case means.peek() of
    { Some first_mean ->
        let nearest = means.fold (\acc -> \curr_mean ->
          let dist = p.distance curr_mean.value
          in
            if dist < acc.distance
            then {mean: curr_mean, distance: dist}
            else acc
        ) {mean: first_mean, distance: p.distance first_mean.value}
        in
          nearest.mean.key
    }
    { None -> (-1) } // Error
)

trigger assign : collection { key: int, value: collection {elem: real} @ {Vector}} @ {Collection} = \new_means -> (
  means = new_means;
  let aggs = data.groupBy
    (\p -> nearest_mean p.elem)
    (\sc -> \p ->
      {count: sc.count + 1, sum: sc.sum.add p.elem}
    )
    {count: 0, sum: zeroVector dimensionality}
  in (aggregate, master) <- aggs
)


declare merge_results : collection {key: int, value: {count: int, sum: collection {elem: real} @ {Vector} }} @ {Collection} -> () = \peer_aggs -> (
  peer_aggs.iterate (\v ->
    case aggregates.lookup v of
     { Some a ->
         aggregates.insert
          { key: v.key,
            value: { count: v.value.count + a.value.count,
                     sum:   v.value.sum.add a.value.sum
                   }
          }
     }
     { None -> aggregates.insert v }
  )
)

trigger aggregate : collection {key: int, value: {count: int, sum: collection {elem: real} @ {Vector} }} @ {Collection} = \peer_aggs -> (
  merge_results peer_aggs;
  requests = requests -1;
  if requests == 0
    then (maximize, master) <- ()
    else ()
)

trigger maximize : () = \_ -> (
  means = empty {key: int, value: collection {elem: real} @ {Vector}} @ {Collection};
  aggregates.iterate (\x ->
    means.insert
      {  key: x.key
      ,  value: x.value.sum.map (\e -> (1.0 / x.value.count) * e.elem)  // scalar * vector
      }
  );
  iterations_remaining = iterations_remaining - 1;
  if iterations_remaining == 0
    then ()
    else (
      aggregates = empty {key:int, value: {count: int, sum: collection {elem: real} @ {Vector}}} @ {Map};
      peers.iterate \p -> (
        requests = requests + 1;
        (assign, p.addr) <- means
      )
    )
)

trigger shutdown : () = \_ -> haltEngine ()

trigger t : () = (\_ ->
 ()
)





source s1 : () = value ()
feed s1 |> t
