include "Annotation/Collection.k3"
include "Annotation/Map.k3"
include "Core/Loaders.k3"
include "Core/Barrier.k3"
include "Core/Builtins.k3"

typedef vertex = int
typedef page_rank = real

declare vertex_count: int = 1
declare iterations: mut int = 5
declare damping_factor: real = 0.5
declare master: address

declare table: collection { key: vertex, value: vertex } @ { Collection }
declare graph: mut collection { key: vertex, value: collection { elem: vertex } @ { Collection }} @ { Map }
declare state: mut collection { key: vertex, value: page_rank } @ { Map }
declare outgoing: mut collection { key: vertex, value: page_rank } @ { Map }
declare active: collection { key: vertex, value: bool } @ { Map }
declare batched: mut collection {
                       key: int,
                       value: collection {
                                key: vertex,
                                value: collection { elem: page_rank } @ { Collection }
                              } @ { Map }
                       } @ { Map }

declare data_file: string = ""

declare peer_by_vertex: vertex -> int = \v -> (v % peers.size ())

declare aggregate_and_send_by_peer: collection { key: vertex, value: page_rank } @ { Map } -> () = \c -> (
    batched = c.groupBy
                    (\r -> peer_by_vertex r.key)
                    (\a -> \r ->
                      let singleton = empty { elem: page_rank } @ { Collection }
                      in (
                           singleton.insert {elem: r.value};
                           a.insert_with
                             { key: r.key, value: singleton }
                             (\e -> \n -> (e.value.insert { elem: r.value }; e));
                           a
                      )
                    )
                    empty {
                      key: vertex,
                      value: collection { elem: page_rank } @ { Collection }
                    } @ { Map };

    (range (peers.size ())).iterate (\i ->
      case batched.lookup { key: i.i
                          , value: empty { key: vertex
                                         , value: collection { elem: page_rank } @ Collection
                                         } @ { Map }
                          } of
        { Some b -> case peers.at i.i of
                      { Some p -> (gather, p.addr) <- b.value }
                      { None ->  () } }
        { None -> case peers.at i.i of
                      { Some p -> ((gather, p.addr) <- empty { key: vertex
                                                             , value: collection { elem: page_rank } @ Collection
                                                             } @ { Map } ) }
                      { None -> () } }
    )
)

declare scatter: () -> () = \_ -> (
  outgoing = empty { key: vertex, value: page_rank } @ { Map };
  state.iterate (\s -> state.insert {
                               key: s.key,
                               value: (((1 - damping_factor)) + damping_factor * s.value)
                             }
  );
  state.iterate (\s ->
    let neighbours = graph.lookup { key: s.key, value: empty { elem: vertex } @ { Collection }}
    in case neighbours of
         { Some ns -> let out_degree = ns.value.size ()
                      in ns.value.iterate (\n -> outgoing.insert_with {
                           key: n.elem,
                           value: s.value / out_degree
                         } (\a -> \e -> { key: a.key, value: a.value + e.value }))
         }
         { None -> () }
  );
  iterations = iterations - 1;
  if iterations > 0
    then ( state.iterate (\s -> state.insert { key: s.key, value: 0.0 })
         ; aggregate_and_send_by_peer outgoing
         ) else (stop, me) <- ()
)

trigger gather: collection { key: vertex, value: collection { elem: page_rank } @ { Collection }} @ { Map } = \message_map -> (
  message_map.iterate (\r -> (
    let local_sum = r.value.fold (\a -> \x -> a + x.elem) 0.0
    in state.insert_with { key: r.key, value: local_sum } (\a -> \b -> { key: r.key, value: a.value + b.value})
  ));
  (scatter ()) @ { OnCounterReset(id=[# gather], eq=[$ peers.size ()]) }
)

trigger load_all: () = \_ -> (
  loadGraph data_file graph;
  graph.iterate (\r -> (state.insert { key: r.key, value: (1.0) }));
  (ready, master) <- ()
)

trigger go: () = \_ -> scatter ()

trigger ready: () = \_ -> (
  if master == me
  then ((peers.iterate (\p -> (go, p.addr) <- ())) @ { OnCounter(id=[# ready], eq=[$ peers.size ()]) }) else ()
)


trigger stop: () = \_ -> (
  state.iterate (\s -> (print (itos s.key); print (rtos s.value)));
  haltEngine ()
)

source s1: () = value ()
feed s1 |> load_all
