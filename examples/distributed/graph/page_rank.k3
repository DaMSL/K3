include "Annotation/Collection.k3"
include "Annotation/Map.k3"

typedef vertex = int
typedef page_rank = real

declare vertex_count: int = 1
declare iterations: int = 30
declare iterations_remaining: int = iterations

declare table: collection { key: vertex, value: vertex } @ { Map }
declare graph: mut collection { key: vertex, value: collection { elem: vertex } @ { Collection }} @ { Map }
declare state: mut collection { key: vertex, value: page_rank } @ { Map }
declare outgoing: mut collection { key: vertex, value: page_rank } @ { Map }

declare data_file: string = ""

declare peer_by_vertex: vertex -> int = \v -> (v % peers.size ())

declare aggregate_and_send_by_peer: collection { key: vertex, value: page_rank } @ { Map } -> () = \c -> (
    let grouped = c.groupBy
                    (\r -> peer_by_vertex r.key)
                    (\a -> \r ->
                      let singleton = empty { elem: page_rank } @ { Collection }
                      in (
                           singleton.insert {elem: r.value};
                           a.insert_with
                             { key: r.key, value: singleton }
                             (\e -> \n -> (e.value.insert { elem: r.value }; e));
                           a
                      )
                    )
                    empty {
                      key: vertex,
                      value: collection {elem: page_rank } @ { Collection }
                    } @ { Map }

    in grouped.iterate (\r -> let a = case peers.at r.key of
                                        { Some n -> n.addr }
                                        { None -> me }
                              in (gather, a) <- r.value)
)

trigger scatter: () = \_ -> (
  outgoing = empty { key: vertex, value: page_rank } @ { Map };
  state.iterate (\s ->
    let neighbours = graph.lookup { key: s.key, value: empty { elem: vertex } @ { Collection }}
    in case neighbours of
         { Some ns -> let out_degree = ns.value.size () in
                        ns.value.iterate (\n -> outgoing.insert {
                          key: n.elem,
                          value: ((0.15 / vertex_count) + 0.85 * s.value) / out_degree
                        })
         }
         { None -> () }
  );
  aggregate_and_send_by_peer outgoing
)

trigger gather: collection { key: vertex, value: collection { elem: page_rank } @ { Collection }} @ { Map } = \message_map -> (
  state = empty { key: vertex, value: real } @ { Map };
  message_map.iterate (\r ->
    let local_sum = r.value.fold (\a -> \x -> a + x.elem) 0
    in state.insert_with { key: r.key, value: local_sum } (\a -> \b -> { key: r.key, value: a.value + b.value})
  )
)

@:CArgs 2
declare graphLoader: string -> collection { key: vertex, value: vertex } @ { Map } -> ()

trigger load_all: () = \_ -> (
  graphLoader data_file table;
  graph = table.groupBy
                  (\r -> r.key)
                  (\a -> \e -> (a.insert { elem: e.value }; a))
                  empty { elem: vertex } @ { Collection }
)
