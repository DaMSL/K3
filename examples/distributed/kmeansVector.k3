include "Annotation/Map.k3"
include "Core/CppBuiltins.k3"
include "Core/SeqVector.k3"

// Contants
declare master: address = 127.0.0.1:40000
declare k: int = 1
declare dimensionality: int =  3
declare num_peers: mut int = 1

// Control
declare iterations_remaining: mut int = 10
declare requests: mut int = 0
declare start_ms: mut int
declare end_ms: mut int
declare elapsed_ms: mut int

// Data Loading
declare LoaderVector : string -> collection { elem: collection {elem: real} @ { Collection } } @ { Collection } -> ()

// Globals
declare means: mut collection {key:int, value: collection {elem: real} @ {Collection} } @ {Collection}
declare aggregates: mut collection { key: int, value: { count: int, sum: collection {elem: real} @ {Collection} } } @ { Map }
declare data: collection { elem: collection { elem: real} @ { Collection } } @ { Collection }

// Utils
declare merge_results: collection { key: int, value: { count: int , sum: collection {elem: real} @ { Collection }} } @ { Map }  -> () = \vals -> (
    vals.iterate (
        \v -> case lookup aggregates v.key of
            { Some a -> aggregates.insert { key: v.key, value:{count: (v.value.count + a.count), sum:(vector_add v.value.sum a.sum)} } }
            { None -> aggregates.insert v }
    )
)

// Print out the current means
declare print_results : () -> () =  \_ -> (
  means.iterate (\m -> (
    (end_ms = now());
    (elapsed_ms = end_ms - start_ms);
    (printLine "Mean: ");
    (m.value).iterate (\p -> printLine (rtos p.elem));
    (printLine (itos elapsed_ms))
    )
  )
)

// Given the current cluster means, and a point, determine the id of the cluster nearest to the point
declare nearest_neighbor: collection { elem: real } @ {Collection} -> collection { key: int, value: collection { elem: real} @ { Collection } } @ { Collection } -> int = \p -> \means -> (
    case means.peek () of
        { Some first_mean ->
            let nearest = means.fold (\acc -> \next ->
                if (squared_distance p next.value) < acc.distance
                    then {mean: next, distance: squared_distance p next.value}
                    else acc
            ) {mean: first_mean, distance: squared_distance p first_mean.value} in nearest.mean.key
        }
        { None -> (-1) } // Error
)

trigger assign: collection { key: int, value: collection {elem: real} @ {Collection} } @ { Collection } = \current_means -> (
        (aggregate, master) <-
            data.groupBy (\p -> nearest_neighbor p.elem current_means) (\sc -> \p -> { count: sc.count + 1 , sum: vector_add sc.sum p.elem}) {count: 0, sum: (zero_vector dimensionality)}
)

trigger aggregate: collection { key: int, value: { count: int , sum: collection {elem: real} @ { Collection }} } @ { Map } = \ags -> (
    (merge_results ags);
    (requests = requests - 1);
    (if requests == 0 then ((maximize,master) <- ()) else ())
)

trigger maximize: () = \_ -> (
  (means = empty { key: int, value: collection {elem: real} @ { Collection } } @ { Collection });
  (aggregates.iterate (\x -> means.insert {key: x.key, value: scalar_mult (1.0/(x.value.count)) (x.value.sum)}));
  (iterations_remaining = iterations_remaining - 1);
  (if iterations_remaining == 0
  then ((print_results ()); peers.iterate (\p -> (shutdown, p.addr) <- ()))
  else (aggregates = empty { key: int, value: { count: int, sum: collection {elem: real} @ { Collection } } } @ { Map }); peers.iterate (\p -> ((requests = requests + 1); (assign, p.addr) <- means)))
)

trigger ready : () = \_ -> (
  (num_peers = num_peers - 1);
  (if num_peers == 0
   then (start_ms = now (); (start, master) <- ())
   else ()
  )
)

trigger start: () = \_ -> (
  let foo = (data.fold
    (\a -> \p ->
      if a == 0
      then a
      else (
        (means.insert {key: a, value: p.elem});
        (a - 1)
      )
    )
    k
  ) in
  (peers.iterate (\p -> ((requests = requests + 1); (assign, p.addr) <- means)))
)

trigger shutdown : () = \_ -> haltEngine ()

trigger load_all : () = \_ -> (
  LoaderVector "/Users/joshwheeler/foo.vector" data;
  (ready, master) <- ()
)

source points : () = value ()
feed points |> load_all