/*
 * theta-join.k3
 *
 * Created by Kartik Thapar on 02/19/2014 at 12:21:03
 * Copyright (c) 2014 Kartik Thapar. All rights reserved.
 *
 */

include "Annotation/Collection.k3"
include "Core/Builtins.k3"

/* DATASETS */

declare sTable : collection {FirstName : string, Age : int, LastName : String} @ {Collection}
declare tTable : collection {Name : string, Age : int, LastName : string} @ {Collection}

declare sNumRows : mut int = 0
declare tNumRows : mut int = 0
declare totalRows : int = 12
declare rowCounter : mut int = 0

/* MAPPER */

declare sMappers : collection {Address : address, Id : int} @ {Collection} = {| Address : address, Id : int | {Address : 127.0.0.1:4001, Id : 1}, {Address : 127.0.0.1:4002, Id : 2}, {Address : 127.0.0.1:4003, Id : 3}, {Address : 127.0.0.1:4004, Id : 4} |} @ {Collection}
declare tMappers : collection {Address : address, Id : int} @ {Collection} = {| Address : address, Id : int | {Address : 127.0.0.1:5001, Id : 1}, {Address : 127.0.0.1:5002, Id : 2}, {Address : 127.0.0.1:5003, Id : 3}, {Address : 127.0.0.1:5004, Id : 4} |} @ {Collection}
declare debugSMappers : collection {Address : address, Id : int} @ {Collection} = {| Address : address, Id : int | {Address : 127.0.0.1:3000, Id : 1} |} @ {Collection}
declare debugTMappers : collection {Address : address, Id : int} @ {Collection} = {| Address : address, Id : int | {Address : 127.0.0.1:3000, Id : 1} |} @ {Collection}

declare sNumMappers : int = 1
declare tNumMappers : int = 1

declare currentMapperSize : mut int = 0
declare sCurrentMapperSize : mut int = 0
declare tCurrentMapperSize : mut int = 0

declare sMapperOutput : collection {RegionId : int, Output : collection {FirstName : string, Age : int, LastName : string} @ {Collection}} @ {Collection}
declare tMapperOutput : collection {RegionId : int, Output : collection {Name : string, Age : int, LastName : string} @ {Collection}} @ {Collection}

declare randomRow : mut int = 0
declare randomColumn : mut int = 0

/* REGIONS */

declare maxS : int = 2
declare maxT : int = 2
declare rowLookupTable : collection {Row : int, Regions : collection {RegionId : int} @ {Collection}} @ {Collection}
declare columnLookupTable : collection {Column : int, Regions : collection {RegionId : int} @ {Collection}} @ {Collection}

/* REDUCER */

declare reducers : collection {Address : address, Id : int} @ {Collection} = {| Address : address, Id : int | {Address : 127.0.0.1:6001, Id : 1}, {Address : 127.0.0.1:6002, Id : 2}, {Address : 127.0.0.1:6003, Id : 3}, {Address : 127.0.0.1:6004, Id : 4} |} @ {Collection}
declare debugReducers : collection {Address : address, Id : int} @ {Collection} = {| Address : address, Id : int | {Address : 127.0.0.1:4000, Id : 1} |} @ {Collection}

declare sTuples : mut collection {FirstName : string, Age : int, LastName : String} @ {Collection}
declare tTuples : mut collection {Name : string, Age : int, LastName : string} @ {Collection}

declare jobOutput : collection {sRow : {FirstName : string, Age : int, LastName : string}, tRow : {Name : string, Age : int, LastName : string}} @ {Collection}

/* PHASE 1: PRE-PROCESS 1 - Process Table Rows */

trigger preProcessTableRows : (collection {fromS : bool, sRow : option {FirstName : string, Age : int, LastName : string}, tRow : option {Name : string, Age : int, LastName : string}} @ {Collection}) = \tableElementCollection -> (
    tableElementCollection.iterate (\tableElement -> (
        rowCounter = rowCounter + 1;
        bind tableElement as {fromS : isItFromS, sRow : sRowElement, tRow : tRowElement} in
        if isItFromS then
            sNumRows = sNumRows + 1;
            case sRowElement of 
            {Some x -> sTable.insert {FirstName : x.FirstName, Age : x.Age, LastName : x.LastName}}
            {None -> ()}
        else
            tNumRows = tNumRows + 1;
            case tRowElement of
            {Some x -> tTable.insert {Name : x.Name, Age : x.Age, LastName : x.LastName}}
            {None -> ()}
    ));

    /* If all the rows have been processed, process regions. */
    if rowCounter == totalRows then (preProcessRegions, me) <- ()
    else ()
)

/* PHASE 1: PRE-PROCESS 2 - Process Regions*/

declare tmpRegions : mut collection {RegionId : int} @ {Collection}

declare getSRegionsWorker : immut (collection {RegionId : int} @ {Collection} -> int -> int -> collection {RegionId : int} @ {Collection}) = fun tmpRegionsX -> fun regionNumber -> fun count -> (
    /* 
     * tmpRegionsX is just the carrier collection for RegionIds; count refers to max number of regions in a row which are added to the regionNumber iteratively.
     * Until count > 0, keep inserting regionNumber + count as a RegionId 
     */
    if count > 0 then
        tmpRegionsX.insert {RegionId : regionNumber + count};
        (getSRegionsWorker tmpRegionsX regionNumber (count - 1))
    else
        tmpRegionsX
)

declare getSRegions : immut (collection {RegionId : int} @ {Collection} -> int -> collection {RegionId : int} @ {Collection}) = fun tmpRegionsX -> fun rowNumber -> (
    (getSRegionsWorker tmpRegionsX ((rowNumber - 1)/maxS * tNumRows/maxT) (tNumRows/maxT))
)

declare getTRegionsWorker : immut (collection {RegionId : int} @ {Collection} -> int -> int -> collection {RegionId : int} @ {Collection}) = fun tmpRegionsX -> fun regionNumber -> fun count -> (
    /* 
     * count is a multiplier to the max number of regions in a row;
     * At every point we check if the regionNumber + thisvalue is greater than total number of regions possible and add to region list if not.
     */
    if (regionNumber + count*(tNumRows/maxT)) <= (sNumRows/maxS * tNumRows/maxT) then
        tmpRegionsX.insert {RegionId : regionNumber + count*(tNumRows/maxT)};
        (getTRegionsWorker tmpRegionsX regionNumber (count + 1))
    else
        tmpRegionsX
)

declare getTRegions : immut (collection {RegionId : int} @ {Collection} -> int -> collection {RegionId : int} @ {Collection}) = fun tmpRegionsX -> fun columnNumber -> (
    (getTRegionsWorker tmpRegionsX ((columnNumber - 1)/maxT + 1) 0)
)

declare preProcessRegionsWorker : mut (int -> string -> ()) = fun numberOfRows -> fun tableName -> (
    /* 
     * Process every single row from the last row to the first row; numberOfRows is just the max row count; but essentially the row number.
     * Create an empty collection always (by searching for a RegionId that does not exist - hack for clearing a list).
     * Find regions and then update them for every row/column.
     */
    if numberOfRows > 0 then
        if tableName == "S" then
            tmpRegions = tmpRegions.filter (\region -> region.RegionId == -127);
            tmpRegions = (getSRegions tmpRegions numberOfRows);
            rowLookupTable.insert {Row : numberOfRows, Regions : tmpRegions};
            (preProcessRegionsWorker (numberOfRows - 1) "S")
        else
            tmpRegions = tmpRegions.filter (\region -> region.RegionId == -1);
            tmpRegions = (getTRegions tmpRegions numberOfRows);
            columnLookupTable.insert {Column : numberOfRows, Regions : tmpRegions};
            (preProcessRegionsWorker (numberOfRows - 1) "T")
    else ()
)

trigger preProcessRegions : () = \_ -> (
    (preProcessRegionsWorker sNumRows "S");
    (preProcessRegionsWorker tNumRows "T");
    (arrangeMap, me) <- ()
)

/* PHASE 2: MAP */

declare getRandom : immut (string -> int) = fun tableName -> (
    if tableName == "S" then (random (sNumRows - 1) + 1)
    else (random (tNumRows - 1) + 1)
)

declare getMapperSize : immut (int -> string -> int) = fun mapperId -> fun tableName -> (
    /*
     * If r == 0 => equal division
     * If mapperId <= r => some r mappers will get the extra 1 row
     * If mapperId > r => will not get extra 1 row
     */
    if tableName == "S" then
        let r = sNumRows % sNumMappers in
            let q = sNumRows / sNumMappers in
                if r == 0 then q else if mapperId <= r then q + 1 else q
    else
        let r = tNumRows % tNumMappers in
            let q = tNumRows / tNumMappers in
                if r == 0 then q else if mapperId <= r then q + 1 else q
)

/* Send rows from both the tables to the mappers using the sendRowToMapper_s/sendRowToMapper_t triggers */
trigger arrangeMap : () = \_ -> (
    sTable.fold (\mapperCounter -> \row -> (
        (sendRowToMapper_s, me) <- (row, (mapperCounter % sNumMappers) + 1);
        mapperCounter + 1
    )) 0;

    tTable.fold (\mapperCounter -> \row -> (
        (sendRowToMapper_t, me) <- (row, (mapperCounter % tNumMappers) + 1);
        mapperCounter + 1
    )) 0
)

/* Send row to mapper */

trigger sendRowToMapper_s : ({FirstName : string, Age : int, LastName : string}, int) = \x -> (
    bind x as (sRow, mapperId) in (
        let mapperSize = (getMapperSize mapperId "S") in
            let fMappers = debugSMappers.filter (\mapper -> (mapper.Id == mapperId)) in
                let mapperInstance = fMappers.peek() in
                    case mapperInstance of 
                    {Some mapper -> (map_s, mapper.Address) <- (sRow, mapperSize)}
                    {None -> ()}
    )
)

trigger sendRowToMapper_t : ({Name : string, Age : int, LastName : string}, int) = \x -> (
    bind x as (tRow, mapperId) in (
        let mapperSize = (getMapperSize mapperId "T") in
            let fMappers = debugTMappers.filter (\mapper -> (mapper.Id == mapperId)) in
                let mapperInstance = fMappers.peek() in
                    case mapperInstance of
                    {Some mapper -> (map_t, mapper.Address) <- (tRow, mapperSize)}
                    {None -> ()}
    )
)

declare tmpMapperOutputCollection : mut collection {FirstName : string, Age : int, LastName : string} @ {Collection}

trigger map_s : ({FirstName : string, Age : int, LastName : string}, int) = \x -> (
    bind x as (sRow, mapperSize) in (
        sCurrentMapperSize = sCurrentMapperSize + 1;
        randomRow = (getRandom "S");

        /*
         * Find the specific row in the lookup table.
         * Lookuo all the regions associated to that row.
         * Find the mapper output associated with that region using the RegionId field.
         * Create a new output if output is None; otherwise, insert the row in the existing output and update collection.
         */
        let optLookupRow = (rowLookupTable.filter (\lookupRow -> lookupRow.Row == randomRow)).peek() in
            case optLookupRow of
            {Some lookupRow -> (
                lookupRow.Regions.iterate (\region -> (
                    let optOldOutput = (sMapperOutput.filter (\output -> output.RegionId == region.RegionId)).peek() in
                        case optOldOutput of
                        {Some oldOutput -> (
                            let newOutput = oldOutput.Output in
                                newOutput.insert {FirstName : sRow.FirstName, Age : sRow.Age, LastName : sRow.LastName};
                                sMapperOutput.update {RegionId : region.RegionId, Output : oldOutput.Output} {RegionId : region.RegionId, Output : newOutput}
                        )}
                        {None -> (
                            tmpMapperOutputCollection = tmpMapperOutputCollection.filter (\outputCollection -> outputCollection.Age == -1);
                            tmpMapperOutputCollection.insert {FirstName : sRow.FirstName, Age : sRow.Age, LastName : sRow.LastName};
                            sMapperOutput.insert {RegionId : region.RegionId, Output : tmpMapperOutputCollection}
                        )}
                ))
            )}
            {None -> ()};
        if sCurrentMapperSize == mapperSize then (sendAllToReducer, me) <- ()
        else ()
    )
)

trigger map_t : ({Name : string, Age : int, LastName : string}, int) = \x -> (
    bind x as (tRow, mapperSize) in (
        tCurrentMapperSize = tCurrentMapperSize + 1;
        randomColumn = (getRandom "T");

        /*
         * Find the specific column in the lookup table.
         * Lookuo all the regions associated to that column.
         * Find the mapper output associated with that region using the RegionId field.
         * Create a new output if output is None; otherwise, insert the column(row) in the existing output and update collection.
         */
        let optLookupColumn = (columnLookupTable.filter (\lookupColumn -> lookupColumn.Column == randomColumn)).peek() in
            case optLookupColumn of
            {Some lookupColumn -> (
                lookupColumn.Regions.iterate (\region -> (
                    let optOldOutput = (tMapperOutput.filter (\output -> output.RegionId == region.RegionId)).peek() in
                        case optOldOutput of
                        {Some oldOutput -> (
                            let newOutput = oldOutput.Output in
                                newOutput.insert {Name : tRow.Name, Age : tRow.Age, LastName : tRow.LastName};
                                tMapperOutput.update {RegionId : region.RegionId, Output : oldOutput.Output} {RegionId : region.RegionId, Output : newOutput}
                        )}
                        {None -> (
                            tmpMapperOutputCollection = tmpMapperOutputCollection.filter (\outputCollection -> outputCollection.Age == -1);
                            tmpMapperOutputCollection.insert {Name : tRow.Name, Age : tRow.Age, LastName : tRow.LastName};
                            tMapperOutput.insert {RegionId : region.RegionId, Output : tmpMapperOutputCollection}
                        )}
                ))
            )}
            {None -> ()};
        if tCurrentMapperSize == mapperSize then (sendAllToReducer, me) <- ()
        else ()
    )
)

/* REDUCER */

trigger sendAllToReducer : () = \_ -> (
    /* 
     * For every output in the mapper outputs, send them to the appropriate reducer.
     * Currently only relying on a single machine; but the next step would be to filter a reducer responsible for a particular.
     * RegionId.
    */
    sMapperOutput.iterate (\mapperOutput -> (
        (reduce_s, me) <- (mapperOutput.Output)
    ));

    tMapperOutput.iterate (\mapperOutput -> (
        (reduce_t, me) <- (mapperOutput.Output)
    ))
)

trigger reduce_s : (collection {FirstName : string, Age : int, LastName : string} @ {Collection}) = \coll -> (
    /* These collections are reducer dependent */
    sTuples = coll;

    /* If tTuples exist, then you have both tTuples and sTuples => reduce */
    let tmpTTuples = tTuples.peek() in
        case tmpTTuples of
        {Some x -> (reduceDoJoin, me) <- ()}
        {None -> ()}
)

trigger reduce_t : (collection {Name : string, Age : int, LastName : string} @ {Collection}) = \coll -> (
    /* These collections are reducer dependent */
    tTuples = coll;

    /* If sTuples exist, then you have both tTuples and sTuples => reduce */
    let tmpSTuples = tTuples.peek() in
        case tmpSTuples of
        {Some x -> (reduceDoJoin, me) <- ()}
        {None -> ()}
)

trigger reduceDoJoin : () = \_ -> (
    sTuples.iterate (\sRow -> (
        tTuples.iterate (\tRow -> (
            if sRow.LastName == tRow.LastName then jobOutput.insert {sRow : sRow, tRow : tRow}
            else ()
        ))
    ))
)

source master : (collection {fromS : bool, sRow : option {FirstName : string, Age : int, LastName : string}, tRow : option {Name : string, Age : int, LastName : string}} @ {Collection}) = file "/Users/kartikthapar/WorkCenter/Projects/K3/core/examples/distributed/MapReduce/ThetaJoin/tables.text" k3

feed master |> preProcessTableRows
