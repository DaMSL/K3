/*
 * theta-join.k3
 *
 * Created by Kartik Thapar on 02/19/2014 at 12:21:03
 * Copyright (c) 2014 Kartik Thapar. All rights reserved.
 *
 */

include "Annotation/Collection.k3"
include "Core/Builtins.k3"

/* DATASETS */

declare sTable : collection {FirstName : string, Age : int, LastName : String} @ {Collection}
declare tTable : collection {Name : string, Age : int, LastName : string} @ {Collection}

declare sNumRows : mut int = 0
declare tNumRows : mut int = 0
declare totalRows : int = 2
declare rowCounter : mut int = 0

/* MAPPER */

declare sMappers : collection {Address : address, Id : int} @ {Collection} = {| Address : address, Id : int | {Address : 127.0.0.1:4001, Id : 1}, {Address : 127.0.0.1:4002, Id : 2}, {Address : 127.0.0.1:4003, Id : 3}, {Address : 127.0.0.1:4004, Id : 4} |} @ {Collection}
declare tMappers : collection {Address : address, Id : int} @ {Collection} = {| Address : address, Id : int | {Address : 127.0.0.1:5001, Id : 1}, {Address : 127.0.0.1:5002, Id : 2}, {Address : 127.0.0.1:5003, Id : 3}, {Address : 127.0.0.1:5004, Id : 4} |} @ {Collection}
declare sNumMappers : int = 4
declare tNumMappers : int = 4

declare currentMapperSize : mut int = 0
declare sMapperOutput : collection {RegionId : int, Output : collection {FirstName : string, Age : int, LastName : String} @ {Collection}} @ {Collection}
declare tMapperOutput : collection {RegionId : int, Output : collection {Name : string, Age : int, LastName : string} @ {Collection}} @ {Collection}

/* REGIONS */

declare regionMaxRow : int = 10
declare regionMaxColumn : int = 10
declare rowLookupTable : collection {Row : int, Regions : collection {RegionId : int} @ {Collection}} @ {Collection}
declare columnLookupTable : collection {Column : int, Regions : collection {RegionId : int} @ {Collection}} @ {Collection}

/* REDUCER */

declare reducers : collection {Address : address, Id : int} @ {Collection} = {| Address : address, Id : int | {Address : 127.0.0.1:6001, Id : 1}, {Address : 127.0.0.1:6002, Id : 2}, {Address : 127.0.0.1:6003, Id : 3}, {Address : 127.0.0.1:6004, Id : 4} |} @ {Collection}
declare sTuples : option mut collection {FirstName : string, Age : int, LastName : String} @ {Collection} = None
declare tTuples : option mut collection {Name : string, Age : int, LastName : string} @ {Collection} = None

/* PHASE 1: PRE-PROCESS 1 - Process Table Rows */

trigger preProcessTableRows : (collection {fromS : bool, sRow : option {FirstName : string, Age : int, LastName : String}, tRow : option {Name : string, Age : int, LastName : string}} @ {Collection}) = \tableElementCollection -> (
    tableElementCollection.iterate (\tableElement -> (
        rowCounter = rowCounter + 1;
        bind tableElement as {fromS : isItFromS, sRow : sRowElement, tRow : tRowElement} in
        if isItFromS then
            sNumRows = sNumRows + 1;
            case sRowElement of 
            {Some x -> sTable.insert {FirstName : x.FirstName, Age : x.Age, LastName : x.LastName}}
            {None -> ()}
        else
            tNumRows = tNumRows + 1;
            case tRowElement of
            {Some x -> tTable.insert {Name : x.Name, Age : x.Age, LastName : x.LastName}}
            {None -> ()}
    ));

    /* If all the rows have been processed, process regions. */
    if rowCounter == totalRows then (preProcessRegions, me) <- ()
    else ()
)

/* PHASE 1: PRE-PROCESS 2 - Process Regions*/

declare tmpRegions : mut collection {RegionId : int} @ {Collection}

declare getSRegionsWorker : immut (collection {RegionId : int} @ {Collection} -> int -> int -> collection {RegionId : int} @ {Collection}) = fun tmpRegionsX -> fun regionNumber -> fun count -> (
    /* 
     * tmpRegionsX is just the carrier collection for RegionIds; count refers to max number of regions in a row which are added to the regionNumber iteratively.
     * Until count > 0, keep inserting regionNumber + count as a RegionId 
     */
    if count > 0 then
        tmpRegionsX.insert {RegionId : regionNumber + count};
        (getSRegionsWorker tmpRegionsX regionNumber (count - 1))
    else
        tmpRegionsX
)

declare getSRegions : immut (collection {RegionId : int} @ {Collection} -> int -> collection {RegionId : int} @ {Collection}) = fun tmpRegionsX -> fun rowNumber -> (
    (getSRegionsWorker tmpRegionsX ((rowNumber - 1)/maxS * tNumRows/maxT) (tNumRows/maxT))
)

declare getTRegionsWorker : immut (collection {RegionId : int} @ {Collection} -> int -> int -> collection {RegionId : int} @ {Collection}) = fun tmpRegionsX -> fun regionNumber -> fun count -> (
    /* 
     * count is a multiplier to the max number of regions in a row;
     * At every point we check if the regionNumber + thisvalue is greater than total number of regions possible and add to region list if not.
     */
    if (regionNumber + count*(tNumRows/maxT)) <= (sNumRows/maxS * tNumRows/maxT) then
        tmpRegionsX.insert {RegionId : regionNumber + count*(tNumRows/maxT)};
        (getTRegionsWorker tmpRegionsX regionNumber (count + 1))
    else
        tmpRegionsX
)

declare getTRegions : immut (collection {RegionId : int} @ {Collection} -> int -> collection {RegionId : int} @ {Collection}) = fun tmpRegionsX -> fun columnNumber -> (
    (getTRegionsWorker tmpRegionsX ((columnNumber - 1)/maxT + 1) 0)
)

declare preProcessRegionsWorker : mut (int -> string -> ()) = fun numberOfRows -> fun tableName -> (
    /* 
     * Process every single row from the last row to the first row; numberOfRows is just the max row count; but essentially the row number.
     * Create an empty collection always (by searching for a RegionId that does not exist - hack for clearing a list).
     * Find regions and then update them for every row/column.
     */
    if numberOfRows > 0 then
        if tableName == "S" then
            tmpRegions = tmpRegions.filter (\region -> region.RegionId == -1);
            tmpRegions = (getSRegions tmpRegions numberOfRows);
            rowLookupTable.insert {Row : numberOfRows, Regions : tmpRegions};
            (preProcessRegionsWorker (numberOfRows - 1) "S")
        else
            tmpRegions = tmpRegions.filter (\region -> region.RegionId == -1);
            tmpRegions = (getTRegions tmpRegions numberOfRows);
            columnLookupTable.insert {Column : numberOfRows, Regions : tmpRegions};
            (preProcessRegionsWorker (numberOfRows - 1) "T")
    else ()
)

trigger preProcessRegions : () = \_ -> (
    (processRegions sNumRows "S");
    (processRegions tNumRows "T")
)

/* PHASE 2: MAP */

declare getMapperSize : immut (int -> string -> int) = fun mapperId -> fun tableName -> (
    /*
     * If r == 0 => equal division
     * If mapperId <= r => some r mappers will get the extra 1 row
     * If mapperId > r => will not get extra 1 row
     */
    if tableName == "S" then
        let r = sNumRows % sNumMappers in
            let q = sNumRows / sNumMappers in
                if r == 0 then q else if mapperId <= r then q + 1 else q
    else
        let r = tNumRows % tNumMappers in
            let q = tNumRows / tNumMappers in
                if r == 0 then q else if mapperId <= r then q + 1 else q
)

declare getRandom : immut (string -> int) = fun tableName -> (
    if tableName == "S" then random sNumRows
    else random tNumRows
)

declare getLookupQuotient : immut (int -> string -> int) = fun random -> fun tableName -> (
    if tableName == "S" then
        if random % regionMaxRow == 0 then random/regionMaxRow
        else random/regionMaxRow + 1
    else
        if random % regionMaxColumn == 0 then random/regionMaxColumn
        else random/regionMaxColumn + 1
)

/* Send rows from both the tables to the mappers using the sendRowToMapper_s/sendRowToMapper_t triggers */
trigger arrangeMap : () = \_ -> (
    sTable.fold (\mapperCounter -> \row -> (
        (sendRowToMapper_s, me) <- (row, (mapperCounter % sNumMappers) + 1);
        mapperCounter + 1
    )) 0;

    tTable.fold (\mapperCounter -> \row -> (
        (sendRowToMapper_t, me) <- (row, (mapperCounter % tNumMappers) + 1);
        mapperCounter + 1
    )) 0
)

/* Send row to mapper */
trigger sendRowToMapper_s : ({FirstName : string, Age : int, LastName : string}, int) = \x -> (
    bind x as (sRow, mapperId) in (
        let mapperSize = (getMapperSize mapperId "S") in
            let fMappers = sMappers.filter (\mapper -> (mapper.Id == mapperId)) in
                let mapperInstance = fMappers.peek() in
                    case mapperInstance of 
                    {Some mapper -> (map_s, mapper.Address) <- (sRow, mapperSize)}
                    {None -> ()}
    )
)

trigger sendRowToMapper_t : ({Name : string, Age : int, LastName : string}, int) = \x -> (
    bind x as (tRow, mapperId) in (
        let mapperSize = (getMapperSize mapperId "T") in
            let fMappers = tMappers.filter (\mapper -> (mapper.Id == mapperId)) in
                let mapperInstance = fMappers.peek() in
                    case mapperInstance of
                    {Some mapper -> (map_t, mapper.Address) <- (tRow, mapperSize)}
                    {None -> ()}
    )
)

trigger map_s : ({FirstName : string, Age : int, LastName : string}, int) = \x -> (
    bind x as (sRow, mapperSize) in (
        currentMapperSize = currentMapperSize + 1;
        randomRow = (getRandom "S");

        /* Lookup in the row lookup table for the random row and find all regions. */
        let optLookupRow = (rowLookupTable.filter (\lookupRow -> lookupRow.row == (getLookupQuotient randomRow "S"))).peek() in
            case optLookupRow of
            {Some lookupRow -> (
                lookupRow.regions.iterate (\region -> (
                    let optOldOutput = (sMapperOutput.filter (\output -> output.RegionId == region.RegionId)).peek() in
                        case optOldOutput of
                        {Some oldOutput -> (
                            let newOutput = oldOutput in
                                newOutput.output.insert {FirstName : sRow.FirstName, Age : sRow.Age, LastName : sRow.LastName};
                                sMapperOutput.update {RegionId : region.RegionId, Output : oldOutput.Output} {RegionId : region.RegionId, Output : newOutput.Output}
                        )}
                        {None -> ()}
                ))
            )}
            {None -> ()};

        /* If mapper is full, then send everything to the reducer */
        if currentMapperSize == mapperSize then (sendAllToReducer, me) <- ()
        else ()
    )
)

trigger map_t : ({Name : string, Age : int, LastName : string}, int) = \x -> (
    bind x as (tRow, mapperSize) in (
        currentMapperSize = currentMapperSize + 1;
        randomColumn = (getRandom "T");

        /* Lookup in the column lookup table for the random column and find all regions. */
        let optLookupColumn = (columnLookupTable.filter (\lookupColumn -> lookupColumn.Column == (getLookupQuotient randomColumn "T"))).peek() in
            case optLookupColumn of
            {Some lookupColumn -> (
                lookupColumn.regions.iterate (\region -> (
                    let optOldOutput = (tMapperOutput.filter (\output -> output.RegionId == region.RegionId)).peek() in
                        case optOldOutput of
                        {Some oldOutput -> (
                            let newOutput = oldOutput in
                                newOutput.output.insert {Name : tRow.Name, Age : tRow.Age, LastName : tRow.LastName};
                                tMapperOutput.update {RegionId : region.regionId, Output : oldOutput.Output} {RegionId : region.RegionId, Output : newOutput.Output}
                        )}
                        {None -> ()}
                ))
            )}
            {None -> ()};

        /* If mapper is full, then send everything to the reducer */
        if currentMapperSize == mapperSize then (sendAllToReducer, me) <- ()
        else ()
    )
)

/* Send output collected at all mappers to the reducers */
trigger sendAllToReducer : () = \_ -> (
    /* Find reducer with the same regionId as that of the mapper output. */
    sMapperOutput.iterate (\mapperOutput -> (
        let reducerInstance = reducers.filter (\reducer -> reducer.Id == mapperOutput.regionId).peek in
            (reduce_s, reducerInstance.Address) <- (mapperOutput.output)
    ));
    tMapperOutput.iterate (\mapperOutput -> (
        let reducerInstance = reducers.filter (\reducer -> reducer.Id == mapperOutput.regionId).peek in
            (reduce_t, reducerInstance.Address) <- (mapperOutput.output)
    ))
)

/* 
 * PHASE 3: REDUCER
 * We have already divided the tuples into two different sets. So there is no need to do that in the reducer.
 * In the reducer, we check if the two sets are valid (not None/Null) and implement the join algorithm.
 */

trigger reduce_s : (immut collection {FirstName : string, Age : int, LastName : string} @ {Collection}) = \coll -> (
    sTuples = coll;
    if tTuples == None then () else (reduceDoJoin, me) <- ()
)

trigger reduce_t : (immut collection {Name : string, Age : int, LastName : string} @ {Collection}) = \coll -> (
    tTuples = coll;
    if sTuples == None then () else (reduceDoJoin, me) <- ()
)

/* Implement custom join algorithm here */
trigger reduceDoJoin : () = \_ -> (
    sTuples.iterate (\sRow -> (
        tTuples.iterate (\tRow -> (
            if sRow.attribute == tRow.attribute then output (sRow, tRow) else ()
        ))
    ))
)

source master : (collection {fromS : bool, sRow : option {FirstName : string, Age : int, LastName : String}, tRow : option {Name : string, Age : int, LastName : string}}) = file "/Users/kartikthapar/WorkCenter/Projects/K3/core/examples/distributed/MapReduce/ThetaJoin/tables.text" k3
feed master |> preProcessTableRows
