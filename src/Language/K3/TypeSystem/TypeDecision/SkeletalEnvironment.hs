{-# LANGUAGE ScopedTypeVariables, TypeSynonymInstances, FlexibleInstances, TemplateHaskell #-}
{-|
  A module containing the routines necessary to construct a skeletal environment
  for the type decision prodecure.
-}
module Language.K3.TypeSystem.TypeDecision.SkeletalEnvironment
( TSkelAliasEnv
, TypeDecideSkelM
, StubInfo(..)
, constructSkeletalAEnv
) where

import Control.Applicative
import Control.Arrow
import Control.Monad.Trans
import Control.Monad.Trans.Writer
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Monoid
import qualified Data.Traversable as Trav

import Language.K3.Core.Annotation
import Language.K3.Core.Declaration
import Language.K3.Core.Type
import Language.K3.Logger
import Language.K3.Pretty
import qualified Language.K3.TypeSystem.ConstraintSetLike as CSL
import Language.K3.TypeSystem.Annotations
import Language.K3.TypeSystem.Data
import Language.K3.TypeSystem.Error
import Language.K3.TypeSystem.Monad.Iface.FreshVar
import Language.K3.TypeSystem.Monad.Iface.TypeError
import Language.K3.TypeSystem.TypeDecision.AnnotationInlining
import Language.K3.TypeSystem.TypeDecision.Data
import Language.K3.TypeSystem.TypeDecision.Monad
import Language.K3.TypeSystem.Utils
import Language.K3.TypeSystem.Utils.K3Tree

$(loggingFunctions)

-- |A type alias for skeletal type alias environments.
type TSkelAliasEnv = TEnv (TypeAliasEntry StubbedConstraintSet)

-- |A type alias for the skeletal construction monad.  The writer output maps
--  each used stub to the information associated with it.
type TypeDecideSkelM = WriterT (Map Stub StubInfo) TypeDecideM

-- |A data type for tracking the information suspended by a stub.
data StubInfo
  = StubInfo
    { stubTypeExpr :: K3 Type
        -- ^ The type expression deferred by this stub.
    , stubVar :: QVar
        -- ^ The type variable to be bounded by the type expression.
    , stubParamEnv :: TParamEnv
        -- ^ The type parameter environment for the annotation in this stub.
    }
  deriving (Show)

instance TypeErrorI TypeDecideSkelM where
  typeError = lift . typeError

-- |A function which constructs a skeletal type environment for the type
--  decision procedure.
constructSkeletalAEnv :: FlatAnnotationDecls -> TypeDecideSkelM TSkelAliasEnv
constructSkeletalAEnv anns = do
  -- First, get a structure for each declaration
  base <- Trav.mapM constructTypeForDecl anns
  _debug $ boxToString $
    ["Base skeletal environment: "] %+ indent 2 (
        vconcats $ map (\(k,(b,p,scs)) -> [k] %+ [" → "] %+
                          prettyLines (AnnType p b scs)) $
                      Map.toList base
      )
  -- Next, join all of the constraint sets together (because each annotation can
  -- refer to the others) and make an environment from it.
  let scs = CSL.unions $ map ((\(_,_,scs') -> scs') . snd) $ Map.toList base
  let aEnv = Map.fromList $
              map (\(i,(b,p,_)) ->
                  (TEnvIdentifier i, AnnAlias $ AnnType p b scs)) $
                Map.toList base
  _debug $ boxToString $
    ["Skeletal environment: "] %+ indent 2 (
        vconcats $ map (\(k,v) -> prettyLines k %+ [" → "] %+ prettyLines v) $
                      Map.toList aEnv
      )
  return aEnv

-- |Constructs a skeletal type environment for a single declaration.
constructTypeForDecl :: (FlatAnnotation, K3 Declaration)
                             -> TypeDecideSkelM
                                  (AnnBodyType, TParamEnv, StubbedConstraintSet)
constructTypeForDecl ((lAtts,sAtts),decl) = do
  u <- uidOf decl
  -- Prepare an appropriate environment
  a_c <- lift $ freshUVar $ TVarSourceOrigin u
  a_f <- lift $ freshUVar $ TVarSourceOrigin u
  a_s <- lift $ freshUVar $ TVarSourceOrigin u
  a_h <- lift $ freshUVar $ TVarSourceOrigin u
  let p = Map.fromList [ (TEnvIdContent, a_c)
                       , (TEnvIdFinal, a_f)
                       , (TEnvIdSelf, a_s) ]
  
  -- Calculate the horizon part of the schema and the constraints generated by
  -- it.  Note that we do not constraint a_Hp to be a subtype of a_C; the
  -- horizon will be the GLB of those two types.
  (sAttTs, scs_h) <- second mconcat <$> unzip <$>
                      gatherParallelSkelErrors (map (memDeclToMemType p) sAtts)
  (a_h', cs_h) <- liftEither (AnnotationDepolarizationFailure u) $
                    depolarize sAttTs
                    
  -- Calculate the type of self and the corresponding constraints
  (lAttTs, scs_s) <- second mconcat <$> unzip <$>
                      gatherParallelSkelErrors (map (memDeclToMemType p) lAtts)
  (a_s', cs_s) <- liftEither (AnnotationDepolarizationFailure u) $
                    depolarize lAttTs

  -- NOTE: The typechecker is required by specification to ensure that a set
  -- of constraints exists in the annotation.  It is considerably more efficient
  -- for this code to ensure that they are generated than it is to check for
  -- them (because the checker would need to perform a general pattern match),
  -- so we just satisfy those constraints here.
  let cs = csFromList [a_f <: a_h, a_h <: a_c, a_h <: a_h', a_s <: a_s']

  -- Construct an appropriate stubbed constraint set
  let scs = CSL.unions [scs_h, scs_s, CSL.promote $ csUnions [cs, cs_h, cs_s]]
  
  -- We now have a result for a single annotation
  return (AnnBodyType sAttTs lAttTs,p,scs)
  where
    liftEither :: (a -> TypeError) -> Either a b -> TypeDecideSkelM b
    liftEither f = either (typeError . f) return
    memDeclToMemType :: TParamEnv -> AnnMemDecl
                     -> TypeDecideSkelM (AnnMemType, StubbedConstraintSet)
    memDeclToMemType p decl' = case decl' of
      Lifted pol i' tExpr _ s -> genMemType pol i' tExpr s
      Attribute pol i' tExpr _ s -> genMemType pol i' tExpr s
      MAnnotation{} ->
        -- These should've been inlined and forgotten!
        error $ "Member annotation declaration found during skeletal " ++
                "environment construction!"
      where
        genMemType pol i' tExpr s = do
          qa <- lift $ freshQVar $ TVarSourceOrigin s
          stub <- lift nextStub
          let scs = CSL.singleton $ CLeft stub
          tell $ Map.singleton stub StubInfo
                    { stubTypeExpr = tExpr, stubVar = qa, stubParamEnv = p }
          return (AnnMemType i' (typeOfPol pol) qa, scs)

-- |Performs error gathering for @TypeDecideSkelM@.
gatherParallelSkelErrors :: forall a. [TypeDecideSkelM a] -> TypeDecideSkelM [a]
gatherParallelSkelErrors xs =
  WriterT $
    second mconcat <$> unzip <$> gatherParallelErrors (map runWriterT xs)
