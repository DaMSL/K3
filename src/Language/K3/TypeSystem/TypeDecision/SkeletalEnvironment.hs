{-# LANGUAGE ScopedTypeVariables, TypeSynonymInstances, FlexibleInstances #-}
{-|
  A module containing the routines necessary to construct a skeletal environment
  for the type decision prodecure.
-}
module Language.K3.TypeSystem.TypeDecision.SkeletalEnvironment
( TSkelAliasEnv
, TypeDecideSkelM
, StubInfo(..)
, constructSkeletalAEnv
) where

import Control.Applicative
import Control.Arrow
import Control.Monad.Trans
import Control.Monad.Trans.Writer
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Monoid
import qualified Data.Traversable as Trav

import Language.K3.Core.Annotation
import Language.K3.Core.Declaration
import Language.K3.Core.Type
import qualified Language.K3.TypeSystem.ConstraintSetLike as CSL
import Language.K3.TypeSystem.Annotations
import Language.K3.TypeSystem.Data
import Language.K3.TypeSystem.Error
import Language.K3.TypeSystem.Monad.Iface.FreshVar
import Language.K3.TypeSystem.Monad.Iface.TypeError
import Language.K3.TypeSystem.TypeDecision.AnnotationInlining
import Language.K3.TypeSystem.TypeDecision.Data
import Language.K3.TypeSystem.TypeDecision.Monad
import Language.K3.TypeSystem.Utils
import Language.K3.TypeSystem.Utils.K3Tree

-- |A type alias for skeletal type alias environments.
type TSkelAliasEnv = TEnv (TypeAliasEntry StubbedConstraintSet)

-- |A type alias for the skeletal construction monad.  The writer output maps
--  each used stub to the information associated with it.
type TypeDecideSkelM = WriterT (Map Stub StubInfo) TypeDecideM

-- |A data type for tracking the information suspended by a stub.
data StubInfo
  = StubInfo
    { stubTypeExpr :: K3 Type
        -- ^ The type expression deferred by this stub.
    , stubVar :: QVar
        -- ^ The type variable to be bounded by the type expression.
    , stubParamEnv :: TParamEnv
        -- ^ The type parameter environment for the annotation in this stub.
    }
  deriving (Show)

instance TypeErrorI TypeDecideSkelM where
  typeError = lift . typeError

-- |A function which constructs a skeletal type environment for the type
--  decision procedure.
constructSkeletalAEnv :: FlatAnnotationDecls -> TypeDecideSkelM TSkelAliasEnv
constructSkeletalAEnv anns = do
  -- First, get a structure for each declaration
  base <- Trav.mapM constructTypeForDecl anns
  -- Next, join all of the constraint sets together (because each annotation can
  -- refer to the others) and make an environment from it.
  let scs = CSL.unions $ map ((\(_,_,scs') -> scs') . snd) $ Map.toList base
  return $ Map.fromList $
            map (\(i,(b,p,_)) ->
                (TEnvIdentifier i, AnnAlias $ AnnType p b scs)) $
              Map.toList base

-- |Constructs a skeletal type environment for a single declaration.
constructTypeForDecl :: (FlatAnnotation, K3 Declaration)
                             -> TypeDecideSkelM
                                  (AnnBodyType, TParamEnv, StubbedConstraintSet)
constructTypeForDecl ((lAtts,sAtts),decl) = do
  u <- uidOf decl
  -- Prepare an appropriate environment
  aP_c <- lift $ freshUVar $ TVarSourceOrigin u
  aP_f <- lift $ freshUVar $ TVarSourceOrigin u
  aP_s <- lift $ freshUVar $ TVarSourceOrigin u
  let p = Map.fromList [ (TEnvIdContent, aP_c)
                       , (TEnvIdFinal, aP_f)
                       , (TEnvIdSelf, aP_s) ]
  -- Calculate the horizon schema t_H and the constraints generated by it
  (sAttTs, scs_H) <- second mconcat <$> unzip <$>
                      gatherParallelSkelErrors (map (memDeclToMemType p) sAtts)
  (a_H, cs_H) <- liftEither (AnnotationDepolarizationFailure u) $
                    depolarize sAttTs
  -- Calculate the type of self and the corresponding constraints
  (lAttTs, scs_S) <- second mconcat <$> unzip <$>
                      gatherParallelSkelErrors (map (memDeclToMemType p) lAtts)
  let b = AnnBodyType lAttTs sAttTs
  let annType = AnnType p b csEmpty
  inst <- lift $ instantiateCollection annType aP_c
  (a_S,cs_S) <- liftEither (InvalidCollectionInstantiation u) inst
  -- Construct an appropriate stubbed constraint set
  let cs = csUnions [cs_S,cs_H,csFromList
                      [aP_f <: a_H, a_H <: aP_c, a_S <: aP_s] ]
  let scs = CSL.unions [scs_H, scs_S, CSL.promote cs]
  -- We now have a result for a single annotation
  return (b,p,scs)
  where
    liftEither :: (a -> TypeError) -> Either a b -> TypeDecideSkelM b
    liftEither f = either (typeError . f) return
    memDeclToMemType :: TParamEnv -> AnnMemDecl
                     -> TypeDecideSkelM (AnnMemType, StubbedConstraintSet)
    memDeclToMemType p decl' = case decl' of
      Lifted pol i' tExpr _ s -> genMemType pol i' tExpr s
      Attribute pol i' tExpr _ s -> genMemType pol i' tExpr s
      MAnnotation{} ->
        -- These should've been inlined and forgotten!
        error $ "Member annotation declaration found during skeletal " ++
                "environment construction!"
      where
        genMemType pol i' tExpr s = do
          qa <- lift $ freshQVar $ TVarSourceOrigin s
          stub <- lift nextStub
          let scs = CSL.singleton $ CLeft stub
          tell $ Map.singleton stub StubInfo
                    { stubTypeExpr = tExpr, stubVar = qa, stubParamEnv = p }
          return (AnnMemType i' (typeOfPol pol) qa, scs)

-- |Performs error gathering for @TypeDecideSkelM@.
gatherParallelSkelErrors :: forall a. [TypeDecideSkelM a] -> TypeDecideSkelM [a]
gatherParallelSkelErrors xs =
  WriterT $
    second mconcat <$> unzip <$> gatherParallelErrors (map runWriterT xs)
