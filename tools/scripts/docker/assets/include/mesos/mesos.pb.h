// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos/mesos.proto

#ifndef PROTOBUF_mesos_2fmesos_2eproto__INCLUDED
#define PROTOBUF_mesos_2fmesos_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace mesos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mesos_2fmesos_2eproto();
void protobuf_AssignDesc_mesos_2fmesos_2eproto();
void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

class FrameworkID;
class OfferID;
class SlaveID;
class TaskID;
class ExecutorID;
class ContainerID;
class FrameworkInfo;
class HealthCheck;
class HealthCheck_HTTP;
class CommandInfo;
class CommandInfo_URI;
class CommandInfo_ContainerInfo;
class ExecutorInfo;
class MasterInfo;
class SlaveInfo;
class Value;
class Value_Scalar;
class Value_Range;
class Value_Ranges;
class Value_Set;
class Value_Text;
class Attribute;
class Resource;
class Resource_DiskInfo;
class Resource_DiskInfo_Persistence;
class ResourceStatistics;
class ResourceUsage;
class PerfStatistics;
class Request;
class Offer;
class Offer_Operation;
class Offer_Operation_Launch;
class Offer_Operation_Reserve;
class Offer_Operation_Unreserve;
class Offer_Operation_Create;
class Offer_Operation_Destroy;
class TaskInfo;
class TaskStatus;
class Filters;
class Environment;
class Environment_Variable;
class Parameter;
class Parameters;
class Credential;
class Credentials;
class ACL;
class ACL_Entity;
class ACL_RegisterFramework;
class ACL_RunTask;
class ACL_ShutdownFramework;
class ACLs;
class RateLimit;
class RateLimits;
class Volume;
class ContainerInfo;
class ContainerInfo_DockerInfo;
class ContainerInfo_DockerInfo_PortMapping;
class Labels;
class Label;
class Port;
class Ports;
class DiscoveryInfo;

enum Value_Type {
  Value_Type_SCALAR = 0,
  Value_Type_RANGES = 1,
  Value_Type_SET = 2,
  Value_Type_TEXT = 3
};
bool Value_Type_IsValid(int value);
const Value_Type Value_Type_Type_MIN = Value_Type_SCALAR;
const Value_Type Value_Type_Type_MAX = Value_Type_TEXT;
const int Value_Type_Type_ARRAYSIZE = Value_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Value_Type_descriptor();
inline const ::std::string& Value_Type_Name(Value_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Value_Type_descriptor(), value);
}
inline bool Value_Type_Parse(
    const ::std::string& name, Value_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Value_Type>(
    Value_Type_descriptor(), name, value);
}
enum Offer_Operation_Type {
  Offer_Operation_Type_LAUNCH = 1,
  Offer_Operation_Type_RESERVE = 2,
  Offer_Operation_Type_UNRESERVE = 3,
  Offer_Operation_Type_CREATE = 4,
  Offer_Operation_Type_DESTROY = 5
};
bool Offer_Operation_Type_IsValid(int value);
const Offer_Operation_Type Offer_Operation_Type_Type_MIN = Offer_Operation_Type_LAUNCH;
const Offer_Operation_Type Offer_Operation_Type_Type_MAX = Offer_Operation_Type_DESTROY;
const int Offer_Operation_Type_Type_ARRAYSIZE = Offer_Operation_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Offer_Operation_Type_descriptor();
inline const ::std::string& Offer_Operation_Type_Name(Offer_Operation_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Offer_Operation_Type_descriptor(), value);
}
inline bool Offer_Operation_Type_Parse(
    const ::std::string& name, Offer_Operation_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Offer_Operation_Type>(
    Offer_Operation_Type_descriptor(), name, value);
}
enum TaskStatus_Source {
  TaskStatus_Source_SOURCE_MASTER = 0,
  TaskStatus_Source_SOURCE_SLAVE = 1,
  TaskStatus_Source_SOURCE_EXECUTOR = 2
};
bool TaskStatus_Source_IsValid(int value);
const TaskStatus_Source TaskStatus_Source_Source_MIN = TaskStatus_Source_SOURCE_MASTER;
const TaskStatus_Source TaskStatus_Source_Source_MAX = TaskStatus_Source_SOURCE_EXECUTOR;
const int TaskStatus_Source_Source_ARRAYSIZE = TaskStatus_Source_Source_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskStatus_Source_descriptor();
inline const ::std::string& TaskStatus_Source_Name(TaskStatus_Source value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskStatus_Source_descriptor(), value);
}
inline bool TaskStatus_Source_Parse(
    const ::std::string& name, TaskStatus_Source* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskStatus_Source>(
    TaskStatus_Source_descriptor(), name, value);
}
enum TaskStatus_Reason {
  TaskStatus_Reason_REASON_COMMAND_EXECUTOR_FAILED = 0,
  TaskStatus_Reason_REASON_EXECUTOR_TERMINATED = 1,
  TaskStatus_Reason_REASON_EXECUTOR_UNREGISTERED = 2,
  TaskStatus_Reason_REASON_FRAMEWORK_REMOVED = 3,
  TaskStatus_Reason_REASON_GC_ERROR = 4,
  TaskStatus_Reason_REASON_INVALID_FRAMEWORKID = 5,
  TaskStatus_Reason_REASON_INVALID_OFFERS = 6,
  TaskStatus_Reason_REASON_MASTER_DISCONNECTED = 7,
  TaskStatus_Reason_REASON_MEMORY_LIMIT = 8,
  TaskStatus_Reason_REASON_RECONCILIATION = 9,
  TaskStatus_Reason_REASON_SLAVE_DISCONNECTED = 10,
  TaskStatus_Reason_REASON_SLAVE_REMOVED = 11,
  TaskStatus_Reason_REASON_SLAVE_RESTARTED = 12,
  TaskStatus_Reason_REASON_SLAVE_UNKNOWN = 13,
  TaskStatus_Reason_REASON_TASK_INVALID = 14,
  TaskStatus_Reason_REASON_TASK_UNAUTHORIZED = 15,
  TaskStatus_Reason_REASON_TASK_UNKNOWN = 16
};
bool TaskStatus_Reason_IsValid(int value);
const TaskStatus_Reason TaskStatus_Reason_Reason_MIN = TaskStatus_Reason_REASON_COMMAND_EXECUTOR_FAILED;
const TaskStatus_Reason TaskStatus_Reason_Reason_MAX = TaskStatus_Reason_REASON_TASK_UNKNOWN;
const int TaskStatus_Reason_Reason_ARRAYSIZE = TaskStatus_Reason_Reason_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskStatus_Reason_descriptor();
inline const ::std::string& TaskStatus_Reason_Name(TaskStatus_Reason value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskStatus_Reason_descriptor(), value);
}
inline bool TaskStatus_Reason_Parse(
    const ::std::string& name, TaskStatus_Reason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskStatus_Reason>(
    TaskStatus_Reason_descriptor(), name, value);
}
enum ACL_Entity_Type {
  ACL_Entity_Type_SOME = 0,
  ACL_Entity_Type_ANY = 1,
  ACL_Entity_Type_NONE = 2
};
bool ACL_Entity_Type_IsValid(int value);
const ACL_Entity_Type ACL_Entity_Type_Type_MIN = ACL_Entity_Type_SOME;
const ACL_Entity_Type ACL_Entity_Type_Type_MAX = ACL_Entity_Type_NONE;
const int ACL_Entity_Type_Type_ARRAYSIZE = ACL_Entity_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACL_Entity_Type_descriptor();
inline const ::std::string& ACL_Entity_Type_Name(ACL_Entity_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACL_Entity_Type_descriptor(), value);
}
inline bool ACL_Entity_Type_Parse(
    const ::std::string& name, ACL_Entity_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACL_Entity_Type>(
    ACL_Entity_Type_descriptor(), name, value);
}
enum Volume_Mode {
  Volume_Mode_RW = 1,
  Volume_Mode_RO = 2
};
bool Volume_Mode_IsValid(int value);
const Volume_Mode Volume_Mode_Mode_MIN = Volume_Mode_RW;
const Volume_Mode Volume_Mode_Mode_MAX = Volume_Mode_RO;
const int Volume_Mode_Mode_ARRAYSIZE = Volume_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Volume_Mode_descriptor();
inline const ::std::string& Volume_Mode_Name(Volume_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Volume_Mode_descriptor(), value);
}
inline bool Volume_Mode_Parse(
    const ::std::string& name, Volume_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Volume_Mode>(
    Volume_Mode_descriptor(), name, value);
}
enum ContainerInfo_DockerInfo_Network {
  ContainerInfo_DockerInfo_Network_HOST = 1,
  ContainerInfo_DockerInfo_Network_BRIDGE = 2,
  ContainerInfo_DockerInfo_Network_NONE = 3
};
bool ContainerInfo_DockerInfo_Network_IsValid(int value);
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo_Network_Network_MIN = ContainerInfo_DockerInfo_Network_HOST;
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo_Network_Network_MAX = ContainerInfo_DockerInfo_Network_NONE;
const int ContainerInfo_DockerInfo_Network_Network_ARRAYSIZE = ContainerInfo_DockerInfo_Network_Network_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContainerInfo_DockerInfo_Network_descriptor();
inline const ::std::string& ContainerInfo_DockerInfo_Network_Name(ContainerInfo_DockerInfo_Network value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContainerInfo_DockerInfo_Network_descriptor(), value);
}
inline bool ContainerInfo_DockerInfo_Network_Parse(
    const ::std::string& name, ContainerInfo_DockerInfo_Network* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContainerInfo_DockerInfo_Network>(
    ContainerInfo_DockerInfo_Network_descriptor(), name, value);
}
enum ContainerInfo_Type {
  ContainerInfo_Type_DOCKER = 1,
  ContainerInfo_Type_MESOS = 2
};
bool ContainerInfo_Type_IsValid(int value);
const ContainerInfo_Type ContainerInfo_Type_Type_MIN = ContainerInfo_Type_DOCKER;
const ContainerInfo_Type ContainerInfo_Type_Type_MAX = ContainerInfo_Type_MESOS;
const int ContainerInfo_Type_Type_ARRAYSIZE = ContainerInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContainerInfo_Type_descriptor();
inline const ::std::string& ContainerInfo_Type_Name(ContainerInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContainerInfo_Type_descriptor(), value);
}
inline bool ContainerInfo_Type_Parse(
    const ::std::string& name, ContainerInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContainerInfo_Type>(
    ContainerInfo_Type_descriptor(), name, value);
}
enum DiscoveryInfo_Visibility {
  DiscoveryInfo_Visibility_FRAMEWORK = 0,
  DiscoveryInfo_Visibility_CLUSTER = 1,
  DiscoveryInfo_Visibility_EXTERNAL = 2
};
bool DiscoveryInfo_Visibility_IsValid(int value);
const DiscoveryInfo_Visibility DiscoveryInfo_Visibility_Visibility_MIN = DiscoveryInfo_Visibility_FRAMEWORK;
const DiscoveryInfo_Visibility DiscoveryInfo_Visibility_Visibility_MAX = DiscoveryInfo_Visibility_EXTERNAL;
const int DiscoveryInfo_Visibility_Visibility_ARRAYSIZE = DiscoveryInfo_Visibility_Visibility_MAX + 1;

const ::google::protobuf::EnumDescriptor* DiscoveryInfo_Visibility_descriptor();
inline const ::std::string& DiscoveryInfo_Visibility_Name(DiscoveryInfo_Visibility value) {
  return ::google::protobuf::internal::NameOfEnum(
    DiscoveryInfo_Visibility_descriptor(), value);
}
inline bool DiscoveryInfo_Visibility_Parse(
    const ::std::string& name, DiscoveryInfo_Visibility* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DiscoveryInfo_Visibility>(
    DiscoveryInfo_Visibility_descriptor(), name, value);
}
enum Status {
  DRIVER_NOT_STARTED = 1,
  DRIVER_RUNNING = 2,
  DRIVER_ABORTED = 3,
  DRIVER_STOPPED = 4
};
bool Status_IsValid(int value);
const Status Status_MIN = DRIVER_NOT_STARTED;
const Status Status_MAX = DRIVER_STOPPED;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
enum TaskState {
  TASK_STAGING = 6,
  TASK_STARTING = 0,
  TASK_RUNNING = 1,
  TASK_FINISHED = 2,
  TASK_FAILED = 3,
  TASK_KILLED = 4,
  TASK_LOST = 5,
  TASK_ERROR = 7
};
bool TaskState_IsValid(int value);
const TaskState TaskState_MIN = TASK_STARTING;
const TaskState TaskState_MAX = TASK_ERROR;
const int TaskState_ARRAYSIZE = TaskState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskState_descriptor();
inline const ::std::string& TaskState_Name(TaskState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskState_descriptor(), value);
}
inline bool TaskState_Parse(
    const ::std::string& name, TaskState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskState>(
    TaskState_descriptor(), name, value);
}
// ===================================================================

class FrameworkID : public ::google::protobuf::Message {
 public:
  FrameworkID();
  virtual ~FrameworkID();

  FrameworkID(const FrameworkID& from);

  inline FrameworkID& operator=(const FrameworkID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkID& default_instance();

  void Swap(FrameworkID* other);

  // implements Message ----------------------------------------------

  FrameworkID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkID& from);
  void MergeFrom(const FrameworkID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.FrameworkID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static FrameworkID* default_instance_;
};
// -------------------------------------------------------------------

class OfferID : public ::google::protobuf::Message {
 public:
  OfferID();
  virtual ~OfferID();

  OfferID(const OfferID& from);

  inline OfferID& operator=(const OfferID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OfferID& default_instance();

  void Swap(OfferID* other);

  // implements Message ----------------------------------------------

  OfferID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OfferID& from);
  void MergeFrom(const OfferID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.OfferID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static OfferID* default_instance_;
};
// -------------------------------------------------------------------

class SlaveID : public ::google::protobuf::Message {
 public:
  SlaveID();
  virtual ~SlaveID();

  SlaveID(const SlaveID& from);

  inline SlaveID& operator=(const SlaveID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveID& default_instance();

  void Swap(SlaveID* other);

  // implements Message ----------------------------------------------

  SlaveID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveID& from);
  void MergeFrom(const SlaveID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.SlaveID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static SlaveID* default_instance_;
};
// -------------------------------------------------------------------

class TaskID : public ::google::protobuf::Message {
 public:
  TaskID();
  virtual ~TaskID();

  TaskID(const TaskID& from);

  inline TaskID& operator=(const TaskID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskID& default_instance();

  void Swap(TaskID* other);

  // implements Message ----------------------------------------------

  TaskID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskID& from);
  void MergeFrom(const TaskID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.TaskID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static TaskID* default_instance_;
};
// -------------------------------------------------------------------

class ExecutorID : public ::google::protobuf::Message {
 public:
  ExecutorID();
  virtual ~ExecutorID();

  ExecutorID(const ExecutorID& from);

  inline ExecutorID& operator=(const ExecutorID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorID& default_instance();

  void Swap(ExecutorID* other);

  // implements Message ----------------------------------------------

  ExecutorID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutorID& from);
  void MergeFrom(const ExecutorID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.ExecutorID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static ExecutorID* default_instance_;
};
// -------------------------------------------------------------------

class ContainerID : public ::google::protobuf::Message {
 public:
  ContainerID();
  virtual ~ContainerID();

  ContainerID(const ContainerID& from);

  inline ContainerID& operator=(const ContainerID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerID& default_instance();

  void Swap(ContainerID* other);

  // implements Message ----------------------------------------------

  ContainerID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerID& from);
  void MergeFrom(const ContainerID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.ContainerID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static ContainerID* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkInfo : public ::google::protobuf::Message {
 public:
  FrameworkInfo();
  virtual ~FrameworkInfo();

  FrameworkInfo(const FrameworkInfo& from);

  inline FrameworkInfo& operator=(const FrameworkInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkInfo& default_instance();

  void Swap(FrameworkInfo* other);

  // implements Message ----------------------------------------------

  FrameworkInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkInfo& from);
  void MergeFrom(const FrameworkInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .mesos.FrameworkID id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::mesos::FrameworkID& id() const;
  inline ::mesos::FrameworkID* mutable_id();
  inline ::mesos::FrameworkID* release_id();
  inline void set_allocated_id(::mesos::FrameworkID* id);

  // optional double failover_timeout = 4 [default = 0];
  inline bool has_failover_timeout() const;
  inline void clear_failover_timeout();
  static const int kFailoverTimeoutFieldNumber = 4;
  inline double failover_timeout() const;
  inline void set_failover_timeout(double value);

  // optional bool checkpoint = 5 [default = false];
  inline bool has_checkpoint() const;
  inline void clear_checkpoint();
  static const int kCheckpointFieldNumber = 5;
  inline bool checkpoint() const;
  inline void set_checkpoint(bool value);

  // optional string role = 6 [default = "*"];
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 6;
  inline const ::std::string& role() const;
  inline void set_role(const ::std::string& value);
  inline void set_role(const char* value);
  inline void set_role(const char* value, size_t size);
  inline ::std::string* mutable_role();
  inline ::std::string* release_role();
  inline void set_allocated_role(::std::string* role);

  // optional string hostname = 7;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 7;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string principal = 8;
  inline bool has_principal() const;
  inline void clear_principal();
  static const int kPrincipalFieldNumber = 8;
  inline const ::std::string& principal() const;
  inline void set_principal(const ::std::string& value);
  inline void set_principal(const char* value);
  inline void set_principal(const char* value, size_t size);
  inline ::std::string* mutable_principal();
  inline ::std::string* release_principal();
  inline void set_allocated_principal(::std::string* principal);

  // optional string webui_url = 9;
  inline bool has_webui_url() const;
  inline void clear_webui_url();
  static const int kWebuiUrlFieldNumber = 9;
  inline const ::std::string& webui_url() const;
  inline void set_webui_url(const ::std::string& value);
  inline void set_webui_url(const char* value);
  inline void set_webui_url(const char* value, size_t size);
  inline ::std::string* mutable_webui_url();
  inline ::std::string* release_webui_url();
  inline void set_allocated_webui_url(::std::string* webui_url);

  // @@protoc_insertion_point(class_scope:mesos.FrameworkInfo)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_failover_timeout();
  inline void clear_has_failover_timeout();
  inline void set_has_checkpoint();
  inline void clear_has_checkpoint();
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_principal();
  inline void clear_has_principal();
  inline void set_has_webui_url();
  inline void clear_has_webui_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_;
  ::std::string* name_;
  ::mesos::FrameworkID* id_;
  double failover_timeout_;
  ::std::string* role_;
  static ::std::string* _default_role_;
  ::std::string* hostname_;
  ::std::string* principal_;
  ::std::string* webui_url_;
  bool checkpoint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static FrameworkInfo* default_instance_;
};
// -------------------------------------------------------------------

class HealthCheck_HTTP : public ::google::protobuf::Message {
 public:
  HealthCheck_HTTP();
  virtual ~HealthCheck_HTTP();

  HealthCheck_HTTP(const HealthCheck_HTTP& from);

  inline HealthCheck_HTTP& operator=(const HealthCheck_HTTP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HealthCheck_HTTP& default_instance();

  void Swap(HealthCheck_HTTP* other);

  // implements Message ----------------------------------------------

  HealthCheck_HTTP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HealthCheck_HTTP& from);
  void MergeFrom(const HealthCheck_HTTP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 port = 1;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 1;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string path = 2 [default = "/"];
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // repeated uint32 statuses = 4;
  inline int statuses_size() const;
  inline void clear_statuses();
  static const int kStatusesFieldNumber = 4;
  inline ::google::protobuf::uint32 statuses(int index) const;
  inline void set_statuses(int index, ::google::protobuf::uint32 value);
  inline void add_statuses(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      statuses() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_statuses();

  // @@protoc_insertion_point(class_scope:mesos.HealthCheck.HTTP)
 private:
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;
  static ::std::string* _default_path_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > statuses_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static HealthCheck_HTTP* default_instance_;
};
// -------------------------------------------------------------------

class HealthCheck : public ::google::protobuf::Message {
 public:
  HealthCheck();
  virtual ~HealthCheck();

  HealthCheck(const HealthCheck& from);

  inline HealthCheck& operator=(const HealthCheck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HealthCheck& default_instance();

  void Swap(HealthCheck* other);

  // implements Message ----------------------------------------------

  HealthCheck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HealthCheck& from);
  void MergeFrom(const HealthCheck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef HealthCheck_HTTP HTTP;

  // accessors -------------------------------------------------------

  // optional .mesos.HealthCheck.HTTP http = 1;
  inline bool has_http() const;
  inline void clear_http();
  static const int kHttpFieldNumber = 1;
  inline const ::mesos::HealthCheck_HTTP& http() const;
  inline ::mesos::HealthCheck_HTTP* mutable_http();
  inline ::mesos::HealthCheck_HTTP* release_http();
  inline void set_allocated_http(::mesos::HealthCheck_HTTP* http);

  // optional double delay_seconds = 2 [default = 15];
  inline bool has_delay_seconds() const;
  inline void clear_delay_seconds();
  static const int kDelaySecondsFieldNumber = 2;
  inline double delay_seconds() const;
  inline void set_delay_seconds(double value);

  // optional double interval_seconds = 3 [default = 10];
  inline bool has_interval_seconds() const;
  inline void clear_interval_seconds();
  static const int kIntervalSecondsFieldNumber = 3;
  inline double interval_seconds() const;
  inline void set_interval_seconds(double value);

  // optional double timeout_seconds = 4 [default = 20];
  inline bool has_timeout_seconds() const;
  inline void clear_timeout_seconds();
  static const int kTimeoutSecondsFieldNumber = 4;
  inline double timeout_seconds() const;
  inline void set_timeout_seconds(double value);

  // optional uint32 consecutive_failures = 5 [default = 3];
  inline bool has_consecutive_failures() const;
  inline void clear_consecutive_failures();
  static const int kConsecutiveFailuresFieldNumber = 5;
  inline ::google::protobuf::uint32 consecutive_failures() const;
  inline void set_consecutive_failures(::google::protobuf::uint32 value);

  // optional double grace_period_seconds = 6 [default = 10];
  inline bool has_grace_period_seconds() const;
  inline void clear_grace_period_seconds();
  static const int kGracePeriodSecondsFieldNumber = 6;
  inline double grace_period_seconds() const;
  inline void set_grace_period_seconds(double value);

  // optional .mesos.CommandInfo command = 7;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 7;
  inline const ::mesos::CommandInfo& command() const;
  inline ::mesos::CommandInfo* mutable_command();
  inline ::mesos::CommandInfo* release_command();
  inline void set_allocated_command(::mesos::CommandInfo* command);

  // @@protoc_insertion_point(class_scope:mesos.HealthCheck)
 private:
  inline void set_has_http();
  inline void clear_has_http();
  inline void set_has_delay_seconds();
  inline void clear_has_delay_seconds();
  inline void set_has_interval_seconds();
  inline void clear_has_interval_seconds();
  inline void set_has_timeout_seconds();
  inline void clear_has_timeout_seconds();
  inline void set_has_consecutive_failures();
  inline void clear_has_consecutive_failures();
  inline void set_has_grace_period_seconds();
  inline void clear_has_grace_period_seconds();
  inline void set_has_command();
  inline void clear_has_command();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::HealthCheck_HTTP* http_;
  double delay_seconds_;
  double interval_seconds_;
  double timeout_seconds_;
  double grace_period_seconds_;
  ::mesos::CommandInfo* command_;
  ::google::protobuf::uint32 consecutive_failures_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static HealthCheck* default_instance_;
};
// -------------------------------------------------------------------

class CommandInfo_URI : public ::google::protobuf::Message {
 public:
  CommandInfo_URI();
  virtual ~CommandInfo_URI();

  CommandInfo_URI(const CommandInfo_URI& from);

  inline CommandInfo_URI& operator=(const CommandInfo_URI& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandInfo_URI& default_instance();

  void Swap(CommandInfo_URI* other);

  // implements Message ----------------------------------------------

  CommandInfo_URI* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandInfo_URI& from);
  void MergeFrom(const CommandInfo_URI& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional bool executable = 2;
  inline bool has_executable() const;
  inline void clear_executable();
  static const int kExecutableFieldNumber = 2;
  inline bool executable() const;
  inline void set_executable(bool value);

  // optional bool extract = 3 [default = true];
  inline bool has_extract() const;
  inline void clear_extract();
  static const int kExtractFieldNumber = 3;
  inline bool extract() const;
  inline void set_extract(bool value);

  // @@protoc_insertion_point(class_scope:mesos.CommandInfo.URI)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_executable();
  inline void clear_has_executable();
  inline void set_has_extract();
  inline void clear_has_extract();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;
  bool executable_;
  bool extract_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static CommandInfo_URI* default_instance_;
};
// -------------------------------------------------------------------

class CommandInfo_ContainerInfo : public ::google::protobuf::Message {
 public:
  CommandInfo_ContainerInfo();
  virtual ~CommandInfo_ContainerInfo();

  CommandInfo_ContainerInfo(const CommandInfo_ContainerInfo& from);

  inline CommandInfo_ContainerInfo& operator=(const CommandInfo_ContainerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandInfo_ContainerInfo& default_instance();

  void Swap(CommandInfo_ContainerInfo* other);

  // implements Message ----------------------------------------------

  CommandInfo_ContainerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandInfo_ContainerInfo& from);
  void MergeFrom(const CommandInfo_ContainerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string image = 1;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 1;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // repeated string options = 2;
  inline int options_size() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 2;
  inline const ::std::string& options(int index) const;
  inline ::std::string* mutable_options(int index);
  inline void set_options(int index, const ::std::string& value);
  inline void set_options(int index, const char* value);
  inline void set_options(int index, const char* value, size_t size);
  inline ::std::string* add_options();
  inline void add_options(const ::std::string& value);
  inline void add_options(const char* value);
  inline void add_options(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& options() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_options();

  // @@protoc_insertion_point(class_scope:mesos.CommandInfo.ContainerInfo)
 private:
  inline void set_has_image();
  inline void clear_has_image();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* image_;
  ::google::protobuf::RepeatedPtrField< ::std::string> options_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static CommandInfo_ContainerInfo* default_instance_;
};
// -------------------------------------------------------------------

class CommandInfo : public ::google::protobuf::Message {
 public:
  CommandInfo();
  virtual ~CommandInfo();

  CommandInfo(const CommandInfo& from);

  inline CommandInfo& operator=(const CommandInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandInfo& default_instance();

  void Swap(CommandInfo* other);

  // implements Message ----------------------------------------------

  CommandInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandInfo& from);
  void MergeFrom(const CommandInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommandInfo_URI URI;
  typedef CommandInfo_ContainerInfo ContainerInfo;

  // accessors -------------------------------------------------------

  // optional .mesos.CommandInfo.ContainerInfo container = 4;
  inline bool has_container() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 4;
  inline const ::mesos::CommandInfo_ContainerInfo& container() const;
  inline ::mesos::CommandInfo_ContainerInfo* mutable_container();
  inline ::mesos::CommandInfo_ContainerInfo* release_container();
  inline void set_allocated_container(::mesos::CommandInfo_ContainerInfo* container);

  // repeated .mesos.CommandInfo.URI uris = 1;
  inline int uris_size() const;
  inline void clear_uris();
  static const int kUrisFieldNumber = 1;
  inline const ::mesos::CommandInfo_URI& uris(int index) const;
  inline ::mesos::CommandInfo_URI* mutable_uris(int index);
  inline ::mesos::CommandInfo_URI* add_uris();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >&
      uris() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >*
      mutable_uris();

  // optional .mesos.Environment environment = 2;
  inline bool has_environment() const;
  inline void clear_environment();
  static const int kEnvironmentFieldNumber = 2;
  inline const ::mesos::Environment& environment() const;
  inline ::mesos::Environment* mutable_environment();
  inline ::mesos::Environment* release_environment();
  inline void set_allocated_environment(::mesos::Environment* environment);

  // optional bool shell = 6 [default = true];
  inline bool has_shell() const;
  inline void clear_shell();
  static const int kShellFieldNumber = 6;
  inline bool shell() const;
  inline void set_shell(bool value);

  // optional string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // repeated string arguments = 7;
  inline int arguments_size() const;
  inline void clear_arguments();
  static const int kArgumentsFieldNumber = 7;
  inline const ::std::string& arguments(int index) const;
  inline ::std::string* mutable_arguments(int index);
  inline void set_arguments(int index, const ::std::string& value);
  inline void set_arguments(int index, const char* value);
  inline void set_arguments(int index, const char* value, size_t size);
  inline ::std::string* add_arguments();
  inline void add_arguments(const ::std::string& value);
  inline void add_arguments(const char* value);
  inline void add_arguments(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& arguments() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_arguments();

  // optional string user = 5;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 5;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // @@protoc_insertion_point(class_scope:mesos.CommandInfo)
 private:
  inline void set_has_container();
  inline void clear_has_container();
  inline void set_has_environment();
  inline void clear_has_environment();
  inline void set_has_shell();
  inline void clear_has_shell();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_user();
  inline void clear_has_user();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::CommandInfo_ContainerInfo* container_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI > uris_;
  ::mesos::Environment* environment_;
  ::std::string* value_;
  ::google::protobuf::RepeatedPtrField< ::std::string> arguments_;
  ::std::string* user_;
  bool shell_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static CommandInfo* default_instance_;
};
// -------------------------------------------------------------------

class ExecutorInfo : public ::google::protobuf::Message {
 public:
  ExecutorInfo();
  virtual ~ExecutorInfo();

  ExecutorInfo(const ExecutorInfo& from);

  inline ExecutorInfo& operator=(const ExecutorInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorInfo& default_instance();

  void Swap(ExecutorInfo* other);

  // implements Message ----------------------------------------------

  ExecutorInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutorInfo& from);
  void MergeFrom(const ExecutorInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ExecutorID executor_id = 1;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 1;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // optional .mesos.FrameworkID framework_id = 8;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 8;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .mesos.CommandInfo command = 7;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 7;
  inline const ::mesos::CommandInfo& command() const;
  inline ::mesos::CommandInfo* mutable_command();
  inline ::mesos::CommandInfo* release_command();
  inline void set_allocated_command(::mesos::CommandInfo* command);

  // optional .mesos.ContainerInfo container = 11;
  inline bool has_container() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 11;
  inline const ::mesos::ContainerInfo& container() const;
  inline ::mesos::ContainerInfo* mutable_container();
  inline ::mesos::ContainerInfo* release_container();
  inline void set_allocated_container(::mesos::ContainerInfo* container);

  // repeated .mesos.Resource resources = 5;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 5;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // optional string name = 9;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 9;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string source = 10;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 10;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  inline void set_allocated_source(::std::string* source);

  // optional bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional .mesos.DiscoveryInfo discovery = 12;
  inline bool has_discovery() const;
  inline void clear_discovery();
  static const int kDiscoveryFieldNumber = 12;
  inline const ::mesos::DiscoveryInfo& discovery() const;
  inline ::mesos::DiscoveryInfo* mutable_discovery();
  inline ::mesos::DiscoveryInfo* release_discovery();
  inline void set_allocated_discovery(::mesos::DiscoveryInfo* discovery);

  // @@protoc_insertion_point(class_scope:mesos.ExecutorInfo)
 private:
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_container();
  inline void clear_has_container();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_discovery();
  inline void clear_has_discovery();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::ExecutorID* executor_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::CommandInfo* command_;
  ::mesos::ContainerInfo* container_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::std::string* name_;
  ::std::string* source_;
  ::std::string* data_;
  ::mesos::DiscoveryInfo* discovery_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static ExecutorInfo* default_instance_;
};
// -------------------------------------------------------------------

class MasterInfo : public ::google::protobuf::Message {
 public:
  MasterInfo();
  virtual ~MasterInfo();

  MasterInfo(const MasterInfo& from);

  inline MasterInfo& operator=(const MasterInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterInfo& default_instance();

  void Swap(MasterInfo* other);

  // implements Message ----------------------------------------------

  MasterInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MasterInfo& from);
  void MergeFrom(const MasterInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // required uint32 port = 3 [default = 5050];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string pid = 4;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 4;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  inline ::std::string* release_pid();
  inline void set_allocated_pid(::std::string* pid);

  // optional string hostname = 5;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 5;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // @@protoc_insertion_point(class_scope:mesos.MasterInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_hostname();
  inline void clear_has_hostname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  ::std::string* pid_;
  ::std::string* hostname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static MasterInfo* default_instance_;
};
// -------------------------------------------------------------------

class SlaveInfo : public ::google::protobuf::Message {
 public:
  SlaveInfo();
  virtual ~SlaveInfo();

  SlaveInfo(const SlaveInfo& from);

  inline SlaveInfo& operator=(const SlaveInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveInfo& default_instance();

  void Swap(SlaveInfo* other);

  // implements Message ----------------------------------------------

  SlaveInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveInfo& from);
  void MergeFrom(const SlaveInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional int32 port = 8 [default = 5051];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 8;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // repeated .mesos.Resource resources = 3;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 3;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // repeated .mesos.Attribute attributes = 5;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 5;
  inline const ::mesos::Attribute& attributes(int index) const;
  inline ::mesos::Attribute* mutable_attributes(int index);
  inline ::mesos::Attribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
      mutable_attributes();

  // optional .mesos.SlaveID id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline const ::mesos::SlaveID& id() const;
  inline ::mesos::SlaveID* mutable_id();
  inline ::mesos::SlaveID* release_id();
  inline void set_allocated_id(::mesos::SlaveID* id);

  // optional bool checkpoint = 7 [default = false];
  inline bool has_checkpoint() const;
  inline void clear_checkpoint();
  static const int kCheckpointFieldNumber = 7;
  inline bool checkpoint() const;
  inline void set_checkpoint(bool value);

  // @@protoc_insertion_point(class_scope:mesos.SlaveInfo)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_checkpoint();
  inline void clear_has_checkpoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hostname_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Attribute > attributes_;
  ::google::protobuf::int32 port_;
  bool checkpoint_;
  ::mesos::SlaveID* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static SlaveInfo* default_instance_;
};
// -------------------------------------------------------------------

class Value_Scalar : public ::google::protobuf::Message {
 public:
  Value_Scalar();
  virtual ~Value_Scalar();

  Value_Scalar(const Value_Scalar& from);

  inline Value_Scalar& operator=(const Value_Scalar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Scalar& default_instance();

  void Swap(Value_Scalar* other);

  // implements Message ----------------------------------------------

  Value_Scalar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Scalar& from);
  void MergeFrom(const Value_Scalar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:mesos.Value.Scalar)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Value_Scalar* default_instance_;
};
// -------------------------------------------------------------------

class Value_Range : public ::google::protobuf::Message {
 public:
  Value_Range();
  virtual ~Value_Range();

  Value_Range(const Value_Range& from);

  inline Value_Range& operator=(const Value_Range& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Range& default_instance();

  void Swap(Value_Range* other);

  // implements Message ----------------------------------------------

  Value_Range* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Range& from);
  void MergeFrom(const Value_Range& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 begin = 1;
  inline bool has_begin() const;
  inline void clear_begin();
  static const int kBeginFieldNumber = 1;
  inline ::google::protobuf::uint64 begin() const;
  inline void set_begin(::google::protobuf::uint64 value);

  // required uint64 end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline ::google::protobuf::uint64 end() const;
  inline void set_end(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.Value.Range)
 private:
  inline void set_has_begin();
  inline void clear_has_begin();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 begin_;
  ::google::protobuf::uint64 end_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Value_Range* default_instance_;
};
// -------------------------------------------------------------------

class Value_Ranges : public ::google::protobuf::Message {
 public:
  Value_Ranges();
  virtual ~Value_Ranges();

  Value_Ranges(const Value_Ranges& from);

  inline Value_Ranges& operator=(const Value_Ranges& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Ranges& default_instance();

  void Swap(Value_Ranges* other);

  // implements Message ----------------------------------------------

  Value_Ranges* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Ranges& from);
  void MergeFrom(const Value_Ranges& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Value.Range range = 1;
  inline int range_size() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 1;
  inline const ::mesos::Value_Range& range(int index) const;
  inline ::mesos::Value_Range* mutable_range(int index);
  inline ::mesos::Value_Range* add_range();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >&
      range() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >*
      mutable_range();

  // @@protoc_insertion_point(class_scope:mesos.Value.Ranges)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range > range_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Value_Ranges* default_instance_;
};
// -------------------------------------------------------------------

class Value_Set : public ::google::protobuf::Message {
 public:
  Value_Set();
  virtual ~Value_Set();

  Value_Set(const Value_Set& from);

  inline Value_Set& operator=(const Value_Set& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Set& default_instance();

  void Swap(Value_Set* other);

  // implements Message ----------------------------------------------

  Value_Set* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Set& from);
  void MergeFrom(const Value_Set& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string item = 1;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 1;
  inline const ::std::string& item(int index) const;
  inline ::std::string* mutable_item(int index);
  inline void set_item(int index, const ::std::string& value);
  inline void set_item(int index, const char* value);
  inline void set_item(int index, const char* value, size_t size);
  inline ::std::string* add_item();
  inline void add_item(const ::std::string& value);
  inline void add_item(const char* value);
  inline void add_item(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& item() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_item();

  // @@protoc_insertion_point(class_scope:mesos.Value.Set)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Value_Set* default_instance_;
};
// -------------------------------------------------------------------

class Value_Text : public ::google::protobuf::Message {
 public:
  Value_Text();
  virtual ~Value_Text();

  Value_Text(const Value_Text& from);

  inline Value_Text& operator=(const Value_Text& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Text& default_instance();

  void Swap(Value_Text* other);

  // implements Message ----------------------------------------------

  Value_Text* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Text& from);
  void MergeFrom(const Value_Text& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.Value.Text)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Value_Text* default_instance_;
};
// -------------------------------------------------------------------

class Value : public ::google::protobuf::Message {
 public:
  Value();
  virtual ~Value();

  Value(const Value& from);

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value& default_instance();

  void Swap(Value* other);

  // implements Message ----------------------------------------------

  Value* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Value_Scalar Scalar;
  typedef Value_Range Range;
  typedef Value_Ranges Ranges;
  typedef Value_Set Set;
  typedef Value_Text Text;

  typedef Value_Type Type;
  static const Type SCALAR = Value_Type_SCALAR;
  static const Type RANGES = Value_Type_RANGES;
  static const Type SET = Value_Type_SET;
  static const Type TEXT = Value_Type_TEXT;
  static inline bool Type_IsValid(int value) {
    return Value_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Value_Type_Type_MIN;
  static const Type Type_MAX =
    Value_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Value_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Value_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Value_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Value_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.Value.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::Value_Type type() const;
  inline void set_type(::mesos::Value_Type value);

  // optional .mesos.Value.Scalar scalar = 2;
  inline bool has_scalar() const;
  inline void clear_scalar();
  static const int kScalarFieldNumber = 2;
  inline const ::mesos::Value_Scalar& scalar() const;
  inline ::mesos::Value_Scalar* mutable_scalar();
  inline ::mesos::Value_Scalar* release_scalar();
  inline void set_allocated_scalar(::mesos::Value_Scalar* scalar);

  // optional .mesos.Value.Ranges ranges = 3;
  inline bool has_ranges() const;
  inline void clear_ranges();
  static const int kRangesFieldNumber = 3;
  inline const ::mesos::Value_Ranges& ranges() const;
  inline ::mesos::Value_Ranges* mutable_ranges();
  inline ::mesos::Value_Ranges* release_ranges();
  inline void set_allocated_ranges(::mesos::Value_Ranges* ranges);

  // optional .mesos.Value.Set set = 4;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 4;
  inline const ::mesos::Value_Set& set() const;
  inline ::mesos::Value_Set* mutable_set();
  inline ::mesos::Value_Set* release_set();
  inline void set_allocated_set(::mesos::Value_Set* set);

  // optional .mesos.Value.Text text = 5;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 5;
  inline const ::mesos::Value_Text& text() const;
  inline ::mesos::Value_Text* mutable_text();
  inline ::mesos::Value_Text* release_text();
  inline void set_allocated_text(::mesos::Value_Text* text);

  // @@protoc_insertion_point(class_scope:mesos.Value)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_scalar();
  inline void clear_has_scalar();
  inline void set_has_ranges();
  inline void clear_has_ranges();
  inline void set_has_set();
  inline void clear_has_set();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::Value_Scalar* scalar_;
  ::mesos::Value_Ranges* ranges_;
  ::mesos::Value_Set* set_;
  ::mesos::Value_Text* text_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Value* default_instance_;
};
// -------------------------------------------------------------------

class Attribute : public ::google::protobuf::Message {
 public:
  Attribute();
  virtual ~Attribute();

  Attribute(const Attribute& from);

  inline Attribute& operator=(const Attribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Attribute& default_instance();

  void Swap(Attribute* other);

  // implements Message ----------------------------------------------

  Attribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Attribute& from);
  void MergeFrom(const Attribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .mesos.Value.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mesos::Value_Type type() const;
  inline void set_type(::mesos::Value_Type value);

  // optional .mesos.Value.Scalar scalar = 3;
  inline bool has_scalar() const;
  inline void clear_scalar();
  static const int kScalarFieldNumber = 3;
  inline const ::mesos::Value_Scalar& scalar() const;
  inline ::mesos::Value_Scalar* mutable_scalar();
  inline ::mesos::Value_Scalar* release_scalar();
  inline void set_allocated_scalar(::mesos::Value_Scalar* scalar);

  // optional .mesos.Value.Ranges ranges = 4;
  inline bool has_ranges() const;
  inline void clear_ranges();
  static const int kRangesFieldNumber = 4;
  inline const ::mesos::Value_Ranges& ranges() const;
  inline ::mesos::Value_Ranges* mutable_ranges();
  inline ::mesos::Value_Ranges* release_ranges();
  inline void set_allocated_ranges(::mesos::Value_Ranges* ranges);

  // optional .mesos.Value.Set set = 6;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 6;
  inline const ::mesos::Value_Set& set() const;
  inline ::mesos::Value_Set* mutable_set();
  inline ::mesos::Value_Set* release_set();
  inline void set_allocated_set(::mesos::Value_Set* set);

  // optional .mesos.Value.Text text = 5;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 5;
  inline const ::mesos::Value_Text& text() const;
  inline ::mesos::Value_Text* mutable_text();
  inline ::mesos::Value_Text* release_text();
  inline void set_allocated_text(::mesos::Value_Text* text);

  // @@protoc_insertion_point(class_scope:mesos.Attribute)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_scalar();
  inline void clear_has_scalar();
  inline void set_has_ranges();
  inline void clear_has_ranges();
  inline void set_has_set();
  inline void clear_has_set();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::mesos::Value_Scalar* scalar_;
  ::mesos::Value_Ranges* ranges_;
  ::mesos::Value_Set* set_;
  ::mesos::Value_Text* text_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Attribute* default_instance_;
};
// -------------------------------------------------------------------

class Resource_DiskInfo_Persistence : public ::google::protobuf::Message {
 public:
  Resource_DiskInfo_Persistence();
  virtual ~Resource_DiskInfo_Persistence();

  Resource_DiskInfo_Persistence(const Resource_DiskInfo_Persistence& from);

  inline Resource_DiskInfo_Persistence& operator=(const Resource_DiskInfo_Persistence& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_DiskInfo_Persistence& default_instance();

  void Swap(Resource_DiskInfo_Persistence* other);

  // implements Message ----------------------------------------------

  Resource_DiskInfo_Persistence* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource_DiskInfo_Persistence& from);
  void MergeFrom(const Resource_DiskInfo_Persistence& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:mesos.Resource.DiskInfo.Persistence)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Resource_DiskInfo_Persistence* default_instance_;
};
// -------------------------------------------------------------------

class Resource_DiskInfo : public ::google::protobuf::Message {
 public:
  Resource_DiskInfo();
  virtual ~Resource_DiskInfo();

  Resource_DiskInfo(const Resource_DiskInfo& from);

  inline Resource_DiskInfo& operator=(const Resource_DiskInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_DiskInfo& default_instance();

  void Swap(Resource_DiskInfo* other);

  // implements Message ----------------------------------------------

  Resource_DiskInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource_DiskInfo& from);
  void MergeFrom(const Resource_DiskInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Resource_DiskInfo_Persistence Persistence;

  // accessors -------------------------------------------------------

  // optional .mesos.Resource.DiskInfo.Persistence persistence = 1;
  inline bool has_persistence() const;
  inline void clear_persistence();
  static const int kPersistenceFieldNumber = 1;
  inline const ::mesos::Resource_DiskInfo_Persistence& persistence() const;
  inline ::mesos::Resource_DiskInfo_Persistence* mutable_persistence();
  inline ::mesos::Resource_DiskInfo_Persistence* release_persistence();
  inline void set_allocated_persistence(::mesos::Resource_DiskInfo_Persistence* persistence);

  // optional .mesos.Volume volume = 2;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 2;
  inline const ::mesos::Volume& volume() const;
  inline ::mesos::Volume* mutable_volume();
  inline ::mesos::Volume* release_volume();
  inline void set_allocated_volume(::mesos::Volume* volume);

  // @@protoc_insertion_point(class_scope:mesos.Resource.DiskInfo)
 private:
  inline void set_has_persistence();
  inline void clear_has_persistence();
  inline void set_has_volume();
  inline void clear_has_volume();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::Resource_DiskInfo_Persistence* persistence_;
  ::mesos::Volume* volume_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Resource_DiskInfo* default_instance_;
};
// -------------------------------------------------------------------

class Resource : public ::google::protobuf::Message {
 public:
  Resource();
  virtual ~Resource();

  Resource(const Resource& from);

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource& default_instance();

  void Swap(Resource* other);

  // implements Message ----------------------------------------------

  Resource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource& from);
  void MergeFrom(const Resource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Resource_DiskInfo DiskInfo;

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .mesos.Value.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mesos::Value_Type type() const;
  inline void set_type(::mesos::Value_Type value);

  // optional .mesos.Value.Scalar scalar = 3;
  inline bool has_scalar() const;
  inline void clear_scalar();
  static const int kScalarFieldNumber = 3;
  inline const ::mesos::Value_Scalar& scalar() const;
  inline ::mesos::Value_Scalar* mutable_scalar();
  inline ::mesos::Value_Scalar* release_scalar();
  inline void set_allocated_scalar(::mesos::Value_Scalar* scalar);

  // optional .mesos.Value.Ranges ranges = 4;
  inline bool has_ranges() const;
  inline void clear_ranges();
  static const int kRangesFieldNumber = 4;
  inline const ::mesos::Value_Ranges& ranges() const;
  inline ::mesos::Value_Ranges* mutable_ranges();
  inline ::mesos::Value_Ranges* release_ranges();
  inline void set_allocated_ranges(::mesos::Value_Ranges* ranges);

  // optional .mesos.Value.Set set = 5;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 5;
  inline const ::mesos::Value_Set& set() const;
  inline ::mesos::Value_Set* mutable_set();
  inline ::mesos::Value_Set* release_set();
  inline void set_allocated_set(::mesos::Value_Set* set);

  // optional string role = 6 [default = "*"];
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 6;
  inline const ::std::string& role() const;
  inline void set_role(const ::std::string& value);
  inline void set_role(const char* value);
  inline void set_role(const char* value, size_t size);
  inline ::std::string* mutable_role();
  inline ::std::string* release_role();
  inline void set_allocated_role(::std::string* role);

  // optional .mesos.Resource.DiskInfo disk = 7;
  inline bool has_disk() const;
  inline void clear_disk();
  static const int kDiskFieldNumber = 7;
  inline const ::mesos::Resource_DiskInfo& disk() const;
  inline ::mesos::Resource_DiskInfo* mutable_disk();
  inline ::mesos::Resource_DiskInfo* release_disk();
  inline void set_allocated_disk(::mesos::Resource_DiskInfo* disk);

  // @@protoc_insertion_point(class_scope:mesos.Resource)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_scalar();
  inline void clear_has_scalar();
  inline void set_has_ranges();
  inline void clear_has_ranges();
  inline void set_has_set();
  inline void clear_has_set();
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_disk();
  inline void clear_has_disk();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::mesos::Value_Scalar* scalar_;
  ::mesos::Value_Ranges* ranges_;
  ::mesos::Value_Set* set_;
  ::std::string* role_;
  static ::std::string* _default_role_;
  ::mesos::Resource_DiskInfo* disk_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Resource* default_instance_;
};
// -------------------------------------------------------------------

class ResourceStatistics : public ::google::protobuf::Message {
 public:
  ResourceStatistics();
  virtual ~ResourceStatistics();

  ResourceStatistics(const ResourceStatistics& from);

  inline ResourceStatistics& operator=(const ResourceStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceStatistics& default_instance();

  void Swap(ResourceStatistics* other);

  // implements Message ----------------------------------------------

  ResourceStatistics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceStatistics& from);
  void MergeFrom(const ResourceStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // optional double cpus_user_time_secs = 2;
  inline bool has_cpus_user_time_secs() const;
  inline void clear_cpus_user_time_secs();
  static const int kCpusUserTimeSecsFieldNumber = 2;
  inline double cpus_user_time_secs() const;
  inline void set_cpus_user_time_secs(double value);

  // optional double cpus_system_time_secs = 3;
  inline bool has_cpus_system_time_secs() const;
  inline void clear_cpus_system_time_secs();
  static const int kCpusSystemTimeSecsFieldNumber = 3;
  inline double cpus_system_time_secs() const;
  inline void set_cpus_system_time_secs(double value);

  // optional double cpus_limit = 4;
  inline bool has_cpus_limit() const;
  inline void clear_cpus_limit();
  static const int kCpusLimitFieldNumber = 4;
  inline double cpus_limit() const;
  inline void set_cpus_limit(double value);

  // optional uint32 cpus_nr_periods = 7;
  inline bool has_cpus_nr_periods() const;
  inline void clear_cpus_nr_periods();
  static const int kCpusNrPeriodsFieldNumber = 7;
  inline ::google::protobuf::uint32 cpus_nr_periods() const;
  inline void set_cpus_nr_periods(::google::protobuf::uint32 value);

  // optional uint32 cpus_nr_throttled = 8;
  inline bool has_cpus_nr_throttled() const;
  inline void clear_cpus_nr_throttled();
  static const int kCpusNrThrottledFieldNumber = 8;
  inline ::google::protobuf::uint32 cpus_nr_throttled() const;
  inline void set_cpus_nr_throttled(::google::protobuf::uint32 value);

  // optional double cpus_throttled_time_secs = 9;
  inline bool has_cpus_throttled_time_secs() const;
  inline void clear_cpus_throttled_time_secs();
  static const int kCpusThrottledTimeSecsFieldNumber = 9;
  inline double cpus_throttled_time_secs() const;
  inline void set_cpus_throttled_time_secs(double value);

  // optional uint64 mem_rss_bytes = 5;
  inline bool has_mem_rss_bytes() const;
  inline void clear_mem_rss_bytes();
  static const int kMemRssBytesFieldNumber = 5;
  inline ::google::protobuf::uint64 mem_rss_bytes() const;
  inline void set_mem_rss_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_limit_bytes = 6;
  inline bool has_mem_limit_bytes() const;
  inline void clear_mem_limit_bytes();
  static const int kMemLimitBytesFieldNumber = 6;
  inline ::google::protobuf::uint64 mem_limit_bytes() const;
  inline void set_mem_limit_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_file_bytes = 10;
  inline bool has_mem_file_bytes() const;
  inline void clear_mem_file_bytes();
  static const int kMemFileBytesFieldNumber = 10;
  inline ::google::protobuf::uint64 mem_file_bytes() const;
  inline void set_mem_file_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_anon_bytes = 11;
  inline bool has_mem_anon_bytes() const;
  inline void clear_mem_anon_bytes();
  static const int kMemAnonBytesFieldNumber = 11;
  inline ::google::protobuf::uint64 mem_anon_bytes() const;
  inline void set_mem_anon_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_mapped_file_bytes = 12;
  inline bool has_mem_mapped_file_bytes() const;
  inline void clear_mem_mapped_file_bytes();
  static const int kMemMappedFileBytesFieldNumber = 12;
  inline ::google::protobuf::uint64 mem_mapped_file_bytes() const;
  inline void set_mem_mapped_file_bytes(::google::protobuf::uint64 value);

  // optional uint64 disk_limit_bytes = 26;
  inline bool has_disk_limit_bytes() const;
  inline void clear_disk_limit_bytes();
  static const int kDiskLimitBytesFieldNumber = 26;
  inline ::google::protobuf::uint64 disk_limit_bytes() const;
  inline void set_disk_limit_bytes(::google::protobuf::uint64 value);

  // optional uint64 disk_used_bytes = 27;
  inline bool has_disk_used_bytes() const;
  inline void clear_disk_used_bytes();
  static const int kDiskUsedBytesFieldNumber = 27;
  inline ::google::protobuf::uint64 disk_used_bytes() const;
  inline void set_disk_used_bytes(::google::protobuf::uint64 value);

  // optional .mesos.PerfStatistics perf = 13;
  inline bool has_perf() const;
  inline void clear_perf();
  static const int kPerfFieldNumber = 13;
  inline const ::mesos::PerfStatistics& perf() const;
  inline ::mesos::PerfStatistics* mutable_perf();
  inline ::mesos::PerfStatistics* release_perf();
  inline void set_allocated_perf(::mesos::PerfStatistics* perf);

  // optional uint64 net_rx_packets = 14;
  inline bool has_net_rx_packets() const;
  inline void clear_net_rx_packets();
  static const int kNetRxPacketsFieldNumber = 14;
  inline ::google::protobuf::uint64 net_rx_packets() const;
  inline void set_net_rx_packets(::google::protobuf::uint64 value);

  // optional uint64 net_rx_bytes = 15;
  inline bool has_net_rx_bytes() const;
  inline void clear_net_rx_bytes();
  static const int kNetRxBytesFieldNumber = 15;
  inline ::google::protobuf::uint64 net_rx_bytes() const;
  inline void set_net_rx_bytes(::google::protobuf::uint64 value);

  // optional uint64 net_rx_errors = 16;
  inline bool has_net_rx_errors() const;
  inline void clear_net_rx_errors();
  static const int kNetRxErrorsFieldNumber = 16;
  inline ::google::protobuf::uint64 net_rx_errors() const;
  inline void set_net_rx_errors(::google::protobuf::uint64 value);

  // optional uint64 net_rx_dropped = 17;
  inline bool has_net_rx_dropped() const;
  inline void clear_net_rx_dropped();
  static const int kNetRxDroppedFieldNumber = 17;
  inline ::google::protobuf::uint64 net_rx_dropped() const;
  inline void set_net_rx_dropped(::google::protobuf::uint64 value);

  // optional uint64 net_tx_packets = 18;
  inline bool has_net_tx_packets() const;
  inline void clear_net_tx_packets();
  static const int kNetTxPacketsFieldNumber = 18;
  inline ::google::protobuf::uint64 net_tx_packets() const;
  inline void set_net_tx_packets(::google::protobuf::uint64 value);

  // optional uint64 net_tx_bytes = 19;
  inline bool has_net_tx_bytes() const;
  inline void clear_net_tx_bytes();
  static const int kNetTxBytesFieldNumber = 19;
  inline ::google::protobuf::uint64 net_tx_bytes() const;
  inline void set_net_tx_bytes(::google::protobuf::uint64 value);

  // optional uint64 net_tx_errors = 20;
  inline bool has_net_tx_errors() const;
  inline void clear_net_tx_errors();
  static const int kNetTxErrorsFieldNumber = 20;
  inline ::google::protobuf::uint64 net_tx_errors() const;
  inline void set_net_tx_errors(::google::protobuf::uint64 value);

  // optional uint64 net_tx_dropped = 21;
  inline bool has_net_tx_dropped() const;
  inline void clear_net_tx_dropped();
  static const int kNetTxDroppedFieldNumber = 21;
  inline ::google::protobuf::uint64 net_tx_dropped() const;
  inline void set_net_tx_dropped(::google::protobuf::uint64 value);

  // optional double net_tcp_rtt_microsecs_p50 = 22;
  inline bool has_net_tcp_rtt_microsecs_p50() const;
  inline void clear_net_tcp_rtt_microsecs_p50();
  static const int kNetTcpRttMicrosecsP50FieldNumber = 22;
  inline double net_tcp_rtt_microsecs_p50() const;
  inline void set_net_tcp_rtt_microsecs_p50(double value);

  // optional double net_tcp_rtt_microsecs_p90 = 23;
  inline bool has_net_tcp_rtt_microsecs_p90() const;
  inline void clear_net_tcp_rtt_microsecs_p90();
  static const int kNetTcpRttMicrosecsP90FieldNumber = 23;
  inline double net_tcp_rtt_microsecs_p90() const;
  inline void set_net_tcp_rtt_microsecs_p90(double value);

  // optional double net_tcp_rtt_microsecs_p95 = 24;
  inline bool has_net_tcp_rtt_microsecs_p95() const;
  inline void clear_net_tcp_rtt_microsecs_p95();
  static const int kNetTcpRttMicrosecsP95FieldNumber = 24;
  inline double net_tcp_rtt_microsecs_p95() const;
  inline void set_net_tcp_rtt_microsecs_p95(double value);

  // optional double net_tcp_rtt_microsecs_p99 = 25;
  inline bool has_net_tcp_rtt_microsecs_p99() const;
  inline void clear_net_tcp_rtt_microsecs_p99();
  static const int kNetTcpRttMicrosecsP99FieldNumber = 25;
  inline double net_tcp_rtt_microsecs_p99() const;
  inline void set_net_tcp_rtt_microsecs_p99(double value);

  // optional double net_tcp_active_connections = 28;
  inline bool has_net_tcp_active_connections() const;
  inline void clear_net_tcp_active_connections();
  static const int kNetTcpActiveConnectionsFieldNumber = 28;
  inline double net_tcp_active_connections() const;
  inline void set_net_tcp_active_connections(double value);

  // optional double net_tcp_time_wait_connections = 29;
  inline bool has_net_tcp_time_wait_connections() const;
  inline void clear_net_tcp_time_wait_connections();
  static const int kNetTcpTimeWaitConnectionsFieldNumber = 29;
  inline double net_tcp_time_wait_connections() const;
  inline void set_net_tcp_time_wait_connections(double value);

  // @@protoc_insertion_point(class_scope:mesos.ResourceStatistics)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_cpus_user_time_secs();
  inline void clear_has_cpus_user_time_secs();
  inline void set_has_cpus_system_time_secs();
  inline void clear_has_cpus_system_time_secs();
  inline void set_has_cpus_limit();
  inline void clear_has_cpus_limit();
  inline void set_has_cpus_nr_periods();
  inline void clear_has_cpus_nr_periods();
  inline void set_has_cpus_nr_throttled();
  inline void clear_has_cpus_nr_throttled();
  inline void set_has_cpus_throttled_time_secs();
  inline void clear_has_cpus_throttled_time_secs();
  inline void set_has_mem_rss_bytes();
  inline void clear_has_mem_rss_bytes();
  inline void set_has_mem_limit_bytes();
  inline void clear_has_mem_limit_bytes();
  inline void set_has_mem_file_bytes();
  inline void clear_has_mem_file_bytes();
  inline void set_has_mem_anon_bytes();
  inline void clear_has_mem_anon_bytes();
  inline void set_has_mem_mapped_file_bytes();
  inline void clear_has_mem_mapped_file_bytes();
  inline void set_has_disk_limit_bytes();
  inline void clear_has_disk_limit_bytes();
  inline void set_has_disk_used_bytes();
  inline void clear_has_disk_used_bytes();
  inline void set_has_perf();
  inline void clear_has_perf();
  inline void set_has_net_rx_packets();
  inline void clear_has_net_rx_packets();
  inline void set_has_net_rx_bytes();
  inline void clear_has_net_rx_bytes();
  inline void set_has_net_rx_errors();
  inline void clear_has_net_rx_errors();
  inline void set_has_net_rx_dropped();
  inline void clear_has_net_rx_dropped();
  inline void set_has_net_tx_packets();
  inline void clear_has_net_tx_packets();
  inline void set_has_net_tx_bytes();
  inline void clear_has_net_tx_bytes();
  inline void set_has_net_tx_errors();
  inline void clear_has_net_tx_errors();
  inline void set_has_net_tx_dropped();
  inline void clear_has_net_tx_dropped();
  inline void set_has_net_tcp_rtt_microsecs_p50();
  inline void clear_has_net_tcp_rtt_microsecs_p50();
  inline void set_has_net_tcp_rtt_microsecs_p90();
  inline void clear_has_net_tcp_rtt_microsecs_p90();
  inline void set_has_net_tcp_rtt_microsecs_p95();
  inline void clear_has_net_tcp_rtt_microsecs_p95();
  inline void set_has_net_tcp_rtt_microsecs_p99();
  inline void clear_has_net_tcp_rtt_microsecs_p99();
  inline void set_has_net_tcp_active_connections();
  inline void clear_has_net_tcp_active_connections();
  inline void set_has_net_tcp_time_wait_connections();
  inline void clear_has_net_tcp_time_wait_connections();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double timestamp_;
  double cpus_user_time_secs_;
  double cpus_system_time_secs_;
  double cpus_limit_;
  ::google::protobuf::uint32 cpus_nr_periods_;
  ::google::protobuf::uint32 cpus_nr_throttled_;
  double cpus_throttled_time_secs_;
  ::google::protobuf::uint64 mem_rss_bytes_;
  ::google::protobuf::uint64 mem_limit_bytes_;
  ::google::protobuf::uint64 mem_file_bytes_;
  ::google::protobuf::uint64 mem_anon_bytes_;
  ::google::protobuf::uint64 mem_mapped_file_bytes_;
  ::google::protobuf::uint64 disk_limit_bytes_;
  ::google::protobuf::uint64 disk_used_bytes_;
  ::mesos::PerfStatistics* perf_;
  ::google::protobuf::uint64 net_rx_packets_;
  ::google::protobuf::uint64 net_rx_bytes_;
  ::google::protobuf::uint64 net_rx_errors_;
  ::google::protobuf::uint64 net_rx_dropped_;
  ::google::protobuf::uint64 net_tx_packets_;
  ::google::protobuf::uint64 net_tx_bytes_;
  ::google::protobuf::uint64 net_tx_errors_;
  ::google::protobuf::uint64 net_tx_dropped_;
  double net_tcp_rtt_microsecs_p50_;
  double net_tcp_rtt_microsecs_p90_;
  double net_tcp_rtt_microsecs_p95_;
  double net_tcp_rtt_microsecs_p99_;
  double net_tcp_active_connections_;
  double net_tcp_time_wait_connections_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(29 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static ResourceStatistics* default_instance_;
};
// -------------------------------------------------------------------

class ResourceUsage : public ::google::protobuf::Message {
 public:
  ResourceUsage();
  virtual ~ResourceUsage();

  ResourceUsage(const ResourceUsage& from);

  inline ResourceUsage& operator=(const ResourceUsage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceUsage& default_instance();

  void Swap(ResourceUsage* other);

  // implements Message ----------------------------------------------

  ResourceUsage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceUsage& from);
  void MergeFrom(const ResourceUsage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // optional .mesos.ExecutorID executor_id = 3;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 3;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // optional string executor_name = 4;
  inline bool has_executor_name() const;
  inline void clear_executor_name();
  static const int kExecutorNameFieldNumber = 4;
  inline const ::std::string& executor_name() const;
  inline void set_executor_name(const ::std::string& value);
  inline void set_executor_name(const char* value);
  inline void set_executor_name(const char* value, size_t size);
  inline ::std::string* mutable_executor_name();
  inline ::std::string* release_executor_name();
  inline void set_allocated_executor_name(::std::string* executor_name);

  // optional .mesos.TaskID task_id = 5;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 5;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // optional .mesos.ResourceStatistics statistics = 6;
  inline bool has_statistics() const;
  inline void clear_statistics();
  static const int kStatisticsFieldNumber = 6;
  inline const ::mesos::ResourceStatistics& statistics() const;
  inline ::mesos::ResourceStatistics* mutable_statistics();
  inline ::mesos::ResourceStatistics* release_statistics();
  inline void set_allocated_statistics(::mesos::ResourceStatistics* statistics);

  // @@protoc_insertion_point(class_scope:mesos.ResourceUsage)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_executor_name();
  inline void clear_has_executor_name();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_statistics();
  inline void clear_has_statistics();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::std::string* executor_name_;
  ::mesos::TaskID* task_id_;
  ::mesos::ResourceStatistics* statistics_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static ResourceUsage* default_instance_;
};
// -------------------------------------------------------------------

class PerfStatistics : public ::google::protobuf::Message {
 public:
  PerfStatistics();
  virtual ~PerfStatistics();

  PerfStatistics(const PerfStatistics& from);

  inline PerfStatistics& operator=(const PerfStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PerfStatistics& default_instance();

  void Swap(PerfStatistics* other);

  // implements Message ----------------------------------------------

  PerfStatistics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PerfStatistics& from);
  void MergeFrom(const PerfStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // required double duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline double duration() const;
  inline void set_duration(double value);

  // optional uint64 cycles = 3;
  inline bool has_cycles() const;
  inline void clear_cycles();
  static const int kCyclesFieldNumber = 3;
  inline ::google::protobuf::uint64 cycles() const;
  inline void set_cycles(::google::protobuf::uint64 value);

  // optional uint64 stalled_cycles_frontend = 4;
  inline bool has_stalled_cycles_frontend() const;
  inline void clear_stalled_cycles_frontend();
  static const int kStalledCyclesFrontendFieldNumber = 4;
  inline ::google::protobuf::uint64 stalled_cycles_frontend() const;
  inline void set_stalled_cycles_frontend(::google::protobuf::uint64 value);

  // optional uint64 stalled_cycles_backend = 5;
  inline bool has_stalled_cycles_backend() const;
  inline void clear_stalled_cycles_backend();
  static const int kStalledCyclesBackendFieldNumber = 5;
  inline ::google::protobuf::uint64 stalled_cycles_backend() const;
  inline void set_stalled_cycles_backend(::google::protobuf::uint64 value);

  // optional uint64 instructions = 6;
  inline bool has_instructions() const;
  inline void clear_instructions();
  static const int kInstructionsFieldNumber = 6;
  inline ::google::protobuf::uint64 instructions() const;
  inline void set_instructions(::google::protobuf::uint64 value);

  // optional uint64 cache_references = 7;
  inline bool has_cache_references() const;
  inline void clear_cache_references();
  static const int kCacheReferencesFieldNumber = 7;
  inline ::google::protobuf::uint64 cache_references() const;
  inline void set_cache_references(::google::protobuf::uint64 value);

  // optional uint64 cache_misses = 8;
  inline bool has_cache_misses() const;
  inline void clear_cache_misses();
  static const int kCacheMissesFieldNumber = 8;
  inline ::google::protobuf::uint64 cache_misses() const;
  inline void set_cache_misses(::google::protobuf::uint64 value);

  // optional uint64 branches = 9;
  inline bool has_branches() const;
  inline void clear_branches();
  static const int kBranchesFieldNumber = 9;
  inline ::google::protobuf::uint64 branches() const;
  inline void set_branches(::google::protobuf::uint64 value);

  // optional uint64 branch_misses = 10;
  inline bool has_branch_misses() const;
  inline void clear_branch_misses();
  static const int kBranchMissesFieldNumber = 10;
  inline ::google::protobuf::uint64 branch_misses() const;
  inline void set_branch_misses(::google::protobuf::uint64 value);

  // optional uint64 bus_cycles = 11;
  inline bool has_bus_cycles() const;
  inline void clear_bus_cycles();
  static const int kBusCyclesFieldNumber = 11;
  inline ::google::protobuf::uint64 bus_cycles() const;
  inline void set_bus_cycles(::google::protobuf::uint64 value);

  // optional uint64 ref_cycles = 12;
  inline bool has_ref_cycles() const;
  inline void clear_ref_cycles();
  static const int kRefCyclesFieldNumber = 12;
  inline ::google::protobuf::uint64 ref_cycles() const;
  inline void set_ref_cycles(::google::protobuf::uint64 value);

  // optional double cpu_clock = 13;
  inline bool has_cpu_clock() const;
  inline void clear_cpu_clock();
  static const int kCpuClockFieldNumber = 13;
  inline double cpu_clock() const;
  inline void set_cpu_clock(double value);

  // optional double task_clock = 14;
  inline bool has_task_clock() const;
  inline void clear_task_clock();
  static const int kTaskClockFieldNumber = 14;
  inline double task_clock() const;
  inline void set_task_clock(double value);

  // optional uint64 page_faults = 15;
  inline bool has_page_faults() const;
  inline void clear_page_faults();
  static const int kPageFaultsFieldNumber = 15;
  inline ::google::protobuf::uint64 page_faults() const;
  inline void set_page_faults(::google::protobuf::uint64 value);

  // optional uint64 minor_faults = 16;
  inline bool has_minor_faults() const;
  inline void clear_minor_faults();
  static const int kMinorFaultsFieldNumber = 16;
  inline ::google::protobuf::uint64 minor_faults() const;
  inline void set_minor_faults(::google::protobuf::uint64 value);

  // optional uint64 major_faults = 17;
  inline bool has_major_faults() const;
  inline void clear_major_faults();
  static const int kMajorFaultsFieldNumber = 17;
  inline ::google::protobuf::uint64 major_faults() const;
  inline void set_major_faults(::google::protobuf::uint64 value);

  // optional uint64 context_switches = 18;
  inline bool has_context_switches() const;
  inline void clear_context_switches();
  static const int kContextSwitchesFieldNumber = 18;
  inline ::google::protobuf::uint64 context_switches() const;
  inline void set_context_switches(::google::protobuf::uint64 value);

  // optional uint64 cpu_migrations = 19;
  inline bool has_cpu_migrations() const;
  inline void clear_cpu_migrations();
  static const int kCpuMigrationsFieldNumber = 19;
  inline ::google::protobuf::uint64 cpu_migrations() const;
  inline void set_cpu_migrations(::google::protobuf::uint64 value);

  // optional uint64 alignment_faults = 20;
  inline bool has_alignment_faults() const;
  inline void clear_alignment_faults();
  static const int kAlignmentFaultsFieldNumber = 20;
  inline ::google::protobuf::uint64 alignment_faults() const;
  inline void set_alignment_faults(::google::protobuf::uint64 value);

  // optional uint64 emulation_faults = 21;
  inline bool has_emulation_faults() const;
  inline void clear_emulation_faults();
  static const int kEmulationFaultsFieldNumber = 21;
  inline ::google::protobuf::uint64 emulation_faults() const;
  inline void set_emulation_faults(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_loads = 22;
  inline bool has_l1_dcache_loads() const;
  inline void clear_l1_dcache_loads();
  static const int kL1DcacheLoadsFieldNumber = 22;
  inline ::google::protobuf::uint64 l1_dcache_loads() const;
  inline void set_l1_dcache_loads(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_load_misses = 23;
  inline bool has_l1_dcache_load_misses() const;
  inline void clear_l1_dcache_load_misses();
  static const int kL1DcacheLoadMissesFieldNumber = 23;
  inline ::google::protobuf::uint64 l1_dcache_load_misses() const;
  inline void set_l1_dcache_load_misses(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_stores = 24;
  inline bool has_l1_dcache_stores() const;
  inline void clear_l1_dcache_stores();
  static const int kL1DcacheStoresFieldNumber = 24;
  inline ::google::protobuf::uint64 l1_dcache_stores() const;
  inline void set_l1_dcache_stores(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_store_misses = 25;
  inline bool has_l1_dcache_store_misses() const;
  inline void clear_l1_dcache_store_misses();
  static const int kL1DcacheStoreMissesFieldNumber = 25;
  inline ::google::protobuf::uint64 l1_dcache_store_misses() const;
  inline void set_l1_dcache_store_misses(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_prefetches = 26;
  inline bool has_l1_dcache_prefetches() const;
  inline void clear_l1_dcache_prefetches();
  static const int kL1DcachePrefetchesFieldNumber = 26;
  inline ::google::protobuf::uint64 l1_dcache_prefetches() const;
  inline void set_l1_dcache_prefetches(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_prefetch_misses = 27;
  inline bool has_l1_dcache_prefetch_misses() const;
  inline void clear_l1_dcache_prefetch_misses();
  static const int kL1DcachePrefetchMissesFieldNumber = 27;
  inline ::google::protobuf::uint64 l1_dcache_prefetch_misses() const;
  inline void set_l1_dcache_prefetch_misses(::google::protobuf::uint64 value);

  // optional uint64 l1_icache_loads = 28;
  inline bool has_l1_icache_loads() const;
  inline void clear_l1_icache_loads();
  static const int kL1IcacheLoadsFieldNumber = 28;
  inline ::google::protobuf::uint64 l1_icache_loads() const;
  inline void set_l1_icache_loads(::google::protobuf::uint64 value);

  // optional uint64 l1_icache_load_misses = 29;
  inline bool has_l1_icache_load_misses() const;
  inline void clear_l1_icache_load_misses();
  static const int kL1IcacheLoadMissesFieldNumber = 29;
  inline ::google::protobuf::uint64 l1_icache_load_misses() const;
  inline void set_l1_icache_load_misses(::google::protobuf::uint64 value);

  // optional uint64 l1_icache_prefetches = 30;
  inline bool has_l1_icache_prefetches() const;
  inline void clear_l1_icache_prefetches();
  static const int kL1IcachePrefetchesFieldNumber = 30;
  inline ::google::protobuf::uint64 l1_icache_prefetches() const;
  inline void set_l1_icache_prefetches(::google::protobuf::uint64 value);

  // optional uint64 l1_icache_prefetch_misses = 31;
  inline bool has_l1_icache_prefetch_misses() const;
  inline void clear_l1_icache_prefetch_misses();
  static const int kL1IcachePrefetchMissesFieldNumber = 31;
  inline ::google::protobuf::uint64 l1_icache_prefetch_misses() const;
  inline void set_l1_icache_prefetch_misses(::google::protobuf::uint64 value);

  // optional uint64 llc_loads = 32;
  inline bool has_llc_loads() const;
  inline void clear_llc_loads();
  static const int kLlcLoadsFieldNumber = 32;
  inline ::google::protobuf::uint64 llc_loads() const;
  inline void set_llc_loads(::google::protobuf::uint64 value);

  // optional uint64 llc_load_misses = 33;
  inline bool has_llc_load_misses() const;
  inline void clear_llc_load_misses();
  static const int kLlcLoadMissesFieldNumber = 33;
  inline ::google::protobuf::uint64 llc_load_misses() const;
  inline void set_llc_load_misses(::google::protobuf::uint64 value);

  // optional uint64 llc_stores = 34;
  inline bool has_llc_stores() const;
  inline void clear_llc_stores();
  static const int kLlcStoresFieldNumber = 34;
  inline ::google::protobuf::uint64 llc_stores() const;
  inline void set_llc_stores(::google::protobuf::uint64 value);

  // optional uint64 llc_store_misses = 35;
  inline bool has_llc_store_misses() const;
  inline void clear_llc_store_misses();
  static const int kLlcStoreMissesFieldNumber = 35;
  inline ::google::protobuf::uint64 llc_store_misses() const;
  inline void set_llc_store_misses(::google::protobuf::uint64 value);

  // optional uint64 llc_prefetches = 36;
  inline bool has_llc_prefetches() const;
  inline void clear_llc_prefetches();
  static const int kLlcPrefetchesFieldNumber = 36;
  inline ::google::protobuf::uint64 llc_prefetches() const;
  inline void set_llc_prefetches(::google::protobuf::uint64 value);

  // optional uint64 llc_prefetch_misses = 37;
  inline bool has_llc_prefetch_misses() const;
  inline void clear_llc_prefetch_misses();
  static const int kLlcPrefetchMissesFieldNumber = 37;
  inline ::google::protobuf::uint64 llc_prefetch_misses() const;
  inline void set_llc_prefetch_misses(::google::protobuf::uint64 value);

  // optional uint64 dtlb_loads = 38;
  inline bool has_dtlb_loads() const;
  inline void clear_dtlb_loads();
  static const int kDtlbLoadsFieldNumber = 38;
  inline ::google::protobuf::uint64 dtlb_loads() const;
  inline void set_dtlb_loads(::google::protobuf::uint64 value);

  // optional uint64 dtlb_load_misses = 39;
  inline bool has_dtlb_load_misses() const;
  inline void clear_dtlb_load_misses();
  static const int kDtlbLoadMissesFieldNumber = 39;
  inline ::google::protobuf::uint64 dtlb_load_misses() const;
  inline void set_dtlb_load_misses(::google::protobuf::uint64 value);

  // optional uint64 dtlb_stores = 40;
  inline bool has_dtlb_stores() const;
  inline void clear_dtlb_stores();
  static const int kDtlbStoresFieldNumber = 40;
  inline ::google::protobuf::uint64 dtlb_stores() const;
  inline void set_dtlb_stores(::google::protobuf::uint64 value);

  // optional uint64 dtlb_store_misses = 41;
  inline bool has_dtlb_store_misses() const;
  inline void clear_dtlb_store_misses();
  static const int kDtlbStoreMissesFieldNumber = 41;
  inline ::google::protobuf::uint64 dtlb_store_misses() const;
  inline void set_dtlb_store_misses(::google::protobuf::uint64 value);

  // optional uint64 dtlb_prefetches = 42;
  inline bool has_dtlb_prefetches() const;
  inline void clear_dtlb_prefetches();
  static const int kDtlbPrefetchesFieldNumber = 42;
  inline ::google::protobuf::uint64 dtlb_prefetches() const;
  inline void set_dtlb_prefetches(::google::protobuf::uint64 value);

  // optional uint64 dtlb_prefetch_misses = 43;
  inline bool has_dtlb_prefetch_misses() const;
  inline void clear_dtlb_prefetch_misses();
  static const int kDtlbPrefetchMissesFieldNumber = 43;
  inline ::google::protobuf::uint64 dtlb_prefetch_misses() const;
  inline void set_dtlb_prefetch_misses(::google::protobuf::uint64 value);

  // optional uint64 itlb_loads = 44;
  inline bool has_itlb_loads() const;
  inline void clear_itlb_loads();
  static const int kItlbLoadsFieldNumber = 44;
  inline ::google::protobuf::uint64 itlb_loads() const;
  inline void set_itlb_loads(::google::protobuf::uint64 value);

  // optional uint64 itlb_load_misses = 45;
  inline bool has_itlb_load_misses() const;
  inline void clear_itlb_load_misses();
  static const int kItlbLoadMissesFieldNumber = 45;
  inline ::google::protobuf::uint64 itlb_load_misses() const;
  inline void set_itlb_load_misses(::google::protobuf::uint64 value);

  // optional uint64 branch_loads = 46;
  inline bool has_branch_loads() const;
  inline void clear_branch_loads();
  static const int kBranchLoadsFieldNumber = 46;
  inline ::google::protobuf::uint64 branch_loads() const;
  inline void set_branch_loads(::google::protobuf::uint64 value);

  // optional uint64 branch_load_misses = 47;
  inline bool has_branch_load_misses() const;
  inline void clear_branch_load_misses();
  static const int kBranchLoadMissesFieldNumber = 47;
  inline ::google::protobuf::uint64 branch_load_misses() const;
  inline void set_branch_load_misses(::google::protobuf::uint64 value);

  // optional uint64 node_loads = 48;
  inline bool has_node_loads() const;
  inline void clear_node_loads();
  static const int kNodeLoadsFieldNumber = 48;
  inline ::google::protobuf::uint64 node_loads() const;
  inline void set_node_loads(::google::protobuf::uint64 value);

  // optional uint64 node_load_misses = 49;
  inline bool has_node_load_misses() const;
  inline void clear_node_load_misses();
  static const int kNodeLoadMissesFieldNumber = 49;
  inline ::google::protobuf::uint64 node_load_misses() const;
  inline void set_node_load_misses(::google::protobuf::uint64 value);

  // optional uint64 node_stores = 50;
  inline bool has_node_stores() const;
  inline void clear_node_stores();
  static const int kNodeStoresFieldNumber = 50;
  inline ::google::protobuf::uint64 node_stores() const;
  inline void set_node_stores(::google::protobuf::uint64 value);

  // optional uint64 node_store_misses = 51;
  inline bool has_node_store_misses() const;
  inline void clear_node_store_misses();
  static const int kNodeStoreMissesFieldNumber = 51;
  inline ::google::protobuf::uint64 node_store_misses() const;
  inline void set_node_store_misses(::google::protobuf::uint64 value);

  // optional uint64 node_prefetches = 52;
  inline bool has_node_prefetches() const;
  inline void clear_node_prefetches();
  static const int kNodePrefetchesFieldNumber = 52;
  inline ::google::protobuf::uint64 node_prefetches() const;
  inline void set_node_prefetches(::google::protobuf::uint64 value);

  // optional uint64 node_prefetch_misses = 53;
  inline bool has_node_prefetch_misses() const;
  inline void clear_node_prefetch_misses();
  static const int kNodePrefetchMissesFieldNumber = 53;
  inline ::google::protobuf::uint64 node_prefetch_misses() const;
  inline void set_node_prefetch_misses(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.PerfStatistics)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_cycles();
  inline void clear_has_cycles();
  inline void set_has_stalled_cycles_frontend();
  inline void clear_has_stalled_cycles_frontend();
  inline void set_has_stalled_cycles_backend();
  inline void clear_has_stalled_cycles_backend();
  inline void set_has_instructions();
  inline void clear_has_instructions();
  inline void set_has_cache_references();
  inline void clear_has_cache_references();
  inline void set_has_cache_misses();
  inline void clear_has_cache_misses();
  inline void set_has_branches();
  inline void clear_has_branches();
  inline void set_has_branch_misses();
  inline void clear_has_branch_misses();
  inline void set_has_bus_cycles();
  inline void clear_has_bus_cycles();
  inline void set_has_ref_cycles();
  inline void clear_has_ref_cycles();
  inline void set_has_cpu_clock();
  inline void clear_has_cpu_clock();
  inline void set_has_task_clock();
  inline void clear_has_task_clock();
  inline void set_has_page_faults();
  inline void clear_has_page_faults();
  inline void set_has_minor_faults();
  inline void clear_has_minor_faults();
  inline void set_has_major_faults();
  inline void clear_has_major_faults();
  inline void set_has_context_switches();
  inline void clear_has_context_switches();
  inline void set_has_cpu_migrations();
  inline void clear_has_cpu_migrations();
  inline void set_has_alignment_faults();
  inline void clear_has_alignment_faults();
  inline void set_has_emulation_faults();
  inline void clear_has_emulation_faults();
  inline void set_has_l1_dcache_loads();
  inline void clear_has_l1_dcache_loads();
  inline void set_has_l1_dcache_load_misses();
  inline void clear_has_l1_dcache_load_misses();
  inline void set_has_l1_dcache_stores();
  inline void clear_has_l1_dcache_stores();
  inline void set_has_l1_dcache_store_misses();
  inline void clear_has_l1_dcache_store_misses();
  inline void set_has_l1_dcache_prefetches();
  inline void clear_has_l1_dcache_prefetches();
  inline void set_has_l1_dcache_prefetch_misses();
  inline void clear_has_l1_dcache_prefetch_misses();
  inline void set_has_l1_icache_loads();
  inline void clear_has_l1_icache_loads();
  inline void set_has_l1_icache_load_misses();
  inline void clear_has_l1_icache_load_misses();
  inline void set_has_l1_icache_prefetches();
  inline void clear_has_l1_icache_prefetches();
  inline void set_has_l1_icache_prefetch_misses();
  inline void clear_has_l1_icache_prefetch_misses();
  inline void set_has_llc_loads();
  inline void clear_has_llc_loads();
  inline void set_has_llc_load_misses();
  inline void clear_has_llc_load_misses();
  inline void set_has_llc_stores();
  inline void clear_has_llc_stores();
  inline void set_has_llc_store_misses();
  inline void clear_has_llc_store_misses();
  inline void set_has_llc_prefetches();
  inline void clear_has_llc_prefetches();
  inline void set_has_llc_prefetch_misses();
  inline void clear_has_llc_prefetch_misses();
  inline void set_has_dtlb_loads();
  inline void clear_has_dtlb_loads();
  inline void set_has_dtlb_load_misses();
  inline void clear_has_dtlb_load_misses();
  inline void set_has_dtlb_stores();
  inline void clear_has_dtlb_stores();
  inline void set_has_dtlb_store_misses();
  inline void clear_has_dtlb_store_misses();
  inline void set_has_dtlb_prefetches();
  inline void clear_has_dtlb_prefetches();
  inline void set_has_dtlb_prefetch_misses();
  inline void clear_has_dtlb_prefetch_misses();
  inline void set_has_itlb_loads();
  inline void clear_has_itlb_loads();
  inline void set_has_itlb_load_misses();
  inline void clear_has_itlb_load_misses();
  inline void set_has_branch_loads();
  inline void clear_has_branch_loads();
  inline void set_has_branch_load_misses();
  inline void clear_has_branch_load_misses();
  inline void set_has_node_loads();
  inline void clear_has_node_loads();
  inline void set_has_node_load_misses();
  inline void clear_has_node_load_misses();
  inline void set_has_node_stores();
  inline void clear_has_node_stores();
  inline void set_has_node_store_misses();
  inline void clear_has_node_store_misses();
  inline void set_has_node_prefetches();
  inline void clear_has_node_prefetches();
  inline void set_has_node_prefetch_misses();
  inline void clear_has_node_prefetch_misses();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double timestamp_;
  double duration_;
  ::google::protobuf::uint64 cycles_;
  ::google::protobuf::uint64 stalled_cycles_frontend_;
  ::google::protobuf::uint64 stalled_cycles_backend_;
  ::google::protobuf::uint64 instructions_;
  ::google::protobuf::uint64 cache_references_;
  ::google::protobuf::uint64 cache_misses_;
  ::google::protobuf::uint64 branches_;
  ::google::protobuf::uint64 branch_misses_;
  ::google::protobuf::uint64 bus_cycles_;
  ::google::protobuf::uint64 ref_cycles_;
  double cpu_clock_;
  double task_clock_;
  ::google::protobuf::uint64 page_faults_;
  ::google::protobuf::uint64 minor_faults_;
  ::google::protobuf::uint64 major_faults_;
  ::google::protobuf::uint64 context_switches_;
  ::google::protobuf::uint64 cpu_migrations_;
  ::google::protobuf::uint64 alignment_faults_;
  ::google::protobuf::uint64 emulation_faults_;
  ::google::protobuf::uint64 l1_dcache_loads_;
  ::google::protobuf::uint64 l1_dcache_load_misses_;
  ::google::protobuf::uint64 l1_dcache_stores_;
  ::google::protobuf::uint64 l1_dcache_store_misses_;
  ::google::protobuf::uint64 l1_dcache_prefetches_;
  ::google::protobuf::uint64 l1_dcache_prefetch_misses_;
  ::google::protobuf::uint64 l1_icache_loads_;
  ::google::protobuf::uint64 l1_icache_load_misses_;
  ::google::protobuf::uint64 l1_icache_prefetches_;
  ::google::protobuf::uint64 l1_icache_prefetch_misses_;
  ::google::protobuf::uint64 llc_loads_;
  ::google::protobuf::uint64 llc_load_misses_;
  ::google::protobuf::uint64 llc_stores_;
  ::google::protobuf::uint64 llc_store_misses_;
  ::google::protobuf::uint64 llc_prefetches_;
  ::google::protobuf::uint64 llc_prefetch_misses_;
  ::google::protobuf::uint64 dtlb_loads_;
  ::google::protobuf::uint64 dtlb_load_misses_;
  ::google::protobuf::uint64 dtlb_stores_;
  ::google::protobuf::uint64 dtlb_store_misses_;
  ::google::protobuf::uint64 dtlb_prefetches_;
  ::google::protobuf::uint64 dtlb_prefetch_misses_;
  ::google::protobuf::uint64 itlb_loads_;
  ::google::protobuf::uint64 itlb_load_misses_;
  ::google::protobuf::uint64 branch_loads_;
  ::google::protobuf::uint64 branch_load_misses_;
  ::google::protobuf::uint64 node_loads_;
  ::google::protobuf::uint64 node_load_misses_;
  ::google::protobuf::uint64 node_stores_;
  ::google::protobuf::uint64 node_store_misses_;
  ::google::protobuf::uint64 node_prefetches_;
  ::google::protobuf::uint64 node_prefetch_misses_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(53 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static PerfStatistics* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // repeated .mesos.Resource resources = 2;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 2;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // @@protoc_insertion_point(class_scope:mesos.Request)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Offer_Operation_Launch : public ::google::protobuf::Message {
 public:
  Offer_Operation_Launch();
  virtual ~Offer_Operation_Launch();

  Offer_Operation_Launch(const Offer_Operation_Launch& from);

  inline Offer_Operation_Launch& operator=(const Offer_Operation_Launch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_Launch& default_instance();

  void Swap(Offer_Operation_Launch* other);

  // implements Message ----------------------------------------------

  Offer_Operation_Launch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer_Operation_Launch& from);
  void MergeFrom(const Offer_Operation_Launch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.TaskInfo task_infos = 1;
  inline int task_infos_size() const;
  inline void clear_task_infos();
  static const int kTaskInfosFieldNumber = 1;
  inline const ::mesos::TaskInfo& task_infos(int index) const;
  inline ::mesos::TaskInfo* mutable_task_infos(int index);
  inline ::mesos::TaskInfo* add_task_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
      task_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
      mutable_task_infos();

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.Launch)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo > task_infos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Offer_Operation_Launch* default_instance_;
};
// -------------------------------------------------------------------

class Offer_Operation_Reserve : public ::google::protobuf::Message {
 public:
  Offer_Operation_Reserve();
  virtual ~Offer_Operation_Reserve();

  Offer_Operation_Reserve(const Offer_Operation_Reserve& from);

  inline Offer_Operation_Reserve& operator=(const Offer_Operation_Reserve& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_Reserve& default_instance();

  void Swap(Offer_Operation_Reserve* other);

  // implements Message ----------------------------------------------

  Offer_Operation_Reserve* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer_Operation_Reserve& from);
  void MergeFrom(const Offer_Operation_Reserve& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 1;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 1;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.Reserve)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Offer_Operation_Reserve* default_instance_;
};
// -------------------------------------------------------------------

class Offer_Operation_Unreserve : public ::google::protobuf::Message {
 public:
  Offer_Operation_Unreserve();
  virtual ~Offer_Operation_Unreserve();

  Offer_Operation_Unreserve(const Offer_Operation_Unreserve& from);

  inline Offer_Operation_Unreserve& operator=(const Offer_Operation_Unreserve& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_Unreserve& default_instance();

  void Swap(Offer_Operation_Unreserve* other);

  // implements Message ----------------------------------------------

  Offer_Operation_Unreserve* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer_Operation_Unreserve& from);
  void MergeFrom(const Offer_Operation_Unreserve& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 1;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 1;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.Unreserve)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Offer_Operation_Unreserve* default_instance_;
};
// -------------------------------------------------------------------

class Offer_Operation_Create : public ::google::protobuf::Message {
 public:
  Offer_Operation_Create();
  virtual ~Offer_Operation_Create();

  Offer_Operation_Create(const Offer_Operation_Create& from);

  inline Offer_Operation_Create& operator=(const Offer_Operation_Create& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_Create& default_instance();

  void Swap(Offer_Operation_Create* other);

  // implements Message ----------------------------------------------

  Offer_Operation_Create* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer_Operation_Create& from);
  void MergeFrom(const Offer_Operation_Create& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource volumes = 1;
  inline int volumes_size() const;
  inline void clear_volumes();
  static const int kVolumesFieldNumber = 1;
  inline const ::mesos::Resource& volumes(int index) const;
  inline ::mesos::Resource* mutable_volumes(int index);
  inline ::mesos::Resource* add_volumes();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      volumes() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_volumes();

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.Create)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > volumes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Offer_Operation_Create* default_instance_;
};
// -------------------------------------------------------------------

class Offer_Operation_Destroy : public ::google::protobuf::Message {
 public:
  Offer_Operation_Destroy();
  virtual ~Offer_Operation_Destroy();

  Offer_Operation_Destroy(const Offer_Operation_Destroy& from);

  inline Offer_Operation_Destroy& operator=(const Offer_Operation_Destroy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_Destroy& default_instance();

  void Swap(Offer_Operation_Destroy* other);

  // implements Message ----------------------------------------------

  Offer_Operation_Destroy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer_Operation_Destroy& from);
  void MergeFrom(const Offer_Operation_Destroy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource volumes = 1;
  inline int volumes_size() const;
  inline void clear_volumes();
  static const int kVolumesFieldNumber = 1;
  inline const ::mesos::Resource& volumes(int index) const;
  inline ::mesos::Resource* mutable_volumes(int index);
  inline ::mesos::Resource* add_volumes();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      volumes() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_volumes();

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.Destroy)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > volumes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Offer_Operation_Destroy* default_instance_;
};
// -------------------------------------------------------------------

class Offer_Operation : public ::google::protobuf::Message {
 public:
  Offer_Operation();
  virtual ~Offer_Operation();

  Offer_Operation(const Offer_Operation& from);

  inline Offer_Operation& operator=(const Offer_Operation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation& default_instance();

  void Swap(Offer_Operation* other);

  // implements Message ----------------------------------------------

  Offer_Operation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer_Operation& from);
  void MergeFrom(const Offer_Operation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Offer_Operation_Launch Launch;
  typedef Offer_Operation_Reserve Reserve;
  typedef Offer_Operation_Unreserve Unreserve;
  typedef Offer_Operation_Create Create;
  typedef Offer_Operation_Destroy Destroy;

  typedef Offer_Operation_Type Type;
  static const Type LAUNCH = Offer_Operation_Type_LAUNCH;
  static const Type RESERVE = Offer_Operation_Type_RESERVE;
  static const Type UNRESERVE = Offer_Operation_Type_UNRESERVE;
  static const Type CREATE = Offer_Operation_Type_CREATE;
  static const Type DESTROY = Offer_Operation_Type_DESTROY;
  static inline bool Type_IsValid(int value) {
    return Offer_Operation_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Offer_Operation_Type_Type_MIN;
  static const Type Type_MAX =
    Offer_Operation_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Offer_Operation_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Offer_Operation_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Offer_Operation_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Offer_Operation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.Offer.Operation.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::Offer_Operation_Type type() const;
  inline void set_type(::mesos::Offer_Operation_Type value);

  // optional .mesos.Offer.Operation.Launch launch = 2;
  inline bool has_launch() const;
  inline void clear_launch();
  static const int kLaunchFieldNumber = 2;
  inline const ::mesos::Offer_Operation_Launch& launch() const;
  inline ::mesos::Offer_Operation_Launch* mutable_launch();
  inline ::mesos::Offer_Operation_Launch* release_launch();
  inline void set_allocated_launch(::mesos::Offer_Operation_Launch* launch);

  // optional .mesos.Offer.Operation.Reserve reserve = 3;
  inline bool has_reserve() const;
  inline void clear_reserve();
  static const int kReserveFieldNumber = 3;
  inline const ::mesos::Offer_Operation_Reserve& reserve() const;
  inline ::mesos::Offer_Operation_Reserve* mutable_reserve();
  inline ::mesos::Offer_Operation_Reserve* release_reserve();
  inline void set_allocated_reserve(::mesos::Offer_Operation_Reserve* reserve);

  // optional .mesos.Offer.Operation.Unreserve unreserve = 4;
  inline bool has_unreserve() const;
  inline void clear_unreserve();
  static const int kUnreserveFieldNumber = 4;
  inline const ::mesos::Offer_Operation_Unreserve& unreserve() const;
  inline ::mesos::Offer_Operation_Unreserve* mutable_unreserve();
  inline ::mesos::Offer_Operation_Unreserve* release_unreserve();
  inline void set_allocated_unreserve(::mesos::Offer_Operation_Unreserve* unreserve);

  // optional .mesos.Offer.Operation.Create create = 5;
  inline bool has_create() const;
  inline void clear_create();
  static const int kCreateFieldNumber = 5;
  inline const ::mesos::Offer_Operation_Create& create() const;
  inline ::mesos::Offer_Operation_Create* mutable_create();
  inline ::mesos::Offer_Operation_Create* release_create();
  inline void set_allocated_create(::mesos::Offer_Operation_Create* create);

  // optional .mesos.Offer.Operation.Destroy destroy = 6;
  inline bool has_destroy() const;
  inline void clear_destroy();
  static const int kDestroyFieldNumber = 6;
  inline const ::mesos::Offer_Operation_Destroy& destroy() const;
  inline ::mesos::Offer_Operation_Destroy* mutable_destroy();
  inline ::mesos::Offer_Operation_Destroy* release_destroy();
  inline void set_allocated_destroy(::mesos::Offer_Operation_Destroy* destroy);

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_launch();
  inline void clear_has_launch();
  inline void set_has_reserve();
  inline void clear_has_reserve();
  inline void set_has_unreserve();
  inline void clear_has_unreserve();
  inline void set_has_create();
  inline void clear_has_create();
  inline void set_has_destroy();
  inline void clear_has_destroy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::Offer_Operation_Launch* launch_;
  ::mesos::Offer_Operation_Reserve* reserve_;
  ::mesos::Offer_Operation_Unreserve* unreserve_;
  ::mesos::Offer_Operation_Create* create_;
  ::mesos::Offer_Operation_Destroy* destroy_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Offer_Operation* default_instance_;
};
// -------------------------------------------------------------------

class Offer : public ::google::protobuf::Message {
 public:
  Offer();
  virtual ~Offer();

  Offer(const Offer& from);

  inline Offer& operator=(const Offer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer& default_instance();

  void Swap(Offer* other);

  // implements Message ----------------------------------------------

  Offer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer& from);
  void MergeFrom(const Offer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Offer_Operation Operation;

  // accessors -------------------------------------------------------

  // required .mesos.OfferID id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::mesos::OfferID& id() const;
  inline ::mesos::OfferID* mutable_id();
  inline ::mesos::OfferID* release_id();
  inline void set_allocated_id(::mesos::OfferID* id);

  // required .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .mesos.SlaveID slave_id = 3;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 3;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required string hostname = 4;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 4;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // repeated .mesos.Resource resources = 5;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 5;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // repeated .mesos.Attribute attributes = 7;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 7;
  inline const ::mesos::Attribute& attributes(int index) const;
  inline ::mesos::Attribute* mutable_attributes(int index);
  inline ::mesos::Attribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
      mutable_attributes();

  // repeated .mesos.ExecutorID executor_ids = 6;
  inline int executor_ids_size() const;
  inline void clear_executor_ids();
  static const int kExecutorIdsFieldNumber = 6;
  inline const ::mesos::ExecutorID& executor_ids(int index) const;
  inline ::mesos::ExecutorID* mutable_executor_ids(int index);
  inline ::mesos::ExecutorID* add_executor_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >&
      executor_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >*
      mutable_executor_ids();

  // @@protoc_insertion_point(class_scope:mesos.Offer)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_hostname();
  inline void clear_has_hostname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::OfferID* id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::SlaveID* slave_id_;
  ::std::string* hostname_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Attribute > attributes_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID > executor_ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Offer* default_instance_;
};
// -------------------------------------------------------------------

class TaskInfo : public ::google::protobuf::Message {
 public:
  TaskInfo();
  virtual ~TaskInfo();

  TaskInfo(const TaskInfo& from);

  inline TaskInfo& operator=(const TaskInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskInfo& default_instance();

  void Swap(TaskInfo* other);

  // implements Message ----------------------------------------------

  TaskInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskInfo& from);
  void MergeFrom(const TaskInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .mesos.TaskID task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // required .mesos.SlaveID slave_id = 3;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 3;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // repeated .mesos.Resource resources = 4;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 4;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // optional .mesos.ExecutorInfo executor = 5;
  inline bool has_executor() const;
  inline void clear_executor();
  static const int kExecutorFieldNumber = 5;
  inline const ::mesos::ExecutorInfo& executor() const;
  inline ::mesos::ExecutorInfo* mutable_executor();
  inline ::mesos::ExecutorInfo* release_executor();
  inline void set_allocated_executor(::mesos::ExecutorInfo* executor);

  // optional .mesos.CommandInfo command = 7;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 7;
  inline const ::mesos::CommandInfo& command() const;
  inline ::mesos::CommandInfo* mutable_command();
  inline ::mesos::CommandInfo* release_command();
  inline void set_allocated_command(::mesos::CommandInfo* command);

  // optional .mesos.ContainerInfo container = 9;
  inline bool has_container() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 9;
  inline const ::mesos::ContainerInfo& container() const;
  inline ::mesos::ContainerInfo* mutable_container();
  inline ::mesos::ContainerInfo* release_container();
  inline void set_allocated_container(::mesos::ContainerInfo* container);

  // optional bytes data = 6;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 6;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional .mesos.HealthCheck health_check = 8;
  inline bool has_health_check() const;
  inline void clear_health_check();
  static const int kHealthCheckFieldNumber = 8;
  inline const ::mesos::HealthCheck& health_check() const;
  inline ::mesos::HealthCheck* mutable_health_check();
  inline ::mesos::HealthCheck* release_health_check();
  inline void set_allocated_health_check(::mesos::HealthCheck* health_check);

  // optional .mesos.Labels labels = 10;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 10;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // optional .mesos.DiscoveryInfo discovery = 11;
  inline bool has_discovery() const;
  inline void clear_discovery();
  static const int kDiscoveryFieldNumber = 11;
  inline const ::mesos::DiscoveryInfo& discovery() const;
  inline ::mesos::DiscoveryInfo* mutable_discovery();
  inline ::mesos::DiscoveryInfo* release_discovery();
  inline void set_allocated_discovery(::mesos::DiscoveryInfo* discovery);

  // @@protoc_insertion_point(class_scope:mesos.TaskInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_executor();
  inline void clear_has_executor();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_container();
  inline void clear_has_container();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_health_check();
  inline void clear_has_health_check();
  inline void set_has_labels();
  inline void clear_has_labels();
  inline void set_has_discovery();
  inline void clear_has_discovery();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::mesos::TaskID* task_id_;
  ::mesos::SlaveID* slave_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::mesos::ExecutorInfo* executor_;
  ::mesos::CommandInfo* command_;
  ::mesos::ContainerInfo* container_;
  ::std::string* data_;
  ::mesos::HealthCheck* health_check_;
  ::mesos::Labels* labels_;
  ::mesos::DiscoveryInfo* discovery_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static TaskInfo* default_instance_;
};
// -------------------------------------------------------------------

class TaskStatus : public ::google::protobuf::Message {
 public:
  TaskStatus();
  virtual ~TaskStatus();

  TaskStatus(const TaskStatus& from);

  inline TaskStatus& operator=(const TaskStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskStatus& default_instance();

  void Swap(TaskStatus* other);

  // implements Message ----------------------------------------------

  TaskStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskStatus& from);
  void MergeFrom(const TaskStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TaskStatus_Source Source;
  static const Source SOURCE_MASTER = TaskStatus_Source_SOURCE_MASTER;
  static const Source SOURCE_SLAVE = TaskStatus_Source_SOURCE_SLAVE;
  static const Source SOURCE_EXECUTOR = TaskStatus_Source_SOURCE_EXECUTOR;
  static inline bool Source_IsValid(int value) {
    return TaskStatus_Source_IsValid(value);
  }
  static const Source Source_MIN =
    TaskStatus_Source_Source_MIN;
  static const Source Source_MAX =
    TaskStatus_Source_Source_MAX;
  static const int Source_ARRAYSIZE =
    TaskStatus_Source_Source_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Source_descriptor() {
    return TaskStatus_Source_descriptor();
  }
  static inline const ::std::string& Source_Name(Source value) {
    return TaskStatus_Source_Name(value);
  }
  static inline bool Source_Parse(const ::std::string& name,
      Source* value) {
    return TaskStatus_Source_Parse(name, value);
  }

  typedef TaskStatus_Reason Reason;
  static const Reason REASON_COMMAND_EXECUTOR_FAILED = TaskStatus_Reason_REASON_COMMAND_EXECUTOR_FAILED;
  static const Reason REASON_EXECUTOR_TERMINATED = TaskStatus_Reason_REASON_EXECUTOR_TERMINATED;
  static const Reason REASON_EXECUTOR_UNREGISTERED = TaskStatus_Reason_REASON_EXECUTOR_UNREGISTERED;
  static const Reason REASON_FRAMEWORK_REMOVED = TaskStatus_Reason_REASON_FRAMEWORK_REMOVED;
  static const Reason REASON_GC_ERROR = TaskStatus_Reason_REASON_GC_ERROR;
  static const Reason REASON_INVALID_FRAMEWORKID = TaskStatus_Reason_REASON_INVALID_FRAMEWORKID;
  static const Reason REASON_INVALID_OFFERS = TaskStatus_Reason_REASON_INVALID_OFFERS;
  static const Reason REASON_MASTER_DISCONNECTED = TaskStatus_Reason_REASON_MASTER_DISCONNECTED;
  static const Reason REASON_MEMORY_LIMIT = TaskStatus_Reason_REASON_MEMORY_LIMIT;
  static const Reason REASON_RECONCILIATION = TaskStatus_Reason_REASON_RECONCILIATION;
  static const Reason REASON_SLAVE_DISCONNECTED = TaskStatus_Reason_REASON_SLAVE_DISCONNECTED;
  static const Reason REASON_SLAVE_REMOVED = TaskStatus_Reason_REASON_SLAVE_REMOVED;
  static const Reason REASON_SLAVE_RESTARTED = TaskStatus_Reason_REASON_SLAVE_RESTARTED;
  static const Reason REASON_SLAVE_UNKNOWN = TaskStatus_Reason_REASON_SLAVE_UNKNOWN;
  static const Reason REASON_TASK_INVALID = TaskStatus_Reason_REASON_TASK_INVALID;
  static const Reason REASON_TASK_UNAUTHORIZED = TaskStatus_Reason_REASON_TASK_UNAUTHORIZED;
  static const Reason REASON_TASK_UNKNOWN = TaskStatus_Reason_REASON_TASK_UNKNOWN;
  static inline bool Reason_IsValid(int value) {
    return TaskStatus_Reason_IsValid(value);
  }
  static const Reason Reason_MIN =
    TaskStatus_Reason_Reason_MIN;
  static const Reason Reason_MAX =
    TaskStatus_Reason_Reason_MAX;
  static const int Reason_ARRAYSIZE =
    TaskStatus_Reason_Reason_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Reason_descriptor() {
    return TaskStatus_Reason_descriptor();
  }
  static inline const ::std::string& Reason_Name(Reason value) {
    return TaskStatus_Reason_Name(value);
  }
  static inline bool Reason_Parse(const ::std::string& name,
      Reason* value) {
    return TaskStatus_Reason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.TaskID task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // required .mesos.TaskState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::mesos::TaskState state() const;
  inline void set_state(::mesos::TaskState value);

  // optional string message = 4;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 4;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional .mesos.TaskStatus.Source source = 9;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 9;
  inline ::mesos::TaskStatus_Source source() const;
  inline void set_source(::mesos::TaskStatus_Source value);

  // optional .mesos.TaskStatus.Reason reason = 10;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 10;
  inline ::mesos::TaskStatus_Reason reason() const;
  inline void set_reason(::mesos::TaskStatus_Reason value);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional .mesos.SlaveID slave_id = 5;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 5;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // optional .mesos.ExecutorID executor_id = 7;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 7;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // optional double timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // optional bytes uuid = 11;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 11;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional bool healthy = 8;
  inline bool has_healthy() const;
  inline void clear_healthy();
  static const int kHealthyFieldNumber = 8;
  inline bool healthy() const;
  inline void set_healthy(bool value);

  // @@protoc_insertion_point(class_scope:mesos.TaskStatus)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_healthy();
  inline void clear_has_healthy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::TaskID* task_id_;
  ::std::string* message_;
  int state_;
  int source_;
  ::std::string* data_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::ExecutorID* executor_id_;
  int reason_;
  bool healthy_;
  double timestamp_;
  ::std::string* uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static TaskStatus* default_instance_;
};
// -------------------------------------------------------------------

class Filters : public ::google::protobuf::Message {
 public:
  Filters();
  virtual ~Filters();

  Filters(const Filters& from);

  inline Filters& operator=(const Filters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Filters& default_instance();

  void Swap(Filters* other);

  // implements Message ----------------------------------------------

  Filters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Filters& from);
  void MergeFrom(const Filters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double refuse_seconds = 1 [default = 5];
  inline bool has_refuse_seconds() const;
  inline void clear_refuse_seconds();
  static const int kRefuseSecondsFieldNumber = 1;
  inline double refuse_seconds() const;
  inline void set_refuse_seconds(double value);

  // @@protoc_insertion_point(class_scope:mesos.Filters)
 private:
  inline void set_has_refuse_seconds();
  inline void clear_has_refuse_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double refuse_seconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Filters* default_instance_;
};
// -------------------------------------------------------------------

class Environment_Variable : public ::google::protobuf::Message {
 public:
  Environment_Variable();
  virtual ~Environment_Variable();

  Environment_Variable(const Environment_Variable& from);

  inline Environment_Variable& operator=(const Environment_Variable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Environment_Variable& default_instance();

  void Swap(Environment_Variable* other);

  // implements Message ----------------------------------------------

  Environment_Variable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Environment_Variable& from);
  void MergeFrom(const Environment_Variable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.Environment.Variable)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Environment_Variable* default_instance_;
};
// -------------------------------------------------------------------

class Environment : public ::google::protobuf::Message {
 public:
  Environment();
  virtual ~Environment();

  Environment(const Environment& from);

  inline Environment& operator=(const Environment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Environment& default_instance();

  void Swap(Environment* other);

  // implements Message ----------------------------------------------

  Environment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Environment& from);
  void MergeFrom(const Environment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Environment_Variable Variable;

  // accessors -------------------------------------------------------

  // repeated .mesos.Environment.Variable variables = 1;
  inline int variables_size() const;
  inline void clear_variables();
  static const int kVariablesFieldNumber = 1;
  inline const ::mesos::Environment_Variable& variables(int index) const;
  inline ::mesos::Environment_Variable* mutable_variables(int index);
  inline ::mesos::Environment_Variable* add_variables();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >&
      variables() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >*
      mutable_variables();

  // @@protoc_insertion_point(class_scope:mesos.Environment)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable > variables_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Environment* default_instance_;
};
// -------------------------------------------------------------------

class Parameter : public ::google::protobuf::Message {
 public:
  Parameter();
  virtual ~Parameter();

  Parameter(const Parameter& from);

  inline Parameter& operator=(const Parameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameter& default_instance();

  void Swap(Parameter* other);

  // implements Message ----------------------------------------------

  Parameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parameter& from);
  void MergeFrom(const Parameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.Parameter)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Parameter* default_instance_;
};
// -------------------------------------------------------------------

class Parameters : public ::google::protobuf::Message {
 public:
  Parameters();
  virtual ~Parameters();

  Parameters(const Parameters& from);

  inline Parameters& operator=(const Parameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameters& default_instance();

  void Swap(Parameters* other);

  // implements Message ----------------------------------------------

  Parameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parameters& from);
  void MergeFrom(const Parameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Parameter parameter = 1;
  inline int parameter_size() const;
  inline void clear_parameter();
  static const int kParameterFieldNumber = 1;
  inline const ::mesos::Parameter& parameter(int index) const;
  inline ::mesos::Parameter* mutable_parameter(int index);
  inline ::mesos::Parameter* add_parameter();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
      parameter() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
      mutable_parameter();

  // @@protoc_insertion_point(class_scope:mesos.Parameters)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Parameter > parameter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Parameters* default_instance_;
};
// -------------------------------------------------------------------

class Credential : public ::google::protobuf::Message {
 public:
  Credential();
  virtual ~Credential();

  Credential(const Credential& from);

  inline Credential& operator=(const Credential& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Credential& default_instance();

  void Swap(Credential* other);

  // implements Message ----------------------------------------------

  Credential* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Credential& from);
  void MergeFrom(const Credential& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string principal = 1;
  inline bool has_principal() const;
  inline void clear_principal();
  static const int kPrincipalFieldNumber = 1;
  inline const ::std::string& principal() const;
  inline void set_principal(const ::std::string& value);
  inline void set_principal(const char* value);
  inline void set_principal(const char* value, size_t size);
  inline ::std::string* mutable_principal();
  inline ::std::string* release_principal();
  inline void set_allocated_principal(::std::string* principal);

  // optional bytes secret = 2;
  inline bool has_secret() const;
  inline void clear_secret();
  static const int kSecretFieldNumber = 2;
  inline const ::std::string& secret() const;
  inline void set_secret(const ::std::string& value);
  inline void set_secret(const char* value);
  inline void set_secret(const void* value, size_t size);
  inline ::std::string* mutable_secret();
  inline ::std::string* release_secret();
  inline void set_allocated_secret(::std::string* secret);

  // @@protoc_insertion_point(class_scope:mesos.Credential)
 private:
  inline void set_has_principal();
  inline void clear_has_principal();
  inline void set_has_secret();
  inline void clear_has_secret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* principal_;
  ::std::string* secret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Credential* default_instance_;
};
// -------------------------------------------------------------------

class Credentials : public ::google::protobuf::Message {
 public:
  Credentials();
  virtual ~Credentials();

  Credentials(const Credentials& from);

  inline Credentials& operator=(const Credentials& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Credentials& default_instance();

  void Swap(Credentials* other);

  // implements Message ----------------------------------------------

  Credentials* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Credentials& from);
  void MergeFrom(const Credentials& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Credential credentials = 1;
  inline int credentials_size() const;
  inline void clear_credentials();
  static const int kCredentialsFieldNumber = 1;
  inline const ::mesos::Credential& credentials(int index) const;
  inline ::mesos::Credential* mutable_credentials(int index);
  inline ::mesos::Credential* add_credentials();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Credential >&
      credentials() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Credential >*
      mutable_credentials();

  // @@protoc_insertion_point(class_scope:mesos.Credentials)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Credential > credentials_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Credentials* default_instance_;
};
// -------------------------------------------------------------------

class ACL_Entity : public ::google::protobuf::Message {
 public:
  ACL_Entity();
  virtual ~ACL_Entity();

  ACL_Entity(const ACL_Entity& from);

  inline ACL_Entity& operator=(const ACL_Entity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_Entity& default_instance();

  void Swap(ACL_Entity* other);

  // implements Message ----------------------------------------------

  ACL_Entity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL_Entity& from);
  void MergeFrom(const ACL_Entity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ACL_Entity_Type Type;
  static const Type SOME = ACL_Entity_Type_SOME;
  static const Type ANY = ACL_Entity_Type_ANY;
  static const Type NONE = ACL_Entity_Type_NONE;
  static inline bool Type_IsValid(int value) {
    return ACL_Entity_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ACL_Entity_Type_Type_MIN;
  static const Type Type_MAX =
    ACL_Entity_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ACL_Entity_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ACL_Entity_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ACL_Entity_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ACL_Entity_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.ACL.Entity.Type type = 1 [default = SOME];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::ACL_Entity_Type type() const;
  inline void set_type(::mesos::ACL_Entity_Type value);

  // repeated string values = 2;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 2;
  inline const ::std::string& values(int index) const;
  inline ::std::string* mutable_values(int index);
  inline void set_values(int index, const ::std::string& value);
  inline void set_values(int index, const char* value);
  inline void set_values(int index, const char* value, size_t size);
  inline ::std::string* add_values();
  inline void add_values(const ::std::string& value);
  inline void add_values(const char* value);
  inline void add_values(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // @@protoc_insertion_point(class_scope:mesos.ACL.Entity)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static ACL_Entity* default_instance_;
};
// -------------------------------------------------------------------

class ACL_RegisterFramework : public ::google::protobuf::Message {
 public:
  ACL_RegisterFramework();
  virtual ~ACL_RegisterFramework();

  ACL_RegisterFramework(const ACL_RegisterFramework& from);

  inline ACL_RegisterFramework& operator=(const ACL_RegisterFramework& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_RegisterFramework& default_instance();

  void Swap(ACL_RegisterFramework* other);

  // implements Message ----------------------------------------------

  ACL_RegisterFramework* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL_RegisterFramework& from);
  void MergeFrom(const ACL_RegisterFramework& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  inline bool has_principals() const;
  inline void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  inline const ::mesos::ACL_Entity& principals() const;
  inline ::mesos::ACL_Entity* mutable_principals();
  inline ::mesos::ACL_Entity* release_principals();
  inline void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity roles = 2;
  inline bool has_roles() const;
  inline void clear_roles();
  static const int kRolesFieldNumber = 2;
  inline const ::mesos::ACL_Entity& roles() const;
  inline ::mesos::ACL_Entity* mutable_roles();
  inline ::mesos::ACL_Entity* release_roles();
  inline void set_allocated_roles(::mesos::ACL_Entity* roles);

  // @@protoc_insertion_point(class_scope:mesos.ACL.RegisterFramework)
 private:
  inline void set_has_principals();
  inline void clear_has_principals();
  inline void set_has_roles();
  inline void clear_has_roles();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* roles_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static ACL_RegisterFramework* default_instance_;
};
// -------------------------------------------------------------------

class ACL_RunTask : public ::google::protobuf::Message {
 public:
  ACL_RunTask();
  virtual ~ACL_RunTask();

  ACL_RunTask(const ACL_RunTask& from);

  inline ACL_RunTask& operator=(const ACL_RunTask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_RunTask& default_instance();

  void Swap(ACL_RunTask* other);

  // implements Message ----------------------------------------------

  ACL_RunTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL_RunTask& from);
  void MergeFrom(const ACL_RunTask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  inline bool has_principals() const;
  inline void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  inline const ::mesos::ACL_Entity& principals() const;
  inline ::mesos::ACL_Entity* mutable_principals();
  inline ::mesos::ACL_Entity* release_principals();
  inline void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  inline bool has_users() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 2;
  inline const ::mesos::ACL_Entity& users() const;
  inline ::mesos::ACL_Entity* mutable_users();
  inline ::mesos::ACL_Entity* release_users();
  inline void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.RunTask)
 private:
  inline void set_has_principals();
  inline void clear_has_principals();
  inline void set_has_users();
  inline void clear_has_users();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static ACL_RunTask* default_instance_;
};
// -------------------------------------------------------------------

class ACL_ShutdownFramework : public ::google::protobuf::Message {
 public:
  ACL_ShutdownFramework();
  virtual ~ACL_ShutdownFramework();

  ACL_ShutdownFramework(const ACL_ShutdownFramework& from);

  inline ACL_ShutdownFramework& operator=(const ACL_ShutdownFramework& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_ShutdownFramework& default_instance();

  void Swap(ACL_ShutdownFramework* other);

  // implements Message ----------------------------------------------

  ACL_ShutdownFramework* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL_ShutdownFramework& from);
  void MergeFrom(const ACL_ShutdownFramework& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  inline bool has_principals() const;
  inline void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  inline const ::mesos::ACL_Entity& principals() const;
  inline ::mesos::ACL_Entity* mutable_principals();
  inline ::mesos::ACL_Entity* release_principals();
  inline void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity framework_principals = 2;
  inline bool has_framework_principals() const;
  inline void clear_framework_principals();
  static const int kFrameworkPrincipalsFieldNumber = 2;
  inline const ::mesos::ACL_Entity& framework_principals() const;
  inline ::mesos::ACL_Entity* mutable_framework_principals();
  inline ::mesos::ACL_Entity* release_framework_principals();
  inline void set_allocated_framework_principals(::mesos::ACL_Entity* framework_principals);

  // @@protoc_insertion_point(class_scope:mesos.ACL.ShutdownFramework)
 private:
  inline void set_has_principals();
  inline void clear_has_principals();
  inline void set_has_framework_principals();
  inline void clear_has_framework_principals();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* framework_principals_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static ACL_ShutdownFramework* default_instance_;
};
// -------------------------------------------------------------------

class ACL : public ::google::protobuf::Message {
 public:
  ACL();
  virtual ~ACL();

  ACL(const ACL& from);

  inline ACL& operator=(const ACL& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL& default_instance();

  void Swap(ACL* other);

  // implements Message ----------------------------------------------

  ACL* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL& from);
  void MergeFrom(const ACL& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ACL_Entity Entity;
  typedef ACL_RegisterFramework RegisterFramework;
  typedef ACL_RunTask RunTask;
  typedef ACL_ShutdownFramework ShutdownFramework;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mesos.ACL)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static ACL* default_instance_;
};
// -------------------------------------------------------------------

class ACLs : public ::google::protobuf::Message {
 public:
  ACLs();
  virtual ~ACLs();

  ACLs(const ACLs& from);

  inline ACLs& operator=(const ACLs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACLs& default_instance();

  void Swap(ACLs* other);

  // implements Message ----------------------------------------------

  ACLs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACLs& from);
  void MergeFrom(const ACLs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool permissive = 1 [default = true];
  inline bool has_permissive() const;
  inline void clear_permissive();
  static const int kPermissiveFieldNumber = 1;
  inline bool permissive() const;
  inline void set_permissive(bool value);

  // repeated .mesos.ACL.RegisterFramework register_frameworks = 2;
  inline int register_frameworks_size() const;
  inline void clear_register_frameworks();
  static const int kRegisterFrameworksFieldNumber = 2;
  inline const ::mesos::ACL_RegisterFramework& register_frameworks(int index) const;
  inline ::mesos::ACL_RegisterFramework* mutable_register_frameworks(int index);
  inline ::mesos::ACL_RegisterFramework* add_register_frameworks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterFramework >&
      register_frameworks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterFramework >*
      mutable_register_frameworks();

  // repeated .mesos.ACL.RunTask run_tasks = 3;
  inline int run_tasks_size() const;
  inline void clear_run_tasks();
  static const int kRunTasksFieldNumber = 3;
  inline const ::mesos::ACL_RunTask& run_tasks(int index) const;
  inline ::mesos::ACL_RunTask* mutable_run_tasks(int index);
  inline ::mesos::ACL_RunTask* add_run_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTask >&
      run_tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTask >*
      mutable_run_tasks();

  // repeated .mesos.ACL.ShutdownFramework shutdown_frameworks = 4;
  inline int shutdown_frameworks_size() const;
  inline void clear_shutdown_frameworks();
  static const int kShutdownFrameworksFieldNumber = 4;
  inline const ::mesos::ACL_ShutdownFramework& shutdown_frameworks(int index) const;
  inline ::mesos::ACL_ShutdownFramework* mutable_shutdown_frameworks(int index);
  inline ::mesos::ACL_ShutdownFramework* add_shutdown_frameworks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ShutdownFramework >&
      shutdown_frameworks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ShutdownFramework >*
      mutable_shutdown_frameworks();

  // @@protoc_insertion_point(class_scope:mesos.ACLs)
 private:
  inline void set_has_permissive();
  inline void clear_has_permissive();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterFramework > register_frameworks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTask > run_tasks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ShutdownFramework > shutdown_frameworks_;
  bool permissive_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static ACLs* default_instance_;
};
// -------------------------------------------------------------------

class RateLimit : public ::google::protobuf::Message {
 public:
  RateLimit();
  virtual ~RateLimit();

  RateLimit(const RateLimit& from);

  inline RateLimit& operator=(const RateLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimit& default_instance();

  void Swap(RateLimit* other);

  // implements Message ----------------------------------------------

  RateLimit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RateLimit& from);
  void MergeFrom(const RateLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double qps = 1;
  inline bool has_qps() const;
  inline void clear_qps();
  static const int kQpsFieldNumber = 1;
  inline double qps() const;
  inline void set_qps(double value);

  // required string principal = 2;
  inline bool has_principal() const;
  inline void clear_principal();
  static const int kPrincipalFieldNumber = 2;
  inline const ::std::string& principal() const;
  inline void set_principal(const ::std::string& value);
  inline void set_principal(const char* value);
  inline void set_principal(const char* value, size_t size);
  inline ::std::string* mutable_principal();
  inline ::std::string* release_principal();
  inline void set_allocated_principal(::std::string* principal);

  // optional uint64 capacity = 3;
  inline bool has_capacity() const;
  inline void clear_capacity();
  static const int kCapacityFieldNumber = 3;
  inline ::google::protobuf::uint64 capacity() const;
  inline void set_capacity(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.RateLimit)
 private:
  inline void set_has_qps();
  inline void clear_has_qps();
  inline void set_has_principal();
  inline void clear_has_principal();
  inline void set_has_capacity();
  inline void clear_has_capacity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double qps_;
  ::std::string* principal_;
  ::google::protobuf::uint64 capacity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static RateLimit* default_instance_;
};
// -------------------------------------------------------------------

class RateLimits : public ::google::protobuf::Message {
 public:
  RateLimits();
  virtual ~RateLimits();

  RateLimits(const RateLimits& from);

  inline RateLimits& operator=(const RateLimits& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimits& default_instance();

  void Swap(RateLimits* other);

  // implements Message ----------------------------------------------

  RateLimits* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RateLimits& from);
  void MergeFrom(const RateLimits& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.RateLimit limits = 1;
  inline int limits_size() const;
  inline void clear_limits();
  static const int kLimitsFieldNumber = 1;
  inline const ::mesos::RateLimit& limits(int index) const;
  inline ::mesos::RateLimit* mutable_limits(int index);
  inline ::mesos::RateLimit* add_limits();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::RateLimit >&
      limits() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::RateLimit >*
      mutable_limits();

  // optional double aggregate_default_qps = 2;
  inline bool has_aggregate_default_qps() const;
  inline void clear_aggregate_default_qps();
  static const int kAggregateDefaultQpsFieldNumber = 2;
  inline double aggregate_default_qps() const;
  inline void set_aggregate_default_qps(double value);

  // optional uint64 aggregate_default_capacity = 3;
  inline bool has_aggregate_default_capacity() const;
  inline void clear_aggregate_default_capacity();
  static const int kAggregateDefaultCapacityFieldNumber = 3;
  inline ::google::protobuf::uint64 aggregate_default_capacity() const;
  inline void set_aggregate_default_capacity(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.RateLimits)
 private:
  inline void set_has_aggregate_default_qps();
  inline void clear_has_aggregate_default_qps();
  inline void set_has_aggregate_default_capacity();
  inline void clear_has_aggregate_default_capacity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::RateLimit > limits_;
  double aggregate_default_qps_;
  ::google::protobuf::uint64 aggregate_default_capacity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static RateLimits* default_instance_;
};
// -------------------------------------------------------------------

class Volume : public ::google::protobuf::Message {
 public:
  Volume();
  virtual ~Volume();

  Volume(const Volume& from);

  inline Volume& operator=(const Volume& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Volume& default_instance();

  void Swap(Volume* other);

  // implements Message ----------------------------------------------

  Volume* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Volume& from);
  void MergeFrom(const Volume& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Volume_Mode Mode;
  static const Mode RW = Volume_Mode_RW;
  static const Mode RO = Volume_Mode_RO;
  static inline bool Mode_IsValid(int value) {
    return Volume_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    Volume_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    Volume_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    Volume_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return Volume_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return Volume_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return Volume_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string container_path = 1;
  inline bool has_container_path() const;
  inline void clear_container_path();
  static const int kContainerPathFieldNumber = 1;
  inline const ::std::string& container_path() const;
  inline void set_container_path(const ::std::string& value);
  inline void set_container_path(const char* value);
  inline void set_container_path(const char* value, size_t size);
  inline ::std::string* mutable_container_path();
  inline ::std::string* release_container_path();
  inline void set_allocated_container_path(::std::string* container_path);

  // optional string host_path = 2;
  inline bool has_host_path() const;
  inline void clear_host_path();
  static const int kHostPathFieldNumber = 2;
  inline const ::std::string& host_path() const;
  inline void set_host_path(const ::std::string& value);
  inline void set_host_path(const char* value);
  inline void set_host_path(const char* value, size_t size);
  inline ::std::string* mutable_host_path();
  inline ::std::string* release_host_path();
  inline void set_allocated_host_path(::std::string* host_path);

  // required .mesos.Volume.Mode mode = 3;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 3;
  inline ::mesos::Volume_Mode mode() const;
  inline void set_mode(::mesos::Volume_Mode value);

  // @@protoc_insertion_point(class_scope:mesos.Volume)
 private:
  inline void set_has_container_path();
  inline void clear_has_container_path();
  inline void set_has_host_path();
  inline void clear_has_host_path();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* container_path_;
  ::std::string* host_path_;
  int mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Volume* default_instance_;
};
// -------------------------------------------------------------------

class ContainerInfo_DockerInfo_PortMapping : public ::google::protobuf::Message {
 public:
  ContainerInfo_DockerInfo_PortMapping();
  virtual ~ContainerInfo_DockerInfo_PortMapping();

  ContainerInfo_DockerInfo_PortMapping(const ContainerInfo_DockerInfo_PortMapping& from);

  inline ContainerInfo_DockerInfo_PortMapping& operator=(const ContainerInfo_DockerInfo_PortMapping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerInfo_DockerInfo_PortMapping& default_instance();

  void Swap(ContainerInfo_DockerInfo_PortMapping* other);

  // implements Message ----------------------------------------------

  ContainerInfo_DockerInfo_PortMapping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerInfo_DockerInfo_PortMapping& from);
  void MergeFrom(const ContainerInfo_DockerInfo_PortMapping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 host_port = 1;
  inline bool has_host_port() const;
  inline void clear_host_port();
  static const int kHostPortFieldNumber = 1;
  inline ::google::protobuf::uint32 host_port() const;
  inline void set_host_port(::google::protobuf::uint32 value);

  // required uint32 container_port = 2;
  inline bool has_container_port() const;
  inline void clear_container_port();
  static const int kContainerPortFieldNumber = 2;
  inline ::google::protobuf::uint32 container_port() const;
  inline void set_container_port(::google::protobuf::uint32 value);

  // optional string protocol = 3;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 3;
  inline const ::std::string& protocol() const;
  inline void set_protocol(const ::std::string& value);
  inline void set_protocol(const char* value);
  inline void set_protocol(const char* value, size_t size);
  inline ::std::string* mutable_protocol();
  inline ::std::string* release_protocol();
  inline void set_allocated_protocol(::std::string* protocol);

  // @@protoc_insertion_point(class_scope:mesos.ContainerInfo.DockerInfo.PortMapping)
 private:
  inline void set_has_host_port();
  inline void clear_has_host_port();
  inline void set_has_container_port();
  inline void clear_has_container_port();
  inline void set_has_protocol();
  inline void clear_has_protocol();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 host_port_;
  ::google::protobuf::uint32 container_port_;
  ::std::string* protocol_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static ContainerInfo_DockerInfo_PortMapping* default_instance_;
};
// -------------------------------------------------------------------

class ContainerInfo_DockerInfo : public ::google::protobuf::Message {
 public:
  ContainerInfo_DockerInfo();
  virtual ~ContainerInfo_DockerInfo();

  ContainerInfo_DockerInfo(const ContainerInfo_DockerInfo& from);

  inline ContainerInfo_DockerInfo& operator=(const ContainerInfo_DockerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerInfo_DockerInfo& default_instance();

  void Swap(ContainerInfo_DockerInfo* other);

  // implements Message ----------------------------------------------

  ContainerInfo_DockerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerInfo_DockerInfo& from);
  void MergeFrom(const ContainerInfo_DockerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ContainerInfo_DockerInfo_PortMapping PortMapping;

  typedef ContainerInfo_DockerInfo_Network Network;
  static const Network HOST = ContainerInfo_DockerInfo_Network_HOST;
  static const Network BRIDGE = ContainerInfo_DockerInfo_Network_BRIDGE;
  static const Network NONE = ContainerInfo_DockerInfo_Network_NONE;
  static inline bool Network_IsValid(int value) {
    return ContainerInfo_DockerInfo_Network_IsValid(value);
  }
  static const Network Network_MIN =
    ContainerInfo_DockerInfo_Network_Network_MIN;
  static const Network Network_MAX =
    ContainerInfo_DockerInfo_Network_Network_MAX;
  static const int Network_ARRAYSIZE =
    ContainerInfo_DockerInfo_Network_Network_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Network_descriptor() {
    return ContainerInfo_DockerInfo_Network_descriptor();
  }
  static inline const ::std::string& Network_Name(Network value) {
    return ContainerInfo_DockerInfo_Network_Name(value);
  }
  static inline bool Network_Parse(const ::std::string& name,
      Network* value) {
    return ContainerInfo_DockerInfo_Network_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string image = 1;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 1;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional .mesos.ContainerInfo.DockerInfo.Network network = 2 [default = HOST];
  inline bool has_network() const;
  inline void clear_network();
  static const int kNetworkFieldNumber = 2;
  inline ::mesos::ContainerInfo_DockerInfo_Network network() const;
  inline void set_network(::mesos::ContainerInfo_DockerInfo_Network value);

  // repeated .mesos.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;
  inline int port_mappings_size() const;
  inline void clear_port_mappings();
  static const int kPortMappingsFieldNumber = 3;
  inline const ::mesos::ContainerInfo_DockerInfo_PortMapping& port_mappings(int index) const;
  inline ::mesos::ContainerInfo_DockerInfo_PortMapping* mutable_port_mappings(int index);
  inline ::mesos::ContainerInfo_DockerInfo_PortMapping* add_port_mappings();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ContainerInfo_DockerInfo_PortMapping >&
      port_mappings() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ContainerInfo_DockerInfo_PortMapping >*
      mutable_port_mappings();

  // optional bool privileged = 4 [default = false];
  inline bool has_privileged() const;
  inline void clear_privileged();
  static const int kPrivilegedFieldNumber = 4;
  inline bool privileged() const;
  inline void set_privileged(bool value);

  // repeated .mesos.Parameter parameters = 5;
  inline int parameters_size() const;
  inline void clear_parameters();
  static const int kParametersFieldNumber = 5;
  inline const ::mesos::Parameter& parameters(int index) const;
  inline ::mesos::Parameter* mutable_parameters(int index);
  inline ::mesos::Parameter* add_parameters();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
      parameters() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
      mutable_parameters();

  // optional bool force_pull_image = 6;
  inline bool has_force_pull_image() const;
  inline void clear_force_pull_image();
  static const int kForcePullImageFieldNumber = 6;
  inline bool force_pull_image() const;
  inline void set_force_pull_image(bool value);

  // @@protoc_insertion_point(class_scope:mesos.ContainerInfo.DockerInfo)
 private:
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_network();
  inline void clear_has_network();
  inline void set_has_privileged();
  inline void clear_has_privileged();
  inline void set_has_force_pull_image();
  inline void clear_has_force_pull_image();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* image_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ContainerInfo_DockerInfo_PortMapping > port_mappings_;
  int network_;
  bool privileged_;
  bool force_pull_image_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Parameter > parameters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static ContainerInfo_DockerInfo* default_instance_;
};
// -------------------------------------------------------------------

class ContainerInfo : public ::google::protobuf::Message {
 public:
  ContainerInfo();
  virtual ~ContainerInfo();

  ContainerInfo(const ContainerInfo& from);

  inline ContainerInfo& operator=(const ContainerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerInfo& default_instance();

  void Swap(ContainerInfo* other);

  // implements Message ----------------------------------------------

  ContainerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerInfo& from);
  void MergeFrom(const ContainerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ContainerInfo_DockerInfo DockerInfo;

  typedef ContainerInfo_Type Type;
  static const Type DOCKER = ContainerInfo_Type_DOCKER;
  static const Type MESOS = ContainerInfo_Type_MESOS;
  static inline bool Type_IsValid(int value) {
    return ContainerInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ContainerInfo_Type_Type_MIN;
  static const Type Type_MAX =
    ContainerInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ContainerInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ContainerInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ContainerInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ContainerInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.ContainerInfo.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::ContainerInfo_Type type() const;
  inline void set_type(::mesos::ContainerInfo_Type value);

  // repeated .mesos.Volume volumes = 2;
  inline int volumes_size() const;
  inline void clear_volumes();
  static const int kVolumesFieldNumber = 2;
  inline const ::mesos::Volume& volumes(int index) const;
  inline ::mesos::Volume* mutable_volumes(int index);
  inline ::mesos::Volume* add_volumes();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Volume >&
      volumes() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Volume >*
      mutable_volumes();

  // optional string hostname = 4;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 4;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional .mesos.ContainerInfo.DockerInfo docker = 3;
  inline bool has_docker() const;
  inline void clear_docker();
  static const int kDockerFieldNumber = 3;
  inline const ::mesos::ContainerInfo_DockerInfo& docker() const;
  inline ::mesos::ContainerInfo_DockerInfo* mutable_docker();
  inline ::mesos::ContainerInfo_DockerInfo* release_docker();
  inline void set_allocated_docker(::mesos::ContainerInfo_DockerInfo* docker);

  // @@protoc_insertion_point(class_scope:mesos.ContainerInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_docker();
  inline void clear_has_docker();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Volume > volumes_;
  ::std::string* hostname_;
  ::mesos::ContainerInfo_DockerInfo* docker_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static ContainerInfo* default_instance_;
};
// -------------------------------------------------------------------

class Labels : public ::google::protobuf::Message {
 public:
  Labels();
  virtual ~Labels();

  Labels(const Labels& from);

  inline Labels& operator=(const Labels& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Labels& default_instance();

  void Swap(Labels* other);

  // implements Message ----------------------------------------------

  Labels* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Labels& from);
  void MergeFrom(const Labels& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Label labels = 1;
  inline int labels_size() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 1;
  inline const ::mesos::Label& labels(int index) const;
  inline ::mesos::Label* mutable_labels(int index);
  inline ::mesos::Label* add_labels();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Label >&
      labels() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Label >*
      mutable_labels();

  // @@protoc_insertion_point(class_scope:mesos.Labels)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Label > labels_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Labels* default_instance_;
};
// -------------------------------------------------------------------

class Label : public ::google::protobuf::Message {
 public:
  Label();
  virtual ~Label();

  Label(const Label& from);

  inline Label& operator=(const Label& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Label& default_instance();

  void Swap(Label* other);

  // implements Message ----------------------------------------------

  Label* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Label& from);
  void MergeFrom(const Label& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.Label)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Label* default_instance_;
};
// -------------------------------------------------------------------

class Port : public ::google::protobuf::Message {
 public:
  Port();
  virtual ~Port();

  Port(const Port& from);

  inline Port& operator=(const Port& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Port& default_instance();

  void Swap(Port* other);

  // implements Message ----------------------------------------------

  Port* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Port& from);
  void MergeFrom(const Port& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 number() const;
  inline void set_number(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string protocol = 3;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 3;
  inline const ::std::string& protocol() const;
  inline void set_protocol(const ::std::string& value);
  inline void set_protocol(const char* value);
  inline void set_protocol(const char* value, size_t size);
  inline ::std::string* mutable_protocol();
  inline ::std::string* release_protocol();
  inline void set_allocated_protocol(::std::string* protocol);

  // @@protoc_insertion_point(class_scope:mesos.Port)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_protocol();
  inline void clear_has_protocol();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* protocol_;
  ::google::protobuf::uint32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Port* default_instance_;
};
// -------------------------------------------------------------------

class Ports : public ::google::protobuf::Message {
 public:
  Ports();
  virtual ~Ports();

  Ports(const Ports& from);

  inline Ports& operator=(const Ports& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ports& default_instance();

  void Swap(Ports* other);

  // implements Message ----------------------------------------------

  Ports* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ports& from);
  void MergeFrom(const Ports& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Port ports = 1;
  inline int ports_size() const;
  inline void clear_ports();
  static const int kPortsFieldNumber = 1;
  inline const ::mesos::Port& ports(int index) const;
  inline ::mesos::Port* mutable_ports(int index);
  inline ::mesos::Port* add_ports();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Port >&
      ports() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Port >*
      mutable_ports();

  // @@protoc_insertion_point(class_scope:mesos.Ports)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Port > ports_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static Ports* default_instance_;
};
// -------------------------------------------------------------------

class DiscoveryInfo : public ::google::protobuf::Message {
 public:
  DiscoveryInfo();
  virtual ~DiscoveryInfo();

  DiscoveryInfo(const DiscoveryInfo& from);

  inline DiscoveryInfo& operator=(const DiscoveryInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiscoveryInfo& default_instance();

  void Swap(DiscoveryInfo* other);

  // implements Message ----------------------------------------------

  DiscoveryInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DiscoveryInfo& from);
  void MergeFrom(const DiscoveryInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DiscoveryInfo_Visibility Visibility;
  static const Visibility FRAMEWORK = DiscoveryInfo_Visibility_FRAMEWORK;
  static const Visibility CLUSTER = DiscoveryInfo_Visibility_CLUSTER;
  static const Visibility EXTERNAL = DiscoveryInfo_Visibility_EXTERNAL;
  static inline bool Visibility_IsValid(int value) {
    return DiscoveryInfo_Visibility_IsValid(value);
  }
  static const Visibility Visibility_MIN =
    DiscoveryInfo_Visibility_Visibility_MIN;
  static const Visibility Visibility_MAX =
    DiscoveryInfo_Visibility_Visibility_MAX;
  static const int Visibility_ARRAYSIZE =
    DiscoveryInfo_Visibility_Visibility_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Visibility_descriptor() {
    return DiscoveryInfo_Visibility_descriptor();
  }
  static inline const ::std::string& Visibility_Name(Visibility value) {
    return DiscoveryInfo_Visibility_Name(value);
  }
  static inline bool Visibility_Parse(const ::std::string& name,
      Visibility* value) {
    return DiscoveryInfo_Visibility_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.DiscoveryInfo.Visibility visibility = 1;
  inline bool has_visibility() const;
  inline void clear_visibility();
  static const int kVisibilityFieldNumber = 1;
  inline ::mesos::DiscoveryInfo_Visibility visibility() const;
  inline void set_visibility(::mesos::DiscoveryInfo_Visibility value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string environment = 3;
  inline bool has_environment() const;
  inline void clear_environment();
  static const int kEnvironmentFieldNumber = 3;
  inline const ::std::string& environment() const;
  inline void set_environment(const ::std::string& value);
  inline void set_environment(const char* value);
  inline void set_environment(const char* value, size_t size);
  inline ::std::string* mutable_environment();
  inline ::std::string* release_environment();
  inline void set_allocated_environment(::std::string* environment);

  // optional string location = 4;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 4;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional .mesos.Ports ports = 6;
  inline bool has_ports() const;
  inline void clear_ports();
  static const int kPortsFieldNumber = 6;
  inline const ::mesos::Ports& ports() const;
  inline ::mesos::Ports* mutable_ports();
  inline ::mesos::Ports* release_ports();
  inline void set_allocated_ports(::mesos::Ports* ports);

  // optional .mesos.Labels labels = 7;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 7;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // @@protoc_insertion_point(class_scope:mesos.DiscoveryInfo)
 private:
  inline void set_has_visibility();
  inline void clear_has_visibility();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_environment();
  inline void clear_has_environment();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_ports();
  inline void clear_has_ports();
  inline void set_has_labels();
  inline void clear_has_labels();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* environment_;
  ::std::string* location_;
  ::std::string* version_;
  ::mesos::Ports* ports_;
  ::mesos::Labels* labels_;
  int visibility_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fmesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2fmesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fmesos_2eproto();

  void InitAsDefaultInstance();
  static DiscoveryInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// FrameworkID

// required string value = 1;
inline bool FrameworkID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkID::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& FrameworkID::value() const {
  return *value_;
}
inline void FrameworkID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void FrameworkID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void FrameworkID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* FrameworkID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FrameworkID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OfferID

// required string value = 1;
inline bool OfferID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OfferID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OfferID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OfferID::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& OfferID::value() const {
  return *value_;
}
inline void OfferID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void OfferID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void OfferID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* OfferID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SlaveID

// required string value = 1;
inline bool SlaveID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveID::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& SlaveID::value() const {
  return *value_;
}
inline void SlaveID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void SlaveID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void SlaveID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* SlaveID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlaveID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TaskID

// required string value = 1;
inline bool TaskID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskID::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& TaskID::value() const {
  return *value_;
}
inline void TaskID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void TaskID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void TaskID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* TaskID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ExecutorID

// required string value = 1;
inline bool ExecutorID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutorID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutorID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutorID::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ExecutorID::value() const {
  return *value_;
}
inline void ExecutorID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ExecutorID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ExecutorID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ExecutorID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutorID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ContainerID

// required string value = 1;
inline bool ContainerID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerID::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ContainerID::value() const {
  return *value_;
}
inline void ContainerID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ContainerID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ContainerID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContainerID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ContainerID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContainerID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FrameworkInfo

// required string user = 1;
inline bool FrameworkInfo::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkInfo::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkInfo::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& FrameworkInfo::user() const {
  return *user_;
}
inline void FrameworkInfo::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void FrameworkInfo::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void FrameworkInfo::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkInfo::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* FrameworkInfo::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FrameworkInfo::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 2;
inline bool FrameworkInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameworkInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameworkInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameworkInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FrameworkInfo::name() const {
  return *name_;
}
inline void FrameworkInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FrameworkInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FrameworkInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FrameworkInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FrameworkInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mesos.FrameworkID id = 3;
inline bool FrameworkInfo::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FrameworkInfo::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FrameworkInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FrameworkInfo::clear_id() {
  if (id_ != NULL) id_->::mesos::FrameworkID::Clear();
  clear_has_id();
}
inline const ::mesos::FrameworkID& FrameworkInfo::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mesos::FrameworkID* FrameworkInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mesos::FrameworkID;
  return id_;
}
inline ::mesos::FrameworkID* FrameworkInfo::release_id() {
  clear_has_id();
  ::mesos::FrameworkID* temp = id_;
  id_ = NULL;
  return temp;
}
inline void FrameworkInfo::set_allocated_id(::mesos::FrameworkID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// optional double failover_timeout = 4 [default = 0];
inline bool FrameworkInfo::has_failover_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FrameworkInfo::set_has_failover_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FrameworkInfo::clear_has_failover_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FrameworkInfo::clear_failover_timeout() {
  failover_timeout_ = 0;
  clear_has_failover_timeout();
}
inline double FrameworkInfo::failover_timeout() const {
  return failover_timeout_;
}
inline void FrameworkInfo::set_failover_timeout(double value) {
  set_has_failover_timeout();
  failover_timeout_ = value;
}

// optional bool checkpoint = 5 [default = false];
inline bool FrameworkInfo::has_checkpoint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FrameworkInfo::set_has_checkpoint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FrameworkInfo::clear_has_checkpoint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FrameworkInfo::clear_checkpoint() {
  checkpoint_ = false;
  clear_has_checkpoint();
}
inline bool FrameworkInfo::checkpoint() const {
  return checkpoint_;
}
inline void FrameworkInfo::set_checkpoint(bool value) {
  set_has_checkpoint();
  checkpoint_ = value;
}

// optional string role = 6 [default = "*"];
inline bool FrameworkInfo::has_role() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FrameworkInfo::set_has_role() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FrameworkInfo::clear_has_role() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FrameworkInfo::clear_role() {
  if (role_ != _default_role_) {
    role_->assign(*_default_role_);
  }
  clear_has_role();
}
inline const ::std::string& FrameworkInfo::role() const {
  return *role_;
}
inline void FrameworkInfo::set_role(const ::std::string& value) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void FrameworkInfo::set_role(const char* value) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void FrameworkInfo::set_role(const char* value, size_t size) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkInfo::mutable_role() {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string(*_default_role_);
  }
  return role_;
}
inline ::std::string* FrameworkInfo::release_role() {
  clear_has_role();
  if (role_ == _default_role_) {
    return NULL;
  } else {
    ::std::string* temp = role_;
    role_ = const_cast< ::std::string*>(_default_role_);
    return temp;
  }
}
inline void FrameworkInfo::set_allocated_role(::std::string* role) {
  if (role_ != _default_role_) {
    delete role_;
  }
  if (role) {
    set_has_role();
    role_ = role;
  } else {
    clear_has_role();
    role_ = const_cast< ::std::string*>(_default_role_);
  }
}

// optional string hostname = 7;
inline bool FrameworkInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FrameworkInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FrameworkInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FrameworkInfo::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& FrameworkInfo::hostname() const {
  return *hostname_;
}
inline void FrameworkInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void FrameworkInfo::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void FrameworkInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkInfo::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* FrameworkInfo::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FrameworkInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string principal = 8;
inline bool FrameworkInfo::has_principal() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FrameworkInfo::set_has_principal() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FrameworkInfo::clear_has_principal() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FrameworkInfo::clear_principal() {
  if (principal_ != &::google::protobuf::internal::kEmptyString) {
    principal_->clear();
  }
  clear_has_principal();
}
inline const ::std::string& FrameworkInfo::principal() const {
  return *principal_;
}
inline void FrameworkInfo::set_principal(const ::std::string& value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
}
inline void FrameworkInfo::set_principal(const char* value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
}
inline void FrameworkInfo::set_principal(const char* value, size_t size) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  principal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkInfo::mutable_principal() {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  return principal_;
}
inline ::std::string* FrameworkInfo::release_principal() {
  clear_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = principal_;
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FrameworkInfo::set_allocated_principal(::std::string* principal) {
  if (principal_ != &::google::protobuf::internal::kEmptyString) {
    delete principal_;
  }
  if (principal) {
    set_has_principal();
    principal_ = principal;
  } else {
    clear_has_principal();
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string webui_url = 9;
inline bool FrameworkInfo::has_webui_url() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FrameworkInfo::set_has_webui_url() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FrameworkInfo::clear_has_webui_url() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FrameworkInfo::clear_webui_url() {
  if (webui_url_ != &::google::protobuf::internal::kEmptyString) {
    webui_url_->clear();
  }
  clear_has_webui_url();
}
inline const ::std::string& FrameworkInfo::webui_url() const {
  return *webui_url_;
}
inline void FrameworkInfo::set_webui_url(const ::std::string& value) {
  set_has_webui_url();
  if (webui_url_ == &::google::protobuf::internal::kEmptyString) {
    webui_url_ = new ::std::string;
  }
  webui_url_->assign(value);
}
inline void FrameworkInfo::set_webui_url(const char* value) {
  set_has_webui_url();
  if (webui_url_ == &::google::protobuf::internal::kEmptyString) {
    webui_url_ = new ::std::string;
  }
  webui_url_->assign(value);
}
inline void FrameworkInfo::set_webui_url(const char* value, size_t size) {
  set_has_webui_url();
  if (webui_url_ == &::google::protobuf::internal::kEmptyString) {
    webui_url_ = new ::std::string;
  }
  webui_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkInfo::mutable_webui_url() {
  set_has_webui_url();
  if (webui_url_ == &::google::protobuf::internal::kEmptyString) {
    webui_url_ = new ::std::string;
  }
  return webui_url_;
}
inline ::std::string* FrameworkInfo::release_webui_url() {
  clear_has_webui_url();
  if (webui_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = webui_url_;
    webui_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FrameworkInfo::set_allocated_webui_url(::std::string* webui_url) {
  if (webui_url_ != &::google::protobuf::internal::kEmptyString) {
    delete webui_url_;
  }
  if (webui_url) {
    set_has_webui_url();
    webui_url_ = webui_url;
  } else {
    clear_has_webui_url();
    webui_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HealthCheck_HTTP

// required uint32 port = 1;
inline bool HealthCheck_HTTP::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HealthCheck_HTTP::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HealthCheck_HTTP::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HealthCheck_HTTP::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 HealthCheck_HTTP::port() const {
  return port_;
}
inline void HealthCheck_HTTP::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string path = 2 [default = "/"];
inline bool HealthCheck_HTTP::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HealthCheck_HTTP::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HealthCheck_HTTP::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HealthCheck_HTTP::clear_path() {
  if (path_ != _default_path_) {
    path_->assign(*_default_path_);
  }
  clear_has_path();
}
inline const ::std::string& HealthCheck_HTTP::path() const {
  return *path_;
}
inline void HealthCheck_HTTP::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == _default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void HealthCheck_HTTP::set_path(const char* value) {
  set_has_path();
  if (path_ == _default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void HealthCheck_HTTP::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == _default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthCheck_HTTP::mutable_path() {
  set_has_path();
  if (path_ == _default_path_) {
    path_ = new ::std::string(*_default_path_);
  }
  return path_;
}
inline ::std::string* HealthCheck_HTTP::release_path() {
  clear_has_path();
  if (path_ == _default_path_) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(_default_path_);
    return temp;
  }
}
inline void HealthCheck_HTTP::set_allocated_path(::std::string* path) {
  if (path_ != _default_path_) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(_default_path_);
  }
}

// repeated uint32 statuses = 4;
inline int HealthCheck_HTTP::statuses_size() const {
  return statuses_.size();
}
inline void HealthCheck_HTTP::clear_statuses() {
  statuses_.Clear();
}
inline ::google::protobuf::uint32 HealthCheck_HTTP::statuses(int index) const {
  return statuses_.Get(index);
}
inline void HealthCheck_HTTP::set_statuses(int index, ::google::protobuf::uint32 value) {
  statuses_.Set(index, value);
}
inline void HealthCheck_HTTP::add_statuses(::google::protobuf::uint32 value) {
  statuses_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
HealthCheck_HTTP::statuses() const {
  return statuses_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
HealthCheck_HTTP::mutable_statuses() {
  return &statuses_;
}

// -------------------------------------------------------------------

// HealthCheck

// optional .mesos.HealthCheck.HTTP http = 1;
inline bool HealthCheck::has_http() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HealthCheck::set_has_http() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HealthCheck::clear_has_http() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HealthCheck::clear_http() {
  if (http_ != NULL) http_->::mesos::HealthCheck_HTTP::Clear();
  clear_has_http();
}
inline const ::mesos::HealthCheck_HTTP& HealthCheck::http() const {
  return http_ != NULL ? *http_ : *default_instance_->http_;
}
inline ::mesos::HealthCheck_HTTP* HealthCheck::mutable_http() {
  set_has_http();
  if (http_ == NULL) http_ = new ::mesos::HealthCheck_HTTP;
  return http_;
}
inline ::mesos::HealthCheck_HTTP* HealthCheck::release_http() {
  clear_has_http();
  ::mesos::HealthCheck_HTTP* temp = http_;
  http_ = NULL;
  return temp;
}
inline void HealthCheck::set_allocated_http(::mesos::HealthCheck_HTTP* http) {
  delete http_;
  http_ = http;
  if (http) {
    set_has_http();
  } else {
    clear_has_http();
  }
}

// optional double delay_seconds = 2 [default = 15];
inline bool HealthCheck::has_delay_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HealthCheck::set_has_delay_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HealthCheck::clear_has_delay_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HealthCheck::clear_delay_seconds() {
  delay_seconds_ = 15;
  clear_has_delay_seconds();
}
inline double HealthCheck::delay_seconds() const {
  return delay_seconds_;
}
inline void HealthCheck::set_delay_seconds(double value) {
  set_has_delay_seconds();
  delay_seconds_ = value;
}

// optional double interval_seconds = 3 [default = 10];
inline bool HealthCheck::has_interval_seconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HealthCheck::set_has_interval_seconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HealthCheck::clear_has_interval_seconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HealthCheck::clear_interval_seconds() {
  interval_seconds_ = 10;
  clear_has_interval_seconds();
}
inline double HealthCheck::interval_seconds() const {
  return interval_seconds_;
}
inline void HealthCheck::set_interval_seconds(double value) {
  set_has_interval_seconds();
  interval_seconds_ = value;
}

// optional double timeout_seconds = 4 [default = 20];
inline bool HealthCheck::has_timeout_seconds() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HealthCheck::set_has_timeout_seconds() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HealthCheck::clear_has_timeout_seconds() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HealthCheck::clear_timeout_seconds() {
  timeout_seconds_ = 20;
  clear_has_timeout_seconds();
}
inline double HealthCheck::timeout_seconds() const {
  return timeout_seconds_;
}
inline void HealthCheck::set_timeout_seconds(double value) {
  set_has_timeout_seconds();
  timeout_seconds_ = value;
}

// optional uint32 consecutive_failures = 5 [default = 3];
inline bool HealthCheck::has_consecutive_failures() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HealthCheck::set_has_consecutive_failures() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HealthCheck::clear_has_consecutive_failures() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HealthCheck::clear_consecutive_failures() {
  consecutive_failures_ = 3u;
  clear_has_consecutive_failures();
}
inline ::google::protobuf::uint32 HealthCheck::consecutive_failures() const {
  return consecutive_failures_;
}
inline void HealthCheck::set_consecutive_failures(::google::protobuf::uint32 value) {
  set_has_consecutive_failures();
  consecutive_failures_ = value;
}

// optional double grace_period_seconds = 6 [default = 10];
inline bool HealthCheck::has_grace_period_seconds() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HealthCheck::set_has_grace_period_seconds() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HealthCheck::clear_has_grace_period_seconds() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HealthCheck::clear_grace_period_seconds() {
  grace_period_seconds_ = 10;
  clear_has_grace_period_seconds();
}
inline double HealthCheck::grace_period_seconds() const {
  return grace_period_seconds_;
}
inline void HealthCheck::set_grace_period_seconds(double value) {
  set_has_grace_period_seconds();
  grace_period_seconds_ = value;
}

// optional .mesos.CommandInfo command = 7;
inline bool HealthCheck::has_command() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HealthCheck::set_has_command() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HealthCheck::clear_has_command() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HealthCheck::clear_command() {
  if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  clear_has_command();
}
inline const ::mesos::CommandInfo& HealthCheck::command() const {
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::mesos::CommandInfo* HealthCheck::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::mesos::CommandInfo;
  return command_;
}
inline ::mesos::CommandInfo* HealthCheck::release_command() {
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline void HealthCheck::set_allocated_command(::mesos::CommandInfo* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
}

// -------------------------------------------------------------------

// CommandInfo_URI

// required string value = 1;
inline bool CommandInfo_URI::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandInfo_URI::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandInfo_URI::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandInfo_URI::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& CommandInfo_URI::value() const {
  return *value_;
}
inline void CommandInfo_URI::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CommandInfo_URI::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CommandInfo_URI::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandInfo_URI::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* CommandInfo_URI::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandInfo_URI::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool executable = 2;
inline bool CommandInfo_URI::has_executable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandInfo_URI::set_has_executable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandInfo_URI::clear_has_executable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandInfo_URI::clear_executable() {
  executable_ = false;
  clear_has_executable();
}
inline bool CommandInfo_URI::executable() const {
  return executable_;
}
inline void CommandInfo_URI::set_executable(bool value) {
  set_has_executable();
  executable_ = value;
}

// optional bool extract = 3 [default = true];
inline bool CommandInfo_URI::has_extract() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandInfo_URI::set_has_extract() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandInfo_URI::clear_has_extract() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandInfo_URI::clear_extract() {
  extract_ = true;
  clear_has_extract();
}
inline bool CommandInfo_URI::extract() const {
  return extract_;
}
inline void CommandInfo_URI::set_extract(bool value) {
  set_has_extract();
  extract_ = value;
}

// -------------------------------------------------------------------

// CommandInfo_ContainerInfo

// required string image = 1;
inline bool CommandInfo_ContainerInfo::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandInfo_ContainerInfo::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandInfo_ContainerInfo::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandInfo_ContainerInfo::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& CommandInfo_ContainerInfo::image() const {
  return *image_;
}
inline void CommandInfo_ContainerInfo::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void CommandInfo_ContainerInfo::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void CommandInfo_ContainerInfo::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandInfo_ContainerInfo::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* CommandInfo_ContainerInfo::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandInfo_ContainerInfo::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string options = 2;
inline int CommandInfo_ContainerInfo::options_size() const {
  return options_.size();
}
inline void CommandInfo_ContainerInfo::clear_options() {
  options_.Clear();
}
inline const ::std::string& CommandInfo_ContainerInfo::options(int index) const {
  return options_.Get(index);
}
inline ::std::string* CommandInfo_ContainerInfo::mutable_options(int index) {
  return options_.Mutable(index);
}
inline void CommandInfo_ContainerInfo::set_options(int index, const ::std::string& value) {
  options_.Mutable(index)->assign(value);
}
inline void CommandInfo_ContainerInfo::set_options(int index, const char* value) {
  options_.Mutable(index)->assign(value);
}
inline void CommandInfo_ContainerInfo::set_options(int index, const char* value, size_t size) {
  options_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandInfo_ContainerInfo::add_options() {
  return options_.Add();
}
inline void CommandInfo_ContainerInfo::add_options(const ::std::string& value) {
  options_.Add()->assign(value);
}
inline void CommandInfo_ContainerInfo::add_options(const char* value) {
  options_.Add()->assign(value);
}
inline void CommandInfo_ContainerInfo::add_options(const char* value, size_t size) {
  options_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommandInfo_ContainerInfo::options() const {
  return options_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommandInfo_ContainerInfo::mutable_options() {
  return &options_;
}

// -------------------------------------------------------------------

// CommandInfo

// optional .mesos.CommandInfo.ContainerInfo container = 4;
inline bool CommandInfo::has_container() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandInfo::set_has_container() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandInfo::clear_has_container() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandInfo::clear_container() {
  if (container_ != NULL) container_->::mesos::CommandInfo_ContainerInfo::Clear();
  clear_has_container();
}
inline const ::mesos::CommandInfo_ContainerInfo& CommandInfo::container() const {
  return container_ != NULL ? *container_ : *default_instance_->container_;
}
inline ::mesos::CommandInfo_ContainerInfo* CommandInfo::mutable_container() {
  set_has_container();
  if (container_ == NULL) container_ = new ::mesos::CommandInfo_ContainerInfo;
  return container_;
}
inline ::mesos::CommandInfo_ContainerInfo* CommandInfo::release_container() {
  clear_has_container();
  ::mesos::CommandInfo_ContainerInfo* temp = container_;
  container_ = NULL;
  return temp;
}
inline void CommandInfo::set_allocated_container(::mesos::CommandInfo_ContainerInfo* container) {
  delete container_;
  container_ = container;
  if (container) {
    set_has_container();
  } else {
    clear_has_container();
  }
}

// repeated .mesos.CommandInfo.URI uris = 1;
inline int CommandInfo::uris_size() const {
  return uris_.size();
}
inline void CommandInfo::clear_uris() {
  uris_.Clear();
}
inline const ::mesos::CommandInfo_URI& CommandInfo::uris(int index) const {
  return uris_.Get(index);
}
inline ::mesos::CommandInfo_URI* CommandInfo::mutable_uris(int index) {
  return uris_.Mutable(index);
}
inline ::mesos::CommandInfo_URI* CommandInfo::add_uris() {
  return uris_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >&
CommandInfo::uris() const {
  return uris_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >*
CommandInfo::mutable_uris() {
  return &uris_;
}

// optional .mesos.Environment environment = 2;
inline bool CommandInfo::has_environment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandInfo::set_has_environment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandInfo::clear_has_environment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandInfo::clear_environment() {
  if (environment_ != NULL) environment_->::mesos::Environment::Clear();
  clear_has_environment();
}
inline const ::mesos::Environment& CommandInfo::environment() const {
  return environment_ != NULL ? *environment_ : *default_instance_->environment_;
}
inline ::mesos::Environment* CommandInfo::mutable_environment() {
  set_has_environment();
  if (environment_ == NULL) environment_ = new ::mesos::Environment;
  return environment_;
}
inline ::mesos::Environment* CommandInfo::release_environment() {
  clear_has_environment();
  ::mesos::Environment* temp = environment_;
  environment_ = NULL;
  return temp;
}
inline void CommandInfo::set_allocated_environment(::mesos::Environment* environment) {
  delete environment_;
  environment_ = environment;
  if (environment) {
    set_has_environment();
  } else {
    clear_has_environment();
  }
}

// optional bool shell = 6 [default = true];
inline bool CommandInfo::has_shell() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandInfo::set_has_shell() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandInfo::clear_has_shell() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandInfo::clear_shell() {
  shell_ = true;
  clear_has_shell();
}
inline bool CommandInfo::shell() const {
  return shell_;
}
inline void CommandInfo::set_shell(bool value) {
  set_has_shell();
  shell_ = value;
}

// optional string value = 3;
inline bool CommandInfo::has_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandInfo::set_has_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandInfo::clear_has_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandInfo::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& CommandInfo::value() const {
  return *value_;
}
inline void CommandInfo::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CommandInfo::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CommandInfo::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandInfo::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* CommandInfo::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandInfo::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string arguments = 7;
inline int CommandInfo::arguments_size() const {
  return arguments_.size();
}
inline void CommandInfo::clear_arguments() {
  arguments_.Clear();
}
inline const ::std::string& CommandInfo::arguments(int index) const {
  return arguments_.Get(index);
}
inline ::std::string* CommandInfo::mutable_arguments(int index) {
  return arguments_.Mutable(index);
}
inline void CommandInfo::set_arguments(int index, const ::std::string& value) {
  arguments_.Mutable(index)->assign(value);
}
inline void CommandInfo::set_arguments(int index, const char* value) {
  arguments_.Mutable(index)->assign(value);
}
inline void CommandInfo::set_arguments(int index, const char* value, size_t size) {
  arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandInfo::add_arguments() {
  return arguments_.Add();
}
inline void CommandInfo::add_arguments(const ::std::string& value) {
  arguments_.Add()->assign(value);
}
inline void CommandInfo::add_arguments(const char* value) {
  arguments_.Add()->assign(value);
}
inline void CommandInfo::add_arguments(const char* value, size_t size) {
  arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommandInfo::arguments() const {
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommandInfo::mutable_arguments() {
  return &arguments_;
}

// optional string user = 5;
inline bool CommandInfo::has_user() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandInfo::set_has_user() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandInfo::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& CommandInfo::user() const {
  return *user_;
}
inline void CommandInfo::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void CommandInfo::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void CommandInfo::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandInfo::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* CommandInfo::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandInfo::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ExecutorInfo

// required .mesos.ExecutorID executor_id = 1;
inline bool ExecutorInfo::has_executor_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutorInfo::set_has_executor_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutorInfo::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutorInfo::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& ExecutorInfo::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* ExecutorInfo::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* ExecutorInfo::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void ExecutorInfo::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
}

// optional .mesos.FrameworkID framework_id = 8;
inline bool ExecutorInfo::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecutorInfo::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecutorInfo::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecutorInfo::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& ExecutorInfo::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ExecutorInfo::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* ExecutorInfo::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void ExecutorInfo::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .mesos.CommandInfo command = 7;
inline bool ExecutorInfo::has_command() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecutorInfo::set_has_command() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecutorInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecutorInfo::clear_command() {
  if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  clear_has_command();
}
inline const ::mesos::CommandInfo& ExecutorInfo::command() const {
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::mesos::CommandInfo* ExecutorInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::mesos::CommandInfo;
  return command_;
}
inline ::mesos::CommandInfo* ExecutorInfo::release_command() {
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline void ExecutorInfo::set_allocated_command(::mesos::CommandInfo* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
}

// optional .mesos.ContainerInfo container = 11;
inline bool ExecutorInfo::has_container() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExecutorInfo::set_has_container() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExecutorInfo::clear_has_container() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExecutorInfo::clear_container() {
  if (container_ != NULL) container_->::mesos::ContainerInfo::Clear();
  clear_has_container();
}
inline const ::mesos::ContainerInfo& ExecutorInfo::container() const {
  return container_ != NULL ? *container_ : *default_instance_->container_;
}
inline ::mesos::ContainerInfo* ExecutorInfo::mutable_container() {
  set_has_container();
  if (container_ == NULL) container_ = new ::mesos::ContainerInfo;
  return container_;
}
inline ::mesos::ContainerInfo* ExecutorInfo::release_container() {
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  container_ = NULL;
  return temp;
}
inline void ExecutorInfo::set_allocated_container(::mesos::ContainerInfo* container) {
  delete container_;
  container_ = container;
  if (container) {
    set_has_container();
  } else {
    clear_has_container();
  }
}

// repeated .mesos.Resource resources = 5;
inline int ExecutorInfo::resources_size() const {
  return resources_.size();
}
inline void ExecutorInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& ExecutorInfo::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* ExecutorInfo::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* ExecutorInfo::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ExecutorInfo::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ExecutorInfo::mutable_resources() {
  return &resources_;
}

// optional string name = 9;
inline bool ExecutorInfo::has_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExecutorInfo::set_has_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExecutorInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExecutorInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ExecutorInfo::name() const {
  return *name_;
}
inline void ExecutorInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ExecutorInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ExecutorInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ExecutorInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutorInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string source = 10;
inline bool ExecutorInfo::has_source() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExecutorInfo::set_has_source() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExecutorInfo::clear_has_source() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExecutorInfo::clear_source() {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& ExecutorInfo::source() const {
  return *source_;
}
inline void ExecutorInfo::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void ExecutorInfo::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void ExecutorInfo::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorInfo::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  return source_;
}
inline ::std::string* ExecutorInfo::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutorInfo::set_allocated_source(::std::string* source) {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    delete source_;
  }
  if (source) {
    set_has_source();
    source_ = source;
  } else {
    clear_has_source();
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes data = 4;
inline bool ExecutorInfo::has_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExecutorInfo::set_has_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ExecutorInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ExecutorInfo::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ExecutorInfo::data() const {
  return *data_;
}
inline void ExecutorInfo::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ExecutorInfo::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ExecutorInfo::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorInfo::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ExecutorInfo::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutorInfo::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mesos.DiscoveryInfo discovery = 12;
inline bool ExecutorInfo::has_discovery() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ExecutorInfo::set_has_discovery() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ExecutorInfo::clear_has_discovery() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ExecutorInfo::clear_discovery() {
  if (discovery_ != NULL) discovery_->::mesos::DiscoveryInfo::Clear();
  clear_has_discovery();
}
inline const ::mesos::DiscoveryInfo& ExecutorInfo::discovery() const {
  return discovery_ != NULL ? *discovery_ : *default_instance_->discovery_;
}
inline ::mesos::DiscoveryInfo* ExecutorInfo::mutable_discovery() {
  set_has_discovery();
  if (discovery_ == NULL) discovery_ = new ::mesos::DiscoveryInfo;
  return discovery_;
}
inline ::mesos::DiscoveryInfo* ExecutorInfo::release_discovery() {
  clear_has_discovery();
  ::mesos::DiscoveryInfo* temp = discovery_;
  discovery_ = NULL;
  return temp;
}
inline void ExecutorInfo::set_allocated_discovery(::mesos::DiscoveryInfo* discovery) {
  delete discovery_;
  discovery_ = discovery;
  if (discovery) {
    set_has_discovery();
  } else {
    clear_has_discovery();
  }
}

// -------------------------------------------------------------------

// MasterInfo

// required string id = 1;
inline bool MasterInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& MasterInfo::id() const {
  return *id_;
}
inline void MasterInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void MasterInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void MasterInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MasterInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* MasterInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MasterInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 ip = 2;
inline bool MasterInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MasterInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MasterInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MasterInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 MasterInfo::ip() const {
  return ip_;
}
inline void MasterInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// required uint32 port = 3 [default = 5050];
inline bool MasterInfo::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MasterInfo::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MasterInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MasterInfo::clear_port() {
  port_ = 5050u;
  clear_has_port();
}
inline ::google::protobuf::uint32 MasterInfo::port() const {
  return port_;
}
inline void MasterInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string pid = 4;
inline bool MasterInfo::has_pid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MasterInfo::set_has_pid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MasterInfo::clear_has_pid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MasterInfo::clear_pid() {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    pid_->clear();
  }
  clear_has_pid();
}
inline const ::std::string& MasterInfo::pid() const {
  return *pid_;
}
inline void MasterInfo::set_pid(const ::std::string& value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void MasterInfo::set_pid(const char* value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void MasterInfo::set_pid(const char* value, size_t size) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MasterInfo::mutable_pid() {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  return pid_;
}
inline ::std::string* MasterInfo::release_pid() {
  clear_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pid_;
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MasterInfo::set_allocated_pid(::std::string* pid) {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    delete pid_;
  }
  if (pid) {
    set_has_pid();
    pid_ = pid;
  } else {
    clear_has_pid();
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hostname = 5;
inline bool MasterInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MasterInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MasterInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MasterInfo::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& MasterInfo::hostname() const {
  return *hostname_;
}
inline void MasterInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void MasterInfo::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void MasterInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MasterInfo::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* MasterInfo::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MasterInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SlaveInfo

// required string hostname = 1;
inline bool SlaveInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveInfo::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& SlaveInfo::hostname() const {
  return *hostname_;
}
inline void SlaveInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void SlaveInfo::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void SlaveInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveInfo::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* SlaveInfo::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlaveInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 8 [default = 5051];
inline bool SlaveInfo::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveInfo::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveInfo::clear_port() {
  port_ = 5051;
  clear_has_port();
}
inline ::google::protobuf::int32 SlaveInfo::port() const {
  return port_;
}
inline void SlaveInfo::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// repeated .mesos.Resource resources = 3;
inline int SlaveInfo::resources_size() const {
  return resources_.size();
}
inline void SlaveInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& SlaveInfo::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* SlaveInfo::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* SlaveInfo::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
SlaveInfo::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
SlaveInfo::mutable_resources() {
  return &resources_;
}

// repeated .mesos.Attribute attributes = 5;
inline int SlaveInfo::attributes_size() const {
  return attributes_.size();
}
inline void SlaveInfo::clear_attributes() {
  attributes_.Clear();
}
inline const ::mesos::Attribute& SlaveInfo::attributes(int index) const {
  return attributes_.Get(index);
}
inline ::mesos::Attribute* SlaveInfo::mutable_attributes(int index) {
  return attributes_.Mutable(index);
}
inline ::mesos::Attribute* SlaveInfo::add_attributes() {
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
SlaveInfo::attributes() const {
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
SlaveInfo::mutable_attributes() {
  return &attributes_;
}

// optional .mesos.SlaveID id = 6;
inline bool SlaveInfo::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SlaveInfo::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SlaveInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SlaveInfo::clear_id() {
  if (id_ != NULL) id_->::mesos::SlaveID::Clear();
  clear_has_id();
}
inline const ::mesos::SlaveID& SlaveInfo::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mesos::SlaveID* SlaveInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mesos::SlaveID;
  return id_;
}
inline ::mesos::SlaveID* SlaveInfo::release_id() {
  clear_has_id();
  ::mesos::SlaveID* temp = id_;
  id_ = NULL;
  return temp;
}
inline void SlaveInfo::set_allocated_id(::mesos::SlaveID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// optional bool checkpoint = 7 [default = false];
inline bool SlaveInfo::has_checkpoint() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SlaveInfo::set_has_checkpoint() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SlaveInfo::clear_has_checkpoint() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SlaveInfo::clear_checkpoint() {
  checkpoint_ = false;
  clear_has_checkpoint();
}
inline bool SlaveInfo::checkpoint() const {
  return checkpoint_;
}
inline void SlaveInfo::set_checkpoint(bool value) {
  set_has_checkpoint();
  checkpoint_ = value;
}

// -------------------------------------------------------------------

// Value_Scalar

// required double value = 1;
inline bool Value_Scalar::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Scalar::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Scalar::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Scalar::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double Value_Scalar::value() const {
  return value_;
}
inline void Value_Scalar::set_value(double value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// Value_Range

// required uint64 begin = 1;
inline bool Value_Range::has_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Range::set_has_begin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Range::clear_has_begin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Range::clear_begin() {
  begin_ = GOOGLE_ULONGLONG(0);
  clear_has_begin();
}
inline ::google::protobuf::uint64 Value_Range::begin() const {
  return begin_;
}
inline void Value_Range::set_begin(::google::protobuf::uint64 value) {
  set_has_begin();
  begin_ = value;
}

// required uint64 end = 2;
inline bool Value_Range::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value_Range::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value_Range::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value_Range::clear_end() {
  end_ = GOOGLE_ULONGLONG(0);
  clear_has_end();
}
inline ::google::protobuf::uint64 Value_Range::end() const {
  return end_;
}
inline void Value_Range::set_end(::google::protobuf::uint64 value) {
  set_has_end();
  end_ = value;
}

// -------------------------------------------------------------------

// Value_Ranges

// repeated .mesos.Value.Range range = 1;
inline int Value_Ranges::range_size() const {
  return range_.size();
}
inline void Value_Ranges::clear_range() {
  range_.Clear();
}
inline const ::mesos::Value_Range& Value_Ranges::range(int index) const {
  return range_.Get(index);
}
inline ::mesos::Value_Range* Value_Ranges::mutable_range(int index) {
  return range_.Mutable(index);
}
inline ::mesos::Value_Range* Value_Ranges::add_range() {
  return range_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >&
Value_Ranges::range() const {
  return range_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >*
Value_Ranges::mutable_range() {
  return &range_;
}

// -------------------------------------------------------------------

// Value_Set

// repeated string item = 1;
inline int Value_Set::item_size() const {
  return item_.size();
}
inline void Value_Set::clear_item() {
  item_.Clear();
}
inline const ::std::string& Value_Set::item(int index) const {
  return item_.Get(index);
}
inline ::std::string* Value_Set::mutable_item(int index) {
  return item_.Mutable(index);
}
inline void Value_Set::set_item(int index, const ::std::string& value) {
  item_.Mutable(index)->assign(value);
}
inline void Value_Set::set_item(int index, const char* value) {
  item_.Mutable(index)->assign(value);
}
inline void Value_Set::set_item(int index, const char* value, size_t size) {
  item_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Value_Set::add_item() {
  return item_.Add();
}
inline void Value_Set::add_item(const ::std::string& value) {
  item_.Add()->assign(value);
}
inline void Value_Set::add_item(const char* value) {
  item_.Add()->assign(value);
}
inline void Value_Set::add_item(const char* value, size_t size) {
  item_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Value_Set::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Value_Set::mutable_item() {
  return &item_;
}

// -------------------------------------------------------------------

// Value_Text

// required string value = 1;
inline bool Value_Text::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Text::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Text::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Text::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Value_Text::value() const {
  return *value_;
}
inline void Value_Text::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Value_Text::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Value_Text::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Value_Text::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Value_Text::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Value_Text::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Value

// required .mesos.Value.Type type = 1;
inline bool Value::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Value_Type Value::type() const {
  return static_cast< ::mesos::Value_Type >(type_);
}
inline void Value::set_type(::mesos::Value_Type value) {
  assert(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mesos.Value.Scalar scalar = 2;
inline bool Value::has_scalar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value::set_has_scalar() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value::clear_scalar() {
  if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
  clear_has_scalar();
}
inline const ::mesos::Value_Scalar& Value::scalar() const {
  return scalar_ != NULL ? *scalar_ : *default_instance_->scalar_;
}
inline ::mesos::Value_Scalar* Value::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) scalar_ = new ::mesos::Value_Scalar;
  return scalar_;
}
inline ::mesos::Value_Scalar* Value::release_scalar() {
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}
inline void Value::set_allocated_scalar(::mesos::Value_Scalar* scalar) {
  delete scalar_;
  scalar_ = scalar;
  if (scalar) {
    set_has_scalar();
  } else {
    clear_has_scalar();
  }
}

// optional .mesos.Value.Ranges ranges = 3;
inline bool Value::has_ranges() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Value::set_has_ranges() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Value::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Value::clear_ranges() {
  if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
  clear_has_ranges();
}
inline const ::mesos::Value_Ranges& Value::ranges() const {
  return ranges_ != NULL ? *ranges_ : *default_instance_->ranges_;
}
inline ::mesos::Value_Ranges* Value::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) ranges_ = new ::mesos::Value_Ranges;
  return ranges_;
}
inline ::mesos::Value_Ranges* Value::release_ranges() {
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}
inline void Value::set_allocated_ranges(::mesos::Value_Ranges* ranges) {
  delete ranges_;
  ranges_ = ranges;
  if (ranges) {
    set_has_ranges();
  } else {
    clear_has_ranges();
  }
}

// optional .mesos.Value.Set set = 4;
inline bool Value::has_set() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Value::set_has_set() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Value::clear_has_set() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Value::clear_set() {
  if (set_ != NULL) set_->::mesos::Value_Set::Clear();
  clear_has_set();
}
inline const ::mesos::Value_Set& Value::set() const {
  return set_ != NULL ? *set_ : *default_instance_->set_;
}
inline ::mesos::Value_Set* Value::mutable_set() {
  set_has_set();
  if (set_ == NULL) set_ = new ::mesos::Value_Set;
  return set_;
}
inline ::mesos::Value_Set* Value::release_set() {
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}
inline void Value::set_allocated_set(::mesos::Value_Set* set) {
  delete set_;
  set_ = set;
  if (set) {
    set_has_set();
  } else {
    clear_has_set();
  }
}

// optional .mesos.Value.Text text = 5;
inline bool Value::has_text() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Value::set_has_text() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Value::clear_has_text() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Value::clear_text() {
  if (text_ != NULL) text_->::mesos::Value_Text::Clear();
  clear_has_text();
}
inline const ::mesos::Value_Text& Value::text() const {
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::mesos::Value_Text* Value::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::mesos::Value_Text;
  return text_;
}
inline ::mesos::Value_Text* Value::release_text() {
  clear_has_text();
  ::mesos::Value_Text* temp = text_;
  text_ = NULL;
  return temp;
}
inline void Value::set_allocated_text(::mesos::Value_Text* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
}

// -------------------------------------------------------------------

// Attribute

// required string name = 1;
inline bool Attribute::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attribute::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attribute::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attribute::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Attribute::name() const {
  return *name_;
}
inline void Attribute::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Attribute::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Attribute::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Attribute::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Attribute::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Attribute::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .mesos.Value.Type type = 2;
inline bool Attribute::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attribute::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attribute::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attribute::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Value_Type Attribute::type() const {
  return static_cast< ::mesos::Value_Type >(type_);
}
inline void Attribute::set_type(::mesos::Value_Type value) {
  assert(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mesos.Value.Scalar scalar = 3;
inline bool Attribute::has_scalar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Attribute::set_has_scalar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Attribute::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Attribute::clear_scalar() {
  if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
  clear_has_scalar();
}
inline const ::mesos::Value_Scalar& Attribute::scalar() const {
  return scalar_ != NULL ? *scalar_ : *default_instance_->scalar_;
}
inline ::mesos::Value_Scalar* Attribute::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) scalar_ = new ::mesos::Value_Scalar;
  return scalar_;
}
inline ::mesos::Value_Scalar* Attribute::release_scalar() {
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}
inline void Attribute::set_allocated_scalar(::mesos::Value_Scalar* scalar) {
  delete scalar_;
  scalar_ = scalar;
  if (scalar) {
    set_has_scalar();
  } else {
    clear_has_scalar();
  }
}

// optional .mesos.Value.Ranges ranges = 4;
inline bool Attribute::has_ranges() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Attribute::set_has_ranges() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Attribute::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Attribute::clear_ranges() {
  if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
  clear_has_ranges();
}
inline const ::mesos::Value_Ranges& Attribute::ranges() const {
  return ranges_ != NULL ? *ranges_ : *default_instance_->ranges_;
}
inline ::mesos::Value_Ranges* Attribute::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) ranges_ = new ::mesos::Value_Ranges;
  return ranges_;
}
inline ::mesos::Value_Ranges* Attribute::release_ranges() {
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}
inline void Attribute::set_allocated_ranges(::mesos::Value_Ranges* ranges) {
  delete ranges_;
  ranges_ = ranges;
  if (ranges) {
    set_has_ranges();
  } else {
    clear_has_ranges();
  }
}

// optional .mesos.Value.Set set = 6;
inline bool Attribute::has_set() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Attribute::set_has_set() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Attribute::clear_has_set() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Attribute::clear_set() {
  if (set_ != NULL) set_->::mesos::Value_Set::Clear();
  clear_has_set();
}
inline const ::mesos::Value_Set& Attribute::set() const {
  return set_ != NULL ? *set_ : *default_instance_->set_;
}
inline ::mesos::Value_Set* Attribute::mutable_set() {
  set_has_set();
  if (set_ == NULL) set_ = new ::mesos::Value_Set;
  return set_;
}
inline ::mesos::Value_Set* Attribute::release_set() {
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}
inline void Attribute::set_allocated_set(::mesos::Value_Set* set) {
  delete set_;
  set_ = set;
  if (set) {
    set_has_set();
  } else {
    clear_has_set();
  }
}

// optional .mesos.Value.Text text = 5;
inline bool Attribute::has_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Attribute::set_has_text() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Attribute::clear_has_text() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Attribute::clear_text() {
  if (text_ != NULL) text_->::mesos::Value_Text::Clear();
  clear_has_text();
}
inline const ::mesos::Value_Text& Attribute::text() const {
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::mesos::Value_Text* Attribute::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::mesos::Value_Text;
  return text_;
}
inline ::mesos::Value_Text* Attribute::release_text() {
  clear_has_text();
  ::mesos::Value_Text* temp = text_;
  text_ = NULL;
  return temp;
}
inline void Attribute::set_allocated_text(::mesos::Value_Text* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
}

// -------------------------------------------------------------------

// Resource_DiskInfo_Persistence

// required string id = 1;
inline bool Resource_DiskInfo_Persistence::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource_DiskInfo_Persistence::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource_DiskInfo_Persistence::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource_DiskInfo_Persistence::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Resource_DiskInfo_Persistence::id() const {
  return *id_;
}
inline void Resource_DiskInfo_Persistence::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Resource_DiskInfo_Persistence::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Resource_DiskInfo_Persistence::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Resource_DiskInfo_Persistence::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Resource_DiskInfo_Persistence::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Resource_DiskInfo_Persistence::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Resource_DiskInfo

// optional .mesos.Resource.DiskInfo.Persistence persistence = 1;
inline bool Resource_DiskInfo::has_persistence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource_DiskInfo::set_has_persistence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource_DiskInfo::clear_has_persistence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource_DiskInfo::clear_persistence() {
  if (persistence_ != NULL) persistence_->::mesos::Resource_DiskInfo_Persistence::Clear();
  clear_has_persistence();
}
inline const ::mesos::Resource_DiskInfo_Persistence& Resource_DiskInfo::persistence() const {
  return persistence_ != NULL ? *persistence_ : *default_instance_->persistence_;
}
inline ::mesos::Resource_DiskInfo_Persistence* Resource_DiskInfo::mutable_persistence() {
  set_has_persistence();
  if (persistence_ == NULL) persistence_ = new ::mesos::Resource_DiskInfo_Persistence;
  return persistence_;
}
inline ::mesos::Resource_DiskInfo_Persistence* Resource_DiskInfo::release_persistence() {
  clear_has_persistence();
  ::mesos::Resource_DiskInfo_Persistence* temp = persistence_;
  persistence_ = NULL;
  return temp;
}
inline void Resource_DiskInfo::set_allocated_persistence(::mesos::Resource_DiskInfo_Persistence* persistence) {
  delete persistence_;
  persistence_ = persistence;
  if (persistence) {
    set_has_persistence();
  } else {
    clear_has_persistence();
  }
}

// optional .mesos.Volume volume = 2;
inline bool Resource_DiskInfo::has_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource_DiskInfo::set_has_volume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource_DiskInfo::clear_has_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource_DiskInfo::clear_volume() {
  if (volume_ != NULL) volume_->::mesos::Volume::Clear();
  clear_has_volume();
}
inline const ::mesos::Volume& Resource_DiskInfo::volume() const {
  return volume_ != NULL ? *volume_ : *default_instance_->volume_;
}
inline ::mesos::Volume* Resource_DiskInfo::mutable_volume() {
  set_has_volume();
  if (volume_ == NULL) volume_ = new ::mesos::Volume;
  return volume_;
}
inline ::mesos::Volume* Resource_DiskInfo::release_volume() {
  clear_has_volume();
  ::mesos::Volume* temp = volume_;
  volume_ = NULL;
  return temp;
}
inline void Resource_DiskInfo::set_allocated_volume(::mesos::Volume* volume) {
  delete volume_;
  volume_ = volume;
  if (volume) {
    set_has_volume();
  } else {
    clear_has_volume();
  }
}

// -------------------------------------------------------------------

// Resource

// required string name = 1;
inline bool Resource::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Resource::name() const {
  return *name_;
}
inline void Resource::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Resource::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Resource::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Resource::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Resource::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Resource::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .mesos.Value.Type type = 2;
inline bool Resource::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Value_Type Resource::type() const {
  return static_cast< ::mesos::Value_Type >(type_);
}
inline void Resource::set_type(::mesos::Value_Type value) {
  assert(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mesos.Value.Scalar scalar = 3;
inline bool Resource::has_scalar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Resource::set_has_scalar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Resource::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Resource::clear_scalar() {
  if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
  clear_has_scalar();
}
inline const ::mesos::Value_Scalar& Resource::scalar() const {
  return scalar_ != NULL ? *scalar_ : *default_instance_->scalar_;
}
inline ::mesos::Value_Scalar* Resource::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) scalar_ = new ::mesos::Value_Scalar;
  return scalar_;
}
inline ::mesos::Value_Scalar* Resource::release_scalar() {
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}
inline void Resource::set_allocated_scalar(::mesos::Value_Scalar* scalar) {
  delete scalar_;
  scalar_ = scalar;
  if (scalar) {
    set_has_scalar();
  } else {
    clear_has_scalar();
  }
}

// optional .mesos.Value.Ranges ranges = 4;
inline bool Resource::has_ranges() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Resource::set_has_ranges() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Resource::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Resource::clear_ranges() {
  if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
  clear_has_ranges();
}
inline const ::mesos::Value_Ranges& Resource::ranges() const {
  return ranges_ != NULL ? *ranges_ : *default_instance_->ranges_;
}
inline ::mesos::Value_Ranges* Resource::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) ranges_ = new ::mesos::Value_Ranges;
  return ranges_;
}
inline ::mesos::Value_Ranges* Resource::release_ranges() {
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}
inline void Resource::set_allocated_ranges(::mesos::Value_Ranges* ranges) {
  delete ranges_;
  ranges_ = ranges;
  if (ranges) {
    set_has_ranges();
  } else {
    clear_has_ranges();
  }
}

// optional .mesos.Value.Set set = 5;
inline bool Resource::has_set() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Resource::set_has_set() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Resource::clear_has_set() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Resource::clear_set() {
  if (set_ != NULL) set_->::mesos::Value_Set::Clear();
  clear_has_set();
}
inline const ::mesos::Value_Set& Resource::set() const {
  return set_ != NULL ? *set_ : *default_instance_->set_;
}
inline ::mesos::Value_Set* Resource::mutable_set() {
  set_has_set();
  if (set_ == NULL) set_ = new ::mesos::Value_Set;
  return set_;
}
inline ::mesos::Value_Set* Resource::release_set() {
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}
inline void Resource::set_allocated_set(::mesos::Value_Set* set) {
  delete set_;
  set_ = set;
  if (set) {
    set_has_set();
  } else {
    clear_has_set();
  }
}

// optional string role = 6 [default = "*"];
inline bool Resource::has_role() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Resource::set_has_role() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Resource::clear_has_role() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Resource::clear_role() {
  if (role_ != _default_role_) {
    role_->assign(*_default_role_);
  }
  clear_has_role();
}
inline const ::std::string& Resource::role() const {
  return *role_;
}
inline void Resource::set_role(const ::std::string& value) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void Resource::set_role(const char* value) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void Resource::set_role(const char* value, size_t size) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Resource::mutable_role() {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string(*_default_role_);
  }
  return role_;
}
inline ::std::string* Resource::release_role() {
  clear_has_role();
  if (role_ == _default_role_) {
    return NULL;
  } else {
    ::std::string* temp = role_;
    role_ = const_cast< ::std::string*>(_default_role_);
    return temp;
  }
}
inline void Resource::set_allocated_role(::std::string* role) {
  if (role_ != _default_role_) {
    delete role_;
  }
  if (role) {
    set_has_role();
    role_ = role;
  } else {
    clear_has_role();
    role_ = const_cast< ::std::string*>(_default_role_);
  }
}

// optional .mesos.Resource.DiskInfo disk = 7;
inline bool Resource::has_disk() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Resource::set_has_disk() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Resource::clear_has_disk() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Resource::clear_disk() {
  if (disk_ != NULL) disk_->::mesos::Resource_DiskInfo::Clear();
  clear_has_disk();
}
inline const ::mesos::Resource_DiskInfo& Resource::disk() const {
  return disk_ != NULL ? *disk_ : *default_instance_->disk_;
}
inline ::mesos::Resource_DiskInfo* Resource::mutable_disk() {
  set_has_disk();
  if (disk_ == NULL) disk_ = new ::mesos::Resource_DiskInfo;
  return disk_;
}
inline ::mesos::Resource_DiskInfo* Resource::release_disk() {
  clear_has_disk();
  ::mesos::Resource_DiskInfo* temp = disk_;
  disk_ = NULL;
  return temp;
}
inline void Resource::set_allocated_disk(::mesos::Resource_DiskInfo* disk) {
  delete disk_;
  disk_ = disk;
  if (disk) {
    set_has_disk();
  } else {
    clear_has_disk();
  }
}

// -------------------------------------------------------------------

// ResourceStatistics

// required double timestamp = 1;
inline bool ResourceStatistics::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceStatistics::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceStatistics::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceStatistics::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double ResourceStatistics::timestamp() const {
  return timestamp_;
}
inline void ResourceStatistics::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional double cpus_user_time_secs = 2;
inline bool ResourceStatistics::has_cpus_user_time_secs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceStatistics::set_has_cpus_user_time_secs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceStatistics::clear_has_cpus_user_time_secs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceStatistics::clear_cpus_user_time_secs() {
  cpus_user_time_secs_ = 0;
  clear_has_cpus_user_time_secs();
}
inline double ResourceStatistics::cpus_user_time_secs() const {
  return cpus_user_time_secs_;
}
inline void ResourceStatistics::set_cpus_user_time_secs(double value) {
  set_has_cpus_user_time_secs();
  cpus_user_time_secs_ = value;
}

// optional double cpus_system_time_secs = 3;
inline bool ResourceStatistics::has_cpus_system_time_secs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceStatistics::set_has_cpus_system_time_secs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceStatistics::clear_has_cpus_system_time_secs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceStatistics::clear_cpus_system_time_secs() {
  cpus_system_time_secs_ = 0;
  clear_has_cpus_system_time_secs();
}
inline double ResourceStatistics::cpus_system_time_secs() const {
  return cpus_system_time_secs_;
}
inline void ResourceStatistics::set_cpus_system_time_secs(double value) {
  set_has_cpus_system_time_secs();
  cpus_system_time_secs_ = value;
}

// optional double cpus_limit = 4;
inline bool ResourceStatistics::has_cpus_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResourceStatistics::set_has_cpus_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResourceStatistics::clear_has_cpus_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResourceStatistics::clear_cpus_limit() {
  cpus_limit_ = 0;
  clear_has_cpus_limit();
}
inline double ResourceStatistics::cpus_limit() const {
  return cpus_limit_;
}
inline void ResourceStatistics::set_cpus_limit(double value) {
  set_has_cpus_limit();
  cpus_limit_ = value;
}

// optional uint32 cpus_nr_periods = 7;
inline bool ResourceStatistics::has_cpus_nr_periods() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResourceStatistics::set_has_cpus_nr_periods() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResourceStatistics::clear_has_cpus_nr_periods() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResourceStatistics::clear_cpus_nr_periods() {
  cpus_nr_periods_ = 0u;
  clear_has_cpus_nr_periods();
}
inline ::google::protobuf::uint32 ResourceStatistics::cpus_nr_periods() const {
  return cpus_nr_periods_;
}
inline void ResourceStatistics::set_cpus_nr_periods(::google::protobuf::uint32 value) {
  set_has_cpus_nr_periods();
  cpus_nr_periods_ = value;
}

// optional uint32 cpus_nr_throttled = 8;
inline bool ResourceStatistics::has_cpus_nr_throttled() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResourceStatistics::set_has_cpus_nr_throttled() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResourceStatistics::clear_has_cpus_nr_throttled() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResourceStatistics::clear_cpus_nr_throttled() {
  cpus_nr_throttled_ = 0u;
  clear_has_cpus_nr_throttled();
}
inline ::google::protobuf::uint32 ResourceStatistics::cpus_nr_throttled() const {
  return cpus_nr_throttled_;
}
inline void ResourceStatistics::set_cpus_nr_throttled(::google::protobuf::uint32 value) {
  set_has_cpus_nr_throttled();
  cpus_nr_throttled_ = value;
}

// optional double cpus_throttled_time_secs = 9;
inline bool ResourceStatistics::has_cpus_throttled_time_secs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResourceStatistics::set_has_cpus_throttled_time_secs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResourceStatistics::clear_has_cpus_throttled_time_secs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResourceStatistics::clear_cpus_throttled_time_secs() {
  cpus_throttled_time_secs_ = 0;
  clear_has_cpus_throttled_time_secs();
}
inline double ResourceStatistics::cpus_throttled_time_secs() const {
  return cpus_throttled_time_secs_;
}
inline void ResourceStatistics::set_cpus_throttled_time_secs(double value) {
  set_has_cpus_throttled_time_secs();
  cpus_throttled_time_secs_ = value;
}

// optional uint64 mem_rss_bytes = 5;
inline bool ResourceStatistics::has_mem_rss_bytes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResourceStatistics::set_has_mem_rss_bytes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResourceStatistics::clear_has_mem_rss_bytes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResourceStatistics::clear_mem_rss_bytes() {
  mem_rss_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_rss_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_rss_bytes() const {
  return mem_rss_bytes_;
}
inline void ResourceStatistics::set_mem_rss_bytes(::google::protobuf::uint64 value) {
  set_has_mem_rss_bytes();
  mem_rss_bytes_ = value;
}

// optional uint64 mem_limit_bytes = 6;
inline bool ResourceStatistics::has_mem_limit_bytes() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResourceStatistics::set_has_mem_limit_bytes() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResourceStatistics::clear_has_mem_limit_bytes() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResourceStatistics::clear_mem_limit_bytes() {
  mem_limit_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_limit_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_limit_bytes() const {
  return mem_limit_bytes_;
}
inline void ResourceStatistics::set_mem_limit_bytes(::google::protobuf::uint64 value) {
  set_has_mem_limit_bytes();
  mem_limit_bytes_ = value;
}

// optional uint64 mem_file_bytes = 10;
inline bool ResourceStatistics::has_mem_file_bytes() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResourceStatistics::set_has_mem_file_bytes() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResourceStatistics::clear_has_mem_file_bytes() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResourceStatistics::clear_mem_file_bytes() {
  mem_file_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_file_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_file_bytes() const {
  return mem_file_bytes_;
}
inline void ResourceStatistics::set_mem_file_bytes(::google::protobuf::uint64 value) {
  set_has_mem_file_bytes();
  mem_file_bytes_ = value;
}

// optional uint64 mem_anon_bytes = 11;
inline bool ResourceStatistics::has_mem_anon_bytes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResourceStatistics::set_has_mem_anon_bytes() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResourceStatistics::clear_has_mem_anon_bytes() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResourceStatistics::clear_mem_anon_bytes() {
  mem_anon_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_anon_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_anon_bytes() const {
  return mem_anon_bytes_;
}
inline void ResourceStatistics::set_mem_anon_bytes(::google::protobuf::uint64 value) {
  set_has_mem_anon_bytes();
  mem_anon_bytes_ = value;
}

// optional uint64 mem_mapped_file_bytes = 12;
inline bool ResourceStatistics::has_mem_mapped_file_bytes() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ResourceStatistics::set_has_mem_mapped_file_bytes() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ResourceStatistics::clear_has_mem_mapped_file_bytes() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ResourceStatistics::clear_mem_mapped_file_bytes() {
  mem_mapped_file_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_mapped_file_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_mapped_file_bytes() const {
  return mem_mapped_file_bytes_;
}
inline void ResourceStatistics::set_mem_mapped_file_bytes(::google::protobuf::uint64 value) {
  set_has_mem_mapped_file_bytes();
  mem_mapped_file_bytes_ = value;
}

// optional uint64 disk_limit_bytes = 26;
inline bool ResourceStatistics::has_disk_limit_bytes() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ResourceStatistics::set_has_disk_limit_bytes() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ResourceStatistics::clear_has_disk_limit_bytes() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ResourceStatistics::clear_disk_limit_bytes() {
  disk_limit_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_disk_limit_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::disk_limit_bytes() const {
  return disk_limit_bytes_;
}
inline void ResourceStatistics::set_disk_limit_bytes(::google::protobuf::uint64 value) {
  set_has_disk_limit_bytes();
  disk_limit_bytes_ = value;
}

// optional uint64 disk_used_bytes = 27;
inline bool ResourceStatistics::has_disk_used_bytes() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ResourceStatistics::set_has_disk_used_bytes() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ResourceStatistics::clear_has_disk_used_bytes() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ResourceStatistics::clear_disk_used_bytes() {
  disk_used_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_disk_used_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::disk_used_bytes() const {
  return disk_used_bytes_;
}
inline void ResourceStatistics::set_disk_used_bytes(::google::protobuf::uint64 value) {
  set_has_disk_used_bytes();
  disk_used_bytes_ = value;
}

// optional .mesos.PerfStatistics perf = 13;
inline bool ResourceStatistics::has_perf() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ResourceStatistics::set_has_perf() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ResourceStatistics::clear_has_perf() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ResourceStatistics::clear_perf() {
  if (perf_ != NULL) perf_->::mesos::PerfStatistics::Clear();
  clear_has_perf();
}
inline const ::mesos::PerfStatistics& ResourceStatistics::perf() const {
  return perf_ != NULL ? *perf_ : *default_instance_->perf_;
}
inline ::mesos::PerfStatistics* ResourceStatistics::mutable_perf() {
  set_has_perf();
  if (perf_ == NULL) perf_ = new ::mesos::PerfStatistics;
  return perf_;
}
inline ::mesos::PerfStatistics* ResourceStatistics::release_perf() {
  clear_has_perf();
  ::mesos::PerfStatistics* temp = perf_;
  perf_ = NULL;
  return temp;
}
inline void ResourceStatistics::set_allocated_perf(::mesos::PerfStatistics* perf) {
  delete perf_;
  perf_ = perf;
  if (perf) {
    set_has_perf();
  } else {
    clear_has_perf();
  }
}

// optional uint64 net_rx_packets = 14;
inline bool ResourceStatistics::has_net_rx_packets() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ResourceStatistics::set_has_net_rx_packets() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ResourceStatistics::clear_has_net_rx_packets() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ResourceStatistics::clear_net_rx_packets() {
  net_rx_packets_ = GOOGLE_ULONGLONG(0);
  clear_has_net_rx_packets();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_rx_packets() const {
  return net_rx_packets_;
}
inline void ResourceStatistics::set_net_rx_packets(::google::protobuf::uint64 value) {
  set_has_net_rx_packets();
  net_rx_packets_ = value;
}

// optional uint64 net_rx_bytes = 15;
inline bool ResourceStatistics::has_net_rx_bytes() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ResourceStatistics::set_has_net_rx_bytes() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ResourceStatistics::clear_has_net_rx_bytes() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ResourceStatistics::clear_net_rx_bytes() {
  net_rx_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_net_rx_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_rx_bytes() const {
  return net_rx_bytes_;
}
inline void ResourceStatistics::set_net_rx_bytes(::google::protobuf::uint64 value) {
  set_has_net_rx_bytes();
  net_rx_bytes_ = value;
}

// optional uint64 net_rx_errors = 16;
inline bool ResourceStatistics::has_net_rx_errors() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ResourceStatistics::set_has_net_rx_errors() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ResourceStatistics::clear_has_net_rx_errors() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ResourceStatistics::clear_net_rx_errors() {
  net_rx_errors_ = GOOGLE_ULONGLONG(0);
  clear_has_net_rx_errors();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_rx_errors() const {
  return net_rx_errors_;
}
inline void ResourceStatistics::set_net_rx_errors(::google::protobuf::uint64 value) {
  set_has_net_rx_errors();
  net_rx_errors_ = value;
}

// optional uint64 net_rx_dropped = 17;
inline bool ResourceStatistics::has_net_rx_dropped() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ResourceStatistics::set_has_net_rx_dropped() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ResourceStatistics::clear_has_net_rx_dropped() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ResourceStatistics::clear_net_rx_dropped() {
  net_rx_dropped_ = GOOGLE_ULONGLONG(0);
  clear_has_net_rx_dropped();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_rx_dropped() const {
  return net_rx_dropped_;
}
inline void ResourceStatistics::set_net_rx_dropped(::google::protobuf::uint64 value) {
  set_has_net_rx_dropped();
  net_rx_dropped_ = value;
}

// optional uint64 net_tx_packets = 18;
inline bool ResourceStatistics::has_net_tx_packets() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ResourceStatistics::set_has_net_tx_packets() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ResourceStatistics::clear_has_net_tx_packets() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ResourceStatistics::clear_net_tx_packets() {
  net_tx_packets_ = GOOGLE_ULONGLONG(0);
  clear_has_net_tx_packets();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_tx_packets() const {
  return net_tx_packets_;
}
inline void ResourceStatistics::set_net_tx_packets(::google::protobuf::uint64 value) {
  set_has_net_tx_packets();
  net_tx_packets_ = value;
}

// optional uint64 net_tx_bytes = 19;
inline bool ResourceStatistics::has_net_tx_bytes() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ResourceStatistics::set_has_net_tx_bytes() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ResourceStatistics::clear_has_net_tx_bytes() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ResourceStatistics::clear_net_tx_bytes() {
  net_tx_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_net_tx_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_tx_bytes() const {
  return net_tx_bytes_;
}
inline void ResourceStatistics::set_net_tx_bytes(::google::protobuf::uint64 value) {
  set_has_net_tx_bytes();
  net_tx_bytes_ = value;
}

// optional uint64 net_tx_errors = 20;
inline bool ResourceStatistics::has_net_tx_errors() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ResourceStatistics::set_has_net_tx_errors() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ResourceStatistics::clear_has_net_tx_errors() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ResourceStatistics::clear_net_tx_errors() {
  net_tx_errors_ = GOOGLE_ULONGLONG(0);
  clear_has_net_tx_errors();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_tx_errors() const {
  return net_tx_errors_;
}
inline void ResourceStatistics::set_net_tx_errors(::google::protobuf::uint64 value) {
  set_has_net_tx_errors();
  net_tx_errors_ = value;
}

// optional uint64 net_tx_dropped = 21;
inline bool ResourceStatistics::has_net_tx_dropped() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ResourceStatistics::set_has_net_tx_dropped() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ResourceStatistics::clear_has_net_tx_dropped() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ResourceStatistics::clear_net_tx_dropped() {
  net_tx_dropped_ = GOOGLE_ULONGLONG(0);
  clear_has_net_tx_dropped();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_tx_dropped() const {
  return net_tx_dropped_;
}
inline void ResourceStatistics::set_net_tx_dropped(::google::protobuf::uint64 value) {
  set_has_net_tx_dropped();
  net_tx_dropped_ = value;
}

// optional double net_tcp_rtt_microsecs_p50 = 22;
inline bool ResourceStatistics::has_net_tcp_rtt_microsecs_p50() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_rtt_microsecs_p50() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ResourceStatistics::clear_has_net_tcp_rtt_microsecs_p50() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ResourceStatistics::clear_net_tcp_rtt_microsecs_p50() {
  net_tcp_rtt_microsecs_p50_ = 0;
  clear_has_net_tcp_rtt_microsecs_p50();
}
inline double ResourceStatistics::net_tcp_rtt_microsecs_p50() const {
  return net_tcp_rtt_microsecs_p50_;
}
inline void ResourceStatistics::set_net_tcp_rtt_microsecs_p50(double value) {
  set_has_net_tcp_rtt_microsecs_p50();
  net_tcp_rtt_microsecs_p50_ = value;
}

// optional double net_tcp_rtt_microsecs_p90 = 23;
inline bool ResourceStatistics::has_net_tcp_rtt_microsecs_p90() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_rtt_microsecs_p90() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ResourceStatistics::clear_has_net_tcp_rtt_microsecs_p90() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ResourceStatistics::clear_net_tcp_rtt_microsecs_p90() {
  net_tcp_rtt_microsecs_p90_ = 0;
  clear_has_net_tcp_rtt_microsecs_p90();
}
inline double ResourceStatistics::net_tcp_rtt_microsecs_p90() const {
  return net_tcp_rtt_microsecs_p90_;
}
inline void ResourceStatistics::set_net_tcp_rtt_microsecs_p90(double value) {
  set_has_net_tcp_rtt_microsecs_p90();
  net_tcp_rtt_microsecs_p90_ = value;
}

// optional double net_tcp_rtt_microsecs_p95 = 24;
inline bool ResourceStatistics::has_net_tcp_rtt_microsecs_p95() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_rtt_microsecs_p95() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ResourceStatistics::clear_has_net_tcp_rtt_microsecs_p95() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ResourceStatistics::clear_net_tcp_rtt_microsecs_p95() {
  net_tcp_rtt_microsecs_p95_ = 0;
  clear_has_net_tcp_rtt_microsecs_p95();
}
inline double ResourceStatistics::net_tcp_rtt_microsecs_p95() const {
  return net_tcp_rtt_microsecs_p95_;
}
inline void ResourceStatistics::set_net_tcp_rtt_microsecs_p95(double value) {
  set_has_net_tcp_rtt_microsecs_p95();
  net_tcp_rtt_microsecs_p95_ = value;
}

// optional double net_tcp_rtt_microsecs_p99 = 25;
inline bool ResourceStatistics::has_net_tcp_rtt_microsecs_p99() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_rtt_microsecs_p99() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ResourceStatistics::clear_has_net_tcp_rtt_microsecs_p99() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ResourceStatistics::clear_net_tcp_rtt_microsecs_p99() {
  net_tcp_rtt_microsecs_p99_ = 0;
  clear_has_net_tcp_rtt_microsecs_p99();
}
inline double ResourceStatistics::net_tcp_rtt_microsecs_p99() const {
  return net_tcp_rtt_microsecs_p99_;
}
inline void ResourceStatistics::set_net_tcp_rtt_microsecs_p99(double value) {
  set_has_net_tcp_rtt_microsecs_p99();
  net_tcp_rtt_microsecs_p99_ = value;
}

// optional double net_tcp_active_connections = 28;
inline bool ResourceStatistics::has_net_tcp_active_connections() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_active_connections() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ResourceStatistics::clear_has_net_tcp_active_connections() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ResourceStatistics::clear_net_tcp_active_connections() {
  net_tcp_active_connections_ = 0;
  clear_has_net_tcp_active_connections();
}
inline double ResourceStatistics::net_tcp_active_connections() const {
  return net_tcp_active_connections_;
}
inline void ResourceStatistics::set_net_tcp_active_connections(double value) {
  set_has_net_tcp_active_connections();
  net_tcp_active_connections_ = value;
}

// optional double net_tcp_time_wait_connections = 29;
inline bool ResourceStatistics::has_net_tcp_time_wait_connections() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_time_wait_connections() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ResourceStatistics::clear_has_net_tcp_time_wait_connections() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ResourceStatistics::clear_net_tcp_time_wait_connections() {
  net_tcp_time_wait_connections_ = 0;
  clear_has_net_tcp_time_wait_connections();
}
inline double ResourceStatistics::net_tcp_time_wait_connections() const {
  return net_tcp_time_wait_connections_;
}
inline void ResourceStatistics::set_net_tcp_time_wait_connections(double value) {
  set_has_net_tcp_time_wait_connections();
  net_tcp_time_wait_connections_ = value;
}

// -------------------------------------------------------------------

// ResourceUsage

// required .mesos.SlaveID slave_id = 1;
inline bool ResourceUsage::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceUsage::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceUsage::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceUsage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& ResourceUsage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* ResourceUsage::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* ResourceUsage::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void ResourceUsage::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// required .mesos.FrameworkID framework_id = 2;
inline bool ResourceUsage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceUsage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceUsage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceUsage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& ResourceUsage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ResourceUsage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* ResourceUsage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void ResourceUsage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// optional .mesos.ExecutorID executor_id = 3;
inline bool ResourceUsage::has_executor_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceUsage::set_has_executor_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceUsage::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceUsage::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& ResourceUsage::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* ResourceUsage::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* ResourceUsage::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void ResourceUsage::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
}

// optional string executor_name = 4;
inline bool ResourceUsage::has_executor_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResourceUsage::set_has_executor_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResourceUsage::clear_has_executor_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResourceUsage::clear_executor_name() {
  if (executor_name_ != &::google::protobuf::internal::kEmptyString) {
    executor_name_->clear();
  }
  clear_has_executor_name();
}
inline const ::std::string& ResourceUsage::executor_name() const {
  return *executor_name_;
}
inline void ResourceUsage::set_executor_name(const ::std::string& value) {
  set_has_executor_name();
  if (executor_name_ == &::google::protobuf::internal::kEmptyString) {
    executor_name_ = new ::std::string;
  }
  executor_name_->assign(value);
}
inline void ResourceUsage::set_executor_name(const char* value) {
  set_has_executor_name();
  if (executor_name_ == &::google::protobuf::internal::kEmptyString) {
    executor_name_ = new ::std::string;
  }
  executor_name_->assign(value);
}
inline void ResourceUsage::set_executor_name(const char* value, size_t size) {
  set_has_executor_name();
  if (executor_name_ == &::google::protobuf::internal::kEmptyString) {
    executor_name_ = new ::std::string;
  }
  executor_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceUsage::mutable_executor_name() {
  set_has_executor_name();
  if (executor_name_ == &::google::protobuf::internal::kEmptyString) {
    executor_name_ = new ::std::string;
  }
  return executor_name_;
}
inline ::std::string* ResourceUsage::release_executor_name() {
  clear_has_executor_name();
  if (executor_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = executor_name_;
    executor_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResourceUsage::set_allocated_executor_name(::std::string* executor_name) {
  if (executor_name_ != &::google::protobuf::internal::kEmptyString) {
    delete executor_name_;
  }
  if (executor_name) {
    set_has_executor_name();
    executor_name_ = executor_name;
  } else {
    clear_has_executor_name();
    executor_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mesos.TaskID task_id = 5;
inline bool ResourceUsage::has_task_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResourceUsage::set_has_task_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResourceUsage::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResourceUsage::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& ResourceUsage::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* ResourceUsage::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}
inline ::mesos::TaskID* ResourceUsage::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void ResourceUsage::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
}

// optional .mesos.ResourceStatistics statistics = 6;
inline bool ResourceUsage::has_statistics() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResourceUsage::set_has_statistics() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResourceUsage::clear_has_statistics() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResourceUsage::clear_statistics() {
  if (statistics_ != NULL) statistics_->::mesos::ResourceStatistics::Clear();
  clear_has_statistics();
}
inline const ::mesos::ResourceStatistics& ResourceUsage::statistics() const {
  return statistics_ != NULL ? *statistics_ : *default_instance_->statistics_;
}
inline ::mesos::ResourceStatistics* ResourceUsage::mutable_statistics() {
  set_has_statistics();
  if (statistics_ == NULL) statistics_ = new ::mesos::ResourceStatistics;
  return statistics_;
}
inline ::mesos::ResourceStatistics* ResourceUsage::release_statistics() {
  clear_has_statistics();
  ::mesos::ResourceStatistics* temp = statistics_;
  statistics_ = NULL;
  return temp;
}
inline void ResourceUsage::set_allocated_statistics(::mesos::ResourceStatistics* statistics) {
  delete statistics_;
  statistics_ = statistics;
  if (statistics) {
    set_has_statistics();
  } else {
    clear_has_statistics();
  }
}

// -------------------------------------------------------------------

// PerfStatistics

// required double timestamp = 1;
inline bool PerfStatistics::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerfStatistics::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerfStatistics::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PerfStatistics::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double PerfStatistics::timestamp() const {
  return timestamp_;
}
inline void PerfStatistics::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required double duration = 2;
inline bool PerfStatistics::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PerfStatistics::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PerfStatistics::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PerfStatistics::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double PerfStatistics::duration() const {
  return duration_;
}
inline void PerfStatistics::set_duration(double value) {
  set_has_duration();
  duration_ = value;
}

// optional uint64 cycles = 3;
inline bool PerfStatistics::has_cycles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PerfStatistics::set_has_cycles() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PerfStatistics::clear_has_cycles() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PerfStatistics::clear_cycles() {
  cycles_ = GOOGLE_ULONGLONG(0);
  clear_has_cycles();
}
inline ::google::protobuf::uint64 PerfStatistics::cycles() const {
  return cycles_;
}
inline void PerfStatistics::set_cycles(::google::protobuf::uint64 value) {
  set_has_cycles();
  cycles_ = value;
}

// optional uint64 stalled_cycles_frontend = 4;
inline bool PerfStatistics::has_stalled_cycles_frontend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PerfStatistics::set_has_stalled_cycles_frontend() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PerfStatistics::clear_has_stalled_cycles_frontend() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PerfStatistics::clear_stalled_cycles_frontend() {
  stalled_cycles_frontend_ = GOOGLE_ULONGLONG(0);
  clear_has_stalled_cycles_frontend();
}
inline ::google::protobuf::uint64 PerfStatistics::stalled_cycles_frontend() const {
  return stalled_cycles_frontend_;
}
inline void PerfStatistics::set_stalled_cycles_frontend(::google::protobuf::uint64 value) {
  set_has_stalled_cycles_frontend();
  stalled_cycles_frontend_ = value;
}

// optional uint64 stalled_cycles_backend = 5;
inline bool PerfStatistics::has_stalled_cycles_backend() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PerfStatistics::set_has_stalled_cycles_backend() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PerfStatistics::clear_has_stalled_cycles_backend() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PerfStatistics::clear_stalled_cycles_backend() {
  stalled_cycles_backend_ = GOOGLE_ULONGLONG(0);
  clear_has_stalled_cycles_backend();
}
inline ::google::protobuf::uint64 PerfStatistics::stalled_cycles_backend() const {
  return stalled_cycles_backend_;
}
inline void PerfStatistics::set_stalled_cycles_backend(::google::protobuf::uint64 value) {
  set_has_stalled_cycles_backend();
  stalled_cycles_backend_ = value;
}

// optional uint64 instructions = 6;
inline bool PerfStatistics::has_instructions() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PerfStatistics::set_has_instructions() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PerfStatistics::clear_has_instructions() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PerfStatistics::clear_instructions() {
  instructions_ = GOOGLE_ULONGLONG(0);
  clear_has_instructions();
}
inline ::google::protobuf::uint64 PerfStatistics::instructions() const {
  return instructions_;
}
inline void PerfStatistics::set_instructions(::google::protobuf::uint64 value) {
  set_has_instructions();
  instructions_ = value;
}

// optional uint64 cache_references = 7;
inline bool PerfStatistics::has_cache_references() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PerfStatistics::set_has_cache_references() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PerfStatistics::clear_has_cache_references() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PerfStatistics::clear_cache_references() {
  cache_references_ = GOOGLE_ULONGLONG(0);
  clear_has_cache_references();
}
inline ::google::protobuf::uint64 PerfStatistics::cache_references() const {
  return cache_references_;
}
inline void PerfStatistics::set_cache_references(::google::protobuf::uint64 value) {
  set_has_cache_references();
  cache_references_ = value;
}

// optional uint64 cache_misses = 8;
inline bool PerfStatistics::has_cache_misses() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PerfStatistics::set_has_cache_misses() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PerfStatistics::clear_has_cache_misses() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PerfStatistics::clear_cache_misses() {
  cache_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_cache_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::cache_misses() const {
  return cache_misses_;
}
inline void PerfStatistics::set_cache_misses(::google::protobuf::uint64 value) {
  set_has_cache_misses();
  cache_misses_ = value;
}

// optional uint64 branches = 9;
inline bool PerfStatistics::has_branches() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PerfStatistics::set_has_branches() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PerfStatistics::clear_has_branches() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PerfStatistics::clear_branches() {
  branches_ = GOOGLE_ULONGLONG(0);
  clear_has_branches();
}
inline ::google::protobuf::uint64 PerfStatistics::branches() const {
  return branches_;
}
inline void PerfStatistics::set_branches(::google::protobuf::uint64 value) {
  set_has_branches();
  branches_ = value;
}

// optional uint64 branch_misses = 10;
inline bool PerfStatistics::has_branch_misses() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PerfStatistics::set_has_branch_misses() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PerfStatistics::clear_has_branch_misses() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PerfStatistics::clear_branch_misses() {
  branch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_branch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::branch_misses() const {
  return branch_misses_;
}
inline void PerfStatistics::set_branch_misses(::google::protobuf::uint64 value) {
  set_has_branch_misses();
  branch_misses_ = value;
}

// optional uint64 bus_cycles = 11;
inline bool PerfStatistics::has_bus_cycles() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PerfStatistics::set_has_bus_cycles() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PerfStatistics::clear_has_bus_cycles() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PerfStatistics::clear_bus_cycles() {
  bus_cycles_ = GOOGLE_ULONGLONG(0);
  clear_has_bus_cycles();
}
inline ::google::protobuf::uint64 PerfStatistics::bus_cycles() const {
  return bus_cycles_;
}
inline void PerfStatistics::set_bus_cycles(::google::protobuf::uint64 value) {
  set_has_bus_cycles();
  bus_cycles_ = value;
}

// optional uint64 ref_cycles = 12;
inline bool PerfStatistics::has_ref_cycles() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PerfStatistics::set_has_ref_cycles() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PerfStatistics::clear_has_ref_cycles() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PerfStatistics::clear_ref_cycles() {
  ref_cycles_ = GOOGLE_ULONGLONG(0);
  clear_has_ref_cycles();
}
inline ::google::protobuf::uint64 PerfStatistics::ref_cycles() const {
  return ref_cycles_;
}
inline void PerfStatistics::set_ref_cycles(::google::protobuf::uint64 value) {
  set_has_ref_cycles();
  ref_cycles_ = value;
}

// optional double cpu_clock = 13;
inline bool PerfStatistics::has_cpu_clock() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PerfStatistics::set_has_cpu_clock() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PerfStatistics::clear_has_cpu_clock() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PerfStatistics::clear_cpu_clock() {
  cpu_clock_ = 0;
  clear_has_cpu_clock();
}
inline double PerfStatistics::cpu_clock() const {
  return cpu_clock_;
}
inline void PerfStatistics::set_cpu_clock(double value) {
  set_has_cpu_clock();
  cpu_clock_ = value;
}

// optional double task_clock = 14;
inline bool PerfStatistics::has_task_clock() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PerfStatistics::set_has_task_clock() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PerfStatistics::clear_has_task_clock() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PerfStatistics::clear_task_clock() {
  task_clock_ = 0;
  clear_has_task_clock();
}
inline double PerfStatistics::task_clock() const {
  return task_clock_;
}
inline void PerfStatistics::set_task_clock(double value) {
  set_has_task_clock();
  task_clock_ = value;
}

// optional uint64 page_faults = 15;
inline bool PerfStatistics::has_page_faults() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PerfStatistics::set_has_page_faults() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PerfStatistics::clear_has_page_faults() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PerfStatistics::clear_page_faults() {
  page_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_page_faults();
}
inline ::google::protobuf::uint64 PerfStatistics::page_faults() const {
  return page_faults_;
}
inline void PerfStatistics::set_page_faults(::google::protobuf::uint64 value) {
  set_has_page_faults();
  page_faults_ = value;
}

// optional uint64 minor_faults = 16;
inline bool PerfStatistics::has_minor_faults() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PerfStatistics::set_has_minor_faults() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PerfStatistics::clear_has_minor_faults() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PerfStatistics::clear_minor_faults() {
  minor_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_minor_faults();
}
inline ::google::protobuf::uint64 PerfStatistics::minor_faults() const {
  return minor_faults_;
}
inline void PerfStatistics::set_minor_faults(::google::protobuf::uint64 value) {
  set_has_minor_faults();
  minor_faults_ = value;
}

// optional uint64 major_faults = 17;
inline bool PerfStatistics::has_major_faults() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PerfStatistics::set_has_major_faults() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PerfStatistics::clear_has_major_faults() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PerfStatistics::clear_major_faults() {
  major_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_major_faults();
}
inline ::google::protobuf::uint64 PerfStatistics::major_faults() const {
  return major_faults_;
}
inline void PerfStatistics::set_major_faults(::google::protobuf::uint64 value) {
  set_has_major_faults();
  major_faults_ = value;
}

// optional uint64 context_switches = 18;
inline bool PerfStatistics::has_context_switches() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PerfStatistics::set_has_context_switches() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PerfStatistics::clear_has_context_switches() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PerfStatistics::clear_context_switches() {
  context_switches_ = GOOGLE_ULONGLONG(0);
  clear_has_context_switches();
}
inline ::google::protobuf::uint64 PerfStatistics::context_switches() const {
  return context_switches_;
}
inline void PerfStatistics::set_context_switches(::google::protobuf::uint64 value) {
  set_has_context_switches();
  context_switches_ = value;
}

// optional uint64 cpu_migrations = 19;
inline bool PerfStatistics::has_cpu_migrations() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PerfStatistics::set_has_cpu_migrations() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PerfStatistics::clear_has_cpu_migrations() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PerfStatistics::clear_cpu_migrations() {
  cpu_migrations_ = GOOGLE_ULONGLONG(0);
  clear_has_cpu_migrations();
}
inline ::google::protobuf::uint64 PerfStatistics::cpu_migrations() const {
  return cpu_migrations_;
}
inline void PerfStatistics::set_cpu_migrations(::google::protobuf::uint64 value) {
  set_has_cpu_migrations();
  cpu_migrations_ = value;
}

// optional uint64 alignment_faults = 20;
inline bool PerfStatistics::has_alignment_faults() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PerfStatistics::set_has_alignment_faults() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PerfStatistics::clear_has_alignment_faults() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PerfStatistics::clear_alignment_faults() {
  alignment_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_alignment_faults();
}
inline ::google::protobuf::uint64 PerfStatistics::alignment_faults() const {
  return alignment_faults_;
}
inline void PerfStatistics::set_alignment_faults(::google::protobuf::uint64 value) {
  set_has_alignment_faults();
  alignment_faults_ = value;
}

// optional uint64 emulation_faults = 21;
inline bool PerfStatistics::has_emulation_faults() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PerfStatistics::set_has_emulation_faults() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PerfStatistics::clear_has_emulation_faults() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PerfStatistics::clear_emulation_faults() {
  emulation_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_emulation_faults();
}
inline ::google::protobuf::uint64 PerfStatistics::emulation_faults() const {
  return emulation_faults_;
}
inline void PerfStatistics::set_emulation_faults(::google::protobuf::uint64 value) {
  set_has_emulation_faults();
  emulation_faults_ = value;
}

// optional uint64 l1_dcache_loads = 22;
inline bool PerfStatistics::has_l1_dcache_loads() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_loads() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PerfStatistics::clear_has_l1_dcache_loads() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PerfStatistics::clear_l1_dcache_loads() {
  l1_dcache_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_loads() const {
  return l1_dcache_loads_;
}
inline void PerfStatistics::set_l1_dcache_loads(::google::protobuf::uint64 value) {
  set_has_l1_dcache_loads();
  l1_dcache_loads_ = value;
}

// optional uint64 l1_dcache_load_misses = 23;
inline bool PerfStatistics::has_l1_dcache_load_misses() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_load_misses() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PerfStatistics::clear_has_l1_dcache_load_misses() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PerfStatistics::clear_l1_dcache_load_misses() {
  l1_dcache_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_load_misses() const {
  return l1_dcache_load_misses_;
}
inline void PerfStatistics::set_l1_dcache_load_misses(::google::protobuf::uint64 value) {
  set_has_l1_dcache_load_misses();
  l1_dcache_load_misses_ = value;
}

// optional uint64 l1_dcache_stores = 24;
inline bool PerfStatistics::has_l1_dcache_stores() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_stores() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PerfStatistics::clear_has_l1_dcache_stores() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PerfStatistics::clear_l1_dcache_stores() {
  l1_dcache_stores_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_stores();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_stores() const {
  return l1_dcache_stores_;
}
inline void PerfStatistics::set_l1_dcache_stores(::google::protobuf::uint64 value) {
  set_has_l1_dcache_stores();
  l1_dcache_stores_ = value;
}

// optional uint64 l1_dcache_store_misses = 25;
inline bool PerfStatistics::has_l1_dcache_store_misses() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_store_misses() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PerfStatistics::clear_has_l1_dcache_store_misses() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PerfStatistics::clear_l1_dcache_store_misses() {
  l1_dcache_store_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_store_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_store_misses() const {
  return l1_dcache_store_misses_;
}
inline void PerfStatistics::set_l1_dcache_store_misses(::google::protobuf::uint64 value) {
  set_has_l1_dcache_store_misses();
  l1_dcache_store_misses_ = value;
}

// optional uint64 l1_dcache_prefetches = 26;
inline bool PerfStatistics::has_l1_dcache_prefetches() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_prefetches() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PerfStatistics::clear_has_l1_dcache_prefetches() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PerfStatistics::clear_l1_dcache_prefetches() {
  l1_dcache_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_prefetches();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_prefetches() const {
  return l1_dcache_prefetches_;
}
inline void PerfStatistics::set_l1_dcache_prefetches(::google::protobuf::uint64 value) {
  set_has_l1_dcache_prefetches();
  l1_dcache_prefetches_ = value;
}

// optional uint64 l1_dcache_prefetch_misses = 27;
inline bool PerfStatistics::has_l1_dcache_prefetch_misses() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_prefetch_misses() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PerfStatistics::clear_has_l1_dcache_prefetch_misses() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PerfStatistics::clear_l1_dcache_prefetch_misses() {
  l1_dcache_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_prefetch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_prefetch_misses() const {
  return l1_dcache_prefetch_misses_;
}
inline void PerfStatistics::set_l1_dcache_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_l1_dcache_prefetch_misses();
  l1_dcache_prefetch_misses_ = value;
}

// optional uint64 l1_icache_loads = 28;
inline bool PerfStatistics::has_l1_icache_loads() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PerfStatistics::set_has_l1_icache_loads() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PerfStatistics::clear_has_l1_icache_loads() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PerfStatistics::clear_l1_icache_loads() {
  l1_icache_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_icache_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_icache_loads() const {
  return l1_icache_loads_;
}
inline void PerfStatistics::set_l1_icache_loads(::google::protobuf::uint64 value) {
  set_has_l1_icache_loads();
  l1_icache_loads_ = value;
}

// optional uint64 l1_icache_load_misses = 29;
inline bool PerfStatistics::has_l1_icache_load_misses() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PerfStatistics::set_has_l1_icache_load_misses() {
  _has_bits_[0] |= 0x10000000u;
}
inline void PerfStatistics::clear_has_l1_icache_load_misses() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void PerfStatistics::clear_l1_icache_load_misses() {
  l1_icache_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_icache_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_icache_load_misses() const {
  return l1_icache_load_misses_;
}
inline void PerfStatistics::set_l1_icache_load_misses(::google::protobuf::uint64 value) {
  set_has_l1_icache_load_misses();
  l1_icache_load_misses_ = value;
}

// optional uint64 l1_icache_prefetches = 30;
inline bool PerfStatistics::has_l1_icache_prefetches() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PerfStatistics::set_has_l1_icache_prefetches() {
  _has_bits_[0] |= 0x20000000u;
}
inline void PerfStatistics::clear_has_l1_icache_prefetches() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void PerfStatistics::clear_l1_icache_prefetches() {
  l1_icache_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_icache_prefetches();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_icache_prefetches() const {
  return l1_icache_prefetches_;
}
inline void PerfStatistics::set_l1_icache_prefetches(::google::protobuf::uint64 value) {
  set_has_l1_icache_prefetches();
  l1_icache_prefetches_ = value;
}

// optional uint64 l1_icache_prefetch_misses = 31;
inline bool PerfStatistics::has_l1_icache_prefetch_misses() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PerfStatistics::set_has_l1_icache_prefetch_misses() {
  _has_bits_[0] |= 0x40000000u;
}
inline void PerfStatistics::clear_has_l1_icache_prefetch_misses() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void PerfStatistics::clear_l1_icache_prefetch_misses() {
  l1_icache_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_icache_prefetch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_icache_prefetch_misses() const {
  return l1_icache_prefetch_misses_;
}
inline void PerfStatistics::set_l1_icache_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_l1_icache_prefetch_misses();
  l1_icache_prefetch_misses_ = value;
}

// optional uint64 llc_loads = 32;
inline bool PerfStatistics::has_llc_loads() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PerfStatistics::set_has_llc_loads() {
  _has_bits_[0] |= 0x80000000u;
}
inline void PerfStatistics::clear_has_llc_loads() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void PerfStatistics::clear_llc_loads() {
  llc_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_loads() const {
  return llc_loads_;
}
inline void PerfStatistics::set_llc_loads(::google::protobuf::uint64 value) {
  set_has_llc_loads();
  llc_loads_ = value;
}

// optional uint64 llc_load_misses = 33;
inline bool PerfStatistics::has_llc_load_misses() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PerfStatistics::set_has_llc_load_misses() {
  _has_bits_[1] |= 0x00000001u;
}
inline void PerfStatistics::clear_has_llc_load_misses() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void PerfStatistics::clear_llc_load_misses() {
  llc_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_load_misses() const {
  return llc_load_misses_;
}
inline void PerfStatistics::set_llc_load_misses(::google::protobuf::uint64 value) {
  set_has_llc_load_misses();
  llc_load_misses_ = value;
}

// optional uint64 llc_stores = 34;
inline bool PerfStatistics::has_llc_stores() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void PerfStatistics::set_has_llc_stores() {
  _has_bits_[1] |= 0x00000002u;
}
inline void PerfStatistics::clear_has_llc_stores() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void PerfStatistics::clear_llc_stores() {
  llc_stores_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_stores();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_stores() const {
  return llc_stores_;
}
inline void PerfStatistics::set_llc_stores(::google::protobuf::uint64 value) {
  set_has_llc_stores();
  llc_stores_ = value;
}

// optional uint64 llc_store_misses = 35;
inline bool PerfStatistics::has_llc_store_misses() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void PerfStatistics::set_has_llc_store_misses() {
  _has_bits_[1] |= 0x00000004u;
}
inline void PerfStatistics::clear_has_llc_store_misses() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void PerfStatistics::clear_llc_store_misses() {
  llc_store_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_store_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_store_misses() const {
  return llc_store_misses_;
}
inline void PerfStatistics::set_llc_store_misses(::google::protobuf::uint64 value) {
  set_has_llc_store_misses();
  llc_store_misses_ = value;
}

// optional uint64 llc_prefetches = 36;
inline bool PerfStatistics::has_llc_prefetches() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void PerfStatistics::set_has_llc_prefetches() {
  _has_bits_[1] |= 0x00000008u;
}
inline void PerfStatistics::clear_has_llc_prefetches() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void PerfStatistics::clear_llc_prefetches() {
  llc_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_prefetches();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_prefetches() const {
  return llc_prefetches_;
}
inline void PerfStatistics::set_llc_prefetches(::google::protobuf::uint64 value) {
  set_has_llc_prefetches();
  llc_prefetches_ = value;
}

// optional uint64 llc_prefetch_misses = 37;
inline bool PerfStatistics::has_llc_prefetch_misses() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void PerfStatistics::set_has_llc_prefetch_misses() {
  _has_bits_[1] |= 0x00000010u;
}
inline void PerfStatistics::clear_has_llc_prefetch_misses() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void PerfStatistics::clear_llc_prefetch_misses() {
  llc_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_prefetch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_prefetch_misses() const {
  return llc_prefetch_misses_;
}
inline void PerfStatistics::set_llc_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_llc_prefetch_misses();
  llc_prefetch_misses_ = value;
}

// optional uint64 dtlb_loads = 38;
inline bool PerfStatistics::has_dtlb_loads() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void PerfStatistics::set_has_dtlb_loads() {
  _has_bits_[1] |= 0x00000020u;
}
inline void PerfStatistics::clear_has_dtlb_loads() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void PerfStatistics::clear_dtlb_loads() {
  dtlb_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_loads() const {
  return dtlb_loads_;
}
inline void PerfStatistics::set_dtlb_loads(::google::protobuf::uint64 value) {
  set_has_dtlb_loads();
  dtlb_loads_ = value;
}

// optional uint64 dtlb_load_misses = 39;
inline bool PerfStatistics::has_dtlb_load_misses() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void PerfStatistics::set_has_dtlb_load_misses() {
  _has_bits_[1] |= 0x00000040u;
}
inline void PerfStatistics::clear_has_dtlb_load_misses() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void PerfStatistics::clear_dtlb_load_misses() {
  dtlb_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_load_misses() const {
  return dtlb_load_misses_;
}
inline void PerfStatistics::set_dtlb_load_misses(::google::protobuf::uint64 value) {
  set_has_dtlb_load_misses();
  dtlb_load_misses_ = value;
}

// optional uint64 dtlb_stores = 40;
inline bool PerfStatistics::has_dtlb_stores() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void PerfStatistics::set_has_dtlb_stores() {
  _has_bits_[1] |= 0x00000080u;
}
inline void PerfStatistics::clear_has_dtlb_stores() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void PerfStatistics::clear_dtlb_stores() {
  dtlb_stores_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_stores();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_stores() const {
  return dtlb_stores_;
}
inline void PerfStatistics::set_dtlb_stores(::google::protobuf::uint64 value) {
  set_has_dtlb_stores();
  dtlb_stores_ = value;
}

// optional uint64 dtlb_store_misses = 41;
inline bool PerfStatistics::has_dtlb_store_misses() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void PerfStatistics::set_has_dtlb_store_misses() {
  _has_bits_[1] |= 0x00000100u;
}
inline void PerfStatistics::clear_has_dtlb_store_misses() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void PerfStatistics::clear_dtlb_store_misses() {
  dtlb_store_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_store_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_store_misses() const {
  return dtlb_store_misses_;
}
inline void PerfStatistics::set_dtlb_store_misses(::google::protobuf::uint64 value) {
  set_has_dtlb_store_misses();
  dtlb_store_misses_ = value;
}

// optional uint64 dtlb_prefetches = 42;
inline bool PerfStatistics::has_dtlb_prefetches() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void PerfStatistics::set_has_dtlb_prefetches() {
  _has_bits_[1] |= 0x00000200u;
}
inline void PerfStatistics::clear_has_dtlb_prefetches() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void PerfStatistics::clear_dtlb_prefetches() {
  dtlb_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_prefetches();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_prefetches() const {
  return dtlb_prefetches_;
}
inline void PerfStatistics::set_dtlb_prefetches(::google::protobuf::uint64 value) {
  set_has_dtlb_prefetches();
  dtlb_prefetches_ = value;
}

// optional uint64 dtlb_prefetch_misses = 43;
inline bool PerfStatistics::has_dtlb_prefetch_misses() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void PerfStatistics::set_has_dtlb_prefetch_misses() {
  _has_bits_[1] |= 0x00000400u;
}
inline void PerfStatistics::clear_has_dtlb_prefetch_misses() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void PerfStatistics::clear_dtlb_prefetch_misses() {
  dtlb_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_prefetch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_prefetch_misses() const {
  return dtlb_prefetch_misses_;
}
inline void PerfStatistics::set_dtlb_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_dtlb_prefetch_misses();
  dtlb_prefetch_misses_ = value;
}

// optional uint64 itlb_loads = 44;
inline bool PerfStatistics::has_itlb_loads() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void PerfStatistics::set_has_itlb_loads() {
  _has_bits_[1] |= 0x00000800u;
}
inline void PerfStatistics::clear_has_itlb_loads() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void PerfStatistics::clear_itlb_loads() {
  itlb_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_itlb_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::itlb_loads() const {
  return itlb_loads_;
}
inline void PerfStatistics::set_itlb_loads(::google::protobuf::uint64 value) {
  set_has_itlb_loads();
  itlb_loads_ = value;
}

// optional uint64 itlb_load_misses = 45;
inline bool PerfStatistics::has_itlb_load_misses() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void PerfStatistics::set_has_itlb_load_misses() {
  _has_bits_[1] |= 0x00001000u;
}
inline void PerfStatistics::clear_has_itlb_load_misses() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void PerfStatistics::clear_itlb_load_misses() {
  itlb_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_itlb_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::itlb_load_misses() const {
  return itlb_load_misses_;
}
inline void PerfStatistics::set_itlb_load_misses(::google::protobuf::uint64 value) {
  set_has_itlb_load_misses();
  itlb_load_misses_ = value;
}

// optional uint64 branch_loads = 46;
inline bool PerfStatistics::has_branch_loads() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void PerfStatistics::set_has_branch_loads() {
  _has_bits_[1] |= 0x00002000u;
}
inline void PerfStatistics::clear_has_branch_loads() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void PerfStatistics::clear_branch_loads() {
  branch_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_branch_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::branch_loads() const {
  return branch_loads_;
}
inline void PerfStatistics::set_branch_loads(::google::protobuf::uint64 value) {
  set_has_branch_loads();
  branch_loads_ = value;
}

// optional uint64 branch_load_misses = 47;
inline bool PerfStatistics::has_branch_load_misses() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void PerfStatistics::set_has_branch_load_misses() {
  _has_bits_[1] |= 0x00004000u;
}
inline void PerfStatistics::clear_has_branch_load_misses() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void PerfStatistics::clear_branch_load_misses() {
  branch_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_branch_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::branch_load_misses() const {
  return branch_load_misses_;
}
inline void PerfStatistics::set_branch_load_misses(::google::protobuf::uint64 value) {
  set_has_branch_load_misses();
  branch_load_misses_ = value;
}

// optional uint64 node_loads = 48;
inline bool PerfStatistics::has_node_loads() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void PerfStatistics::set_has_node_loads() {
  _has_bits_[1] |= 0x00008000u;
}
inline void PerfStatistics::clear_has_node_loads() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void PerfStatistics::clear_node_loads() {
  node_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_node_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::node_loads() const {
  return node_loads_;
}
inline void PerfStatistics::set_node_loads(::google::protobuf::uint64 value) {
  set_has_node_loads();
  node_loads_ = value;
}

// optional uint64 node_load_misses = 49;
inline bool PerfStatistics::has_node_load_misses() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void PerfStatistics::set_has_node_load_misses() {
  _has_bits_[1] |= 0x00010000u;
}
inline void PerfStatistics::clear_has_node_load_misses() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void PerfStatistics::clear_node_load_misses() {
  node_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_node_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::node_load_misses() const {
  return node_load_misses_;
}
inline void PerfStatistics::set_node_load_misses(::google::protobuf::uint64 value) {
  set_has_node_load_misses();
  node_load_misses_ = value;
}

// optional uint64 node_stores = 50;
inline bool PerfStatistics::has_node_stores() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void PerfStatistics::set_has_node_stores() {
  _has_bits_[1] |= 0x00020000u;
}
inline void PerfStatistics::clear_has_node_stores() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void PerfStatistics::clear_node_stores() {
  node_stores_ = GOOGLE_ULONGLONG(0);
  clear_has_node_stores();
}
inline ::google::protobuf::uint64 PerfStatistics::node_stores() const {
  return node_stores_;
}
inline void PerfStatistics::set_node_stores(::google::protobuf::uint64 value) {
  set_has_node_stores();
  node_stores_ = value;
}

// optional uint64 node_store_misses = 51;
inline bool PerfStatistics::has_node_store_misses() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void PerfStatistics::set_has_node_store_misses() {
  _has_bits_[1] |= 0x00040000u;
}
inline void PerfStatistics::clear_has_node_store_misses() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void PerfStatistics::clear_node_store_misses() {
  node_store_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_node_store_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::node_store_misses() const {
  return node_store_misses_;
}
inline void PerfStatistics::set_node_store_misses(::google::protobuf::uint64 value) {
  set_has_node_store_misses();
  node_store_misses_ = value;
}

// optional uint64 node_prefetches = 52;
inline bool PerfStatistics::has_node_prefetches() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void PerfStatistics::set_has_node_prefetches() {
  _has_bits_[1] |= 0x00080000u;
}
inline void PerfStatistics::clear_has_node_prefetches() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void PerfStatistics::clear_node_prefetches() {
  node_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_node_prefetches();
}
inline ::google::protobuf::uint64 PerfStatistics::node_prefetches() const {
  return node_prefetches_;
}
inline void PerfStatistics::set_node_prefetches(::google::protobuf::uint64 value) {
  set_has_node_prefetches();
  node_prefetches_ = value;
}

// optional uint64 node_prefetch_misses = 53;
inline bool PerfStatistics::has_node_prefetch_misses() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void PerfStatistics::set_has_node_prefetch_misses() {
  _has_bits_[1] |= 0x00100000u;
}
inline void PerfStatistics::clear_has_node_prefetch_misses() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void PerfStatistics::clear_node_prefetch_misses() {
  node_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_node_prefetch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::node_prefetch_misses() const {
  return node_prefetch_misses_;
}
inline void PerfStatistics::set_node_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_node_prefetch_misses();
  node_prefetch_misses_ = value;
}

// -------------------------------------------------------------------

// Request

// optional .mesos.SlaveID slave_id = 1;
inline bool Request::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Request::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Request::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* Request::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Request::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// repeated .mesos.Resource resources = 2;
inline int Request::resources_size() const {
  return resources_.size();
}
inline void Request::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Request::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* Request::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Request::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Request::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Request::mutable_resources() {
  return &resources_;
}

// -------------------------------------------------------------------

// Offer_Operation_Launch

// repeated .mesos.TaskInfo task_infos = 1;
inline int Offer_Operation_Launch::task_infos_size() const {
  return task_infos_.size();
}
inline void Offer_Operation_Launch::clear_task_infos() {
  task_infos_.Clear();
}
inline const ::mesos::TaskInfo& Offer_Operation_Launch::task_infos(int index) const {
  return task_infos_.Get(index);
}
inline ::mesos::TaskInfo* Offer_Operation_Launch::mutable_task_infos(int index) {
  return task_infos_.Mutable(index);
}
inline ::mesos::TaskInfo* Offer_Operation_Launch::add_task_infos() {
  return task_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
Offer_Operation_Launch::task_infos() const {
  return task_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
Offer_Operation_Launch::mutable_task_infos() {
  return &task_infos_;
}

// -------------------------------------------------------------------

// Offer_Operation_Reserve

// repeated .mesos.Resource resources = 1;
inline int Offer_Operation_Reserve::resources_size() const {
  return resources_.size();
}
inline void Offer_Operation_Reserve::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Offer_Operation_Reserve::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* Offer_Operation_Reserve::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Offer_Operation_Reserve::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer_Operation_Reserve::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer_Operation_Reserve::mutable_resources() {
  return &resources_;
}

// -------------------------------------------------------------------

// Offer_Operation_Unreserve

// repeated .mesos.Resource resources = 1;
inline int Offer_Operation_Unreserve::resources_size() const {
  return resources_.size();
}
inline void Offer_Operation_Unreserve::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Offer_Operation_Unreserve::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* Offer_Operation_Unreserve::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Offer_Operation_Unreserve::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer_Operation_Unreserve::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer_Operation_Unreserve::mutable_resources() {
  return &resources_;
}

// -------------------------------------------------------------------

// Offer_Operation_Create

// repeated .mesos.Resource volumes = 1;
inline int Offer_Operation_Create::volumes_size() const {
  return volumes_.size();
}
inline void Offer_Operation_Create::clear_volumes() {
  volumes_.Clear();
}
inline const ::mesos::Resource& Offer_Operation_Create::volumes(int index) const {
  return volumes_.Get(index);
}
inline ::mesos::Resource* Offer_Operation_Create::mutable_volumes(int index) {
  return volumes_.Mutable(index);
}
inline ::mesos::Resource* Offer_Operation_Create::add_volumes() {
  return volumes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer_Operation_Create::volumes() const {
  return volumes_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer_Operation_Create::mutable_volumes() {
  return &volumes_;
}

// -------------------------------------------------------------------

// Offer_Operation_Destroy

// repeated .mesos.Resource volumes = 1;
inline int Offer_Operation_Destroy::volumes_size() const {
  return volumes_.size();
}
inline void Offer_Operation_Destroy::clear_volumes() {
  volumes_.Clear();
}
inline const ::mesos::Resource& Offer_Operation_Destroy::volumes(int index) const {
  return volumes_.Get(index);
}
inline ::mesos::Resource* Offer_Operation_Destroy::mutable_volumes(int index) {
  return volumes_.Mutable(index);
}
inline ::mesos::Resource* Offer_Operation_Destroy::add_volumes() {
  return volumes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer_Operation_Destroy::volumes() const {
  return volumes_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer_Operation_Destroy::mutable_volumes() {
  return &volumes_;
}

// -------------------------------------------------------------------

// Offer_Operation

// required .mesos.Offer.Operation.Type type = 1;
inline bool Offer_Operation::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offer_Operation::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offer_Operation::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offer_Operation::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mesos::Offer_Operation_Type Offer_Operation::type() const {
  return static_cast< ::mesos::Offer_Operation_Type >(type_);
}
inline void Offer_Operation::set_type(::mesos::Offer_Operation_Type value) {
  assert(::mesos::Offer_Operation_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mesos.Offer.Operation.Launch launch = 2;
inline bool Offer_Operation::has_launch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Offer_Operation::set_has_launch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Offer_Operation::clear_has_launch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Offer_Operation::clear_launch() {
  if (launch_ != NULL) launch_->::mesos::Offer_Operation_Launch::Clear();
  clear_has_launch();
}
inline const ::mesos::Offer_Operation_Launch& Offer_Operation::launch() const {
  return launch_ != NULL ? *launch_ : *default_instance_->launch_;
}
inline ::mesos::Offer_Operation_Launch* Offer_Operation::mutable_launch() {
  set_has_launch();
  if (launch_ == NULL) launch_ = new ::mesos::Offer_Operation_Launch;
  return launch_;
}
inline ::mesos::Offer_Operation_Launch* Offer_Operation::release_launch() {
  clear_has_launch();
  ::mesos::Offer_Operation_Launch* temp = launch_;
  launch_ = NULL;
  return temp;
}
inline void Offer_Operation::set_allocated_launch(::mesos::Offer_Operation_Launch* launch) {
  delete launch_;
  launch_ = launch;
  if (launch) {
    set_has_launch();
  } else {
    clear_has_launch();
  }
}

// optional .mesos.Offer.Operation.Reserve reserve = 3;
inline bool Offer_Operation::has_reserve() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Offer_Operation::set_has_reserve() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Offer_Operation::clear_has_reserve() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Offer_Operation::clear_reserve() {
  if (reserve_ != NULL) reserve_->::mesos::Offer_Operation_Reserve::Clear();
  clear_has_reserve();
}
inline const ::mesos::Offer_Operation_Reserve& Offer_Operation::reserve() const {
  return reserve_ != NULL ? *reserve_ : *default_instance_->reserve_;
}
inline ::mesos::Offer_Operation_Reserve* Offer_Operation::mutable_reserve() {
  set_has_reserve();
  if (reserve_ == NULL) reserve_ = new ::mesos::Offer_Operation_Reserve;
  return reserve_;
}
inline ::mesos::Offer_Operation_Reserve* Offer_Operation::release_reserve() {
  clear_has_reserve();
  ::mesos::Offer_Operation_Reserve* temp = reserve_;
  reserve_ = NULL;
  return temp;
}
inline void Offer_Operation::set_allocated_reserve(::mesos::Offer_Operation_Reserve* reserve) {
  delete reserve_;
  reserve_ = reserve;
  if (reserve) {
    set_has_reserve();
  } else {
    clear_has_reserve();
  }
}

// optional .mesos.Offer.Operation.Unreserve unreserve = 4;
inline bool Offer_Operation::has_unreserve() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Offer_Operation::set_has_unreserve() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Offer_Operation::clear_has_unreserve() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Offer_Operation::clear_unreserve() {
  if (unreserve_ != NULL) unreserve_->::mesos::Offer_Operation_Unreserve::Clear();
  clear_has_unreserve();
}
inline const ::mesos::Offer_Operation_Unreserve& Offer_Operation::unreserve() const {
  return unreserve_ != NULL ? *unreserve_ : *default_instance_->unreserve_;
}
inline ::mesos::Offer_Operation_Unreserve* Offer_Operation::mutable_unreserve() {
  set_has_unreserve();
  if (unreserve_ == NULL) unreserve_ = new ::mesos::Offer_Operation_Unreserve;
  return unreserve_;
}
inline ::mesos::Offer_Operation_Unreserve* Offer_Operation::release_unreserve() {
  clear_has_unreserve();
  ::mesos::Offer_Operation_Unreserve* temp = unreserve_;
  unreserve_ = NULL;
  return temp;
}
inline void Offer_Operation::set_allocated_unreserve(::mesos::Offer_Operation_Unreserve* unreserve) {
  delete unreserve_;
  unreserve_ = unreserve;
  if (unreserve) {
    set_has_unreserve();
  } else {
    clear_has_unreserve();
  }
}

// optional .mesos.Offer.Operation.Create create = 5;
inline bool Offer_Operation::has_create() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Offer_Operation::set_has_create() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Offer_Operation::clear_has_create() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Offer_Operation::clear_create() {
  if (create_ != NULL) create_->::mesos::Offer_Operation_Create::Clear();
  clear_has_create();
}
inline const ::mesos::Offer_Operation_Create& Offer_Operation::create() const {
  return create_ != NULL ? *create_ : *default_instance_->create_;
}
inline ::mesos::Offer_Operation_Create* Offer_Operation::mutable_create() {
  set_has_create();
  if (create_ == NULL) create_ = new ::mesos::Offer_Operation_Create;
  return create_;
}
inline ::mesos::Offer_Operation_Create* Offer_Operation::release_create() {
  clear_has_create();
  ::mesos::Offer_Operation_Create* temp = create_;
  create_ = NULL;
  return temp;
}
inline void Offer_Operation::set_allocated_create(::mesos::Offer_Operation_Create* create) {
  delete create_;
  create_ = create;
  if (create) {
    set_has_create();
  } else {
    clear_has_create();
  }
}

// optional .mesos.Offer.Operation.Destroy destroy = 6;
inline bool Offer_Operation::has_destroy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Offer_Operation::set_has_destroy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Offer_Operation::clear_has_destroy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Offer_Operation::clear_destroy() {
  if (destroy_ != NULL) destroy_->::mesos::Offer_Operation_Destroy::Clear();
  clear_has_destroy();
}
inline const ::mesos::Offer_Operation_Destroy& Offer_Operation::destroy() const {
  return destroy_ != NULL ? *destroy_ : *default_instance_->destroy_;
}
inline ::mesos::Offer_Operation_Destroy* Offer_Operation::mutable_destroy() {
  set_has_destroy();
  if (destroy_ == NULL) destroy_ = new ::mesos::Offer_Operation_Destroy;
  return destroy_;
}
inline ::mesos::Offer_Operation_Destroy* Offer_Operation::release_destroy() {
  clear_has_destroy();
  ::mesos::Offer_Operation_Destroy* temp = destroy_;
  destroy_ = NULL;
  return temp;
}
inline void Offer_Operation::set_allocated_destroy(::mesos::Offer_Operation_Destroy* destroy) {
  delete destroy_;
  destroy_ = destroy;
  if (destroy) {
    set_has_destroy();
  } else {
    clear_has_destroy();
  }
}

// -------------------------------------------------------------------

// Offer

// required .mesos.OfferID id = 1;
inline bool Offer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offer::clear_id() {
  if (id_ != NULL) id_->::mesos::OfferID::Clear();
  clear_has_id();
}
inline const ::mesos::OfferID& Offer::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mesos::OfferID* Offer::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mesos::OfferID;
  return id_;
}
inline ::mesos::OfferID* Offer::release_id() {
  clear_has_id();
  ::mesos::OfferID* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Offer::set_allocated_id(::mesos::OfferID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// required .mesos.FrameworkID framework_id = 2;
inline bool Offer::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Offer::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Offer::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Offer::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& Offer::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* Offer::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* Offer::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void Offer::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .mesos.SlaveID slave_id = 3;
inline bool Offer::has_slave_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Offer::set_has_slave_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Offer::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Offer::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Offer::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Offer::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* Offer::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Offer::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// required string hostname = 4;
inline bool Offer::has_hostname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Offer::set_has_hostname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Offer::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Offer::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& Offer::hostname() const {
  return *hostname_;
}
inline void Offer::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Offer::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Offer::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Offer::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* Offer::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Offer::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .mesos.Resource resources = 5;
inline int Offer::resources_size() const {
  return resources_.size();
}
inline void Offer::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Offer::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* Offer::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Offer::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer::mutable_resources() {
  return &resources_;
}

// repeated .mesos.Attribute attributes = 7;
inline int Offer::attributes_size() const {
  return attributes_.size();
}
inline void Offer::clear_attributes() {
  attributes_.Clear();
}
inline const ::mesos::Attribute& Offer::attributes(int index) const {
  return attributes_.Get(index);
}
inline ::mesos::Attribute* Offer::mutable_attributes(int index) {
  return attributes_.Mutable(index);
}
inline ::mesos::Attribute* Offer::add_attributes() {
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
Offer::attributes() const {
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
Offer::mutable_attributes() {
  return &attributes_;
}

// repeated .mesos.ExecutorID executor_ids = 6;
inline int Offer::executor_ids_size() const {
  return executor_ids_.size();
}
inline void Offer::clear_executor_ids() {
  executor_ids_.Clear();
}
inline const ::mesos::ExecutorID& Offer::executor_ids(int index) const {
  return executor_ids_.Get(index);
}
inline ::mesos::ExecutorID* Offer::mutable_executor_ids(int index) {
  return executor_ids_.Mutable(index);
}
inline ::mesos::ExecutorID* Offer::add_executor_ids() {
  return executor_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >&
Offer::executor_ids() const {
  return executor_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >*
Offer::mutable_executor_ids() {
  return &executor_ids_;
}

// -------------------------------------------------------------------

// TaskInfo

// required string name = 1;
inline bool TaskInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TaskInfo::name() const {
  return *name_;
}
inline void TaskInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TaskInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TaskInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TaskInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .mesos.TaskID task_id = 2;
inline bool TaskInfo::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskInfo::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskInfo::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskInfo::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& TaskInfo::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* TaskInfo::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}
inline ::mesos::TaskID* TaskInfo::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
}

// required .mesos.SlaveID slave_id = 3;
inline bool TaskInfo::has_slave_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskInfo::set_has_slave_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskInfo::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskInfo::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& TaskInfo::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* TaskInfo::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* TaskInfo::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// repeated .mesos.Resource resources = 4;
inline int TaskInfo::resources_size() const {
  return resources_.size();
}
inline void TaskInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& TaskInfo::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* TaskInfo::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* TaskInfo::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
TaskInfo::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
TaskInfo::mutable_resources() {
  return &resources_;
}

// optional .mesos.ExecutorInfo executor = 5;
inline bool TaskInfo::has_executor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskInfo::set_has_executor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskInfo::clear_has_executor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskInfo::clear_executor() {
  if (executor_ != NULL) executor_->::mesos::ExecutorInfo::Clear();
  clear_has_executor();
}
inline const ::mesos::ExecutorInfo& TaskInfo::executor() const {
  return executor_ != NULL ? *executor_ : *default_instance_->executor_;
}
inline ::mesos::ExecutorInfo* TaskInfo::mutable_executor() {
  set_has_executor();
  if (executor_ == NULL) executor_ = new ::mesos::ExecutorInfo;
  return executor_;
}
inline ::mesos::ExecutorInfo* TaskInfo::release_executor() {
  clear_has_executor();
  ::mesos::ExecutorInfo* temp = executor_;
  executor_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_executor(::mesos::ExecutorInfo* executor) {
  delete executor_;
  executor_ = executor;
  if (executor) {
    set_has_executor();
  } else {
    clear_has_executor();
  }
}

// optional .mesos.CommandInfo command = 7;
inline bool TaskInfo::has_command() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskInfo::set_has_command() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskInfo::clear_command() {
  if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  clear_has_command();
}
inline const ::mesos::CommandInfo& TaskInfo::command() const {
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::mesos::CommandInfo* TaskInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::mesos::CommandInfo;
  return command_;
}
inline ::mesos::CommandInfo* TaskInfo::release_command() {
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_command(::mesos::CommandInfo* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
}

// optional .mesos.ContainerInfo container = 9;
inline bool TaskInfo::has_container() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TaskInfo::set_has_container() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TaskInfo::clear_has_container() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TaskInfo::clear_container() {
  if (container_ != NULL) container_->::mesos::ContainerInfo::Clear();
  clear_has_container();
}
inline const ::mesos::ContainerInfo& TaskInfo::container() const {
  return container_ != NULL ? *container_ : *default_instance_->container_;
}
inline ::mesos::ContainerInfo* TaskInfo::mutable_container() {
  set_has_container();
  if (container_ == NULL) container_ = new ::mesos::ContainerInfo;
  return container_;
}
inline ::mesos::ContainerInfo* TaskInfo::release_container() {
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  container_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_container(::mesos::ContainerInfo* container) {
  delete container_;
  container_ = container;
  if (container) {
    set_has_container();
  } else {
    clear_has_container();
  }
}

// optional bytes data = 6;
inline bool TaskInfo::has_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TaskInfo::set_has_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TaskInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TaskInfo::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& TaskInfo::data() const {
  return *data_;
}
inline void TaskInfo::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskInfo::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskInfo::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskInfo::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* TaskInfo::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskInfo::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mesos.HealthCheck health_check = 8;
inline bool TaskInfo::has_health_check() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TaskInfo::set_has_health_check() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TaskInfo::clear_has_health_check() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TaskInfo::clear_health_check() {
  if (health_check_ != NULL) health_check_->::mesos::HealthCheck::Clear();
  clear_has_health_check();
}
inline const ::mesos::HealthCheck& TaskInfo::health_check() const {
  return health_check_ != NULL ? *health_check_ : *default_instance_->health_check_;
}
inline ::mesos::HealthCheck* TaskInfo::mutable_health_check() {
  set_has_health_check();
  if (health_check_ == NULL) health_check_ = new ::mesos::HealthCheck;
  return health_check_;
}
inline ::mesos::HealthCheck* TaskInfo::release_health_check() {
  clear_has_health_check();
  ::mesos::HealthCheck* temp = health_check_;
  health_check_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_health_check(::mesos::HealthCheck* health_check) {
  delete health_check_;
  health_check_ = health_check;
  if (health_check) {
    set_has_health_check();
  } else {
    clear_has_health_check();
  }
}

// optional .mesos.Labels labels = 10;
inline bool TaskInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TaskInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TaskInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TaskInfo::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& TaskInfo::labels() const {
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* TaskInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  return labels_;
}
inline ::mesos::Labels* TaskInfo::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
}

// optional .mesos.DiscoveryInfo discovery = 11;
inline bool TaskInfo::has_discovery() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TaskInfo::set_has_discovery() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TaskInfo::clear_has_discovery() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TaskInfo::clear_discovery() {
  if (discovery_ != NULL) discovery_->::mesos::DiscoveryInfo::Clear();
  clear_has_discovery();
}
inline const ::mesos::DiscoveryInfo& TaskInfo::discovery() const {
  return discovery_ != NULL ? *discovery_ : *default_instance_->discovery_;
}
inline ::mesos::DiscoveryInfo* TaskInfo::mutable_discovery() {
  set_has_discovery();
  if (discovery_ == NULL) discovery_ = new ::mesos::DiscoveryInfo;
  return discovery_;
}
inline ::mesos::DiscoveryInfo* TaskInfo::release_discovery() {
  clear_has_discovery();
  ::mesos::DiscoveryInfo* temp = discovery_;
  discovery_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_discovery(::mesos::DiscoveryInfo* discovery) {
  delete discovery_;
  discovery_ = discovery;
  if (discovery) {
    set_has_discovery();
  } else {
    clear_has_discovery();
  }
}

// -------------------------------------------------------------------

// TaskStatus

// required .mesos.TaskID task_id = 1;
inline bool TaskStatus::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskStatus::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskStatus::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskStatus::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& TaskStatus::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* TaskStatus::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}
inline ::mesos::TaskID* TaskStatus::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void TaskStatus::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
}

// required .mesos.TaskState state = 2;
inline bool TaskStatus::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskStatus::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskStatus::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskStatus::clear_state() {
  state_ = 6;
  clear_has_state();
}
inline ::mesos::TaskState TaskStatus::state() const {
  return static_cast< ::mesos::TaskState >(state_);
}
inline void TaskStatus::set_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional string message = 4;
inline bool TaskStatus::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskStatus::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskStatus::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskStatus::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& TaskStatus::message() const {
  return *message_;
}
inline void TaskStatus::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void TaskStatus::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void TaskStatus::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskStatus::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* TaskStatus::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskStatus::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mesos.TaskStatus.Source source = 9;
inline bool TaskStatus::has_source() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskStatus::set_has_source() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskStatus::clear_has_source() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskStatus::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::mesos::TaskStatus_Source TaskStatus::source() const {
  return static_cast< ::mesos::TaskStatus_Source >(source_);
}
inline void TaskStatus::set_source(::mesos::TaskStatus_Source value) {
  assert(::mesos::TaskStatus_Source_IsValid(value));
  set_has_source();
  source_ = value;
}

// optional .mesos.TaskStatus.Reason reason = 10;
inline bool TaskStatus::has_reason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskStatus::set_has_reason() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskStatus::clear_has_reason() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskStatus::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::mesos::TaskStatus_Reason TaskStatus::reason() const {
  return static_cast< ::mesos::TaskStatus_Reason >(reason_);
}
inline void TaskStatus::set_reason(::mesos::TaskStatus_Reason value) {
  assert(::mesos::TaskStatus_Reason_IsValid(value));
  set_has_reason();
  reason_ = value;
}

// optional bytes data = 3;
inline bool TaskStatus::has_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskStatus::set_has_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskStatus::clear_has_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskStatus::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& TaskStatus::data() const {
  return *data_;
}
inline void TaskStatus::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskStatus::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskStatus::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskStatus::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* TaskStatus::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskStatus::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mesos.SlaveID slave_id = 5;
inline bool TaskStatus::has_slave_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TaskStatus::set_has_slave_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TaskStatus::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TaskStatus::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& TaskStatus::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* TaskStatus::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* TaskStatus::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void TaskStatus::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// optional .mesos.ExecutorID executor_id = 7;
inline bool TaskStatus::has_executor_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TaskStatus::set_has_executor_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TaskStatus::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TaskStatus::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& TaskStatus::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* TaskStatus::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* TaskStatus::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void TaskStatus::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
}

// optional double timestamp = 6;
inline bool TaskStatus::has_timestamp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TaskStatus::set_has_timestamp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TaskStatus::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TaskStatus::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double TaskStatus::timestamp() const {
  return timestamp_;
}
inline void TaskStatus::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional bytes uuid = 11;
inline bool TaskStatus::has_uuid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TaskStatus::set_has_uuid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TaskStatus::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TaskStatus::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& TaskStatus::uuid() const {
  return *uuid_;
}
inline void TaskStatus::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void TaskStatus::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void TaskStatus::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskStatus::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* TaskStatus::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskStatus::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool healthy = 8;
inline bool TaskStatus::has_healthy() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TaskStatus::set_has_healthy() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TaskStatus::clear_has_healthy() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TaskStatus::clear_healthy() {
  healthy_ = false;
  clear_has_healthy();
}
inline bool TaskStatus::healthy() const {
  return healthy_;
}
inline void TaskStatus::set_healthy(bool value) {
  set_has_healthy();
  healthy_ = value;
}

// -------------------------------------------------------------------

// Filters

// optional double refuse_seconds = 1 [default = 5];
inline bool Filters::has_refuse_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Filters::set_has_refuse_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Filters::clear_has_refuse_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Filters::clear_refuse_seconds() {
  refuse_seconds_ = 5;
  clear_has_refuse_seconds();
}
inline double Filters::refuse_seconds() const {
  return refuse_seconds_;
}
inline void Filters::set_refuse_seconds(double value) {
  set_has_refuse_seconds();
  refuse_seconds_ = value;
}

// -------------------------------------------------------------------

// Environment_Variable

// required string name = 1;
inline bool Environment_Variable::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Environment_Variable::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Environment_Variable::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Environment_Variable::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Environment_Variable::name() const {
  return *name_;
}
inline void Environment_Variable::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Environment_Variable::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Environment_Variable::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Environment_Variable::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Environment_Variable::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Environment_Variable::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool Environment_Variable::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Environment_Variable::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Environment_Variable::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Environment_Variable::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Environment_Variable::value() const {
  return *value_;
}
inline void Environment_Variable::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Environment_Variable::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Environment_Variable::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Environment_Variable::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Environment_Variable::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Environment_Variable::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Environment

// repeated .mesos.Environment.Variable variables = 1;
inline int Environment::variables_size() const {
  return variables_.size();
}
inline void Environment::clear_variables() {
  variables_.Clear();
}
inline const ::mesos::Environment_Variable& Environment::variables(int index) const {
  return variables_.Get(index);
}
inline ::mesos::Environment_Variable* Environment::mutable_variables(int index) {
  return variables_.Mutable(index);
}
inline ::mesos::Environment_Variable* Environment::add_variables() {
  return variables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >&
Environment::variables() const {
  return variables_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >*
Environment::mutable_variables() {
  return &variables_;
}

// -------------------------------------------------------------------

// Parameter

// required string key = 1;
inline bool Parameter::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parameter::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parameter::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parameter::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Parameter::key() const {
  return *key_;
}
inline void Parameter::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Parameter::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Parameter::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parameter::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Parameter::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Parameter::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool Parameter::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parameter::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parameter::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parameter::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Parameter::value() const {
  return *value_;
}
inline void Parameter::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Parameter::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Parameter::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parameter::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Parameter::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Parameter::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Parameters

// repeated .mesos.Parameter parameter = 1;
inline int Parameters::parameter_size() const {
  return parameter_.size();
}
inline void Parameters::clear_parameter() {
  parameter_.Clear();
}
inline const ::mesos::Parameter& Parameters::parameter(int index) const {
  return parameter_.Get(index);
}
inline ::mesos::Parameter* Parameters::mutable_parameter(int index) {
  return parameter_.Mutable(index);
}
inline ::mesos::Parameter* Parameters::add_parameter() {
  return parameter_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
Parameters::parameter() const {
  return parameter_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
Parameters::mutable_parameter() {
  return &parameter_;
}

// -------------------------------------------------------------------

// Credential

// required string principal = 1;
inline bool Credential::has_principal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Credential::set_has_principal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Credential::clear_has_principal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Credential::clear_principal() {
  if (principal_ != &::google::protobuf::internal::kEmptyString) {
    principal_->clear();
  }
  clear_has_principal();
}
inline const ::std::string& Credential::principal() const {
  return *principal_;
}
inline void Credential::set_principal(const ::std::string& value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
}
inline void Credential::set_principal(const char* value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
}
inline void Credential::set_principal(const char* value, size_t size) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  principal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Credential::mutable_principal() {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  return principal_;
}
inline ::std::string* Credential::release_principal() {
  clear_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = principal_;
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Credential::set_allocated_principal(::std::string* principal) {
  if (principal_ != &::google::protobuf::internal::kEmptyString) {
    delete principal_;
  }
  if (principal) {
    set_has_principal();
    principal_ = principal;
  } else {
    clear_has_principal();
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes secret = 2;
inline bool Credential::has_secret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Credential::set_has_secret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Credential::clear_has_secret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Credential::clear_secret() {
  if (secret_ != &::google::protobuf::internal::kEmptyString) {
    secret_->clear();
  }
  clear_has_secret();
}
inline const ::std::string& Credential::secret() const {
  return *secret_;
}
inline void Credential::set_secret(const ::std::string& value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
}
inline void Credential::set_secret(const char* value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
}
inline void Credential::set_secret(const void* value, size_t size) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  secret_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Credential::mutable_secret() {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  return secret_;
}
inline ::std::string* Credential::release_secret() {
  clear_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secret_;
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Credential::set_allocated_secret(::std::string* secret) {
  if (secret_ != &::google::protobuf::internal::kEmptyString) {
    delete secret_;
  }
  if (secret) {
    set_has_secret();
    secret_ = secret;
  } else {
    clear_has_secret();
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Credentials

// repeated .mesos.Credential credentials = 1;
inline int Credentials::credentials_size() const {
  return credentials_.size();
}
inline void Credentials::clear_credentials() {
  credentials_.Clear();
}
inline const ::mesos::Credential& Credentials::credentials(int index) const {
  return credentials_.Get(index);
}
inline ::mesos::Credential* Credentials::mutable_credentials(int index) {
  return credentials_.Mutable(index);
}
inline ::mesos::Credential* Credentials::add_credentials() {
  return credentials_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Credential >&
Credentials::credentials() const {
  return credentials_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Credential >*
Credentials::mutable_credentials() {
  return &credentials_;
}

// -------------------------------------------------------------------

// ACL_Entity

// optional .mesos.ACL.Entity.Type type = 1 [default = SOME];
inline bool ACL_Entity::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_Entity::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_Entity::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_Entity::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::ACL_Entity_Type ACL_Entity::type() const {
  return static_cast< ::mesos::ACL_Entity_Type >(type_);
}
inline void ACL_Entity::set_type(::mesos::ACL_Entity_Type value) {
  assert(::mesos::ACL_Entity_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated string values = 2;
inline int ACL_Entity::values_size() const {
  return values_.size();
}
inline void ACL_Entity::clear_values() {
  values_.Clear();
}
inline const ::std::string& ACL_Entity::values(int index) const {
  return values_.Get(index);
}
inline ::std::string* ACL_Entity::mutable_values(int index) {
  return values_.Mutable(index);
}
inline void ACL_Entity::set_values(int index, const ::std::string& value) {
  values_.Mutable(index)->assign(value);
}
inline void ACL_Entity::set_values(int index, const char* value) {
  values_.Mutable(index)->assign(value);
}
inline void ACL_Entity::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACL_Entity::add_values() {
  return values_.Add();
}
inline void ACL_Entity::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
}
inline void ACL_Entity::add_values(const char* value) {
  values_.Add()->assign(value);
}
inline void ACL_Entity::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ACL_Entity::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ACL_Entity::mutable_values() {
  return &values_;
}

// -------------------------------------------------------------------

// ACL_RegisterFramework

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_RegisterFramework::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_RegisterFramework::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_RegisterFramework::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_RegisterFramework::clear_principals() {
  if (principals_ != NULL) principals_->::mesos::ACL_Entity::Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_RegisterFramework::principals() const {
  return principals_ != NULL ? *principals_ : *default_instance_->principals_;
}
inline ::mesos::ACL_Entity* ACL_RegisterFramework::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) principals_ = new ::mesos::ACL_Entity;
  return principals_;
}
inline ::mesos::ACL_Entity* ACL_RegisterFramework::release_principals() {
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline void ACL_RegisterFramework::set_allocated_principals(::mesos::ACL_Entity* principals) {
  delete principals_;
  principals_ = principals;
  if (principals) {
    set_has_principals();
  } else {
    clear_has_principals();
  }
}

// required .mesos.ACL.Entity roles = 2;
inline bool ACL_RegisterFramework::has_roles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_RegisterFramework::set_has_roles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_RegisterFramework::clear_has_roles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_RegisterFramework::clear_roles() {
  if (roles_ != NULL) roles_->::mesos::ACL_Entity::Clear();
  clear_has_roles();
}
inline const ::mesos::ACL_Entity& ACL_RegisterFramework::roles() const {
  return roles_ != NULL ? *roles_ : *default_instance_->roles_;
}
inline ::mesos::ACL_Entity* ACL_RegisterFramework::mutable_roles() {
  set_has_roles();
  if (roles_ == NULL) roles_ = new ::mesos::ACL_Entity;
  return roles_;
}
inline ::mesos::ACL_Entity* ACL_RegisterFramework::release_roles() {
  clear_has_roles();
  ::mesos::ACL_Entity* temp = roles_;
  roles_ = NULL;
  return temp;
}
inline void ACL_RegisterFramework::set_allocated_roles(::mesos::ACL_Entity* roles) {
  delete roles_;
  roles_ = roles;
  if (roles) {
    set_has_roles();
  } else {
    clear_has_roles();
  }
}

// -------------------------------------------------------------------

// ACL_RunTask

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_RunTask::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_RunTask::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_RunTask::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_RunTask::clear_principals() {
  if (principals_ != NULL) principals_->::mesos::ACL_Entity::Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_RunTask::principals() const {
  return principals_ != NULL ? *principals_ : *default_instance_->principals_;
}
inline ::mesos::ACL_Entity* ACL_RunTask::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) principals_ = new ::mesos::ACL_Entity;
  return principals_;
}
inline ::mesos::ACL_Entity* ACL_RunTask::release_principals() {
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline void ACL_RunTask::set_allocated_principals(::mesos::ACL_Entity* principals) {
  delete principals_;
  principals_ = principals;
  if (principals) {
    set_has_principals();
  } else {
    clear_has_principals();
  }
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_RunTask::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_RunTask::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_RunTask::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_RunTask::clear_users() {
  if (users_ != NULL) users_->::mesos::ACL_Entity::Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_RunTask::users() const {
  return users_ != NULL ? *users_ : *default_instance_->users_;
}
inline ::mesos::ACL_Entity* ACL_RunTask::mutable_users() {
  set_has_users();
  if (users_ == NULL) users_ = new ::mesos::ACL_Entity;
  return users_;
}
inline ::mesos::ACL_Entity* ACL_RunTask::release_users() {
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline void ACL_RunTask::set_allocated_users(::mesos::ACL_Entity* users) {
  delete users_;
  users_ = users;
  if (users) {
    set_has_users();
  } else {
    clear_has_users();
  }
}

// -------------------------------------------------------------------

// ACL_ShutdownFramework

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_ShutdownFramework::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_ShutdownFramework::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_ShutdownFramework::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_ShutdownFramework::clear_principals() {
  if (principals_ != NULL) principals_->::mesos::ACL_Entity::Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_ShutdownFramework::principals() const {
  return principals_ != NULL ? *principals_ : *default_instance_->principals_;
}
inline ::mesos::ACL_Entity* ACL_ShutdownFramework::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) principals_ = new ::mesos::ACL_Entity;
  return principals_;
}
inline ::mesos::ACL_Entity* ACL_ShutdownFramework::release_principals() {
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline void ACL_ShutdownFramework::set_allocated_principals(::mesos::ACL_Entity* principals) {
  delete principals_;
  principals_ = principals;
  if (principals) {
    set_has_principals();
  } else {
    clear_has_principals();
  }
}

// required .mesos.ACL.Entity framework_principals = 2;
inline bool ACL_ShutdownFramework::has_framework_principals() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_ShutdownFramework::set_has_framework_principals() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_ShutdownFramework::clear_has_framework_principals() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_ShutdownFramework::clear_framework_principals() {
  if (framework_principals_ != NULL) framework_principals_->::mesos::ACL_Entity::Clear();
  clear_has_framework_principals();
}
inline const ::mesos::ACL_Entity& ACL_ShutdownFramework::framework_principals() const {
  return framework_principals_ != NULL ? *framework_principals_ : *default_instance_->framework_principals_;
}
inline ::mesos::ACL_Entity* ACL_ShutdownFramework::mutable_framework_principals() {
  set_has_framework_principals();
  if (framework_principals_ == NULL) framework_principals_ = new ::mesos::ACL_Entity;
  return framework_principals_;
}
inline ::mesos::ACL_Entity* ACL_ShutdownFramework::release_framework_principals() {
  clear_has_framework_principals();
  ::mesos::ACL_Entity* temp = framework_principals_;
  framework_principals_ = NULL;
  return temp;
}
inline void ACL_ShutdownFramework::set_allocated_framework_principals(::mesos::ACL_Entity* framework_principals) {
  delete framework_principals_;
  framework_principals_ = framework_principals;
  if (framework_principals) {
    set_has_framework_principals();
  } else {
    clear_has_framework_principals();
  }
}

// -------------------------------------------------------------------

// ACL

// -------------------------------------------------------------------

// ACLs

// optional bool permissive = 1 [default = true];
inline bool ACLs::has_permissive() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACLs::set_has_permissive() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACLs::clear_has_permissive() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACLs::clear_permissive() {
  permissive_ = true;
  clear_has_permissive();
}
inline bool ACLs::permissive() const {
  return permissive_;
}
inline void ACLs::set_permissive(bool value) {
  set_has_permissive();
  permissive_ = value;
}

// repeated .mesos.ACL.RegisterFramework register_frameworks = 2;
inline int ACLs::register_frameworks_size() const {
  return register_frameworks_.size();
}
inline void ACLs::clear_register_frameworks() {
  register_frameworks_.Clear();
}
inline const ::mesos::ACL_RegisterFramework& ACLs::register_frameworks(int index) const {
  return register_frameworks_.Get(index);
}
inline ::mesos::ACL_RegisterFramework* ACLs::mutable_register_frameworks(int index) {
  return register_frameworks_.Mutable(index);
}
inline ::mesos::ACL_RegisterFramework* ACLs::add_register_frameworks() {
  return register_frameworks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterFramework >&
ACLs::register_frameworks() const {
  return register_frameworks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterFramework >*
ACLs::mutable_register_frameworks() {
  return &register_frameworks_;
}

// repeated .mesos.ACL.RunTask run_tasks = 3;
inline int ACLs::run_tasks_size() const {
  return run_tasks_.size();
}
inline void ACLs::clear_run_tasks() {
  run_tasks_.Clear();
}
inline const ::mesos::ACL_RunTask& ACLs::run_tasks(int index) const {
  return run_tasks_.Get(index);
}
inline ::mesos::ACL_RunTask* ACLs::mutable_run_tasks(int index) {
  return run_tasks_.Mutable(index);
}
inline ::mesos::ACL_RunTask* ACLs::add_run_tasks() {
  return run_tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTask >&
ACLs::run_tasks() const {
  return run_tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTask >*
ACLs::mutable_run_tasks() {
  return &run_tasks_;
}

// repeated .mesos.ACL.ShutdownFramework shutdown_frameworks = 4;
inline int ACLs::shutdown_frameworks_size() const {
  return shutdown_frameworks_.size();
}
inline void ACLs::clear_shutdown_frameworks() {
  shutdown_frameworks_.Clear();
}
inline const ::mesos::ACL_ShutdownFramework& ACLs::shutdown_frameworks(int index) const {
  return shutdown_frameworks_.Get(index);
}
inline ::mesos::ACL_ShutdownFramework* ACLs::mutable_shutdown_frameworks(int index) {
  return shutdown_frameworks_.Mutable(index);
}
inline ::mesos::ACL_ShutdownFramework* ACLs::add_shutdown_frameworks() {
  return shutdown_frameworks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ShutdownFramework >&
ACLs::shutdown_frameworks() const {
  return shutdown_frameworks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ShutdownFramework >*
ACLs::mutable_shutdown_frameworks() {
  return &shutdown_frameworks_;
}

// -------------------------------------------------------------------

// RateLimit

// optional double qps = 1;
inline bool RateLimit::has_qps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RateLimit::set_has_qps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RateLimit::clear_has_qps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RateLimit::clear_qps() {
  qps_ = 0;
  clear_has_qps();
}
inline double RateLimit::qps() const {
  return qps_;
}
inline void RateLimit::set_qps(double value) {
  set_has_qps();
  qps_ = value;
}

// required string principal = 2;
inline bool RateLimit::has_principal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RateLimit::set_has_principal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RateLimit::clear_has_principal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RateLimit::clear_principal() {
  if (principal_ != &::google::protobuf::internal::kEmptyString) {
    principal_->clear();
  }
  clear_has_principal();
}
inline const ::std::string& RateLimit::principal() const {
  return *principal_;
}
inline void RateLimit::set_principal(const ::std::string& value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
}
inline void RateLimit::set_principal(const char* value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
}
inline void RateLimit::set_principal(const char* value, size_t size) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  principal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RateLimit::mutable_principal() {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  return principal_;
}
inline ::std::string* RateLimit::release_principal() {
  clear_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = principal_;
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RateLimit::set_allocated_principal(::std::string* principal) {
  if (principal_ != &::google::protobuf::internal::kEmptyString) {
    delete principal_;
  }
  if (principal) {
    set_has_principal();
    principal_ = principal;
  } else {
    clear_has_principal();
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 capacity = 3;
inline bool RateLimit::has_capacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RateLimit::set_has_capacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RateLimit::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RateLimit::clear_capacity() {
  capacity_ = GOOGLE_ULONGLONG(0);
  clear_has_capacity();
}
inline ::google::protobuf::uint64 RateLimit::capacity() const {
  return capacity_;
}
inline void RateLimit::set_capacity(::google::protobuf::uint64 value) {
  set_has_capacity();
  capacity_ = value;
}

// -------------------------------------------------------------------

// RateLimits

// repeated .mesos.RateLimit limits = 1;
inline int RateLimits::limits_size() const {
  return limits_.size();
}
inline void RateLimits::clear_limits() {
  limits_.Clear();
}
inline const ::mesos::RateLimit& RateLimits::limits(int index) const {
  return limits_.Get(index);
}
inline ::mesos::RateLimit* RateLimits::mutable_limits(int index) {
  return limits_.Mutable(index);
}
inline ::mesos::RateLimit* RateLimits::add_limits() {
  return limits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::RateLimit >&
RateLimits::limits() const {
  return limits_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::RateLimit >*
RateLimits::mutable_limits() {
  return &limits_;
}

// optional double aggregate_default_qps = 2;
inline bool RateLimits::has_aggregate_default_qps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RateLimits::set_has_aggregate_default_qps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RateLimits::clear_has_aggregate_default_qps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RateLimits::clear_aggregate_default_qps() {
  aggregate_default_qps_ = 0;
  clear_has_aggregate_default_qps();
}
inline double RateLimits::aggregate_default_qps() const {
  return aggregate_default_qps_;
}
inline void RateLimits::set_aggregate_default_qps(double value) {
  set_has_aggregate_default_qps();
  aggregate_default_qps_ = value;
}

// optional uint64 aggregate_default_capacity = 3;
inline bool RateLimits::has_aggregate_default_capacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RateLimits::set_has_aggregate_default_capacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RateLimits::clear_has_aggregate_default_capacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RateLimits::clear_aggregate_default_capacity() {
  aggregate_default_capacity_ = GOOGLE_ULONGLONG(0);
  clear_has_aggregate_default_capacity();
}
inline ::google::protobuf::uint64 RateLimits::aggregate_default_capacity() const {
  return aggregate_default_capacity_;
}
inline void RateLimits::set_aggregate_default_capacity(::google::protobuf::uint64 value) {
  set_has_aggregate_default_capacity();
  aggregate_default_capacity_ = value;
}

// -------------------------------------------------------------------

// Volume

// required string container_path = 1;
inline bool Volume::has_container_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Volume::set_has_container_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Volume::clear_has_container_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Volume::clear_container_path() {
  if (container_path_ != &::google::protobuf::internal::kEmptyString) {
    container_path_->clear();
  }
  clear_has_container_path();
}
inline const ::std::string& Volume::container_path() const {
  return *container_path_;
}
inline void Volume::set_container_path(const ::std::string& value) {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    container_path_ = new ::std::string;
  }
  container_path_->assign(value);
}
inline void Volume::set_container_path(const char* value) {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    container_path_ = new ::std::string;
  }
  container_path_->assign(value);
}
inline void Volume::set_container_path(const char* value, size_t size) {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    container_path_ = new ::std::string;
  }
  container_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Volume::mutable_container_path() {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    container_path_ = new ::std::string;
  }
  return container_path_;
}
inline ::std::string* Volume::release_container_path() {
  clear_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = container_path_;
    container_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Volume::set_allocated_container_path(::std::string* container_path) {
  if (container_path_ != &::google::protobuf::internal::kEmptyString) {
    delete container_path_;
  }
  if (container_path) {
    set_has_container_path();
    container_path_ = container_path;
  } else {
    clear_has_container_path();
    container_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string host_path = 2;
inline bool Volume::has_host_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Volume::set_has_host_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Volume::clear_has_host_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Volume::clear_host_path() {
  if (host_path_ != &::google::protobuf::internal::kEmptyString) {
    host_path_->clear();
  }
  clear_has_host_path();
}
inline const ::std::string& Volume::host_path() const {
  return *host_path_;
}
inline void Volume::set_host_path(const ::std::string& value) {
  set_has_host_path();
  if (host_path_ == &::google::protobuf::internal::kEmptyString) {
    host_path_ = new ::std::string;
  }
  host_path_->assign(value);
}
inline void Volume::set_host_path(const char* value) {
  set_has_host_path();
  if (host_path_ == &::google::protobuf::internal::kEmptyString) {
    host_path_ = new ::std::string;
  }
  host_path_->assign(value);
}
inline void Volume::set_host_path(const char* value, size_t size) {
  set_has_host_path();
  if (host_path_ == &::google::protobuf::internal::kEmptyString) {
    host_path_ = new ::std::string;
  }
  host_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Volume::mutable_host_path() {
  set_has_host_path();
  if (host_path_ == &::google::protobuf::internal::kEmptyString) {
    host_path_ = new ::std::string;
  }
  return host_path_;
}
inline ::std::string* Volume::release_host_path() {
  clear_has_host_path();
  if (host_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_path_;
    host_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Volume::set_allocated_host_path(::std::string* host_path) {
  if (host_path_ != &::google::protobuf::internal::kEmptyString) {
    delete host_path_;
  }
  if (host_path) {
    set_has_host_path();
    host_path_ = host_path;
  } else {
    clear_has_host_path();
    host_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .mesos.Volume.Mode mode = 3;
inline bool Volume::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Volume::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Volume::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Volume::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
inline ::mesos::Volume_Mode Volume::mode() const {
  return static_cast< ::mesos::Volume_Mode >(mode_);
}
inline void Volume::set_mode(::mesos::Volume_Mode value) {
  assert(::mesos::Volume_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// ContainerInfo_DockerInfo_PortMapping

// required uint32 host_port = 1;
inline bool ContainerInfo_DockerInfo_PortMapping::has_host_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerInfo_DockerInfo_PortMapping::set_has_host_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_has_host_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_host_port() {
  host_port_ = 0u;
  clear_has_host_port();
}
inline ::google::protobuf::uint32 ContainerInfo_DockerInfo_PortMapping::host_port() const {
  return host_port_;
}
inline void ContainerInfo_DockerInfo_PortMapping::set_host_port(::google::protobuf::uint32 value) {
  set_has_host_port();
  host_port_ = value;
}

// required uint32 container_port = 2;
inline bool ContainerInfo_DockerInfo_PortMapping::has_container_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerInfo_DockerInfo_PortMapping::set_has_container_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_has_container_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_container_port() {
  container_port_ = 0u;
  clear_has_container_port();
}
inline ::google::protobuf::uint32 ContainerInfo_DockerInfo_PortMapping::container_port() const {
  return container_port_;
}
inline void ContainerInfo_DockerInfo_PortMapping::set_container_port(::google::protobuf::uint32 value) {
  set_has_container_port();
  container_port_ = value;
}

// optional string protocol = 3;
inline bool ContainerInfo_DockerInfo_PortMapping::has_protocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerInfo_DockerInfo_PortMapping::set_has_protocol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_protocol() {
  if (protocol_ != &::google::protobuf::internal::kEmptyString) {
    protocol_->clear();
  }
  clear_has_protocol();
}
inline const ::std::string& ContainerInfo_DockerInfo_PortMapping::protocol() const {
  return *protocol_;
}
inline void ContainerInfo_DockerInfo_PortMapping::set_protocol(const ::std::string& value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void ContainerInfo_DockerInfo_PortMapping::set_protocol(const char* value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void ContainerInfo_DockerInfo_PortMapping::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContainerInfo_DockerInfo_PortMapping::mutable_protocol() {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  return protocol_;
}
inline ::std::string* ContainerInfo_DockerInfo_PortMapping::release_protocol() {
  clear_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocol_;
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContainerInfo_DockerInfo_PortMapping::set_allocated_protocol(::std::string* protocol) {
  if (protocol_ != &::google::protobuf::internal::kEmptyString) {
    delete protocol_;
  }
  if (protocol) {
    set_has_protocol();
    protocol_ = protocol;
  } else {
    clear_has_protocol();
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ContainerInfo_DockerInfo

// required string image = 1;
inline bool ContainerInfo_DockerInfo::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerInfo_DockerInfo::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerInfo_DockerInfo::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerInfo_DockerInfo::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& ContainerInfo_DockerInfo::image() const {
  return *image_;
}
inline void ContainerInfo_DockerInfo::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void ContainerInfo_DockerInfo::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void ContainerInfo_DockerInfo::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContainerInfo_DockerInfo::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* ContainerInfo_DockerInfo::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContainerInfo_DockerInfo::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mesos.ContainerInfo.DockerInfo.Network network = 2 [default = HOST];
inline bool ContainerInfo_DockerInfo::has_network() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerInfo_DockerInfo::set_has_network() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerInfo_DockerInfo::clear_has_network() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerInfo_DockerInfo::clear_network() {
  network_ = 1;
  clear_has_network();
}
inline ::mesos::ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo::network() const {
  return static_cast< ::mesos::ContainerInfo_DockerInfo_Network >(network_);
}
inline void ContainerInfo_DockerInfo::set_network(::mesos::ContainerInfo_DockerInfo_Network value) {
  assert(::mesos::ContainerInfo_DockerInfo_Network_IsValid(value));
  set_has_network();
  network_ = value;
}

// repeated .mesos.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;
inline int ContainerInfo_DockerInfo::port_mappings_size() const {
  return port_mappings_.size();
}
inline void ContainerInfo_DockerInfo::clear_port_mappings() {
  port_mappings_.Clear();
}
inline const ::mesos::ContainerInfo_DockerInfo_PortMapping& ContainerInfo_DockerInfo::port_mappings(int index) const {
  return port_mappings_.Get(index);
}
inline ::mesos::ContainerInfo_DockerInfo_PortMapping* ContainerInfo_DockerInfo::mutable_port_mappings(int index) {
  return port_mappings_.Mutable(index);
}
inline ::mesos::ContainerInfo_DockerInfo_PortMapping* ContainerInfo_DockerInfo::add_port_mappings() {
  return port_mappings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ContainerInfo_DockerInfo_PortMapping >&
ContainerInfo_DockerInfo::port_mappings() const {
  return port_mappings_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ContainerInfo_DockerInfo_PortMapping >*
ContainerInfo_DockerInfo::mutable_port_mappings() {
  return &port_mappings_;
}

// optional bool privileged = 4 [default = false];
inline bool ContainerInfo_DockerInfo::has_privileged() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerInfo_DockerInfo::set_has_privileged() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerInfo_DockerInfo::clear_has_privileged() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerInfo_DockerInfo::clear_privileged() {
  privileged_ = false;
  clear_has_privileged();
}
inline bool ContainerInfo_DockerInfo::privileged() const {
  return privileged_;
}
inline void ContainerInfo_DockerInfo::set_privileged(bool value) {
  set_has_privileged();
  privileged_ = value;
}

// repeated .mesos.Parameter parameters = 5;
inline int ContainerInfo_DockerInfo::parameters_size() const {
  return parameters_.size();
}
inline void ContainerInfo_DockerInfo::clear_parameters() {
  parameters_.Clear();
}
inline const ::mesos::Parameter& ContainerInfo_DockerInfo::parameters(int index) const {
  return parameters_.Get(index);
}
inline ::mesos::Parameter* ContainerInfo_DockerInfo::mutable_parameters(int index) {
  return parameters_.Mutable(index);
}
inline ::mesos::Parameter* ContainerInfo_DockerInfo::add_parameters() {
  return parameters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
ContainerInfo_DockerInfo::parameters() const {
  return parameters_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
ContainerInfo_DockerInfo::mutable_parameters() {
  return &parameters_;
}

// optional bool force_pull_image = 6;
inline bool ContainerInfo_DockerInfo::has_force_pull_image() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContainerInfo_DockerInfo::set_has_force_pull_image() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContainerInfo_DockerInfo::clear_has_force_pull_image() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ContainerInfo_DockerInfo::clear_force_pull_image() {
  force_pull_image_ = false;
  clear_has_force_pull_image();
}
inline bool ContainerInfo_DockerInfo::force_pull_image() const {
  return force_pull_image_;
}
inline void ContainerInfo_DockerInfo::set_force_pull_image(bool value) {
  set_has_force_pull_image();
  force_pull_image_ = value;
}

// -------------------------------------------------------------------

// ContainerInfo

// required .mesos.ContainerInfo.Type type = 1;
inline bool ContainerInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mesos::ContainerInfo_Type ContainerInfo::type() const {
  return static_cast< ::mesos::ContainerInfo_Type >(type_);
}
inline void ContainerInfo::set_type(::mesos::ContainerInfo_Type value) {
  assert(::mesos::ContainerInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .mesos.Volume volumes = 2;
inline int ContainerInfo::volumes_size() const {
  return volumes_.size();
}
inline void ContainerInfo::clear_volumes() {
  volumes_.Clear();
}
inline const ::mesos::Volume& ContainerInfo::volumes(int index) const {
  return volumes_.Get(index);
}
inline ::mesos::Volume* ContainerInfo::mutable_volumes(int index) {
  return volumes_.Mutable(index);
}
inline ::mesos::Volume* ContainerInfo::add_volumes() {
  return volumes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Volume >&
ContainerInfo::volumes() const {
  return volumes_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Volume >*
ContainerInfo::mutable_volumes() {
  return &volumes_;
}

// optional string hostname = 4;
inline bool ContainerInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerInfo::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& ContainerInfo::hostname() const {
  return *hostname_;
}
inline void ContainerInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void ContainerInfo::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void ContainerInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContainerInfo::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* ContainerInfo::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContainerInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mesos.ContainerInfo.DockerInfo docker = 3;
inline bool ContainerInfo::has_docker() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerInfo::set_has_docker() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerInfo::clear_has_docker() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerInfo::clear_docker() {
  if (docker_ != NULL) docker_->::mesos::ContainerInfo_DockerInfo::Clear();
  clear_has_docker();
}
inline const ::mesos::ContainerInfo_DockerInfo& ContainerInfo::docker() const {
  return docker_ != NULL ? *docker_ : *default_instance_->docker_;
}
inline ::mesos::ContainerInfo_DockerInfo* ContainerInfo::mutable_docker() {
  set_has_docker();
  if (docker_ == NULL) docker_ = new ::mesos::ContainerInfo_DockerInfo;
  return docker_;
}
inline ::mesos::ContainerInfo_DockerInfo* ContainerInfo::release_docker() {
  clear_has_docker();
  ::mesos::ContainerInfo_DockerInfo* temp = docker_;
  docker_ = NULL;
  return temp;
}
inline void ContainerInfo::set_allocated_docker(::mesos::ContainerInfo_DockerInfo* docker) {
  delete docker_;
  docker_ = docker;
  if (docker) {
    set_has_docker();
  } else {
    clear_has_docker();
  }
}

// -------------------------------------------------------------------

// Labels

// repeated .mesos.Label labels = 1;
inline int Labels::labels_size() const {
  return labels_.size();
}
inline void Labels::clear_labels() {
  labels_.Clear();
}
inline const ::mesos::Label& Labels::labels(int index) const {
  return labels_.Get(index);
}
inline ::mesos::Label* Labels::mutable_labels(int index) {
  return labels_.Mutable(index);
}
inline ::mesos::Label* Labels::add_labels() {
  return labels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Label >&
Labels::labels() const {
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Label >*
Labels::mutable_labels() {
  return &labels_;
}

// -------------------------------------------------------------------

// Label

// required string key = 1;
inline bool Label::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Label::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Label::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Label::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Label::key() const {
  return *key_;
}
inline void Label::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Label::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Label::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Label::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Label::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Label::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool Label::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Label::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Label::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Label::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Label::value() const {
  return *value_;
}
inline void Label::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Label::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Label::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Label::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Label::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Label::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Port

// required uint32 number = 1;
inline bool Port::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Port::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Port::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Port::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 Port::number() const {
  return number_;
}
inline void Port::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
}

// optional string name = 2;
inline bool Port::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Port::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Port::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Port::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Port::name() const {
  return *name_;
}
inline void Port::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Port::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Port::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Port::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Port::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Port::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string protocol = 3;
inline bool Port::has_protocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Port::set_has_protocol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Port::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Port::clear_protocol() {
  if (protocol_ != &::google::protobuf::internal::kEmptyString) {
    protocol_->clear();
  }
  clear_has_protocol();
}
inline const ::std::string& Port::protocol() const {
  return *protocol_;
}
inline void Port::set_protocol(const ::std::string& value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void Port::set_protocol(const char* value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void Port::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Port::mutable_protocol() {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  return protocol_;
}
inline ::std::string* Port::release_protocol() {
  clear_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocol_;
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Port::set_allocated_protocol(::std::string* protocol) {
  if (protocol_ != &::google::protobuf::internal::kEmptyString) {
    delete protocol_;
  }
  if (protocol) {
    set_has_protocol();
    protocol_ = protocol;
  } else {
    clear_has_protocol();
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Ports

// repeated .mesos.Port ports = 1;
inline int Ports::ports_size() const {
  return ports_.size();
}
inline void Ports::clear_ports() {
  ports_.Clear();
}
inline const ::mesos::Port& Ports::ports(int index) const {
  return ports_.Get(index);
}
inline ::mesos::Port* Ports::mutable_ports(int index) {
  return ports_.Mutable(index);
}
inline ::mesos::Port* Ports::add_ports() {
  return ports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Port >&
Ports::ports() const {
  return ports_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Port >*
Ports::mutable_ports() {
  return &ports_;
}

// -------------------------------------------------------------------

// DiscoveryInfo

// required .mesos.DiscoveryInfo.Visibility visibility = 1;
inline bool DiscoveryInfo::has_visibility() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiscoveryInfo::set_has_visibility() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiscoveryInfo::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiscoveryInfo::clear_visibility() {
  visibility_ = 0;
  clear_has_visibility();
}
inline ::mesos::DiscoveryInfo_Visibility DiscoveryInfo::visibility() const {
  return static_cast< ::mesos::DiscoveryInfo_Visibility >(visibility_);
}
inline void DiscoveryInfo::set_visibility(::mesos::DiscoveryInfo_Visibility value) {
  assert(::mesos::DiscoveryInfo_Visibility_IsValid(value));
  set_has_visibility();
  visibility_ = value;
}

// optional string name = 2;
inline bool DiscoveryInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiscoveryInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiscoveryInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiscoveryInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DiscoveryInfo::name() const {
  return *name_;
}
inline void DiscoveryInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DiscoveryInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DiscoveryInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiscoveryInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* DiscoveryInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DiscoveryInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string environment = 3;
inline bool DiscoveryInfo::has_environment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiscoveryInfo::set_has_environment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiscoveryInfo::clear_has_environment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiscoveryInfo::clear_environment() {
  if (environment_ != &::google::protobuf::internal::kEmptyString) {
    environment_->clear();
  }
  clear_has_environment();
}
inline const ::std::string& DiscoveryInfo::environment() const {
  return *environment_;
}
inline void DiscoveryInfo::set_environment(const ::std::string& value) {
  set_has_environment();
  if (environment_ == &::google::protobuf::internal::kEmptyString) {
    environment_ = new ::std::string;
  }
  environment_->assign(value);
}
inline void DiscoveryInfo::set_environment(const char* value) {
  set_has_environment();
  if (environment_ == &::google::protobuf::internal::kEmptyString) {
    environment_ = new ::std::string;
  }
  environment_->assign(value);
}
inline void DiscoveryInfo::set_environment(const char* value, size_t size) {
  set_has_environment();
  if (environment_ == &::google::protobuf::internal::kEmptyString) {
    environment_ = new ::std::string;
  }
  environment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiscoveryInfo::mutable_environment() {
  set_has_environment();
  if (environment_ == &::google::protobuf::internal::kEmptyString) {
    environment_ = new ::std::string;
  }
  return environment_;
}
inline ::std::string* DiscoveryInfo::release_environment() {
  clear_has_environment();
  if (environment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = environment_;
    environment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DiscoveryInfo::set_allocated_environment(::std::string* environment) {
  if (environment_ != &::google::protobuf::internal::kEmptyString) {
    delete environment_;
  }
  if (environment) {
    set_has_environment();
    environment_ = environment;
  } else {
    clear_has_environment();
    environment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string location = 4;
inline bool DiscoveryInfo::has_location() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DiscoveryInfo::set_has_location() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DiscoveryInfo::clear_has_location() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DiscoveryInfo::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& DiscoveryInfo::location() const {
  return *location_;
}
inline void DiscoveryInfo::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void DiscoveryInfo::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void DiscoveryInfo::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiscoveryInfo::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* DiscoveryInfo::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DiscoveryInfo::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 5;
inline bool DiscoveryInfo::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DiscoveryInfo::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DiscoveryInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DiscoveryInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& DiscoveryInfo::version() const {
  return *version_;
}
inline void DiscoveryInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void DiscoveryInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void DiscoveryInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiscoveryInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* DiscoveryInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DiscoveryInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mesos.Ports ports = 6;
inline bool DiscoveryInfo::has_ports() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DiscoveryInfo::set_has_ports() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DiscoveryInfo::clear_has_ports() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DiscoveryInfo::clear_ports() {
  if (ports_ != NULL) ports_->::mesos::Ports::Clear();
  clear_has_ports();
}
inline const ::mesos::Ports& DiscoveryInfo::ports() const {
  return ports_ != NULL ? *ports_ : *default_instance_->ports_;
}
inline ::mesos::Ports* DiscoveryInfo::mutable_ports() {
  set_has_ports();
  if (ports_ == NULL) ports_ = new ::mesos::Ports;
  return ports_;
}
inline ::mesos::Ports* DiscoveryInfo::release_ports() {
  clear_has_ports();
  ::mesos::Ports* temp = ports_;
  ports_ = NULL;
  return temp;
}
inline void DiscoveryInfo::set_allocated_ports(::mesos::Ports* ports) {
  delete ports_;
  ports_ = ports;
  if (ports) {
    set_has_ports();
  } else {
    clear_has_ports();
  }
}

// optional .mesos.Labels labels = 7;
inline bool DiscoveryInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DiscoveryInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DiscoveryInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DiscoveryInfo::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& DiscoveryInfo::labels() const {
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* DiscoveryInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  return labels_;
}
inline ::mesos::Labels* DiscoveryInfo::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void DiscoveryInfo::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mesos

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Value_Type>() {
  return ::mesos::Value_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Offer_Operation_Type>() {
  return ::mesos::Offer_Operation_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::TaskStatus_Source>() {
  return ::mesos::TaskStatus_Source_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::TaskStatus_Reason>() {
  return ::mesos::TaskStatus_Reason_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::ACL_Entity_Type>() {
  return ::mesos::ACL_Entity_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Volume_Mode>() {
  return ::mesos::Volume_Mode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::ContainerInfo_DockerInfo_Network>() {
  return ::mesos::ContainerInfo_DockerInfo_Network_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::ContainerInfo_Type>() {
  return ::mesos::ContainerInfo_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::DiscoveryInfo_Visibility>() {
  return ::mesos::DiscoveryInfo_Visibility_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Status>() {
  return ::mesos::Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::TaskState>() {
  return ::mesos::TaskState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mesos_2fmesos_2eproto__INCLUDED
