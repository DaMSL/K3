// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos/scheduler/scheduler.proto

#ifndef PROTOBUF_mesos_2fscheduler_2fscheduler_2eproto__INCLUDED
#define PROTOBUF_mesos_2fscheduler_2fscheduler_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mesos/mesos.pb.h"
// @@protoc_insertion_point(includes)

namespace mesos {
namespace scheduler {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

class Event;
class Event_Registered;
class Event_Reregistered;
class Event_Offers;
class Event_Rescind;
class Event_Update;
class Event_Message;
class Event_Failure;
class Event_Error;
class Call;
class Call_Request;
class Call_Decline;
class Call_Accept;
class Call_Launch;
class Call_Kill;
class Call_Acknowledge;
class Call_Reconcile;
class Call_Message;

enum Event_Type {
  Event_Type_REGISTERED = 1,
  Event_Type_REREGISTERED = 2,
  Event_Type_OFFERS = 3,
  Event_Type_RESCIND = 4,
  Event_Type_UPDATE = 5,
  Event_Type_MESSAGE = 6,
  Event_Type_FAILURE = 7,
  Event_Type_ERROR = 8
};
bool Event_Type_IsValid(int value);
const Event_Type Event_Type_Type_MIN = Event_Type_REGISTERED;
const Event_Type Event_Type_Type_MAX = Event_Type_ERROR;
const int Event_Type_Type_ARRAYSIZE = Event_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Event_Type_descriptor();
inline const ::std::string& Event_Type_Name(Event_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Event_Type_descriptor(), value);
}
inline bool Event_Type_Parse(
    const ::std::string& name, Event_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Event_Type>(
    Event_Type_descriptor(), name, value);
}
enum Call_Type {
  Call_Type_REGISTER = 1,
  Call_Type_REREGISTER = 2,
  Call_Type_UNREGISTER = 3,
  Call_Type_REQUEST = 4,
  Call_Type_REVIVE = 6,
  Call_Type_DECLINE = 5,
  Call_Type_ACCEPT = 12,
  Call_Type_LAUNCH = 7,
  Call_Type_KILL = 8,
  Call_Type_ACKNOWLEDGE = 9,
  Call_Type_RECONCILE = 10,
  Call_Type_MESSAGE = 11
};
bool Call_Type_IsValid(int value);
const Call_Type Call_Type_Type_MIN = Call_Type_REGISTER;
const Call_Type Call_Type_Type_MAX = Call_Type_ACCEPT;
const int Call_Type_Type_ARRAYSIZE = Call_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Call_Type_descriptor();
inline const ::std::string& Call_Type_Name(Call_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Call_Type_descriptor(), value);
}
inline bool Call_Type_Parse(
    const ::std::string& name, Call_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Call_Type>(
    Call_Type_descriptor(), name, value);
}
// ===================================================================

class Event_Registered : public ::google::protobuf::Message {
 public:
  Event_Registered();
  virtual ~Event_Registered();

  Event_Registered(const Event_Registered& from);

  inline Event_Registered& operator=(const Event_Registered& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Registered& default_instance();

  void Swap(Event_Registered* other);

  // implements Message ----------------------------------------------

  Event_Registered* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event_Registered& from);
  void MergeFrom(const Event_Registered& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .mesos.MasterInfo master_info = 2;
  inline bool has_master_info() const;
  inline void clear_master_info();
  static const int kMasterInfoFieldNumber = 2;
  inline const ::mesos::MasterInfo& master_info() const;
  inline ::mesos::MasterInfo* mutable_master_info();
  inline ::mesos::MasterInfo* release_master_info();
  inline void set_allocated_master_info(::mesos::MasterInfo* master_info);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Registered)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_master_info();
  inline void clear_has_master_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;
  ::mesos::MasterInfo* master_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Event_Registered* default_instance_;
};
// -------------------------------------------------------------------

class Event_Reregistered : public ::google::protobuf::Message {
 public:
  Event_Reregistered();
  virtual ~Event_Reregistered();

  Event_Reregistered(const Event_Reregistered& from);

  inline Event_Reregistered& operator=(const Event_Reregistered& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Reregistered& default_instance();

  void Swap(Event_Reregistered* other);

  // implements Message ----------------------------------------------

  Event_Reregistered* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event_Reregistered& from);
  void MergeFrom(const Event_Reregistered& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .mesos.MasterInfo master_info = 2;
  inline bool has_master_info() const;
  inline void clear_master_info();
  static const int kMasterInfoFieldNumber = 2;
  inline const ::mesos::MasterInfo& master_info() const;
  inline ::mesos::MasterInfo* mutable_master_info();
  inline ::mesos::MasterInfo* release_master_info();
  inline void set_allocated_master_info(::mesos::MasterInfo* master_info);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Reregistered)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_master_info();
  inline void clear_has_master_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;
  ::mesos::MasterInfo* master_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Event_Reregistered* default_instance_;
};
// -------------------------------------------------------------------

class Event_Offers : public ::google::protobuf::Message {
 public:
  Event_Offers();
  virtual ~Event_Offers();

  Event_Offers(const Event_Offers& from);

  inline Event_Offers& operator=(const Event_Offers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Offers& default_instance();

  void Swap(Event_Offers* other);

  // implements Message ----------------------------------------------

  Event_Offers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event_Offers& from);
  void MergeFrom(const Event_Offers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Offer offers = 1;
  inline int offers_size() const;
  inline void clear_offers();
  static const int kOffersFieldNumber = 1;
  inline const ::mesos::Offer& offers(int index) const;
  inline ::mesos::Offer* mutable_offers(int index);
  inline ::mesos::Offer* add_offers();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Offer >&
      offers() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Offer >*
      mutable_offers();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Offers)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Offer > offers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Event_Offers* default_instance_;
};
// -------------------------------------------------------------------

class Event_Rescind : public ::google::protobuf::Message {
 public:
  Event_Rescind();
  virtual ~Event_Rescind();

  Event_Rescind(const Event_Rescind& from);

  inline Event_Rescind& operator=(const Event_Rescind& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Rescind& default_instance();

  void Swap(Event_Rescind* other);

  // implements Message ----------------------------------------------

  Event_Rescind* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event_Rescind& from);
  void MergeFrom(const Event_Rescind& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.OfferID offer_id = 1;
  inline bool has_offer_id() const;
  inline void clear_offer_id();
  static const int kOfferIdFieldNumber = 1;
  inline const ::mesos::OfferID& offer_id() const;
  inline ::mesos::OfferID* mutable_offer_id();
  inline ::mesos::OfferID* release_offer_id();
  inline void set_allocated_offer_id(::mesos::OfferID* offer_id);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Rescind)
 private:
  inline void set_has_offer_id();
  inline void clear_has_offer_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::OfferID* offer_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Event_Rescind* default_instance_;
};
// -------------------------------------------------------------------

class Event_Update : public ::google::protobuf::Message {
 public:
  Event_Update();
  virtual ~Event_Update();

  Event_Update(const Event_Update& from);

  inline Event_Update& operator=(const Event_Update& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Update& default_instance();

  void Swap(Event_Update* other);

  // implements Message ----------------------------------------------

  Event_Update* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event_Update& from);
  void MergeFrom(const Event_Update& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // required .mesos.TaskStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::mesos::TaskStatus& status() const;
  inline ::mesos::TaskStatus* mutable_status();
  inline ::mesos::TaskStatus* release_status();
  inline void set_allocated_status(::mesos::TaskStatus* status);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Update)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;
  ::mesos::TaskStatus* status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Event_Update* default_instance_;
};
// -------------------------------------------------------------------

class Event_Message : public ::google::protobuf::Message {
 public:
  Event_Message();
  virtual ~Event_Message();

  Event_Message(const Event_Message& from);

  inline Event_Message& operator=(const Event_Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Message& default_instance();

  void Swap(Event_Message* other);

  // implements Message ----------------------------------------------

  Event_Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event_Message& from);
  void MergeFrom(const Event_Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.ExecutorID executor_id = 2;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 2;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // required bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Message)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::mesos::ExecutorID* executor_id_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Event_Message* default_instance_;
};
// -------------------------------------------------------------------

class Event_Failure : public ::google::protobuf::Message {
 public:
  Event_Failure();
  virtual ~Event_Failure();

  Event_Failure(const Event_Failure& from);

  inline Event_Failure& operator=(const Event_Failure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Failure& default_instance();

  void Swap(Event_Failure* other);

  // implements Message ----------------------------------------------

  Event_Failure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event_Failure& from);
  void MergeFrom(const Event_Failure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // optional .mesos.ExecutorID executor_id = 2;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 2;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // optional int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Failure)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::mesos::ExecutorID* executor_id_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Event_Failure* default_instance_;
};
// -------------------------------------------------------------------

class Event_Error : public ::google::protobuf::Message {
 public:
  Event_Error();
  virtual ~Event_Error();

  Event_Error(const Event_Error& from);

  inline Event_Error& operator=(const Event_Error& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Error& default_instance();

  void Swap(Event_Error* other);

  // implements Message ----------------------------------------------

  Event_Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event_Error& from);
  void MergeFrom(const Event_Error& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Error)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Event_Error* default_instance_;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  void Swap(Event* other);

  // implements Message ----------------------------------------------

  Event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Event_Registered Registered;
  typedef Event_Reregistered Reregistered;
  typedef Event_Offers Offers;
  typedef Event_Rescind Rescind;
  typedef Event_Update Update;
  typedef Event_Message Message;
  typedef Event_Failure Failure;
  typedef Event_Error Error;

  typedef Event_Type Type;
  static const Type REGISTERED = Event_Type_REGISTERED;
  static const Type REREGISTERED = Event_Type_REREGISTERED;
  static const Type OFFERS = Event_Type_OFFERS;
  static const Type RESCIND = Event_Type_RESCIND;
  static const Type UPDATE = Event_Type_UPDATE;
  static const Type MESSAGE = Event_Type_MESSAGE;
  static const Type FAILURE = Event_Type_FAILURE;
  static const Type ERROR = Event_Type_ERROR;
  static inline bool Type_IsValid(int value) {
    return Event_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Event_Type_Type_MIN;
  static const Type Type_MAX =
    Event_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Event_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Event_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Event_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Event_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.scheduler.Event.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::scheduler::Event_Type type() const;
  inline void set_type(::mesos::scheduler::Event_Type value);

  // optional .mesos.scheduler.Event.Registered registered = 2;
  inline bool has_registered() const;
  inline void clear_registered();
  static const int kRegisteredFieldNumber = 2;
  inline const ::mesos::scheduler::Event_Registered& registered() const;
  inline ::mesos::scheduler::Event_Registered* mutable_registered();
  inline ::mesos::scheduler::Event_Registered* release_registered();
  inline void set_allocated_registered(::mesos::scheduler::Event_Registered* registered);

  // optional .mesos.scheduler.Event.Reregistered reregistered = 3;
  inline bool has_reregistered() const;
  inline void clear_reregistered();
  static const int kReregisteredFieldNumber = 3;
  inline const ::mesos::scheduler::Event_Reregistered& reregistered() const;
  inline ::mesos::scheduler::Event_Reregistered* mutable_reregistered();
  inline ::mesos::scheduler::Event_Reregistered* release_reregistered();
  inline void set_allocated_reregistered(::mesos::scheduler::Event_Reregistered* reregistered);

  // optional .mesos.scheduler.Event.Offers offers = 4;
  inline bool has_offers() const;
  inline void clear_offers();
  static const int kOffersFieldNumber = 4;
  inline const ::mesos::scheduler::Event_Offers& offers() const;
  inline ::mesos::scheduler::Event_Offers* mutable_offers();
  inline ::mesos::scheduler::Event_Offers* release_offers();
  inline void set_allocated_offers(::mesos::scheduler::Event_Offers* offers);

  // optional .mesos.scheduler.Event.Rescind rescind = 5;
  inline bool has_rescind() const;
  inline void clear_rescind();
  static const int kRescindFieldNumber = 5;
  inline const ::mesos::scheduler::Event_Rescind& rescind() const;
  inline ::mesos::scheduler::Event_Rescind* mutable_rescind();
  inline ::mesos::scheduler::Event_Rescind* release_rescind();
  inline void set_allocated_rescind(::mesos::scheduler::Event_Rescind* rescind);

  // optional .mesos.scheduler.Event.Update update = 6;
  inline bool has_update() const;
  inline void clear_update();
  static const int kUpdateFieldNumber = 6;
  inline const ::mesos::scheduler::Event_Update& update() const;
  inline ::mesos::scheduler::Event_Update* mutable_update();
  inline ::mesos::scheduler::Event_Update* release_update();
  inline void set_allocated_update(::mesos::scheduler::Event_Update* update);

  // optional .mesos.scheduler.Event.Message message = 7;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 7;
  inline const ::mesos::scheduler::Event_Message& message() const;
  inline ::mesos::scheduler::Event_Message* mutable_message();
  inline ::mesos::scheduler::Event_Message* release_message();
  inline void set_allocated_message(::mesos::scheduler::Event_Message* message);

  // optional .mesos.scheduler.Event.Failure failure = 8;
  inline bool has_failure() const;
  inline void clear_failure();
  static const int kFailureFieldNumber = 8;
  inline const ::mesos::scheduler::Event_Failure& failure() const;
  inline ::mesos::scheduler::Event_Failure* mutable_failure();
  inline ::mesos::scheduler::Event_Failure* release_failure();
  inline void set_allocated_failure(::mesos::scheduler::Event_Failure* failure);

  // optional .mesos.scheduler.Event.Error error = 9;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 9;
  inline const ::mesos::scheduler::Event_Error& error() const;
  inline ::mesos::scheduler::Event_Error* mutable_error();
  inline ::mesos::scheduler::Event_Error* release_error();
  inline void set_allocated_error(::mesos::scheduler::Event_Error* error);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_registered();
  inline void clear_has_registered();
  inline void set_has_reregistered();
  inline void clear_has_reregistered();
  inline void set_has_offers();
  inline void clear_has_offers();
  inline void set_has_rescind();
  inline void clear_has_rescind();
  inline void set_has_update();
  inline void clear_has_update();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_failure();
  inline void clear_has_failure();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::scheduler::Event_Registered* registered_;
  ::mesos::scheduler::Event_Reregistered* reregistered_;
  ::mesos::scheduler::Event_Offers* offers_;
  ::mesos::scheduler::Event_Rescind* rescind_;
  ::mesos::scheduler::Event_Update* update_;
  ::mesos::scheduler::Event_Message* message_;
  ::mesos::scheduler::Event_Failure* failure_;
  ::mesos::scheduler::Event_Error* error_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Event* default_instance_;
};
// -------------------------------------------------------------------

class Call_Request : public ::google::protobuf::Message {
 public:
  Call_Request();
  virtual ~Call_Request();

  Call_Request(const Call_Request& from);

  inline Call_Request& operator=(const Call_Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Request& default_instance();

  void Swap(Call_Request* other);

  // implements Message ----------------------------------------------

  Call_Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Request& from);
  void MergeFrom(const Call_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Request requests = 1;
  inline int requests_size() const;
  inline void clear_requests();
  static const int kRequestsFieldNumber = 1;
  inline const ::mesos::Request& requests(int index) const;
  inline ::mesos::Request* mutable_requests(int index);
  inline ::mesos::Request* add_requests();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Request >&
      requests() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Request >*
      mutable_requests();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Request)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Request > requests_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Request* default_instance_;
};
// -------------------------------------------------------------------

class Call_Decline : public ::google::protobuf::Message {
 public:
  Call_Decline();
  virtual ~Call_Decline();

  Call_Decline(const Call_Decline& from);

  inline Call_Decline& operator=(const Call_Decline& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Decline& default_instance();

  void Swap(Call_Decline* other);

  // implements Message ----------------------------------------------

  Call_Decline* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Decline& from);
  void MergeFrom(const Call_Decline& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.OfferID offer_ids = 1;
  inline int offer_ids_size() const;
  inline void clear_offer_ids();
  static const int kOfferIdsFieldNumber = 1;
  inline const ::mesos::OfferID& offer_ids(int index) const;
  inline ::mesos::OfferID* mutable_offer_ids(int index);
  inline ::mesos::OfferID* add_offer_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
      offer_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
      mutable_offer_ids();

  // optional .mesos.Filters filters = 2;
  inline bool has_filters() const;
  inline void clear_filters();
  static const int kFiltersFieldNumber = 2;
  inline const ::mesos::Filters& filters() const;
  inline ::mesos::Filters* mutable_filters();
  inline ::mesos::Filters* release_filters();
  inline void set_allocated_filters(::mesos::Filters* filters);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Decline)
 private:
  inline void set_has_filters();
  inline void clear_has_filters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::OfferID > offer_ids_;
  ::mesos::Filters* filters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Decline* default_instance_;
};
// -------------------------------------------------------------------

class Call_Accept : public ::google::protobuf::Message {
 public:
  Call_Accept();
  virtual ~Call_Accept();

  Call_Accept(const Call_Accept& from);

  inline Call_Accept& operator=(const Call_Accept& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Accept& default_instance();

  void Swap(Call_Accept* other);

  // implements Message ----------------------------------------------

  Call_Accept* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Accept& from);
  void MergeFrom(const Call_Accept& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.OfferID offer_ids = 1;
  inline int offer_ids_size() const;
  inline void clear_offer_ids();
  static const int kOfferIdsFieldNumber = 1;
  inline const ::mesos::OfferID& offer_ids(int index) const;
  inline ::mesos::OfferID* mutable_offer_ids(int index);
  inline ::mesos::OfferID* add_offer_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
      offer_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
      mutable_offer_ids();

  // repeated .mesos.Offer.Operation operations = 2;
  inline int operations_size() const;
  inline void clear_operations();
  static const int kOperationsFieldNumber = 2;
  inline const ::mesos::Offer_Operation& operations(int index) const;
  inline ::mesos::Offer_Operation* mutable_operations(int index);
  inline ::mesos::Offer_Operation* add_operations();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Offer_Operation >&
      operations() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Offer_Operation >*
      mutable_operations();

  // optional .mesos.Filters filters = 3;
  inline bool has_filters() const;
  inline void clear_filters();
  static const int kFiltersFieldNumber = 3;
  inline const ::mesos::Filters& filters() const;
  inline ::mesos::Filters* mutable_filters();
  inline ::mesos::Filters* release_filters();
  inline void set_allocated_filters(::mesos::Filters* filters);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Accept)
 private:
  inline void set_has_filters();
  inline void clear_has_filters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::OfferID > offer_ids_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Offer_Operation > operations_;
  ::mesos::Filters* filters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Accept* default_instance_;
};
// -------------------------------------------------------------------

class Call_Launch : public ::google::protobuf::Message {
 public:
  Call_Launch();
  virtual ~Call_Launch();

  Call_Launch(const Call_Launch& from);

  inline Call_Launch& operator=(const Call_Launch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Launch& default_instance();

  void Swap(Call_Launch* other);

  // implements Message ----------------------------------------------

  Call_Launch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Launch& from);
  void MergeFrom(const Call_Launch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.TaskInfo task_infos = 1;
  inline int task_infos_size() const;
  inline void clear_task_infos();
  static const int kTaskInfosFieldNumber = 1;
  inline const ::mesos::TaskInfo& task_infos(int index) const;
  inline ::mesos::TaskInfo* mutable_task_infos(int index);
  inline ::mesos::TaskInfo* add_task_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
      task_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
      mutable_task_infos();

  // repeated .mesos.OfferID offer_ids = 2;
  inline int offer_ids_size() const;
  inline void clear_offer_ids();
  static const int kOfferIdsFieldNumber = 2;
  inline const ::mesos::OfferID& offer_ids(int index) const;
  inline ::mesos::OfferID* mutable_offer_ids(int index);
  inline ::mesos::OfferID* add_offer_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
      offer_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
      mutable_offer_ids();

  // optional .mesos.Filters filters = 3;
  inline bool has_filters() const;
  inline void clear_filters();
  static const int kFiltersFieldNumber = 3;
  inline const ::mesos::Filters& filters() const;
  inline ::mesos::Filters* mutable_filters();
  inline ::mesos::Filters* release_filters();
  inline void set_allocated_filters(::mesos::Filters* filters);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Launch)
 private:
  inline void set_has_filters();
  inline void clear_has_filters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo > task_infos_;
  ::google::protobuf::RepeatedPtrField< ::mesos::OfferID > offer_ids_;
  ::mesos::Filters* filters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Launch* default_instance_;
};
// -------------------------------------------------------------------

class Call_Kill : public ::google::protobuf::Message {
 public:
  Call_Kill();
  virtual ~Call_Kill();

  Call_Kill(const Call_Kill& from);

  inline Call_Kill& operator=(const Call_Kill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Kill& default_instance();

  void Swap(Call_Kill* other);

  // implements Message ----------------------------------------------

  Call_Kill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Kill& from);
  void MergeFrom(const Call_Kill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.TaskID task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Kill)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::TaskID* task_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Kill* default_instance_;
};
// -------------------------------------------------------------------

class Call_Acknowledge : public ::google::protobuf::Message {
 public:
  Call_Acknowledge();
  virtual ~Call_Acknowledge();

  Call_Acknowledge(const Call_Acknowledge& from);

  inline Call_Acknowledge& operator=(const Call_Acknowledge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Acknowledge& default_instance();

  void Swap(Call_Acknowledge* other);

  // implements Message ----------------------------------------------

  Call_Acknowledge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Acknowledge& from);
  void MergeFrom(const Call_Acknowledge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.TaskID task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // required bytes uuid = 3;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 3;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Acknowledge)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::mesos::TaskID* task_id_;
  ::std::string* uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Acknowledge* default_instance_;
};
// -------------------------------------------------------------------

class Call_Reconcile : public ::google::protobuf::Message {
 public:
  Call_Reconcile();
  virtual ~Call_Reconcile();

  Call_Reconcile(const Call_Reconcile& from);

  inline Call_Reconcile& operator=(const Call_Reconcile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Reconcile& default_instance();

  void Swap(Call_Reconcile* other);

  // implements Message ----------------------------------------------

  Call_Reconcile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Reconcile& from);
  void MergeFrom(const Call_Reconcile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.TaskStatus statuses = 1;
  inline int statuses_size() const;
  inline void clear_statuses();
  static const int kStatusesFieldNumber = 1;
  inline const ::mesos::TaskStatus& statuses(int index) const;
  inline ::mesos::TaskStatus* mutable_statuses(int index);
  inline ::mesos::TaskStatus* add_statuses();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >&
      statuses() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >*
      mutable_statuses();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Reconcile)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus > statuses_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Reconcile* default_instance_;
};
// -------------------------------------------------------------------

class Call_Message : public ::google::protobuf::Message {
 public:
  Call_Message();
  virtual ~Call_Message();

  Call_Message(const Call_Message& from);

  inline Call_Message& operator=(const Call_Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Message& default_instance();

  void Swap(Call_Message* other);

  // implements Message ----------------------------------------------

  Call_Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Message& from);
  void MergeFrom(const Call_Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.ExecutorID executor_id = 2;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 2;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // required bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Message)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::mesos::ExecutorID* executor_id_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Message* default_instance_;
};
// -------------------------------------------------------------------

class Call : public ::google::protobuf::Message {
 public:
  Call();
  virtual ~Call();

  Call(const Call& from);

  inline Call& operator=(const Call& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call& default_instance();

  void Swap(Call* other);

  // implements Message ----------------------------------------------

  Call* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call& from);
  void MergeFrom(const Call& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Call_Request Request;
  typedef Call_Decline Decline;
  typedef Call_Accept Accept;
  typedef Call_Launch Launch;
  typedef Call_Kill Kill;
  typedef Call_Acknowledge Acknowledge;
  typedef Call_Reconcile Reconcile;
  typedef Call_Message Message;

  typedef Call_Type Type;
  static const Type REGISTER = Call_Type_REGISTER;
  static const Type REREGISTER = Call_Type_REREGISTER;
  static const Type UNREGISTER = Call_Type_UNREGISTER;
  static const Type REQUEST = Call_Type_REQUEST;
  static const Type REVIVE = Call_Type_REVIVE;
  static const Type DECLINE = Call_Type_DECLINE;
  static const Type ACCEPT = Call_Type_ACCEPT;
  static const Type LAUNCH = Call_Type_LAUNCH;
  static const Type KILL = Call_Type_KILL;
  static const Type ACKNOWLEDGE = Call_Type_ACKNOWLEDGE;
  static const Type RECONCILE = Call_Type_RECONCILE;
  static const Type MESSAGE = Call_Type_MESSAGE;
  static inline bool Type_IsValid(int value) {
    return Call_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Call_Type_Type_MIN;
  static const Type Type_MAX =
    Call_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Call_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Call_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Call_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Call_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkInfo framework_info = 1;
  inline bool has_framework_info() const;
  inline void clear_framework_info();
  static const int kFrameworkInfoFieldNumber = 1;
  inline const ::mesos::FrameworkInfo& framework_info() const;
  inline ::mesos::FrameworkInfo* mutable_framework_info();
  inline ::mesos::FrameworkInfo* release_framework_info();
  inline void set_allocated_framework_info(::mesos::FrameworkInfo* framework_info);

  // required .mesos.scheduler.Call.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mesos::scheduler::Call_Type type() const;
  inline void set_type(::mesos::scheduler::Call_Type value);

  // optional .mesos.scheduler.Call.Request request = 3;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 3;
  inline const ::mesos::scheduler::Call_Request& request() const;
  inline ::mesos::scheduler::Call_Request* mutable_request();
  inline ::mesos::scheduler::Call_Request* release_request();
  inline void set_allocated_request(::mesos::scheduler::Call_Request* request);

  // optional .mesos.scheduler.Call.Decline decline = 4;
  inline bool has_decline() const;
  inline void clear_decline();
  static const int kDeclineFieldNumber = 4;
  inline const ::mesos::scheduler::Call_Decline& decline() const;
  inline ::mesos::scheduler::Call_Decline* mutable_decline();
  inline ::mesos::scheduler::Call_Decline* release_decline();
  inline void set_allocated_decline(::mesos::scheduler::Call_Decline* decline);

  // optional .mesos.scheduler.Call.Accept accept = 10;
  inline bool has_accept() const;
  inline void clear_accept();
  static const int kAcceptFieldNumber = 10;
  inline const ::mesos::scheduler::Call_Accept& accept() const;
  inline ::mesos::scheduler::Call_Accept* mutable_accept();
  inline ::mesos::scheduler::Call_Accept* release_accept();
  inline void set_allocated_accept(::mesos::scheduler::Call_Accept* accept);

  // optional .mesos.scheduler.Call.Launch launch = 5;
  inline bool has_launch() const;
  inline void clear_launch();
  static const int kLaunchFieldNumber = 5;
  inline const ::mesos::scheduler::Call_Launch& launch() const;
  inline ::mesos::scheduler::Call_Launch* mutable_launch();
  inline ::mesos::scheduler::Call_Launch* release_launch();
  inline void set_allocated_launch(::mesos::scheduler::Call_Launch* launch);

  // optional .mesos.scheduler.Call.Kill kill = 6;
  inline bool has_kill() const;
  inline void clear_kill();
  static const int kKillFieldNumber = 6;
  inline const ::mesos::scheduler::Call_Kill& kill() const;
  inline ::mesos::scheduler::Call_Kill* mutable_kill();
  inline ::mesos::scheduler::Call_Kill* release_kill();
  inline void set_allocated_kill(::mesos::scheduler::Call_Kill* kill);

  // optional .mesos.scheduler.Call.Acknowledge acknowledge = 7;
  inline bool has_acknowledge() const;
  inline void clear_acknowledge();
  static const int kAcknowledgeFieldNumber = 7;
  inline const ::mesos::scheduler::Call_Acknowledge& acknowledge() const;
  inline ::mesos::scheduler::Call_Acknowledge* mutable_acknowledge();
  inline ::mesos::scheduler::Call_Acknowledge* release_acknowledge();
  inline void set_allocated_acknowledge(::mesos::scheduler::Call_Acknowledge* acknowledge);

  // optional .mesos.scheduler.Call.Reconcile reconcile = 8;
  inline bool has_reconcile() const;
  inline void clear_reconcile();
  static const int kReconcileFieldNumber = 8;
  inline const ::mesos::scheduler::Call_Reconcile& reconcile() const;
  inline ::mesos::scheduler::Call_Reconcile* mutable_reconcile();
  inline ::mesos::scheduler::Call_Reconcile* release_reconcile();
  inline void set_allocated_reconcile(::mesos::scheduler::Call_Reconcile* reconcile);

  // optional .mesos.scheduler.Call.Message message = 9;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 9;
  inline const ::mesos::scheduler::Call_Message& message() const;
  inline ::mesos::scheduler::Call_Message* mutable_message();
  inline ::mesos::scheduler::Call_Message* release_message();
  inline void set_allocated_message(::mesos::scheduler::Call_Message* message);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call)
 private:
  inline void set_has_framework_info();
  inline void clear_has_framework_info();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_decline();
  inline void clear_has_decline();
  inline void set_has_accept();
  inline void clear_has_accept();
  inline void set_has_launch();
  inline void clear_has_launch();
  inline void set_has_kill();
  inline void clear_has_kill();
  inline void set_has_acknowledge();
  inline void clear_has_acknowledge();
  inline void set_has_reconcile();
  inline void clear_has_reconcile();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkInfo* framework_info_;
  ::mesos::scheduler::Call_Request* request_;
  ::mesos::scheduler::Call_Decline* decline_;
  ::mesos::scheduler::Call_Accept* accept_;
  ::mesos::scheduler::Call_Launch* launch_;
  ::mesos::scheduler::Call_Kill* kill_;
  ::mesos::scheduler::Call_Acknowledge* acknowledge_;
  ::mesos::scheduler::Call_Reconcile* reconcile_;
  ::mesos::scheduler::Call_Message* message_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_AssignDesc_mesos_2fscheduler_2fscheduler_2eproto();
  friend void protobuf_ShutdownFile_mesos_2fscheduler_2fscheduler_2eproto();

  void InitAsDefaultInstance();
  static Call* default_instance_;
};
// ===================================================================


// ===================================================================

// Event_Registered

// required .mesos.FrameworkID framework_id = 1;
inline bool Event_Registered::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Registered::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Registered::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_Registered::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& Event_Registered::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* Event_Registered::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* Event_Registered::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void Event_Registered::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .mesos.MasterInfo master_info = 2;
inline bool Event_Registered::has_master_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event_Registered::set_has_master_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event_Registered::clear_has_master_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event_Registered::clear_master_info() {
  if (master_info_ != NULL) master_info_->::mesos::MasterInfo::Clear();
  clear_has_master_info();
}
inline const ::mesos::MasterInfo& Event_Registered::master_info() const {
  return master_info_ != NULL ? *master_info_ : *default_instance_->master_info_;
}
inline ::mesos::MasterInfo* Event_Registered::mutable_master_info() {
  set_has_master_info();
  if (master_info_ == NULL) master_info_ = new ::mesos::MasterInfo;
  return master_info_;
}
inline ::mesos::MasterInfo* Event_Registered::release_master_info() {
  clear_has_master_info();
  ::mesos::MasterInfo* temp = master_info_;
  master_info_ = NULL;
  return temp;
}
inline void Event_Registered::set_allocated_master_info(::mesos::MasterInfo* master_info) {
  delete master_info_;
  master_info_ = master_info;
  if (master_info) {
    set_has_master_info();
  } else {
    clear_has_master_info();
  }
}

// -------------------------------------------------------------------

// Event_Reregistered

// required .mesos.FrameworkID framework_id = 1;
inline bool Event_Reregistered::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Reregistered::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Reregistered::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_Reregistered::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& Event_Reregistered::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* Event_Reregistered::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* Event_Reregistered::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void Event_Reregistered::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .mesos.MasterInfo master_info = 2;
inline bool Event_Reregistered::has_master_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event_Reregistered::set_has_master_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event_Reregistered::clear_has_master_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event_Reregistered::clear_master_info() {
  if (master_info_ != NULL) master_info_->::mesos::MasterInfo::Clear();
  clear_has_master_info();
}
inline const ::mesos::MasterInfo& Event_Reregistered::master_info() const {
  return master_info_ != NULL ? *master_info_ : *default_instance_->master_info_;
}
inline ::mesos::MasterInfo* Event_Reregistered::mutable_master_info() {
  set_has_master_info();
  if (master_info_ == NULL) master_info_ = new ::mesos::MasterInfo;
  return master_info_;
}
inline ::mesos::MasterInfo* Event_Reregistered::release_master_info() {
  clear_has_master_info();
  ::mesos::MasterInfo* temp = master_info_;
  master_info_ = NULL;
  return temp;
}
inline void Event_Reregistered::set_allocated_master_info(::mesos::MasterInfo* master_info) {
  delete master_info_;
  master_info_ = master_info;
  if (master_info) {
    set_has_master_info();
  } else {
    clear_has_master_info();
  }
}

// -------------------------------------------------------------------

// Event_Offers

// repeated .mesos.Offer offers = 1;
inline int Event_Offers::offers_size() const {
  return offers_.size();
}
inline void Event_Offers::clear_offers() {
  offers_.Clear();
}
inline const ::mesos::Offer& Event_Offers::offers(int index) const {
  return offers_.Get(index);
}
inline ::mesos::Offer* Event_Offers::mutable_offers(int index) {
  return offers_.Mutable(index);
}
inline ::mesos::Offer* Event_Offers::add_offers() {
  return offers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Offer >&
Event_Offers::offers() const {
  return offers_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Offer >*
Event_Offers::mutable_offers() {
  return &offers_;
}

// -------------------------------------------------------------------

// Event_Rescind

// required .mesos.OfferID offer_id = 1;
inline bool Event_Rescind::has_offer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Rescind::set_has_offer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Rescind::clear_has_offer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_Rescind::clear_offer_id() {
  if (offer_id_ != NULL) offer_id_->::mesos::OfferID::Clear();
  clear_has_offer_id();
}
inline const ::mesos::OfferID& Event_Rescind::offer_id() const {
  return offer_id_ != NULL ? *offer_id_ : *default_instance_->offer_id_;
}
inline ::mesos::OfferID* Event_Rescind::mutable_offer_id() {
  set_has_offer_id();
  if (offer_id_ == NULL) offer_id_ = new ::mesos::OfferID;
  return offer_id_;
}
inline ::mesos::OfferID* Event_Rescind::release_offer_id() {
  clear_has_offer_id();
  ::mesos::OfferID* temp = offer_id_;
  offer_id_ = NULL;
  return temp;
}
inline void Event_Rescind::set_allocated_offer_id(::mesos::OfferID* offer_id) {
  delete offer_id_;
  offer_id_ = offer_id;
  if (offer_id) {
    set_has_offer_id();
  } else {
    clear_has_offer_id();
  }
}

// -------------------------------------------------------------------

// Event_Update

// required bytes uuid = 1;
inline bool Event_Update::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Update::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Update::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_Update::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& Event_Update::uuid() const {
  return *uuid_;
}
inline void Event_Update::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Event_Update::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Event_Update::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Event_Update::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* Event_Update::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Event_Update::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .mesos.TaskStatus status = 2;
inline bool Event_Update::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event_Update::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event_Update::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event_Update::clear_status() {
  if (status_ != NULL) status_->::mesos::TaskStatus::Clear();
  clear_has_status();
}
inline const ::mesos::TaskStatus& Event_Update::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::mesos::TaskStatus* Event_Update::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::mesos::TaskStatus;
  return status_;
}
inline ::mesos::TaskStatus* Event_Update::release_status() {
  clear_has_status();
  ::mesos::TaskStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void Event_Update::set_allocated_status(::mesos::TaskStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// -------------------------------------------------------------------

// Event_Message

// required .mesos.SlaveID slave_id = 1;
inline bool Event_Message::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Message::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Message::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_Message::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Event_Message::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Event_Message::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* Event_Message::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Event_Message::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// required .mesos.ExecutorID executor_id = 2;
inline bool Event_Message::has_executor_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event_Message::set_has_executor_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event_Message::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event_Message::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& Event_Message::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* Event_Message::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* Event_Message::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void Event_Message::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
}

// required bytes data = 3;
inline bool Event_Message::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event_Message::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event_Message::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event_Message::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Event_Message::data() const {
  return *data_;
}
inline void Event_Message::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Event_Message::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Event_Message::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Event_Message::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* Event_Message::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Event_Message::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Event_Failure

// optional .mesos.SlaveID slave_id = 1;
inline bool Event_Failure::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Failure::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Failure::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_Failure::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Event_Failure::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Event_Failure::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* Event_Failure::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Event_Failure::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// optional .mesos.ExecutorID executor_id = 2;
inline bool Event_Failure::has_executor_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event_Failure::set_has_executor_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event_Failure::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event_Failure::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& Event_Failure::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* Event_Failure::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* Event_Failure::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void Event_Failure::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
}

// optional int32 status = 3;
inline bool Event_Failure::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event_Failure::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event_Failure::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event_Failure::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 Event_Failure::status() const {
  return status_;
}
inline void Event_Failure::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// Event_Error

// required string message = 1;
inline bool Event_Error::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Error::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Error::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_Error::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Event_Error::message() const {
  return *message_;
}
inline void Event_Error::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Event_Error::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Event_Error::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Event_Error::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* Event_Error::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Event_Error::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Event

// required .mesos.scheduler.Event.Type type = 1;
inline bool Event::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mesos::scheduler::Event_Type Event::type() const {
  return static_cast< ::mesos::scheduler::Event_Type >(type_);
}
inline void Event::set_type(::mesos::scheduler::Event_Type value) {
  assert(::mesos::scheduler::Event_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mesos.scheduler.Event.Registered registered = 2;
inline bool Event::has_registered() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event::set_has_registered() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event::clear_has_registered() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event::clear_registered() {
  if (registered_ != NULL) registered_->::mesos::scheduler::Event_Registered::Clear();
  clear_has_registered();
}
inline const ::mesos::scheduler::Event_Registered& Event::registered() const {
  return registered_ != NULL ? *registered_ : *default_instance_->registered_;
}
inline ::mesos::scheduler::Event_Registered* Event::mutable_registered() {
  set_has_registered();
  if (registered_ == NULL) registered_ = new ::mesos::scheduler::Event_Registered;
  return registered_;
}
inline ::mesos::scheduler::Event_Registered* Event::release_registered() {
  clear_has_registered();
  ::mesos::scheduler::Event_Registered* temp = registered_;
  registered_ = NULL;
  return temp;
}
inline void Event::set_allocated_registered(::mesos::scheduler::Event_Registered* registered) {
  delete registered_;
  registered_ = registered;
  if (registered) {
    set_has_registered();
  } else {
    clear_has_registered();
  }
}

// optional .mesos.scheduler.Event.Reregistered reregistered = 3;
inline bool Event::has_reregistered() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event::set_has_reregistered() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event::clear_has_reregistered() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event::clear_reregistered() {
  if (reregistered_ != NULL) reregistered_->::mesos::scheduler::Event_Reregistered::Clear();
  clear_has_reregistered();
}
inline const ::mesos::scheduler::Event_Reregistered& Event::reregistered() const {
  return reregistered_ != NULL ? *reregistered_ : *default_instance_->reregistered_;
}
inline ::mesos::scheduler::Event_Reregistered* Event::mutable_reregistered() {
  set_has_reregistered();
  if (reregistered_ == NULL) reregistered_ = new ::mesos::scheduler::Event_Reregistered;
  return reregistered_;
}
inline ::mesos::scheduler::Event_Reregistered* Event::release_reregistered() {
  clear_has_reregistered();
  ::mesos::scheduler::Event_Reregistered* temp = reregistered_;
  reregistered_ = NULL;
  return temp;
}
inline void Event::set_allocated_reregistered(::mesos::scheduler::Event_Reregistered* reregistered) {
  delete reregistered_;
  reregistered_ = reregistered;
  if (reregistered) {
    set_has_reregistered();
  } else {
    clear_has_reregistered();
  }
}

// optional .mesos.scheduler.Event.Offers offers = 4;
inline bool Event::has_offers() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Event::set_has_offers() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Event::clear_has_offers() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Event::clear_offers() {
  if (offers_ != NULL) offers_->::mesos::scheduler::Event_Offers::Clear();
  clear_has_offers();
}
inline const ::mesos::scheduler::Event_Offers& Event::offers() const {
  return offers_ != NULL ? *offers_ : *default_instance_->offers_;
}
inline ::mesos::scheduler::Event_Offers* Event::mutable_offers() {
  set_has_offers();
  if (offers_ == NULL) offers_ = new ::mesos::scheduler::Event_Offers;
  return offers_;
}
inline ::mesos::scheduler::Event_Offers* Event::release_offers() {
  clear_has_offers();
  ::mesos::scheduler::Event_Offers* temp = offers_;
  offers_ = NULL;
  return temp;
}
inline void Event::set_allocated_offers(::mesos::scheduler::Event_Offers* offers) {
  delete offers_;
  offers_ = offers;
  if (offers) {
    set_has_offers();
  } else {
    clear_has_offers();
  }
}

// optional .mesos.scheduler.Event.Rescind rescind = 5;
inline bool Event::has_rescind() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Event::set_has_rescind() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Event::clear_has_rescind() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Event::clear_rescind() {
  if (rescind_ != NULL) rescind_->::mesos::scheduler::Event_Rescind::Clear();
  clear_has_rescind();
}
inline const ::mesos::scheduler::Event_Rescind& Event::rescind() const {
  return rescind_ != NULL ? *rescind_ : *default_instance_->rescind_;
}
inline ::mesos::scheduler::Event_Rescind* Event::mutable_rescind() {
  set_has_rescind();
  if (rescind_ == NULL) rescind_ = new ::mesos::scheduler::Event_Rescind;
  return rescind_;
}
inline ::mesos::scheduler::Event_Rescind* Event::release_rescind() {
  clear_has_rescind();
  ::mesos::scheduler::Event_Rescind* temp = rescind_;
  rescind_ = NULL;
  return temp;
}
inline void Event::set_allocated_rescind(::mesos::scheduler::Event_Rescind* rescind) {
  delete rescind_;
  rescind_ = rescind;
  if (rescind) {
    set_has_rescind();
  } else {
    clear_has_rescind();
  }
}

// optional .mesos.scheduler.Event.Update update = 6;
inline bool Event::has_update() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Event::set_has_update() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Event::clear_has_update() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Event::clear_update() {
  if (update_ != NULL) update_->::mesos::scheduler::Event_Update::Clear();
  clear_has_update();
}
inline const ::mesos::scheduler::Event_Update& Event::update() const {
  return update_ != NULL ? *update_ : *default_instance_->update_;
}
inline ::mesos::scheduler::Event_Update* Event::mutable_update() {
  set_has_update();
  if (update_ == NULL) update_ = new ::mesos::scheduler::Event_Update;
  return update_;
}
inline ::mesos::scheduler::Event_Update* Event::release_update() {
  clear_has_update();
  ::mesos::scheduler::Event_Update* temp = update_;
  update_ = NULL;
  return temp;
}
inline void Event::set_allocated_update(::mesos::scheduler::Event_Update* update) {
  delete update_;
  update_ = update;
  if (update) {
    set_has_update();
  } else {
    clear_has_update();
  }
}

// optional .mesos.scheduler.Event.Message message = 7;
inline bool Event::has_message() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Event::set_has_message() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Event::clear_has_message() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Event::clear_message() {
  if (message_ != NULL) message_->::mesos::scheduler::Event_Message::Clear();
  clear_has_message();
}
inline const ::mesos::scheduler::Event_Message& Event::message() const {
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::mesos::scheduler::Event_Message* Event::mutable_message() {
  set_has_message();
  if (message_ == NULL) message_ = new ::mesos::scheduler::Event_Message;
  return message_;
}
inline ::mesos::scheduler::Event_Message* Event::release_message() {
  clear_has_message();
  ::mesos::scheduler::Event_Message* temp = message_;
  message_ = NULL;
  return temp;
}
inline void Event::set_allocated_message(::mesos::scheduler::Event_Message* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
}

// optional .mesos.scheduler.Event.Failure failure = 8;
inline bool Event::has_failure() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Event::set_has_failure() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Event::clear_has_failure() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Event::clear_failure() {
  if (failure_ != NULL) failure_->::mesos::scheduler::Event_Failure::Clear();
  clear_has_failure();
}
inline const ::mesos::scheduler::Event_Failure& Event::failure() const {
  return failure_ != NULL ? *failure_ : *default_instance_->failure_;
}
inline ::mesos::scheduler::Event_Failure* Event::mutable_failure() {
  set_has_failure();
  if (failure_ == NULL) failure_ = new ::mesos::scheduler::Event_Failure;
  return failure_;
}
inline ::mesos::scheduler::Event_Failure* Event::release_failure() {
  clear_has_failure();
  ::mesos::scheduler::Event_Failure* temp = failure_;
  failure_ = NULL;
  return temp;
}
inline void Event::set_allocated_failure(::mesos::scheduler::Event_Failure* failure) {
  delete failure_;
  failure_ = failure;
  if (failure) {
    set_has_failure();
  } else {
    clear_has_failure();
  }
}

// optional .mesos.scheduler.Event.Error error = 9;
inline bool Event::has_error() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Event::set_has_error() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Event::clear_has_error() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Event::clear_error() {
  if (error_ != NULL) error_->::mesos::scheduler::Event_Error::Clear();
  clear_has_error();
}
inline const ::mesos::scheduler::Event_Error& Event::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::mesos::scheduler::Event_Error* Event::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::mesos::scheduler::Event_Error;
  return error_;
}
inline ::mesos::scheduler::Event_Error* Event::release_error() {
  clear_has_error();
  ::mesos::scheduler::Event_Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline void Event::set_allocated_error(::mesos::scheduler::Event_Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
}

// -------------------------------------------------------------------

// Call_Request

// repeated .mesos.Request requests = 1;
inline int Call_Request::requests_size() const {
  return requests_.size();
}
inline void Call_Request::clear_requests() {
  requests_.Clear();
}
inline const ::mesos::Request& Call_Request::requests(int index) const {
  return requests_.Get(index);
}
inline ::mesos::Request* Call_Request::mutable_requests(int index) {
  return requests_.Mutable(index);
}
inline ::mesos::Request* Call_Request::add_requests() {
  return requests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Request >&
Call_Request::requests() const {
  return requests_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Request >*
Call_Request::mutable_requests() {
  return &requests_;
}

// -------------------------------------------------------------------

// Call_Decline

// repeated .mesos.OfferID offer_ids = 1;
inline int Call_Decline::offer_ids_size() const {
  return offer_ids_.size();
}
inline void Call_Decline::clear_offer_ids() {
  offer_ids_.Clear();
}
inline const ::mesos::OfferID& Call_Decline::offer_ids(int index) const {
  return offer_ids_.Get(index);
}
inline ::mesos::OfferID* Call_Decline::mutable_offer_ids(int index) {
  return offer_ids_.Mutable(index);
}
inline ::mesos::OfferID* Call_Decline::add_offer_ids() {
  return offer_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
Call_Decline::offer_ids() const {
  return offer_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
Call_Decline::mutable_offer_ids() {
  return &offer_ids_;
}

// optional .mesos.Filters filters = 2;
inline bool Call_Decline::has_filters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_Decline::set_has_filters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_Decline::clear_has_filters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_Decline::clear_filters() {
  if (filters_ != NULL) filters_->::mesos::Filters::Clear();
  clear_has_filters();
}
inline const ::mesos::Filters& Call_Decline::filters() const {
  return filters_ != NULL ? *filters_ : *default_instance_->filters_;
}
inline ::mesos::Filters* Call_Decline::mutable_filters() {
  set_has_filters();
  if (filters_ == NULL) filters_ = new ::mesos::Filters;
  return filters_;
}
inline ::mesos::Filters* Call_Decline::release_filters() {
  clear_has_filters();
  ::mesos::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline void Call_Decline::set_allocated_filters(::mesos::Filters* filters) {
  delete filters_;
  filters_ = filters;
  if (filters) {
    set_has_filters();
  } else {
    clear_has_filters();
  }
}

// -------------------------------------------------------------------

// Call_Accept

// repeated .mesos.OfferID offer_ids = 1;
inline int Call_Accept::offer_ids_size() const {
  return offer_ids_.size();
}
inline void Call_Accept::clear_offer_ids() {
  offer_ids_.Clear();
}
inline const ::mesos::OfferID& Call_Accept::offer_ids(int index) const {
  return offer_ids_.Get(index);
}
inline ::mesos::OfferID* Call_Accept::mutable_offer_ids(int index) {
  return offer_ids_.Mutable(index);
}
inline ::mesos::OfferID* Call_Accept::add_offer_ids() {
  return offer_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
Call_Accept::offer_ids() const {
  return offer_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
Call_Accept::mutable_offer_ids() {
  return &offer_ids_;
}

// repeated .mesos.Offer.Operation operations = 2;
inline int Call_Accept::operations_size() const {
  return operations_.size();
}
inline void Call_Accept::clear_operations() {
  operations_.Clear();
}
inline const ::mesos::Offer_Operation& Call_Accept::operations(int index) const {
  return operations_.Get(index);
}
inline ::mesos::Offer_Operation* Call_Accept::mutable_operations(int index) {
  return operations_.Mutable(index);
}
inline ::mesos::Offer_Operation* Call_Accept::add_operations() {
  return operations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Offer_Operation >&
Call_Accept::operations() const {
  return operations_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Offer_Operation >*
Call_Accept::mutable_operations() {
  return &operations_;
}

// optional .mesos.Filters filters = 3;
inline bool Call_Accept::has_filters() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_Accept::set_has_filters() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_Accept::clear_has_filters() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Call_Accept::clear_filters() {
  if (filters_ != NULL) filters_->::mesos::Filters::Clear();
  clear_has_filters();
}
inline const ::mesos::Filters& Call_Accept::filters() const {
  return filters_ != NULL ? *filters_ : *default_instance_->filters_;
}
inline ::mesos::Filters* Call_Accept::mutable_filters() {
  set_has_filters();
  if (filters_ == NULL) filters_ = new ::mesos::Filters;
  return filters_;
}
inline ::mesos::Filters* Call_Accept::release_filters() {
  clear_has_filters();
  ::mesos::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline void Call_Accept::set_allocated_filters(::mesos::Filters* filters) {
  delete filters_;
  filters_ = filters;
  if (filters) {
    set_has_filters();
  } else {
    clear_has_filters();
  }
}

// -------------------------------------------------------------------

// Call_Launch

// repeated .mesos.TaskInfo task_infos = 1;
inline int Call_Launch::task_infos_size() const {
  return task_infos_.size();
}
inline void Call_Launch::clear_task_infos() {
  task_infos_.Clear();
}
inline const ::mesos::TaskInfo& Call_Launch::task_infos(int index) const {
  return task_infos_.Get(index);
}
inline ::mesos::TaskInfo* Call_Launch::mutable_task_infos(int index) {
  return task_infos_.Mutable(index);
}
inline ::mesos::TaskInfo* Call_Launch::add_task_infos() {
  return task_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
Call_Launch::task_infos() const {
  return task_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
Call_Launch::mutable_task_infos() {
  return &task_infos_;
}

// repeated .mesos.OfferID offer_ids = 2;
inline int Call_Launch::offer_ids_size() const {
  return offer_ids_.size();
}
inline void Call_Launch::clear_offer_ids() {
  offer_ids_.Clear();
}
inline const ::mesos::OfferID& Call_Launch::offer_ids(int index) const {
  return offer_ids_.Get(index);
}
inline ::mesos::OfferID* Call_Launch::mutable_offer_ids(int index) {
  return offer_ids_.Mutable(index);
}
inline ::mesos::OfferID* Call_Launch::add_offer_ids() {
  return offer_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
Call_Launch::offer_ids() const {
  return offer_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
Call_Launch::mutable_offer_ids() {
  return &offer_ids_;
}

// optional .mesos.Filters filters = 3;
inline bool Call_Launch::has_filters() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_Launch::set_has_filters() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_Launch::clear_has_filters() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Call_Launch::clear_filters() {
  if (filters_ != NULL) filters_->::mesos::Filters::Clear();
  clear_has_filters();
}
inline const ::mesos::Filters& Call_Launch::filters() const {
  return filters_ != NULL ? *filters_ : *default_instance_->filters_;
}
inline ::mesos::Filters* Call_Launch::mutable_filters() {
  set_has_filters();
  if (filters_ == NULL) filters_ = new ::mesos::Filters;
  return filters_;
}
inline ::mesos::Filters* Call_Launch::release_filters() {
  clear_has_filters();
  ::mesos::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline void Call_Launch::set_allocated_filters(::mesos::Filters* filters) {
  delete filters_;
  filters_ = filters;
  if (filters) {
    set_has_filters();
  } else {
    clear_has_filters();
  }
}

// -------------------------------------------------------------------

// Call_Kill

// required .mesos.TaskID task_id = 1;
inline bool Call_Kill::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Kill::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Kill::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_Kill::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& Call_Kill::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* Call_Kill::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}
inline ::mesos::TaskID* Call_Kill::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void Call_Kill::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
}

// -------------------------------------------------------------------

// Call_Acknowledge

// required .mesos.SlaveID slave_id = 1;
inline bool Call_Acknowledge::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Acknowledge::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Acknowledge::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_Acknowledge::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Call_Acknowledge::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Call_Acknowledge::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* Call_Acknowledge::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Call_Acknowledge::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// required .mesos.TaskID task_id = 2;
inline bool Call_Acknowledge::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_Acknowledge::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_Acknowledge::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_Acknowledge::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& Call_Acknowledge::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* Call_Acknowledge::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}
inline ::mesos::TaskID* Call_Acknowledge::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void Call_Acknowledge::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
}

// required bytes uuid = 3;
inline bool Call_Acknowledge::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_Acknowledge::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_Acknowledge::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Call_Acknowledge::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& Call_Acknowledge::uuid() const {
  return *uuid_;
}
inline void Call_Acknowledge::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Call_Acknowledge::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Call_Acknowledge::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Call_Acknowledge::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* Call_Acknowledge::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Call_Acknowledge::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Call_Reconcile

// repeated .mesos.TaskStatus statuses = 1;
inline int Call_Reconcile::statuses_size() const {
  return statuses_.size();
}
inline void Call_Reconcile::clear_statuses() {
  statuses_.Clear();
}
inline const ::mesos::TaskStatus& Call_Reconcile::statuses(int index) const {
  return statuses_.Get(index);
}
inline ::mesos::TaskStatus* Call_Reconcile::mutable_statuses(int index) {
  return statuses_.Mutable(index);
}
inline ::mesos::TaskStatus* Call_Reconcile::add_statuses() {
  return statuses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >&
Call_Reconcile::statuses() const {
  return statuses_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >*
Call_Reconcile::mutable_statuses() {
  return &statuses_;
}

// -------------------------------------------------------------------

// Call_Message

// required .mesos.SlaveID slave_id = 1;
inline bool Call_Message::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Message::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Message::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_Message::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Call_Message::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Call_Message::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* Call_Message::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Call_Message::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// required .mesos.ExecutorID executor_id = 2;
inline bool Call_Message::has_executor_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_Message::set_has_executor_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_Message::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_Message::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& Call_Message::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* Call_Message::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* Call_Message::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void Call_Message::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
}

// required bytes data = 3;
inline bool Call_Message::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_Message::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_Message::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Call_Message::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Call_Message::data() const {
  return *data_;
}
inline void Call_Message::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Call_Message::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Call_Message::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Call_Message::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* Call_Message::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Call_Message::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Call

// required .mesos.FrameworkInfo framework_info = 1;
inline bool Call::has_framework_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call::set_has_framework_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call::clear_has_framework_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call::clear_framework_info() {
  if (framework_info_ != NULL) framework_info_->::mesos::FrameworkInfo::Clear();
  clear_has_framework_info();
}
inline const ::mesos::FrameworkInfo& Call::framework_info() const {
  return framework_info_ != NULL ? *framework_info_ : *default_instance_->framework_info_;
}
inline ::mesos::FrameworkInfo* Call::mutable_framework_info() {
  set_has_framework_info();
  if (framework_info_ == NULL) framework_info_ = new ::mesos::FrameworkInfo;
  return framework_info_;
}
inline ::mesos::FrameworkInfo* Call::release_framework_info() {
  clear_has_framework_info();
  ::mesos::FrameworkInfo* temp = framework_info_;
  framework_info_ = NULL;
  return temp;
}
inline void Call::set_allocated_framework_info(::mesos::FrameworkInfo* framework_info) {
  delete framework_info_;
  framework_info_ = framework_info;
  if (framework_info) {
    set_has_framework_info();
  } else {
    clear_has_framework_info();
  }
}

// required .mesos.scheduler.Call.Type type = 2;
inline bool Call::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mesos::scheduler::Call_Type Call::type() const {
  return static_cast< ::mesos::scheduler::Call_Type >(type_);
}
inline void Call::set_type(::mesos::scheduler::Call_Type value) {
  assert(::mesos::scheduler::Call_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mesos.scheduler.Call.Request request = 3;
inline bool Call::has_request() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call::set_has_request() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call::clear_has_request() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Call::clear_request() {
  if (request_ != NULL) request_->::mesos::scheduler::Call_Request::Clear();
  clear_has_request();
}
inline const ::mesos::scheduler::Call_Request& Call::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::mesos::scheduler::Call_Request* Call::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::mesos::scheduler::Call_Request;
  return request_;
}
inline ::mesos::scheduler::Call_Request* Call::release_request() {
  clear_has_request();
  ::mesos::scheduler::Call_Request* temp = request_;
  request_ = NULL;
  return temp;
}
inline void Call::set_allocated_request(::mesos::scheduler::Call_Request* request) {
  delete request_;
  request_ = request;
  if (request) {
    set_has_request();
  } else {
    clear_has_request();
  }
}

// optional .mesos.scheduler.Call.Decline decline = 4;
inline bool Call::has_decline() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Call::set_has_decline() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Call::clear_has_decline() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Call::clear_decline() {
  if (decline_ != NULL) decline_->::mesos::scheduler::Call_Decline::Clear();
  clear_has_decline();
}
inline const ::mesos::scheduler::Call_Decline& Call::decline() const {
  return decline_ != NULL ? *decline_ : *default_instance_->decline_;
}
inline ::mesos::scheduler::Call_Decline* Call::mutable_decline() {
  set_has_decline();
  if (decline_ == NULL) decline_ = new ::mesos::scheduler::Call_Decline;
  return decline_;
}
inline ::mesos::scheduler::Call_Decline* Call::release_decline() {
  clear_has_decline();
  ::mesos::scheduler::Call_Decline* temp = decline_;
  decline_ = NULL;
  return temp;
}
inline void Call::set_allocated_decline(::mesos::scheduler::Call_Decline* decline) {
  delete decline_;
  decline_ = decline;
  if (decline) {
    set_has_decline();
  } else {
    clear_has_decline();
  }
}

// optional .mesos.scheduler.Call.Accept accept = 10;
inline bool Call::has_accept() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Call::set_has_accept() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Call::clear_has_accept() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Call::clear_accept() {
  if (accept_ != NULL) accept_->::mesos::scheduler::Call_Accept::Clear();
  clear_has_accept();
}
inline const ::mesos::scheduler::Call_Accept& Call::accept() const {
  return accept_ != NULL ? *accept_ : *default_instance_->accept_;
}
inline ::mesos::scheduler::Call_Accept* Call::mutable_accept() {
  set_has_accept();
  if (accept_ == NULL) accept_ = new ::mesos::scheduler::Call_Accept;
  return accept_;
}
inline ::mesos::scheduler::Call_Accept* Call::release_accept() {
  clear_has_accept();
  ::mesos::scheduler::Call_Accept* temp = accept_;
  accept_ = NULL;
  return temp;
}
inline void Call::set_allocated_accept(::mesos::scheduler::Call_Accept* accept) {
  delete accept_;
  accept_ = accept;
  if (accept) {
    set_has_accept();
  } else {
    clear_has_accept();
  }
}

// optional .mesos.scheduler.Call.Launch launch = 5;
inline bool Call::has_launch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Call::set_has_launch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Call::clear_has_launch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Call::clear_launch() {
  if (launch_ != NULL) launch_->::mesos::scheduler::Call_Launch::Clear();
  clear_has_launch();
}
inline const ::mesos::scheduler::Call_Launch& Call::launch() const {
  return launch_ != NULL ? *launch_ : *default_instance_->launch_;
}
inline ::mesos::scheduler::Call_Launch* Call::mutable_launch() {
  set_has_launch();
  if (launch_ == NULL) launch_ = new ::mesos::scheduler::Call_Launch;
  return launch_;
}
inline ::mesos::scheduler::Call_Launch* Call::release_launch() {
  clear_has_launch();
  ::mesos::scheduler::Call_Launch* temp = launch_;
  launch_ = NULL;
  return temp;
}
inline void Call::set_allocated_launch(::mesos::scheduler::Call_Launch* launch) {
  delete launch_;
  launch_ = launch;
  if (launch) {
    set_has_launch();
  } else {
    clear_has_launch();
  }
}

// optional .mesos.scheduler.Call.Kill kill = 6;
inline bool Call::has_kill() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Call::set_has_kill() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Call::clear_has_kill() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Call::clear_kill() {
  if (kill_ != NULL) kill_->::mesos::scheduler::Call_Kill::Clear();
  clear_has_kill();
}
inline const ::mesos::scheduler::Call_Kill& Call::kill() const {
  return kill_ != NULL ? *kill_ : *default_instance_->kill_;
}
inline ::mesos::scheduler::Call_Kill* Call::mutable_kill() {
  set_has_kill();
  if (kill_ == NULL) kill_ = new ::mesos::scheduler::Call_Kill;
  return kill_;
}
inline ::mesos::scheduler::Call_Kill* Call::release_kill() {
  clear_has_kill();
  ::mesos::scheduler::Call_Kill* temp = kill_;
  kill_ = NULL;
  return temp;
}
inline void Call::set_allocated_kill(::mesos::scheduler::Call_Kill* kill) {
  delete kill_;
  kill_ = kill;
  if (kill) {
    set_has_kill();
  } else {
    clear_has_kill();
  }
}

// optional .mesos.scheduler.Call.Acknowledge acknowledge = 7;
inline bool Call::has_acknowledge() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Call::set_has_acknowledge() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Call::clear_has_acknowledge() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Call::clear_acknowledge() {
  if (acknowledge_ != NULL) acknowledge_->::mesos::scheduler::Call_Acknowledge::Clear();
  clear_has_acknowledge();
}
inline const ::mesos::scheduler::Call_Acknowledge& Call::acknowledge() const {
  return acknowledge_ != NULL ? *acknowledge_ : *default_instance_->acknowledge_;
}
inline ::mesos::scheduler::Call_Acknowledge* Call::mutable_acknowledge() {
  set_has_acknowledge();
  if (acknowledge_ == NULL) acknowledge_ = new ::mesos::scheduler::Call_Acknowledge;
  return acknowledge_;
}
inline ::mesos::scheduler::Call_Acknowledge* Call::release_acknowledge() {
  clear_has_acknowledge();
  ::mesos::scheduler::Call_Acknowledge* temp = acknowledge_;
  acknowledge_ = NULL;
  return temp;
}
inline void Call::set_allocated_acknowledge(::mesos::scheduler::Call_Acknowledge* acknowledge) {
  delete acknowledge_;
  acknowledge_ = acknowledge;
  if (acknowledge) {
    set_has_acknowledge();
  } else {
    clear_has_acknowledge();
  }
}

// optional .mesos.scheduler.Call.Reconcile reconcile = 8;
inline bool Call::has_reconcile() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Call::set_has_reconcile() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Call::clear_has_reconcile() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Call::clear_reconcile() {
  if (reconcile_ != NULL) reconcile_->::mesos::scheduler::Call_Reconcile::Clear();
  clear_has_reconcile();
}
inline const ::mesos::scheduler::Call_Reconcile& Call::reconcile() const {
  return reconcile_ != NULL ? *reconcile_ : *default_instance_->reconcile_;
}
inline ::mesos::scheduler::Call_Reconcile* Call::mutable_reconcile() {
  set_has_reconcile();
  if (reconcile_ == NULL) reconcile_ = new ::mesos::scheduler::Call_Reconcile;
  return reconcile_;
}
inline ::mesos::scheduler::Call_Reconcile* Call::release_reconcile() {
  clear_has_reconcile();
  ::mesos::scheduler::Call_Reconcile* temp = reconcile_;
  reconcile_ = NULL;
  return temp;
}
inline void Call::set_allocated_reconcile(::mesos::scheduler::Call_Reconcile* reconcile) {
  delete reconcile_;
  reconcile_ = reconcile;
  if (reconcile) {
    set_has_reconcile();
  } else {
    clear_has_reconcile();
  }
}

// optional .mesos.scheduler.Call.Message message = 9;
inline bool Call::has_message() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Call::set_has_message() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Call::clear_has_message() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Call::clear_message() {
  if (message_ != NULL) message_->::mesos::scheduler::Call_Message::Clear();
  clear_has_message();
}
inline const ::mesos::scheduler::Call_Message& Call::message() const {
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::mesos::scheduler::Call_Message* Call::mutable_message() {
  set_has_message();
  if (message_ == NULL) message_ = new ::mesos::scheduler::Call_Message;
  return message_;
}
inline ::mesos::scheduler::Call_Message* Call::release_message() {
  clear_has_message();
  ::mesos::scheduler::Call_Message* temp = message_;
  message_ = NULL;
  return temp;
}
inline void Call::set_allocated_message(::mesos::scheduler::Call_Message* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace scheduler
}  // namespace mesos

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::scheduler::Event_Type>() {
  return ::mesos::scheduler::Event_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::scheduler::Call_Type>() {
  return ::mesos::scheduler::Call_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mesos_2fscheduler_2fscheduler_2eproto__INCLUDED
